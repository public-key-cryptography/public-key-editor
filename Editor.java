 	
	
	
	/************************************************
	
	
	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License as
	published by the Free Software Foundation, either version 3 of
	the License, or, at your option, any later version.
	
	
	
	A java text editor and email client for public key cryptography
	and encryption. The ciphers use hypercomplex and hyper-dimensional
	numbers (including vectors, quaternions, matrices, cubes, and tes-
	seracts), polynomials, determinants, multi-variable, multi-equation,
	and multi-dimensional arithmetic, and Merkle-Hellman knapsacks.
	
	
	github.com/public-key-cryptography
	
	
	Save this file as Editor.java
	
	
	
	Readme file
	
	
	The Java Editor program contains a text editor, table editor, email editor and image viewer. The
	program also includes the Math, Number, Matrix, PublicKey, Signature, Cipher, and Convert classes.
	These classes contain all the ciphers, algorithms, protocols, and software required to do cryptog-
	raphy. The Mail, PopMail, and SendMail classes contain the software required to send and retrieve
	email.
	
	All the software is included in one file so the source code can be executed without compiling the
	program. No other packages or modules are required to run the program or to use encrypted email.
	Software developers can copy and paste these classes into other free and open source software pro-
	grams that have compatible licenses. This means that the software can be used with a more permissive
	license but not a more restrictive or proprietary license.
	
	The public keys are based on the Diffie-Hellman ciphers  Y = A X,  Y = X^-1 A X, and Y = x A1^x1 A0
	A2^x2 (mod p), where A, A0, A1, A2, and p are public parameters, x1, x2, and X are private keys, and
	Y is the public key. The equations use polynomials, vectors, determinants, matrices, cubes, and tes-
	seracts. The vector cross product cipher Y = A (x) X,  E = Y * K uses a parallelogram as a public key
	and a parallelepiped as a shared secret key or key agreement. The matrix product cipher  Y = |A1|X1|
	uses 2-dimensional arithmetic which multiplies from left to right and from top to bottom.    |X2|
	The matrix polynomial discrete log cipher uses Y = A^x C B^x + ... + A^0 C B^0 (mod p). These equa-
	tions were selected for public key cryptography because nonlinear, multivariate, multi-dimensional,
	modular and non-modular equations are unsolvable.
	
	The public keys also include the Merkle-Hellman / knapsack cipher c[] = s0 a[] + r[][] s[] (mod n),
	b = c[] (m[] + e[]) where the vector c is the cipher or static public key, a[] is a superincreasing
	sequence of integers, r is a public random matrix, s0, s[], and n are secret keys, e[] is a vector of
	small random errors, and b is the sender's one-time public key.
	
	The email encryption program uses a composite key that has multiple public key ciphers. The public key
	agreements are reduced modulo F8 = 2 ^ 256 + 1 and then the key agreements are xor-ed to generate the
	composite secret key, session key or encryption key. Each public key agreement or cipher functions as
	a one-time pad to encrypt the other public key agreements which are also one-time pads or ciphers. The
	composite key is then used to initialize a hash function that generates another one-time pad for the
	message encryption.
	
	The public key agreement or encryption is unbreakable since every public key cipher would have to be
	broken to solve for the composite secret key. Also, the program doesn't use broken ciphers such as
	RSA or the integer Diffie-Hellman cipher which are not based on any hard math problem. The software
	includes 18 Diffie-Merkle-Hellman ciphers and 2 matrix digital signature algorithms.
	
	If any of these ciphers can be broken it will just get replaced. For example, if a cipher can be
	solved because it uses integers and a single equation, then it can be replaced by another cipher that
	uses matrices, polynomials, powers of a matrix (cube or tesseract), or fractional numbers instead of
	integers. Similarly, if a cipher can be broken because a matrix is diagonalizable or real and symme-
	tric, then it can be replaced by a non-diagonalizable, non-real, or non-symmetric matrix.
	
	
	
	The Mail program can send and retrieve messages using POP mail or Post Office Protocol. The Mail pro-
	gram has a test mail feature on the help menu for the user to try the mail program without being con-
	nected to the internet or using a real email account. The help menu of the Mail program also has a
	document called "How to use pop mail" which explains how to use the program.
	
	Imap is not included because the protocol is more complicated to implement than POP mail. Imap allows
	multiple users to access an email account from different computers which is useful for some companies
	or organizations that have to reply to large numbers of emails. POP mail also allows multiple users
	to access an email account if none of the users deletes the new messages or only the old messages are
	deleted.
	
	Imap allows users to change the state of the messages on the server, but the POP mail protocol could
	be amended or the email servers could be upgraded to include this feature. POP mail servers could
	also be upgraded to allow multiple users to retrieve and delete emails by assigning a hash value or
	time stamp in milliseconds to each message so the retrieve and delete commands could use the number
	assigned to the messages instead of the ordinal / cardinal numbers that are used to enumerate the
	messages. Otherwise if multiple users list the emails and try to delete messages using the ordinal
	numbers, the email messages on the clients' computers will not correspond to messages on the server
	computer because the messages get re-numbered every time one of the users deletes a message and signs
	out, and the wrong messages will get deleted or retrieved.
	
	Messages are encrypted by choosing a random number or one-time encryption key (using the passphrase,
	the plaintext hash, and the system nano time as sources of entropy), hashing the random number to cre-
	ate a one-time pad, xor-ing the one-time pad and the plaindata or plaintext to generate the cipherdata
	or ciphertext, and then using the passphrase hash or shared secret key as a re-usable pad to encrypt
	the random number or one-time encryption key. The receiver decrypts a message by xor-ing the encrypted
	random number using the shared secret key, hashing the random number to create the one-time pad, and
	then xor-ing the one-time pad and the cipherdata to recover the plaindata.
	
	The email text, file attachments, and file descriptions are each encoded in base-64, and then the en-
	coded data are concatenated using newline chars (\n\n), encrypted, and re-encoded in base 64 to remove
	special characters from the encryption method such as newlines, carriage returns, and end of message
	or end of file chars. This expands the data to (4/3)^2 = 16/9 the size because base-64 encoding maps
	6 bits of data to 8-bit chars and two encodings are used to package the data. (The public key encryp-
	tion method includes a base-64 encoding because it has to encode the cipherdata to attach the one-time
	public keys.) Other protocols may use one encoding but this would only reduce the expansion to 3/4 the
	size.
	
	
	The text editor and email program were written to test the public key software and to show developers
	how to use and implement the public key ciphers in other programs. The text editor was also used to
	write, test, and debug all the software except for the first few hundred lines which had to be written
	using a different text editor. Anybody who knows how to install Java and run a java program (either a
	java source code file or a java jar file) can use the program to do text editing or to send and re-
	ceive encrypted emails.
	
	The sender and receiver have to be using the same ciphers and protocols because the software is not
	compatible with other encryption programs. Users also may have to upgrade their software, change their
	public keys, and re-encrypt their files or directories if the implementation of the ciphers or encryp-
	tion protocols changes.
	
	
	** Note that the new version of the software will not decrypt email messages encrypted by previous
	versions of the software if the maximum number of ciphers is used because a private key was modified
	in one of the public key ciphers but messages saved on users' computers will still be decryptable be-
	cause file encryption uses private key cryptography. Also, an error was corrected in the passphrase
	dialog that caused problems on some versions of Linux; an error in the Save As menu item was corrected
	that caused files to be encrypted twice; and an error in the save mail settings method was corrected
	so that the method saves the font size, frame size, number of ciphers, and other mail settings.
	
	
	
	
	
	
	Instructions for running java programs on Linux
	
	(Your computer should have at least 8 GB of memory
	if you run Java and a web browser at the same time
	or else your computer could run out of memory.)
	
	
	Downloading the java development kit (JDK)
	
	To download the JDK, go to jdk.java.net
	Click on the link that says  Ready for use: JDK 22.
	
	Then click on a tar file link that says tar.gz.
	Choose the correct file for your processor architecture
	which should be x64 for Intel or Aarch for Arm processor.
	
	A dialog box appears that says read or save file.
	Click on the button that says Save File.
	
	This should download and save the file
	openjdk-22.0.1_linux-x64_bin.tar.gz
	in the Downloads folder / directory.
	
	
	
	Installing the java development kit (JDK) and running the java editor program
	
	0.  Download the file openjdk-22.0.1_linux-x64_bin.tar.gz  from the website jdk.java.net/22.
	
	1.  Drag and drop or copy and paste the Editor.java file to the Downloads folder.
	
	2.  Open a terminal and copy and paste the commands or the command line
	
	    cd; sudo mkdir -p /usr/jdk; cd; sudo cp ./Downloads/openjdk-22.0.1_linux-x64_bin.tar.gz /usr/jdk;
	    cd /usr/jdk; sudo tar zxvf openjdk-22.0.1_linux-x64_bin.tar.gz; cd;
	
	    (the -p option suppresses the error message if the directory already exists and creates the parent
	    directories as needed)
	
	3.  To run the Editor program, copy the Editor.java file to the Downloads directory and type the command
	
	    cd; /usr/jdk/jdk-22.0.1/bin/java ./Downloads/Editor.java (text, table, image, mail)
	
	If you add an argument after the file name then the program will display the text editor, table editor,
	image viewer, or email editor.
	
	(The Editor program has a table editor, html viewer, and image viewer because other editors are not
	able to display encrypted files or directories. The text editor, html viewer, and image viewer programs
	don't have to decrypt and re-encrypt the Documents and Pictures folders because they only read and de-
	crypt the file input to the program. The files on the disk remain encrypted and unmodified unless the
	user decrypts them.)
	
	
	All the commands can be concatenated into a single line using the semicolon as a delimiter.
	
	If you are running a live version of Linux, you can drag and drop the openjdk-22.0.1_linux-x64_bin.tar.gz
	file and the Editor.java file to the Downloads folder from a USB device and then copy and paste the
	single command line
	
	cd; sudo mkdir -p /usr/jdk; cd; sudo cp ./Downloads/openjdk-22.0.1_linux-x64_bin.tar.gz /usr/jdk; cd /usr/jdk;
	sudo tar zxvf openjdk-22.0.1_linux-x64_bin.tar.gz; cd; /usr/jdk/jdk-22.0.1/bin/java ./Downloads/Editor.java
	
	or for the email client
	
	cd; sudo mkdir -p /usr/jdk; cd; sudo cp ./Downloads/openjdk-22.0.1_linux-x64_bin.tar.gz /usr/jdk; cd /usr/jdk;
	sudo tar zxvf openjdk-22.0.1_linux-x64_bin.tar.gz; cd; /usr/jdk/jdk-22.0.1/bin/java ./Downloads/Editor.java mail
	
	into the terminal using the Edit -> Paste command or the popup menu.
	
	If the directory or folder name has a space character, then you have to use the back slash '\' before
	the space char to escape it. For example, a folder named My Documents would be written My\ Documents in
	the command line.
	
	
	
	Compiling the source code
	
	It is faster to compile the program once so that the program doesn't have to be re-compiled every time.
	
	If the jdk is not installed in your computer, you first have to untar the openjdk-22.0.1 using the command
	
	cd; sudo mkdir -p /usr/jdk; cd; sudo cp ./Downloads/openjdk-22.0.1_linux-x64_bin.tar.gz /usr/jdk;
	cd /usr/jdk; sudo tar zxvf openjdk-22.0.1_linux-x64_bin.tar.gz; cd;
	
	To compile the Editor program, copy the Editor.java file to the Downloads folder and then copy and paste
	the command line
	
	cd; mkdir -p ./EditorClassFiles; /usr/jdk/jdk-22.0.1/bin/javac -Xlint -d ./EditorClassFiles ./Downloads/Editor.java;
	
	To run the compiled Editor or Mail program, use the command
	
	cd; /usr/jdk/jdk-22.0.1/bin/java -cp ./EditorClassFiles Editor   or
	    /usr/jdk/jdk-22.0.1/bin/java -cp /home/username/EditorClassFiles Editor
	
	
	To remove or delete the jdk directory from your computer, use the command
	
	sudo rm -r -f /usr/jdk
	
	The --recursive option is required because the file is a directory and the
	rm command doesn't delete directories by default; the user has to confirm
	that the file to be removed is a directory by specifying the recursive
	option so users cannot inadvertently delete a directory instead of a file.
	
	The --force option tells the command not to prompt the user for a confir-
	mation before deleting each file and subdirectory, and it ignores nonexis-
	tent files and arguments which means that it will not inform the user that
	it cannot remove the file if there is no such file or directory.
	
	The sudo command is required because only the superuser can add or remove
	files that are not located in the user's home directory.
	
	
	
	Creating a compiled / executable java .jar file
	
	You can create a java archive or java jar file
	so the file doesn't have to be compiled each time.
	
	If the Editor.java file is in the Downloads folder, use the commands
	
	/usr/jdk/jdk-22.0.1/bin/javac -d TempDirectory Downloads/Editor.java;
	/usr/jdk/jdk-22.0.1/bin/jar cvf Editor.jar -C TempDirectory .;
	cd; echo "Main-Class: Editor" > temp.txt;
	/usr/jdk/jdk-22.0.1/bin/jar -u -f Editor.jar -m temp.txt;
	rm -r -f TempDirectory; rm temp.txt;
	
	by copying and pasting into the terminal.
	
	This command creates the jar file by compiling the program, creating a temporary directory
	for the compiled code or class files, creating a jar file and loading the class files into
	the jar file, creating a manifest file and saving the text "Main-Class: Editor", updating
	the jar file to include the manifest file, and then deleting the temporary class files
	directory and manifest file.
	
	The five command lines are printed using newline chars for readability (and to keep the
	horizontal scroll bar from expanding), but you could delete the four newline chars and
	four tab chars in the terminal and replace them with single space chars before executing
	the command to make it easier to scroll through the command history using the up and down
	arrow keys.
	
	(It doesn't matter if you run this command more than once because it just re-creates the
	jar file, but the new jar file may not have the same hash value as the previous jar file
	because it may include a time stamp.)
	
	
	
	The Editor.jar file will save around 2 to 6 seconds each time the program is executed
	depending on the speed of the processor or computer. Even on a laptop computer it only
	takes about 3 seconds to start the program except for very slow processors that could
	take up to 10 seconds.
	
	If you delete the compiled classes directory using rm -r -f EditorClassFiles, the Editor
	.jar file will still execute because the classes were loaded into the file. The class files
	are only required to create a jar file, not to run the file (unless the jar file is created
	to use the directory by specifying the class path in the manifest but then the jar file
	would only work on the computer on which the code was compiled).
	
	Note that the cd command can be omitted because it just changes the directory to the home
	directory. This is useful if the next command contains a relative path name or path that
	doesn't start with a slash /, but it is redundant to use cd if the next command has an
	absolute path name because then it doesn't do anything.
	
	The path name /usr/jdk/jdk-22.0.1/bin/java can be replaced by the file name java if the
	terminal knows where to find the java command. The path name is included because some
	users may be running a live version of Linux.
	
	
	
	Running the jar file
	
	The jar file can be run using the command
	
	cd; /usr/jdk/jdk-22.0.1/bin/java -jar Editor.jar (text) for the text editor, or
	
	cd; /usr/jdk/jdk-22.0.1/bin/java -jar Editor.jar mail
	cd; /usr/jdk/jdk-22.0.1/bin/java -jar Editor.jar table
	cd; /usr/jdk/jdk-22.0.1/bin/java -jar Editor.jar image
	
	for the email client, table editor, or image viewer, and the file will be executed
	immediately because the jar file contains the compiled classes or executable byte
	code instead of the source code. The java virtual machine will convert the byte code
	to the user's binary machine code depending on the user's computer or processor
	architecture.
	
	If you execute a .jar file instead of a .java file, then you have to remember to
	create a new jar file for each new version of the source code. You can do this either
	by copying and pasting the single command for creating the jar file each time, or by
	using the up arrow key on the keyboard to search the command history on the terminal
	until you find the command for creating the jar file and then pressing enter.
	
	
	
	
	
	
	
	Exchanging public keys and sending encrypted email
	
	To encrypt an email message the user has to find the recipient's public key, copy the public key
	to the clipboard, move the focus to the To: field (in the Send mail frame) by using the mouse or
	the tab key, and then press the enter key. If the To: field has an email address and it matches
	the address on the clipboard key, then a public key icon will appear next to the To: field to show
	that the key will be used to encrypt the message. The program can also fill in an empty To: field
	using the clipboard key address. If the clipboard key has no address, then a dialog box will ap-
	pear displaying the public key hash to confirm if the user wants to use the clipboard key as the
	recipient's public key. If the To: field already has an address and the clipboard key matches the
	address, then clicking the Send button will also display the public key icon.
	
	The problem of distributing or exchanging public keys is solvable by the email service providers
	and email server software developers. Email server programs would have to be upgraded to allow
	users to store and retrieve public keys. Users could log in to their accounts and copy and paste
	their public keys in base-16 separated by a delimiter such as '-' or the base-16 digits 0 to f,
	and then email clients could retrieve the recipient's key from the POP mail server by connecting
	to the server and then sending a request such as RETR followed by the recipient's address, or
	just sending the recipient's address to the POP mail server, and the email server would reply by
	returning the public key.
	
	For private email servers that don't have a website the server would have to allow the client /
	user to send the public key to the server after logging in to the account using a command such as
	SEND or using no command to send the key. If the client / user is logged in to a POP mail account
	and the server receives several bytes of data it would verify that the key is valid by removing
	the hyphens and testing if the data is in base 16 or only contains the chars 0 to f.
	
	Email server programs could also be upgraded so that POP mail clients could change the state of
	the messages on the server by using a POP mail command such as STAT m n where m is the message
	number and n is a state from 0 to 9. The LIST command returns an enumerated list of sizes but it
	could also return the message state number after each message size such as 1 size 0 \n, 2 size 2
	\n, 3 size 1 \n, ..., or  1 size time-stamp state \n, 2 size time-stamp state \n, 3 size time-stamp
	state \n, et cetera.
	
	This would be backward compatible with the POP mail protocol because it would only display a number
	if a user changes the state of a message. Also the client could retrieve and delete messages using
	the ordinal / cardinal numbers or the time stamps. If multiple users want to retrieve and delete
	the same messages simultaneously they would have to use a newer POP mail program that retrieves and
	deletes messages using the time stamps or message hashes.
	
	The client program stores the message hashes and message states in a file but the user has to use
	the same computer or store the mail folder / directory on a USB storage device to view the message
	states. (The program uses the hash of the from address + the number of bytes because the program
	doesn't know the hashes of the emails from the List screen or the tops of the messages.)
	
	Until the problem of storing public keys on email servers is solved, email encryption will not be-
	come widely used. A few hundred thousand to a few million people might use encryption by copying
	and pasting keys, but hundreds of millions of people will not use email encryption by finding or
	requesting users' keys and then copying and pasting the keys into an email program. This is why
	less than a hundred thousand people and maybe even fewer than fifty thousand people in the world
	use encryption programs such as gpg.
	
	
	
	
	
	Public and private key ciphers used by the software
	
	The program uses hypercomplex and hyper-dimensional ciphers for public key agreement and a hash cipher
	for private key encryption. The public key agreement or secret key is hashed to generate a sequence of
	random numbers which is used as a one-time pad. The ciphertext is computed by adding the one-time pad
	to the plaintext, and then the plaintext is recovered by subtracting the one-time pad from the cipher-
	text.
	
	The hash cipher is unbreakable because cryptographic hash functions are non-invertible. Even if the
	hash function could be inverted it wouldn't break the cipher because there are 2^768 pre-images for
	each hash value, and a cryptanalyst wouldn't know which one is the correct solution.
	
	The matrix public key ciphers are variants of the equations or functions
	
	          -x2   x1   x2          -1   x              x
	Y  =  x  A2   A1   A2 ,   Y  =  X   A   X ,  Y  =  A   X ,     Y  =  A (x) X ,   Y  =  X1  A  X2
	
	          -k2   k1   k2          -1   k              k
	E  =  k  A2   Y    A2 ,   E  =  K   Y   K ,  E  =  A   Y  K ,  E  =  Y (*) K ,   E  =  K1  Y  K2
	
	which are similar to the Diffie-Merkle-Hellman cipher y = a ^ x, e = y ^ k (mod p) except that they
	use matrices or hypercomplex numbers instead of integers and they use multiple variables instead of a
	single variable. These ciphers are a generalization of the Diffie-Hellman cipher because they reduce
	to the integer cipher y = a ^ x (mod p) if x2 = 0 and A1 is a 1x1 matrix.
	
	The integer Diffie-Hellman ciphers y = a x and y = a ^ x (mod p) can be generalized to use polynomi-
	ials, vectors, matrices, cubes, tesseracts, or any n-dimensional object. Some of them can also use
	hypercomplex numbers such as quaternions or octonions and fractional numbers or non-integers.
	
	All numbers are dimensional objects. A real or complex number is a point on an axis or a plane, or a
	0-dimensional object; an array or vector is a line or a 1-dimensional object; a matrix is a square or
	rectangular array of numbers or 2-dimensional object; a cube is 3-dimensional; and a tesseract is 4-
	dimensional.
	
	A public key Y is created by using a public parameter A to encrypt a private variable X. The simplest
	public key function is Y = A X. This is similar to private key encryption except that A is a non-
	invertible public parameter instead of a secret message, and X is the secret message encrypted by the
	public parameter A. In private key cryptography A would be a plaintext message encrypted by a secret
	key matrix X, but in public key cryptography the private key X is the plaintext message encrypted by
	the public parameter A, and the public key Y is the ciphertext, cipherdata or cipher. Because the
	encryption key A is public, the security of public key cryptography is based entirely on the non-
	invertibility of the function. If the function could be inverted then a cryptanalyst could solve for
	the private key or message X.
	
	A recipient who wants to receive encrypted messages computes the static public key Y = A X. This is
	the same equation as A X == B but the equation is written using X and Y instead of A and B because
	X is chosen and the equation is computed or evaluated as a function Y = f(x) = A X. If A and B are
	chosen then the equation has to be solved for X instead of evaluated for X and the equation would be
	written as A X == B instead of Y = A X. By placing the X variable on the left or right side the read-
	er knows whether the equation is being solved for X or evaluated for X.
	
	A sender who wants to send an encrypted message computes the one-time public key Z = A K if the pri-
	vate variables are commutative or Z = K A if K and X are non-commutative. Then the sender and recipi-
	ent compute the same public key agreement or secret key E = A K X  or  E = K A X  using only multi-
	plication because each of them knows either K or X. A wiretapper would have to do an inversion to
	solve for K or X, but this is a hard math problem because A is chosen to be non-invertible.
	
	The cipher Y = A X doesn't work for integers or matrices because A can be inverted to solve for X =
	A^-1 Y; even if A is a singular matrix the equation can still be solved for X. But the equation can
	be generalized to Y = X A X so that A is non-invertible and immovable because matrix multiplication
	is not generally commutative. Multiplication is commutative only for 0-dimensional numbers such as
	integers, complex numbers, and quaternions which are points on a line, plane, or tesseract. (Also,
	because multiplication is non-commutative, there is no division operation defined for matrices except
	for integers or scalars; to divide a matrix by a matrix, the matrix has to be pre- or post-multiplied
	by the inverse of the divisor, and the divisor has to be an invertible or non-singular matrix.)
	
	Public key ciphers can also be generalized by using multi-dimensional multiplication instead of one-
	dimensional multiplication. For example, for 2-D multiplication, matrices can be multiplied from left
	to right and from top to bottom. Ciphers can be generalized further to use multi-dimensional algebra
	by using points on a plane a0 + a1 i instead of points on a line, points in a cube a0 + a1 i + a2 j,
	points in a tesseract a0 + a1 i + a2 j + a3 k, or points in any-dimensional space or hyperspace by
	defining i^2 == j^2 == k^2 == 1 and i j == k, j k == i, k i == j, ... Matrices of multi-dimensional
	points such as quaternions can also use multi-dimensional arithmetic in addition to multi-dimensional
	algebra.
	
	Ciphers can also be generalized by using a symmetric matrix of matrices such as the 2x2 block matrix
	A[][] = { { A1, A2 }, { A2, A3 } } as a public parameter, reducing the 2x2 block matrix to a 2x1 block
	matrix or public key vector Y[] = { A1^x1  A2^x2 , A2^x1  A3^x2 } where x1, x2 are the private keys,
	and then reducing the public key vector Y[] to a 1x1 block matrix or secret key E = Y[1] ^ k1 Y2[2] ^
	k2 == A1 ^ (k1 x1) A2 ^ (k1 x2 + k2 x1) A3 ^ (k2 x2).
	
	Nonlinear multivariate equations are difficult or impossible to solve. If solving an equation such as
	Y = X A X were as simple as diagonalizing a matrix, doing a Fourier transform, or reducing a matrix
	to echelon and row canonical form, then math programs would have functions or methods for solving
	these equations and math books would explain how to solve them. Matrix and linear algebra books only
	explain how to solve the linear equation Y == A X or A X == B by pre-multiplying by the inverse of A
	to get X = A^-1 B. Even multivariable integer equations such as Pell's equation x^2 - d y^2 == c or 1
	are unsolvable without quantum computing, and the equations used in the public key class are much
	more difficult to solve than Pell's equation.
	
	The public key class and email program were created to use these non-invertible or one-way functions
	as public key ciphers. The class will eventually have tens of public key ciphers or puzzles copied
	from matrix and linear algebra books. It is unlikely that these ciphers could be broken unless the
	Diffie-Hellman problem can be solved or the public key agreement can be computed without breaking the
	static public key, inverting the function, or solving the underlying math problem.
	
	The public key class uses a composite key that includes several ciphers because there is no proof that
	any one-way function is non-invertible or that the implementation is correct and because the methods
	of cryptanalysis are secret. If cryptanalysts weren't secretive, users would know which public key ci-
	phers are broken and would stop using them, and cryptographers would figure out how to strengthen the
	ciphers to resist these attacks. The only way to deal with this problem is to use a redundancy of ci-
	phers based on different math problems.
	
	Composite keys are a game changer because a cryptanalyst would have to break every cipher, invert
	every function, or solve every equation in the public key class to read the encrypted messages. The
	cryptographer or user has an advantage since only one of the ciphers has to be secure for the encryp-
	tion to be unbreakable. Breaking a few of the ciphers doesn't get a cryptanalyst anything because
	breaking a composite key is an all-or-nothing game.
	
	The ciphers in the public key class that have a many-to-one mapping of the private key X to the public
	key Y may be unbreakable by classical and quantum computing because the solution is ambiguous and the
	private key X is only used once. Quantum computers are unable to solve math problems that have ambigu-
	ous solutions because they wouldn't know which solution to solve for. This is why a quantum computer
	can only attack the factorization problem by solving the discrete log problem, not by solving the dif-
	ference of squares equation x^2 == 1 (mod n). Even if the solution is unambiguous, it doesn't mean
	that a quantum computer can solve it; there has to be an algorithm or method for solving it, or the
	same private key X would have to be used more than once with a different public parameter A.
	
	Encryption ciphers are not used in the software because they have a one-to-one mapping (or function)
	of the plaintext to ciphertext. It doesn't make sense to use an encryption cipher that has a one-to-
	one mapping because there may be quantum (and classical) algorithms for breaking all of these ciphers.
	(A quantum algorithm already exists that can search for keys for any unknown function or black box in
	sub-exponential time by trying only the square root of the number of combinations, and there may be
	another quantum or classical algorithm that can find keys in polynomial time.)
	
	Elliptic curve ciphers Q = k P where the points are defined by the equation y^2 == x^3 + a x + b mod p
	are not included in the software because the elliptic curve discrete log function has a periodicity
	which makes it susceptible to quantum computing. In addition, the complexity of elliptic curves makes
	the ciphers vulnerable to attack without solving the ecdlp or underlying math problem if the parame-
	ters a, b, and p are not chosen correctly, and nobody knows how to choose the parameters of the curves
	to protect against all unknown attacks. Many people are suspicious or distrustful of elliptic curve
	ciphers because the equations are complicated and they have a large attack surface.
	
	In 2021 we wrote that elliptic curve ciphers that are based on isogenies are quantum resistant but are
	almost certainly broken since they are being approved for standardization and cryptanalysts have had
	over a decade to study them. Just because a cipher is quantum resistant doesn't mean that the cipher
	is also classical resistant or resistant to classical computing.
	
	In 2022, after we wrote that the cipher was almost certainly broken because it had been approved for
	standardization and it was being promoted and backed by a few companies, a method was published for
	breaking the supersingular isogeny key exchange cipher. If the authors hadn't published their paper,
	this algorithm would have been standardized and implemented in software programs along with the other
	broken public key ciphers, including polynomial factorization, error-correcting code ciphers, the Mc-
	Eliece cipher, the learning with errors cipher, and lattice ciphers.
	
	This example shows that the reason for the cipher competition is to discover which ciphers or equa-
	tions are complicated enough that only a few mathematicians or cryptanalysts can break or solve them,
	and then standardize those broken ciphers. This mistake or embarrassment occurred because in approving
	this cipher they underestimated the number of mathematicians who can comprehend the math that was used
	to break the cipher. For the methods of cryptanalysis to remain secret, the number of mathematicians
	who can break a cipher has to be in the single digits (such as for solving coprime root extraction,
	factorization, and the integer Diffie-Hellman problem) and in this case the number was in the double
	digits because there are tens of mathematicians who can understand the math for breaking supersingular
	isogeny key exchange. This discovery was of no importance to the field of mathematics because the ci-
	phers included additional information in the public key to do the key agreement, and this information
	was used to break the cipher without solving the underlying math problem.
	
	Competitions are good for many things but public key cryptography is not one of them because it just
	selects ciphers, functions, or equations that only a few people in the world know how to break, in-
	vert, or solve, and it gives users a false sense of security and confidence in the ciphers. Some users
	reassure themselves that because ciphers such as coprime root extraction or RSA have withstood many
	decades of public cryptanalysis, that this gives them a certain level of confidence in the security of
	the ciphers which is a false or erroneous assumption because cryptanalysts are secretive. They don't
	know that coprime root extraction has been broken for a few decades (which is why RSA was rejected for
	digital signature algorithms) or that lattice ciphers and error-correcting code ciphers are completely
	broken for all key sizes and parameters. Some companies are implementing lattice ciphers into their
	software programs even though some of them have been publicly broken and all of them have been pri-
	vately broken just like RSA.
	
	Another broken cipher that is being backed by a number of companies is the learning with errors ci-
	pher. In the LWE cipher, the recipient chooses a prime (or prime power) modulus q, a public array a[],
	a private key s, and a secret random error array e[] where the sum of the elements is smaller than
	q/2, and then computes the static public key b[] = a[] s + e[] modulo q. (The random errors can be
	discarded because they are not used for decryption.) To encrypt a binary message m[], for each bit or
	element in m the sender chooses a subset of elements in a and b and then calculates u = the subset sum
	of the a elements mod q, and v = the subset sum of b[] + [q/2] m[i] (mod q) where q/2 m[i] is either 0
	or q/2. For each bit m[i] the one-time public key is the pair (u, v), and for m[] the one-time public
	key is the array of pairs or doubles { { u0, v0 }, { u1, v1 }, { u2, v2 }, ... }.
	
	Since a[] s + e[] == b[], multiplying u (== a subset sum of a[]) by s approximately equals v (== a
	subset sum of b[] + 0 or q/2); therefore the recipient can use the private / secret key s to decrypt
	or recover the message bit by calculating m == (v - s u modulo q) / [q/2] because the difference v -
	s u (mod q) equals 0 or q/2 plus the sum of the errors which is not large enough to change the quo-
	tient. But a cryptanalyst who knows how to solve the subset sum problem can also decrypt the message
	by inverting u to find the indices of the samples and then using the indices to find the subset sum of
	b[] and solving for m[i] == (v - the subset of b[] (mod q)) / [q/2]. Even if the subset sum problem
	has a many-to-one mapping, any solution to the subset sum problem will break the cipher. A cryptana-
	lyst can also break the static public key because the equations are linear and the modulus is public
	unlike the knapsack cipher which is also linear and has small errors but uses a private modulus.
	
	The Merkle-Hellman / knapsack cipher c[] = s0 a[] + r[][] s[] (mod n), b = c[] (m[] + e[]), b1 =
	r[][] ^ T (m[] + e[]) is included in the public key class because it is the only cipher that uses a
	private modulus. Unlike lattice ciphers, this cipher is secure because it uses random errors in the
	static public key c[] and the one-time public key b. Unless the static public key could be broken, the
	one-time public key can never be broken because the solution is ambiguous and the search space or so-
	lution set is too large to try all the possible keys or combinations.
	
	
	************************************************/










import java.awt.*;
import java.awt.datatransfer.*;
import java.awt.dnd.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.print.*;

import java.io.*;
import java.net.*;

import java.nio.*;
import java.nio.file.*;
import java.nio.channels.*;

import java.security.*;
import java.text.*;

import java.math.BigInteger;

import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;
import java.util.zip.*;

import java.util.concurrent.*;
import java.util.concurrent.locks.*;
import java.util.concurrent.atomic.*;

import javax.net.ssl.*;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.text.*;
import javax.swing.text.html.*;







public class Editor
{

	public static void main(String[] args)
	{
	
		//  Run the program by passing it as an argument to
		//  the EventQueue.invokeLater(Runnable runnable) method
		//  so that the dispatch thread can start the program.
		
		EventQueue.invokeLater( new Runnable()
		{
			//  invokeLater "causes runnable to have its run method
			//  called in the dispatch thread of the system EventQueue.
			//  This will happen after all pending events are processed."
			
			//  The five editor frames
			
			Programs.TextFrame textframe;
			Programs.TableFrame tableframe;
			Programs.ImageFrame imageframe;
			Programs.HTMLFrame htmlframe;
			
			Programs.Mail.RetrieveMailFrame mailframe;
			
			//  These member variables are not used by the program.
			//  The code could just use new Programs().new TextFrame(),
			//  new Programs().new TableFrame(), or new Programs().new
			//  Mail().new RetrieveMailFrame() without assigning the ob-
			//  ject returned by the constructor to a variable. The text-
			//  frame, tableframe, imageframe, htmlframe, and mailframe
			//  variables are only listed as members to show the objects
			//  that are created by the run method.
			
			public void run()
			{
			
				if ( (args.length == 0) || args[0]
				
				    .equalsIgnoreCase(__.text) )
				{
					//  Text editor
					
					textframe = new Programs()
					
					    .new TextFrame();
				}
				
				
				else if ( (args.length > 0) &&
				
				   args[0].equalsIgnoreCase(__.table) )
				{
					//  Table editor / spreadsheet
					
					tableframe = new Programs()
					
					    .new TableFrame();
				}
				
				
				else if ( (args.length > 0) &&
				
				   args[0].equalsIgnoreCase(__.image) )
				{
					//  Image viewer
					
					imageframe = new Programs()
					
					    .new ImageFrame();
				}
				
				
				else if ( (args.length > 0) &&
				
				   args[0].equalsIgnoreCase(__.html) )
				{
					//  HTML Editor
					
					htmlframe = new Programs()
					
					    .new HTMLFrame();
				}
				
				
				else if ( (args.length > 0) &&
				
				   ( args[0].equalsIgnoreCase(__.mail)
				  || args[0].equalsIgnoreCase(__.email) ) )
				{
					//  E-mail client
					
					mailframe = new Programs()
					
					    .new Mail() .new RetrieveMailFrame();
				}
				
				
				//  else if (args[0].equals(...))
				
				
				else System.out.println("Unknown argument");
			}
		} ) ;
	}
}








class __
{

	//  This class contains all the global character and
	//  string literals for this program.
	//
	//  (The class name could be changed to something else
	//  using find and replace or replace all.)
	
	
	//  To translate the program into other languages
	//  replace the characters and strings in this class
	
	
	
	public static final char
	
	
	pluskeychar = '=',
	minuskeychar = '-',
	
	
	newkeycode = 'N',
	openkeycode = 'O',
	deletekeycode = 'D',
	savekeycode = 'S',
	saveaskeycode = 'S',
	printkeycode = 'P',
	closekeycode = 'W',
	exitkeycode = 'Q',
	
	undokeycode = 'Z',
	redokeycode = 'Z',
	
	findkeycode = 'F',
	replacekeycode = 'G',
	gotolinekeycode = 'I',
	
	selectallkeycode = 'A',
	
	linewrapkeycode = 'L',
	
	passphrasekeycode = 'P',
	
	checkallkeycode = 'D'
	
	;
	
	
	
	static String
	
	mailpassphrase = "mail passphrase",
	
	file = "File",
	
	new_ = "New",
	newkey = "New         Ctrl+N",
	
	open = "Open",
	openkey = "Open       Ctrl+O",
	
	openfile = "Open File",
	openfilekey = "Open File  Ctrl+O",
	
	opendirectory = "Open Dir",
	opendirectorykey = "Open Dir  Ctrl+Shift+O",
	
	deletekey = "Delete     Ctrl+D",
	
	save = "Save",
	
	savekey = "Save        Ctrl+S",
	
	saveas = "Save As",
	saveaskey = "Save As   Ctrl+Shift+S",
	
	print = "Print",
	printkey = "Print       Ctrl+P",
	
	close = "Close",
	closekey = "Close      Ctrl+W",
	
	exit = "Exit",
	exitkey = "Exit         Ctrl+Q",
	
	
	
	
	edit = "Edit",
	
	undo = "Undo",
	undokey = "Undo      Ctrl+Z",
	
	redo = "Redo",
	redokey = "Redo      Ctrl+Shift+Z",
	
	cut = "Cut",
	cutkey   = "Cut        Ctrl+X",
	
	copy = "Copy",
	copykey =  "Copy      Ctrl+C",
	
	paste = "Paste",
	pastekey = "Paste     Ctrl+V",
	
	find = "Find / Replace",
	findkey =  "Find / Replace   Ctrl+F",
	
	replace = "Find and Replace",
	replacekey = "Find and Replace   Ctrl+G",
	
	passphrasekey = "Passphrase / Settings  Ctrl+P",
	
	checkallkey = "Check All   Ctrl+D",
	
	
	
	
	replaceall = "Replace All",
	
	highlighttext = "Highlight Text",
	
	tabtitle = "tab title",
	programtitle = "program title",
	
	settitle = "Set Title",
	
	settabtitle = "Set Tab Title",
	setprogramtitle = "Set Program Title",
	
	base16 = "base 16",
	base64 = "base 64",
	string = "string",
	revert = "revert",
	
	gotoline = "Goto Line",
	gotolinekey = "Goto Line  Ctrl+I",
	
	upperlowercase = "Upper / Lower Case",
	indentunindent = "Indent / Unindent",
	
	gotoposition = "Goto Position",
	
	converttext = "Convert Text / Document",
	
	selectall = "Select All",
	selectallkey = "Select All  Ctrl+A",
	
	selectrange = "Select Range",
	
	hash = "Hash",
	
	hashtext = "Hash Text / Document",
	hashfile = "Hash File",
	hashpublickey = "Hash Public Key",
	
	hashstring = "Hash String",
	
	
	
	view = "View",
	
	linewrap = "Line Wrap",
	linewrapkey = "Line Wrap   Ctrl+L",
	
	lineunwrap = "Line Unwrap",
	lineunwrapkey = "Line Unwrap  Ctrl+L",
	
	font = "Font",
	fontsize = "Font Size",
	fontsizekey = "Font Size   Ctrl++",
	
	fonttype = "Font Type / Bold",
	
	bold_unbold = "Bold / Unbold (Plain)",
	
	textcolor = "Text Color",
	screencolor = "Screen Color",
	swapcolors = "Swap Colors",
	
	reverse_colors = "Reverse colors",
	
	textscreencolor = "Text / Screen Color",
	
	wordlinecount = "Word Line Count",
	
	showhidebuttons = "Show / Hide Panel",
	
	showpanel = "show panel",
	
	
	line = "line",
	column = "column",
	position = "position",
	
	
	imageviewer = "Image Viewer",
	tableeditor = "Table Editor",
	
	fitwidth  = "Fit Width",
	fitheight = "Fit Height",
	fitimage  = "Fit Image",
	
	showtitle = "Show Title",
	
	
	html = "html",
	
	htmlfileviewer = "HTML File Viewer",
	htmleditorpane = "HTML Viewer",
	
	HTMLEditor = "HTML Editor",
	texthtml = "Text / HTML",
	
	
	
	
	encrypt = "Encrypt",
	decrypt = "Decrypt",
	
	encryptmessage = "Encrypt Message",
	decryptmessage = "Decrypt Message",
	
	encryptdirectory = "Encrypt Directory",
	decryptdirectory = "Decrypt Directory",
	
	encryptdecryptdirectory = "Encrypt / Decrypt Directory",
	
	encryptfile = "Encrypt File",
	decryptfile = "Decrypt File",
	
	signaturekey = "Signature Key",
	
	signdocument = "Sign Document",
	signmessage  = "Sign Message",
	
	verifysignature = "Verify Signature",
	
	privatekeyencryption = "Private Key Encryption",
	
	viewcipherdata = "cipherdata / ciphertext",
	viewciphertext = "cipherdata / ciphertext",
	
	   publickey = "Public Key",
	
	newpublickey = "Print Public Key",
	// changed from New to Print
	
	publickeyhash = "Public key hash",
	
	
	
	sendretrievemail = "Send / Retrieve Mail",
	
	sendemail = "Send Email",
	
	closetab = "Close tab",
	closealltabs = "Close all tabs",
	
	image = "Image",
	
	table = "Table",
	
	table_editor = "Table Editor",
	
	tablesize = "Table Size",
	
	row  = "row",  col  = "col",
	rows = "rows", cols = "cols",
	
	cells = "cells", Cell = "Cell",
	
	autosum = "Auto Sum",
	
	Sum = "Sum", Range = "Range",
	
	Average = "Average",
	
	Median = "Median",
	
	Min = "Min", Max = "Max",
	
	transpose = "Transpose",
	
	transposerowscols = "Transpose rows / cols",
	
	showgrid = "Show Grid",
	
	enablereordering = "Enable Reordering",
	enablesorting = "Enable Sorting",
	
	insertrows = "Insert Rows",
	deleterows = "Delete Rows",
	
	setautoresize = "Set Auto Resize",
	
	enterrowsandcols = "Enter rows and cols",
	
	//  character separated values (comma or tab)
	
	noncsvfile = "non character separated values / .csv file",
	
	
	   help = "Help",
	  about = "About",
	license = "License",
	
	howtousepopmail = "How To Use Pop Mail",
	
	
	addfiletolist = "Add file to list",
	addfilename   = "Add file name",
	
	
	framesize = "frame size",
	
	frameposition = "frame position",
	
	
	bold = "bold",
	
	selectfonttype = "Select font type",
	
	matchcase = "match case",
	
	click = "click",
	
	clicktoedit = "click to edit",
	
	files = "files",
	
	untitled = "Untitled",
	
	base = "base",
	
	//  del could be replaced by a delete symbol
	
	del = "del", // delete  or  x
	
	deletefile = "Delete file",
	
	deletefileorfolder = "DELETE file or folder",
	renamefileorfolder = "Rename file or folder",
	
	newfilename = "New file name",
	
	filewillbedeleted = "File will be permanently deleted",
	
	folderwillbedeleted = "FOLDER will be permanently deleted",
	
	words = "words",  newlines = "lines",
	
	softwarelicense = "Software License",
	
	
	OK = "OK", Yes = "Yes", No = "No",
	
	
	attach = "Attach", // file or document
	
	attachfiles = "Attach Files",
	
	attachfilesordirectory = "Attach Files or Directory",
	
	fileisalreadyattached = "File is already attached",
	
	monospaced = "Monospaced",
	
	Warning = "Warning",
	
	
	clipboardisempty = "Clipboard is empty",
	
	nopublickey = "No public key or key is invalid",
	
	noclipboardkey = "No clipboard key\n or key is invalid",
	
	publickeyhaschanged = "Public key has changed",
	
	passphrasewarning =
	
	    "Email passphrase is less than 16 characters.\n" +
	
	    "You can use numbers, letters, and special chars\n" +
	    "such as < ^ > ? / \\ . , : { } [ ] ( ) | - + = _ ! @ # $ & *",
	
	invalidpublickey = "Public key is not valid",
	
	invalidemailaddress = "Email address has no '@' sign",
	
	wrongpublickey = "Address on clipboard public key\n" +
	                 "does not match address in To: field",
	
	enteranemailaddress =
	
	    "Enter an email address\n"
	     + "(use the tab key)",
	
	zero = "zero", single = "single", double1 = "double",
	quad = "quad", oct = "oct", max = "max",
	
	
	cipher = "cipher",
	
	rng = "random number generator",
	
	savedpassphrase = "saved passphrase",
	typedpassphrase = "typed passphrase",
	
	passphraseandemailhash = "passphrase and email hash",
	
	passphrasehash = "passphrase hash",
	
	
	
	internet = "internet",
	Internet = "Internet",
	
	mail = "mail",
	Mail = "Mail",
	
	POPMail = "POP Mail",
	
	usernames = "user names",
	
	entersecretpassphrase = "Enter secret passphrase",
	
	filenotfound = "File not found",
	
	largefile = "Large file",
	
	directory = "Directory",
	
	directoryisnotinhomefolder =
	
	    "Directory is not in home folder",
	
	media = "media",
	
	test = "Test",
	
	encryptfilename    = "Encrypt file name",
	encryptfilenames   = "Encrypt file names",
	encryptfilewithkey = "Encrypt file with key",
	
	encryptdirectorywithkey = "Encrypt directory with key",
	decryptdirectorywithkey = "Decrypt directory with key",
	
	encrypteddirectory = "Encrypted directory",
	decrypteddirectory = "Decrypted directory",
	
	encryptedfile = "Encrypted file",
	unencryptedfile = "Unencrypted file",
	
	encryptingfile = "Encrypting file",
	decryptingfile = "Decrypting file",
	
	encryptingfilename = "Encrypting file name",
	
	errorencryptingfile = "Error encrypting file",
	errordecryptingfile = "Error decrypting file",
	
	fileisalreadyencrypted = "File is already encrypted",
	fileisnotencrypted     = "File is not encrypted",
	fileisnotwritable      = "File is not writable",
	
	selectanaddress = "Select the recipient's public key",
	
	Replace = "Replace",
	savefile = "Save file",
	
	Prev = "Prev",
	Find = "Find",
	
	noselectedtext  = "No selected text",
	noselectedcells = "No selected cells",
	
	usearrowkeystoindent
	
	  = "Use arrow keys to indent",
	
	titlename = "title name",
	
	filehash = "file hash",
	filename = "file name",
	filesize = "file size",
	
	bytes = "bytes",
	chars = "chars",
	
	seconds = "seconds",
	
	editor = "editor",
	Editor = "Editor",
	
	java_editor = "java editor",
	Java_Editor = "Java Editor",
	
	Public_Key_Editor = "Public Key Editor",
	
	text = "text",
	
	texteditor = "texteditor",
	TextEditor = "TextEditor",
	
	Color = "Color",
	
	changethefontsize = "Font size (Ctrl++ / Ctr--)",
	
	emailaddress = "Email Address",
	
	passphrase = "passphrase",
	Passphrase = "Passphrase",
	
	numberofciphers = "number of ciphers",
	usereplyaddresskey = "use reply address for reply key",
	
	includelargeciphers = "include large ciphers",
	
	usemyaddresstogeneratereplykey =
	
	    "Use my email address to generate the reply key\n" +
	    "so the reply key is different for each user name",
	
	mypublickeyhash = "My Public Key Hash",
	
	charsperline = "chars / line",
	
	publickeywidth = "key width / chars per line",
	
	keywidth = "key width",
	
	shiftarrow = "use shift + arrow to select multiple addresses",
	
	passphrasefile = "passphrase file",
	
	passphrasesettings = "Passphrase / settings",
	
	settings = "settings",
	Settings = "Settings",
	
	replykeysettings = "Reply Key Settings",
	
	userpassword = "Userpass / Password",
	
	filelistsize = "File list size",
	
	createanewpublickey = "Create a new public key",
	
	enteryoursecretpassphrase = "Enter your secret passphrase",
	
	nothingtosign = "Nothing to sign",
	nothingtoverify = "Nothing to verify",
	nosignature = "No signature",
	invalidsignature = "Invalid signature",
	invalidhash = "Invalid hash",
	
	signdocumentwithkey = "Sign document with signature key",
	signmessagewithkey  = "Sign message with signature key "
	                    + "(ignore tabs, newlines, and spaces)",
	
	enterpassphrase = "Enter passphrase",
	
	thisprogramwassignedby  = "This program was signed by",
	thisdocumentwassignedby = "This document was signed by",
	
	signatureisfalse = "Signature is false",
	signatureistrue  = "Signature is true",
	
	nothingtoencrypt = "Nothing to encrypt",
	nothingtodecrypt = "Nothing to decrypt",
	
	messageisalreadyencrypted = "Message is already encrypted",
	
	unabletoconnecttodirectory = "Unable to connect to directory",
	
	version = "version",
	
	licensetext =
	
	    "This program is free software; you can redistribute it " +
	    "and/or modify it under the terms of the GNU General " +
	    "Public License as published by the Free Software Foundation, " +
	    "either version 3 of the License, or, at your option, " +
	    "any later version.",
	
	
	publickeyerror =
	
	    "A public key is required to encrypt a message.\n" +
	    "Find the recipient's public key and copy it to\n" +
	    "the clipboard before encrypting.",
	
	
	passphrasehaschanged =
	
	    "If you're changing your passphrase, enter your previous\n" +
	    "passphrase to re-encrypt your saved emails or else your\n" +
	    "previous saved emails will be undecryptable using the new\n" +
	    "passphrase. (Don't enter your email address because the\n" +
	    "email address is not used for file encryption.)"
	
	;
	
	
	
	
	//  POP Mail
	
	
	
	public static final char
	
	mail_listkeycode = 'L',
	mail_readallkeycode = 'A',
	mail_deletekeycode = 'D',
	mail_signoutkeycode = 'O',
	
	mail_replykeycode = 'R',
	mail_prevkeycode = KeyEvent.VK_LEFT,
	mail_nextkeycode = KeyEvent.VK_RIGHT
	
	;
	
	
	
	
	public static final String
	
	
	title = "",
	
	
	email = "email",
	Email = "Email",
	
	Date = "Date",
	From = "From",
	To = "To",
	Subject = "Subject",
	Size = "Size",
	
	sizeinKB = "Size in KB",
	
	headerinfo = "Header info",
	
	messages = "messages",
	
	publickeys = "public keys",
	
	viewpublickeys = "View Public Keys",
	
	viewsavedemails = "View Saved Emails",
	
	recipientspublickeys = "Recipient's Public Keys",
	
	messagestates = "message states",
	
	clientservercomm = "Client/Server Communication",
	
	showsentemails = "Show / Hide Sent Emails",
	
	Showkeyboard = "Show / Hide Keyboard",
	
	newtab = "New Tab",
	// closetab = "Close Tab",
	
	Message = "Message",
	Sendmessage = "Send Message",
	
	Sendplaintextmessage  = "Send plaintext message",
	Sendciphertextmessage = "Send ciphertext message",
	
	incomingmailserver = "Incoming mail server",
	outgoingmailserver = "Outgoing mail server",
	
	numberofmessages = "Number of messages",
	
	 ascending =  "ascending",
	descending = "descending",
	
	maildirectory = "Mail directory",
	
	setmaildirectory = "Set mail directory",
	
	createnewmaildir = "Create a new mail folder",
	
	Sent = "Sent",
	Received = "Received",
	
	undelete = "Undelete",
	resetmailserver = "Reset mail server",
	
	hide = "Hide",
	
	delete = "delete",
	reply = "reply",
	prev = "prev",
	next = "next",
	
	Reply = "Reply",
	Send = "Send",
	Clear = "Clear",
	
	Addkey = "Add key",
	Removekey = "Remove key",
	
	emptyfield = "empty field",
	
	
	
	text_bold = "Text Bold",
	
	printpublickey = "Print public key",
	
	compose_mail = "Compose email",
	
	sendmail = "Send Mail",
	
	
	//  button labels
	
	// Stat = "Stat",
	List    = "List",
	Inbox   = "Inbox",
	// Retr = "Retrieve All",
	ReadAll = "Read All",
	Delete  = "Delete",
	Signout = "Sign Out",
	
	
	//  email labels
	
	unread = "unread",
	read = "read",
	repliedto = "replied to",
	// delete = "delete",
	important = "important",
	urgent = "urgent",
	spam = "spam",
	star = "star",
	// save = "save",
	
	
	Keyboard = "Keyboard",
	
	testmail = "Test Mail",
	
	mailcopytoself = "mail copy to self",
	
	sentpublickey = "sent public key",
	
	error = "error",  Error = "Error",
	
	connectedtoserver = "Connected to server",
	
	secretpassphrase = "Secret passphrase",
	
	clicktoshowhidekeyboard = "Click to show/hide keyboard",
	clicktoshowhidetext = "Click to show/hide text",
	
	myemailaddress = "My email address",
	
	shortpassword = "Short password",
	newpassword = "New password",
	
	pastepublickey = "Paste public key",
	
	serverkeyhash = "Server key hash",
	serverport = "Server port",
	
	openedsocket = "Opened socket",
	closedsocket = "Closed socket",
	
	sockettimedout = "socket timed out",
	reconnectingtoserver = "reconnecting to server",
	
	localipaddress = "local IP address",
	
	sendkeytoemailserver =
	
	   "Send public key to email server",
	
	  encrypted =   "encrypted",
	unencrypted = "unencrypted",
	
	plaintextmessage = "Plaintext Message",
	encryptedmessage = "Encrypted Message",
	
	useclipboardkey = "Use clipboard key as recipient's key",
	usekeyringkey = "Use key ring key as recipient's key",
	
	messageisnotencrypted = "Message is not encrypted",
	proceedanyway = "Proceed anyway",
	
	connection_error = "Connection error",
	
	login_error = "Login error",
	
	username_error = "Username error",
	
	authentication_error = "Authentication error / wrong userpass",
	
	mailtransport_error = "Mail transport error",
	
	thefollowingmessagewassentencrypted =
	
	    "The following message was sent encrypted",
	
	thefollowingmessagewassentunencrypted =
	
	    "The following message was sent in the clear\n\n" +
	
	    "(the message may be encoded in base 64 if a file is attached)",
	
	enterpasswordforthisemailaddress =
	
	    "Enter or confirm your user password\n" +
	    "because you are not replying to an email",
	
	decryptfilebeforeattaching = "Decrypt file before attaching;\n"
	
	    + "file will be encrypted to recipient's key",
	
	fileisnotattached1 = "File is not attached because it was not decrypted",
	fileisnotattached2 = "The file has to be decrypted before encrypting it\n" +
	                     "to the recipient's public key",
	
	errorsendingpublickey =
	
	    "Error sending public key to email server\n" +
	    "Use the Send Public Key menu item.",
	
	dontshowthismessageagain = "Don't show this message again",
	
	encryptfilebeforesaving = "Encrypt file before saving",
	
	deleteorclosetab = "Delete address or close tab",
	
	deletetab = "Delete email address",
	
	encryptkeysize = "Encrypt Key Size",
	myreplykeysize = "My Reply Key Size",
	  replykeysize =    "Reply Key Size",
	
	encryptionreplykeyciphers = "Encryption / reply key ciphers",
	
	recipientspublickeyhash = "Recipient's public key hash",
	
	copytoclipboard = "Copy to clipboard",
	
	cancel = "Cancel",  canceled = "Canceled",
	
	clickdecrypt = "Click decrypt to undo encryption",
	
	AttachedFile  = "Attached File",
	AttachedFiles = "Attached Files",
	
	numberoffiles = "number of files",
	
	Attachments = "Attachments",
	
	viewattachedfile = "[ view ]",
	saveattachedfile = "[ save ]",
	deleattachedfile = "[ x ]",
	
	insert = "insert", prepend = "prepend", append = "append",
	
	filedescription = "File title / description",
	
	notitle = "no title",
	
	readingmailsettings = "reading mail settings",
	 savingmailsettings =  "saving mail settings",
	
	username = "user name",
	userpass = "user pass",
	
	randomtextgenerator = "Random Text Generator",
	randomtextanddate   = "Random text and date",
	   newtextanddate   = "New Text",
	
	popmailuserpass = "Pop mail userpass",
	
	userpasswarning =
	
	    "userpass is > 12 chars\n" +
	    "Do not use your passphrase\n" +
	    "as a userpass for your accounts",
	
	  userdomain =   "user domain",
	serverdomain = "server domain",
	
	selectedindex = "selected index",
	
	  textrgb =   "text rgb",
	screenrgb = "screen rgb",
	
	fontname = "font name",
	
	incomingmailport = "incoming mail port",
	outgoingmailport = "outgoing mail port",
	
	messagesperscreen = "messages per screen",
	
	deleteboxischecked = "delete box is checked",
	
	replytoself = "Reply to self",
	
	listfirst = "List first",
	
	nocheckedboxes = "No checked msgs",
	
	firstmessage = "first message",
	 lastmessage =  "last message",
	
	stopping = "stopping",
	
	stopped = "stopped",
	
	stop = "stop",
	
	true_ = "true"
	
	;
	
	
	
	
	
	
	//  Colors
	
	
	public static final String
	
	
	black = "black",
	darkgray = "dark gray",
	
	brightred = "bright red",
	red = "red",
	mediumred = "medium red",
	darkred = "dark red",
	
	orange = "orange (red + 1/3 green)",
	
	brightgreen = "bright green",
	green = "green",
	darkgreen = "dark green",
	
	
	brightblue = "bright blue",
	blue = "blue",
	mediumblue = "medium blue",
	darkblue = "dark blue",
	cobaltblue = "cobalt blue (blue + 1/3 green)",
	paleblue = "pale blue",
	
	brightpink = "bright pink (r + 3/4 b)",
	pink = "pink (bluish red)",
	redpink = "red pink (r + 1/2 b)",
	reddishblue = "blue + 3/4 red",
	
	magenta = "magenta (red + blue)",
	darkmagenta = "dark magenta (purplish red)",
	    crimson = "crimson (red + 2/3 blue)",
	
	palepurple = "pale purple / lavender blue",
	brightpurple = "bright purple",
	purple = "purple (blue + 1/2 red)",
	darkpurple = "dark purple (blue + 1/2 red)",
	
	purplishblue = "indigo (royal / purplish blue)",
	violet  = "violet (dark reddish blue)",
	
	aqua = "aqua (greenish blue)",
	darkaqua = "dark aqua (blue + 1/2 green)",
	cyan = "cyan (green + blue)",
	darkcyan = "dark cyan (green + blue)"
	
	;
	
	
	
	
	
	
	//  Imap is not included in the list of mail servers because Imap is more complicated
	//  to implement than POP mail. Both protocols leave messages on the server until the
	//  user deletes them but Imap allows the user to mark messages with labels such as
	//  read or unread, replied to / answered, delete, important, or urgent. Imap also
	//  has some other features such as folders.
	//
	//  POP3 could be amended to include a command that allows users to mark or label
	//  messages by specifying the message number and a number from 0 to n specifying
	//  the state of the message such as unread, read, replied to, important, urgent,
	//  spam, etc.
	//
	//  To implement this feature, the STAT command could be augmented or overloaded to
	//  accept two arguments so that the user could change the status of a message, and
	//  the LIST or TOP command could return the message state number in the enumerated
	//  list of messages. The LIST command could also include a message hash or a time
	//  stamp in milliseconds such as 1 bytes time_stamp state\n, 2 bytes time_stamp state\n,
	//  3 bytes time_stamp state\n, ... so the client could retrieve and delete messages
	//  using the time stamp or hash instead of the cardinal or ordinal numbers.
	//
	//  The command STAT m n could change the state of message m to state n, where m is
	//  the message number from 1 to k and n is an integer from 0 to 9. By default mes-
	//  sages could be given the state 0 which would mean unread. The client's mail pro-
	//  gram would be responsible for interpreting the number code and converting it to
	//  a word or icon next to the message number.
	
	
	
	
	public static final String[] incomingmailservers = new String[]
	{
		"",
		
		//  an example used for testing or debugging
		
		"pop.example.com  995", // not a real email server
		
		//  free and paid pop mail providers
		
		//  these port numbers might not be correct
		
		"pop.gmx.com  995",
		
		"pop.gmail.com  995",
		
		"pop.mail.com  995",
		
		"pop.yandex.com  995",
		
		//  ...
	};
	
	
	
	public static final String[] outgoingmailservers = new String[]
	{
		"",
		
		//  an example used for testing or debugging
		
		"smtp.example.com  465", // not a real email server
		
		//  free and paid email providers
		
		//  these port numbers might not be correct
		
		"smtp.gmx.com  465",
		
		"smtp.gmail.com  465",
		
		"smtp.mail.com  465",
		
		"smtp.yandex.com  465",
		
		//  ...
	};
	
	
	
	public static final Integer[] messagenumbers = new Integer[]
	{
		//  number of emails messages to retrieve and display
		
		10, 20, 50, 100,
	};
	
	
	
	
	//  POP Mail / Send Mail information messages
	
	
	public static final String
	
	enterthefromaddress =
	
	    "Enter the from: address so your reply key\n" +
	    "can be attached to your message. The reply key\n" +
	    "is different for each email address because it\n" +
	    "uses the hash of the passphrase and username.",
	
	choosethereplykeysize1 =
	
	    "Choose the key size that you want sent with this message.\n" +
	    "The recipient will use this key to reply to your message.",
	
	choosethereplykeysize2 =
	
	    "If you do not include a reply key, the recipient will have to request\n" +
	    "your public key to send an encrypted reply to your email until email\n" +
	    "service providers upgrade their software to allow clients or users to\n" +
	    "store public keys on their servers.",
	
	thismessageisundecryptable =
	
	    "This message is undecryptable\n" +
	    "(Either the wrong passphrase was used for\n" +
	    "encryption or the ciphertext is defective)",
	
	thismessagewassentunencrypted =
	
	    "This message was sent unencrypted",
	
	clipboardkeyhasnoaddress =
	
	    "Clipboard key has no address. Type the recipient's\n" +
	    "email address in the to field and then press enter."
	
	;
	
	
	
	
	//  POP mail / Send Mail error messages
	
	
	public static final String
	
	unabletoconnecttoserver = "Unable to connect to server ",
	
	unknownusername = "Unknown username",
	
	wronguserpassorpop3maildisabled =
	
	    "Wrong userpass or POP3 mail is disabled\n\n" +
	
	    "Click on the userpass menu item to confirm your password or\n" +
	    "use the client/server communication menu item to see the error\n\n" +
	
	    "You may have to enable POP mail on your email account\n\n" +
	
	    "Also, for some email providers such as yandex mail, the web mail\n" +
	    "password will not work for pop mail. On the email website you have\n" +
	    "to click on All Settings, Security, App Passwords, Pop3 mail.\n\n" +
	
	    "You will be prompted to enter your web mail password and then it will\n" +
	    "issue and assign a random 16-letter password to your pop mail account.\n" +
	    "Write down the password and type it into the userpass settings box on\n" +
	    "the mail program. You may have to click ok a few times because the pro-\n" +
	    "gram will assume that you are mistakenly entering the public key pass-\n" +
	    "phrase instead of the userpass because it contains more than 12 chars.",
	
	
	passphrasefieldisempty = "Passphrase field is empty",
	
	passphraseislessthan16chars = "Passphrase is less than 16 characters",
	
	publickeyringisempty = "Public key ring is empty",
	
	emailaddressisempty = "Email address is empty",
	
	ifyoualreadyhaveanemailaddr =
	
	    "If you already have an email address\n" +
	    "open the passphrase / settings dialog,\n" +
	    "enter your passphrase and click ok",
	
	emailaddressisinvalid = "Email address is invalid",
	
	incomingmailserverfieldisempty =
	
	    "Incoming mail server field is empty\n" +
	    "(Open the passphrase / settings dialog box)",
	
	outgoingmailserverfieldisempty =
	
	    "Outgoing mail server field is empty\n" +
	    "(Open the passphrase / settings dialog box)",
	
	typetheoutgoingmailport = "Type the outgoing mail port 465 after the server name",
	typetheincomingmailport = "Type the incoming mail port 995 after the server name",
	
	userdomaindoesnotmatchserverdomain = "User domain does not match server domain",
	
	tofieldisempty = "To: field is empty",
	
	toaddressisinvalid = "To: address is invalid",
	
	nothingtosend = "Nothing to send",
	
	decryptionerror = "Decryption error",
	
	wrongencryptionordecryptionkey =
	
	    "Wrong encryption or decryption key or defective ciphertext",
	
	subjectwarning =
	
	    "Subject Warning: The sender's\n" +
	    "email includes a plaintext subject",
	
	subjectfieldisempty =
	
	    "Subject field is empty\n" +
	    "Type a subject or a space char"
	
	;
	
	
	
	public static final String testmailmessage =
	
		//  This email message is displayed in test mail
		
		"This is the first line of the email message.\n\n" +
		
		"If this message includes a file attachment, you can view or save the file " +
		"by clicking on [ view ] or [ save ].\n\n" +
		
		"If the file contains text or images, clicking the [ view ] \"button\" will " +
		"display the document, table, or image in a popup window. A table file will " +
		"only be displayed if the file was saved by the sender using a .csv or character-" +
		"separated values format which uses tabs as delimiters for the table cells but " +
		"can also use commas or semicolons.\n\n" +
		
		"Clicking the [ save ] button will display a file chooser dialog box so you can " +
		"save the document or image as a file.\n\n" +
		
		"You can also use the numbers 1 to 9 (and 0 for 10) to view the attached files, " +
		"or hold down the control / ctrl button and press the file number to open the " +
		"save file dialog box.\n\n" +
		
		"You can close the popup window by pressing the escape key or enter key on the " +
		"keyboard if the popup window has the focus. You can also change the size of an " +
		"image by moving the mouse wheel if the caret / cursor is over the image. (If you " +
		"don't have a mouse you can use the arrow keys to change the image size.)\n\n" +
		
		"If the (decrypted or unencrypted) message starts with a line that has the word " +
		"HTML or html in it, a popup window will display the document. If the html document " +
		"contains a hypertext link, clicking on the link prints the url address in the term" +
		"inal and copies it to the clipboard so you can paste the address into a web browser. " +
		"(In future versions it may open an html editor and connect to the address in the " +
		"hyperlink if the user enables this feature.) Note that if you save the file the Html " +
		"Viewer will not open files that do not end with the suffix .html or .htm.\n\n" +
		
		"A few unencrypted and undecryptable messages are included to test the mail program " +
		"because some messages may be sent unencrypted or may be encrypted to the wrong " +
		"public key.\n\n" +
		
		"A few self-addressed emails are also included to test the mail program because " +
		"the mail program can send a duplicate copy of your messages to your email ad" +
		"dress so that you have a copy of all your sent messages in your inbox. You can " +
		"hide these emails by clicking a menu item that says show / hide sent emails.\n\n\n" +
		
		
		"You can change the size of the window by dragging the lower right corner of the " +
		"window frame and the mail program will automatically adjust the font size. If " +
		"you drag the lower right corner of the window and make the frame narrow or shal" +
		"low the font size will become smaller so the program can display the text in a " +
		"smaller area.\n\n" +
		
		"The Image Viewer program also resizes images to fit the size of the frame, but " +
		"you can change the setting by clicking on the View menu item to fit the width " +
		"or height instead of the width and the height.";
}


//  End class __














class Programs
{


	//  Shared data
	
	
	PublicKeyRing publickeyring = new PublicKeyRing();
	
	private String SP0; // the saved passphrase
	private String SP; // the secret passphrase SP = SP0 + SP1
	
	private byte[] SK; // encryption secret key
	private byte[] signatureSK; // signature secret key
	private byte[] filekey; // file key
	
	//  Save the last directory used by File->Open or File->Save
	//  in the directory variable so the user doesn't have to
	//  keep changing directories
	
	private String directory;
	
	
	//  the number of files in the file list
	
	private int numberoffiles = 16;
	
	
	//  the max and min icon sizes
	
	private int miniconsize = 14;
	private int maxiconsize = 24;
	
	private Clipboard cb = Toolkit
	
	   .getDefaultToolkit() .getSystemClipboard();
	
	private Dimension d = Toolkit
	
	    .getDefaultToolkit().getScreenSize();
	
	//  1920 * 1080 ~ 2 M,  1366 * 768 ~ 1 M
	
	private double screenarea = d.getWidth() * d.getHeight();
	
	private static Font textfont;
	private static Font labelfont;
	private static Font menufont;
	private static Font menuitemfont;
	
	
	{	//  Scale the font sizes so the size is proportional to the
		//  screen size; otherwise the font size would appear too
		//  small on a large screen and too large on a small screen
		
		float q = (float) (screenarea / (1024*1024));
		
		float q1 = q - 1; // q ~ 0 to 1
		
		textfont = new JTextArea().getFont() .deriveFont( // ~ 16 to 19
		
		    new JTextArea().getFont().getSize() + 2 + 3.0f * q1);
		
		labelfont = new JLabel() .getFont() .deriveFont(
		
		    new JLabel().getFont().getSize() + 1 + 3.0f * q1);
		
		menufont = new JMenu().getFont() .deriveFont(
		
		    new JMenu().getFont().getSize() + 1 + 2.0f * q1);
		
		menuitemfont = new JMenuItem().getFont() .deriveFont(
		
		    new JMenuItem().getFont().getSize() + 2 + 1.5f * q1);
	}
	
	
	
	
	
	private JMenuBar menubar;
	
	private String titleseparator = "  -  ";
	
	//  double spacing is used around the hyphen because it
	//  appears as single space in the java title bar
	//
	//  e.g., Mydocument - Editor
	
	
	private boolean showkeyboard;
	
	
	
	
	//  ms, second, minute, hour, day, week, month, year
	
	int ms  =    1;
	int sec = 1000 * ms, second = sec, seconds = sec;
	int min =   60 * sec, minute = min, minutes = min;
	int hour =  60 * min, hours = hour;
	long day =  24 * hour, days = day;
	long week =  7 * days, weeks = week;
	
	long month = (long) ((365.25*days)/12), months = month;
	long year  = (long)  (365.25*days), years = year;
	
	
	
	
	
	//  virtual key codes
	
	int vk_enter     = KeyEvent.VK_ENTER;
	int vk_backspace = KeyEvent.VK_BACK_SPACE;
	int vk_delete    = KeyEvent.VK_DELETE;
	int vk_tab       = KeyEvent.VK_TAB;
	int vk_escape    = KeyEvent.VK_ESCAPE;
	int vk_cancel    = KeyEvent.VK_CANCEL;
	int vk_clear     = KeyEvent.VK_CLEAR;
	int vk_shift     = KeyEvent.VK_SHIFT;
	int vk_control   = KeyEvent.VK_CONTROL;
	int vk_alt       = KeyEvent.VK_ALT;
	int vk_pause     = KeyEvent.VK_PAUSE;
	int vk_caps_lock = KeyEvent.VK_CAPS_LOCK;
	int vk_space     = KeyEvent.VK_SPACE;
	int vk_pageup    = KeyEvent.VK_PAGE_UP;
	int vk_pagedown  = KeyEvent.VK_PAGE_DOWN;
	int vk_end       = KeyEvent.VK_END;
	int vk_home      = KeyEvent.VK_HOME;
	int vk_up        = KeyEvent.VK_UP;
	int vk_down      = KeyEvent.VK_DOWN;
	int vk_left      = KeyEvent.VK_LEFT;
	int vk_right     = KeyEvent.VK_RIGHT;
	
	
	
	
	ImageIcon newicon = Icons.get(Icons.new_);
	ImageIcon openicon = Icons.get(Icons.open);
	ImageIcon saveicon = Icons.get(Icons.save);
	ImageIcon saveasicon = Icons.get(Icons.saveas);
	ImageIcon deleteicon = Icons.get(Icons.delete);
	ImageIcon printicon = Icons.get(Icons.print);
	ImageIcon closeicon = Icons.get(Icons.close);
	ImageIcon exiticon = Icons.get(Icons.quit);
	ImageIcon undoicon = Icons.get(Icons.undo);
	ImageIcon redoicon = Icons.get(Icons.redo);
	ImageIcon cuticon = Icons.get(Icons.cut);
	ImageIcon copyicon = Icons.get(Icons.copy);
	ImageIcon pasteicon = Icons.get(Icons.paste);
	ImageIcon selectallicon = Icons.get(Icons.selectall);
	ImageIcon findicon = Icons.get(Icons.findandreplace);
	ImageIcon gotolineicon = Icons.get(Icons.down);
	ImageIcon indenticon = Icons.get(Icons.text_indent);
	ImageIcon fonticon = Icons.get(Icons.font);
	ImageIcon textboldicon = Icons.get(Icons.text_bold);
	ImageIcon textscreencoloricon = Icons.get(Icons.colors);
	ImageIcon coloricon = Icons.get(Icons.colors);
	ImageIcon imageviewericon = Icons.get(Icons.image_viewer);
	ImageIcon tableeditoricon = Icons.get(Icons.view_grid);
	ImageIcon encryptmessageicon = Icons.get(Icons.message);
	ImageIcon encryptdirectoryicon = Icons.get(Icons.directory);
	ImageIcon encryptfileicon = Icons.get(Icons.file);
	ImageIcon signdocumenticon = Icons.get(Icons.mail_signed);
	ImageIcon signmessageicon = Icons.get(Icons.mail_signed);
	ImageIcon verifysignatureicon = Icons.get(Icons.mail_signed_verified);
	ImageIcon newpublickeyicon = Icons.get(Icons.key);
	ImageIcon sendreceiveicon = Icons.get(Icons.mail_send_receive_24x24);
	ImageIcon abouticon = Icons.get(Icons.about);
	ImageIcon editicon = Icons.get(Icons.edit);
	
	
	
	
	
	
	
	public class TextFrame extends JFrame
	{
	
		private static final long serialVersionUID = 1L;
		
		private String version = "0.0";
		
		private JFrame frame;
		
		private JDraggableTabbedPane tabbedpane;
		
		private TextAreaPanel textareapanel;
		
		private ArrayList<TextAreaPanel> textareapanellist;
		
		
		private JTextField currentlinefield;
		private JTextField currentcolfield;
		private JTextField currentposfield;
		
		private Font font, defaultfont;
		
		private String fontname = __.monospaced;
		
		private int fontstyle = Font.PLAIN;
		
		private float fontsize = textfont.getSize();
		
		private int width  = (int) d.getWidth() * 2/3;
		private int height = (int) d.getHeight()* 3/4;
		
		private boolean showhidebuttons = true;
		
		private String program = "Java Editor";
		
		private String titlename = "";
		
		private Color foreground;
		private Color background;
		private Color caretcolor;
		
		
		
		NewListener newlistener;
		OpenListener openlistener;
		DeleteFileListener deletefilelistener;
		SaveListener savelistener;
		SaveAsListener saveaslistener;
		PrintListener printlistener;
		CloseListener closelistener;
		ExitListener exitlistener;
		
		
		//  Opening the file list
		
		FileListListener filelistlistener;
		
		//  Opening a file on the file list
		
		OpenListFileListener openlistfilelistener;
		
		
		UndoListener undolistener;
		
		CutListener cutlistener;
		CopyListener copylistener;
		PasteListener pastelistener;
		
		FindAndReplace.FindListener findlistener;
		FindAndReplace.ReplaceListener replacelistener;
		ReplaceAllListener replacealllistener;
		
		HighlightTextListener highlighttextlistener;
		GoToLineListener gotolinelistener;
		UpperLowerCaseListener upperlowercaselistener;
		IndentListener indentlistener;
		SelectAllListener selectalllistener;
		SelectRangeListener selectrangelistener;
		ConvertTextListener converttextlistener;
		SetTitleListener settitlelistener;
		
		HashListener hashlistener;
		HashFileListener hashfilelistener;
		HashPublicKeyListener hashpublickeylistener;
		
		
		LineWrapListener linewraplistener;
		FontSizeListener fontsizelistener;
		FontTypeListener fonttypelistener;
		TextBoldListener textboldlistener;
		ColorListener colorlistener;
		WordLineCountListener wordlinecountlistener;
		ShowHideButtonsListener showhidebuttonslistener;
		ImageViewerListener imageviewerlistener;
		TableEditorListener tableeditorlistener;
		HTMLEditorPaneListener htmleditorpanelistener;
		
		EncryptMessageListener encryptmessagelistener;
		DecryptMessageListener decryptmessagelistener;
		
		EncryptDirectoryListener encryptdirectorylistener;
		DecryptDirectoryListener decryptdirectorylistener;
		
		EncryptFileListener encryptfilelistener;
		DecryptFileListener decryptfilelistener;
		
		SignKeyListener signkeylistener;
		SignDocumentListener signdocumentlistener1;
		SignDocumentListener signdocumentlistener2;
		VerifySignatureListener verifysignaturelistener;
		
		PrivateKeyListener privatekeylistener;
		PublicKeyListener publickeylistener;
		
		EditorListener editorlistener;
		RetrieveMailListener retrievemaillistener;
		
		AboutListener aboutlistener;
		LicenseListener licenselistener;
		
		ColorButtonListener colorbuttonlistener;
		
		
		WindowListener1 windowlistener1;
		ChangeListener1 changelistener1;
		ComponentListener1 componentlistener1;
		
		KeyListener1 keylistener1;
		MouseWheelListener1 mousewheellistener1;
		
		FocusListener focuslistener;
		MouseListener mouselistener;
		
		
		
		ArrayList<String> filenamelist;
		
		ArrayList<JTextField> textfieldlist;
		
		ArrayList<JMenuItem> listmenuitem;
		
		
		
		
		//  Text Editor Program Menus and Items
		
		
		JMenuItem[] menuitems;
		
		JMenu  filemenu, editmenu, viewmenu,
		encryptmenu, internetmenu, helpmenu;
		
		
		JMenuItem newmenuitem, openmenuitem,
		savemenuitem, saveasmenuitem, deletemenuitem,
		printmenuitem, closemenuitem, exitmenuitem;
		
		JMenuItem undomenuitem, redomenuitem,
		cutmenuitem, copymenuitem, pastemenuitem,
		findmenuitem, replacemenuitem, replaceallmenuitem,
		highlighttextmenuitem, converttextmenuitem,
		settitlemenuitem,
		
		gotolinemenuitem, upperlowercasemenuitem,
		indentmenuitem, selectallmenuitem,
		selectrangemenuitem, hashmenuitem, hashfilemenuitem,
		hashpublickeymenuitem, hashstringmenuitem;
		
		JMenuItem fontsizemenuitem, fonttypemenuitem,
		boldmenuitem, colormenuitem,
		linewrapmenuitem, wordlinecountmenuitem,
		showhidebuttonsmenuitem,
		imageviewermenuitem, tableeditormenuitem,
		htmlfileviewermenuitem, htmleditorpanemenuitem;
		
		JMenuItem encryptmessagemenuitem, decryptmessagemenuitem,
		encryptdirectorymenuitem, decryptdirectorymenuitem,
		encryptfilemenuitem, decryptfilemenuitem,
		signkeymenuitem, signdocumentmenuitem,
		signmessagemenuitem, verifysignaturemenuitem,
		privatekeymenuitem, newpublickeymenuitem;
		
		JMenuItem retrievemenuitem, sendmenuitem;
		
		JMenuItem aboutmenuitem, licensemenuitem;
		
		
		
		//  iconpanel could mean iconbuttonpanel
		//  if buttons are used or iconlabelpanel
		//  if labels are used
		
		private JPanel iconpanel;
		
		private ImageIcon[] imageicons;
		private JButton[] iconbuttons;
		
		
		private JButton
		
		newbutton, openbutton,
		savebutton, closebutton,
		
		undobutton, redobutton,
		cutbutton, copybutton,
		pastebutton, findbutton,
		
		linewrapbutton, fontsizebutton,
		fonttypebutton, textboldbutton,
		colorbutton, sendretrievemailbutton,
		
		tableeditorbutton,
		imageviewerbutton,
		htmlviewerbutton;
		
		
		
		
		public TextFrame()
		{
		
			frame = this;
			frame.setSize(width, height);
			frame.setResizable(true);
			frame.setVisible(true);
			frame.setTitle(titlename);
			frame.setLayout(new GridBagLayout());
			frame.setDefaultCloseOperation(
			    DO_NOTHING_ON_CLOSE);
			
			
			windowlistener1 = new WindowListener1();
			changelistener1 = new ChangeListener1();
			componentlistener1 = new ComponentListener1();
			
			keylistener1 = new KeyListener1();
			focuslistener = new FocusListener();
			mouselistener = new MouseListener();
			mousewheellistener1 = new MouseWheelListener1();
			
			
			//  Create an array list of TextAreaPanel to hold the text area panels
			
			textareapanellist = new ArrayList<TextAreaPanel>();
			
			
			//  Create a draggable tabbed pane
			
			tabbedpane = new JDraggableTabbedPane();
			tabbedpane.setDragEnabled(true);
			tabbedpane.setFocusTraversalPolicy();
			tabbedpane.addMouseListener(mouselistener);
			
			
			
			//  Add an EventListener or ChangeListener to the JTabbedPane
			//
			//  to change the reference to the selected tab
			
			tabbedpane.addChangeListener(changelistener1);
			
			
			
			
			//  Listeners
			
			
			newlistener = new NewListener();
			openlistener = new OpenListener();
			openlistfilelistener = new OpenListFileListener();
			deletefilelistener = new DeleteFileListener(frame);
			savelistener = new SaveListener();
			saveaslistener = new SaveAsListener();
			printlistener = new PrintListener();
			closelistener = new CloseListener();
			exitlistener = new ExitListener();
			filelistlistener = new FileListListener();
			
			
			
			undolistener = new UndoListener();
			
			cutlistener = new CutListener();
			copylistener = new CopyListener();
			pastelistener = new PasteListener();
			
			selectalllistener = new SelectAllListener();
			selectrangelistener = new SelectRangeListener();
			
			findlistener = new FindAndReplace() .new FindListener();
			replacelistener = new FindAndReplace() .new ReplaceListener();
			replacealllistener = new ReplaceAllListener();
			
			highlighttextlistener = new HighlightTextListener();
			gotolinelistener = new GoToLineListener();
			upperlowercaselistener = new UpperLowerCaseListener();
			indentlistener = new IndentListener();
			
			converttextlistener = new ConvertTextListener();
			settitlelistener = new SetTitleListener();
			
			hashlistener = new HashListener();
			
			hashfilelistener = new HashFileListener();
			
			hashpublickeylistener = new HashPublicKeyListener();
			
			
			
			linewraplistener = new LineWrapListener();
			
			fontsizelistener = new FontSizeListener();
			fonttypelistener = new FontTypeListener();
			textboldlistener = new TextBoldListener();
			
			colorlistener = new ColorListener();
			
			wordlinecountlistener = new WordLineCountListener();
			showhidebuttonslistener = new ShowHideButtonsListener();
			
			imageviewerlistener = new ImageViewerListener();
			tableeditorlistener = new TableEditorListener();
			htmleditorpanelistener = new HTMLEditorPaneListener();
			
			
			
			encryptmessagelistener = new EncryptMessageListener();
			decryptmessagelistener = new DecryptMessageListener();
			
			encryptfilelistener = new EncryptFileListener();
			decryptfilelistener = new DecryptFileListener();
			
			encryptdirectorylistener = new EncryptDirectoryListener();
			decryptdirectorylistener = new DecryptDirectoryListener();
			
			signkeylistener = new SignKeyListener();
			signdocumentlistener1 = new SignDocumentListener(1);
			signdocumentlistener2 = new SignDocumentListener(2);
			verifysignaturelistener = new VerifySignatureListener();
			
			privatekeylistener = new PrivateKeyListener();
			publickeylistener = new PublicKeyListener();
			
			
			editorlistener = new EditorListener();
			retrievemaillistener = new RetrieveMailListener();
			
			
			aboutlistener = new AboutListener();
			licenselistener = new LicenseListener();
			
			
			colorbuttonlistener = new ColorButtonListener();
			
			
			
			//  Create an icon panel
			
			iconpanel = createIconPanel();
			
			
			//  Add the icon panel and the
			//  JTabbedPane to the frame
			
			Gbc gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setFill(Gbc.none);
			gbc.setAnchor(Gbc.left);
			
			frame.add(iconpanel, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			frame.add(tabbedpane, gbc);
			
			
			
			
			//  MenuBar,   Menu, Menu items, ...
			
			
			menubar = new JMenuBar();
			
			frame.setJMenuBar(menubar);
			
			
			
			
			
			
			//  File menu
			
			
			filemenu = new JMenu(__.file);
			filemenu.setFont(menufont);
			
			
			newmenuitem = new JMenuItem(__.newkey, newicon);
			newmenuitem.addActionListener(newlistener);
			filemenu.add(newmenuitem);
			
			openmenuitem = new JMenuItem(__.openkey, openicon);
			openmenuitem.addActionListener(openlistener);
			filemenu.add(openmenuitem);
			
			savemenuitem = new JMenuItem(__.savekey, saveicon);
			savemenuitem.addActionListener(savelistener);
			filemenu.add(savemenuitem);
			
			saveasmenuitem = new JMenuItem(__.saveaskey, saveasicon);
			saveasmenuitem.addActionListener(saveaslistener);
			filemenu.add(saveasmenuitem);
			
			
			
			deletemenuitem = new JMenuItem(__.deletekey, deleteicon);
			deletemenuitem.addActionListener(deletefilelistener);
			filemenu.add(deletemenuitem);
			
			printmenuitem = new JMenuItem(__.printkey, printicon);
			printmenuitem.addActionListener(printlistener);
			filemenu.add(printmenuitem);
			
			closemenuitem = new JMenuItem(__.closekey, closeicon);
			closemenuitem.addActionListener(closelistener);
			filemenu.add(closemenuitem);
			
			exitmenuitem = new JMenuItem(__.exitkey, exiticon);
			exitmenuitem.addActionListener(exitlistener);
			filemenu.add(exitmenuitem);
			
			filemenu.addSeparator();
			
			JMenuItem menuitem = new JMenuItem("");
			menuitem.addActionListener(filelistlistener);
			filemenu.add(menuitem);
			
			filemenu.addSeparator();
			
			//  ...
			
			menubar.add(filemenu);
			
			
			
			
			
			//  Edit menu
			
			
			editmenu = new JMenu(__.edit);
			editmenu.setFont(menufont);
			
			
			undomenuitem = new JMenuItem(__.undokey, undoicon);
			undomenuitem.addActionListener(undolistener);
			editmenu.add(undomenuitem);
			
			redomenuitem = new JMenuItem(__.redokey, redoicon);
			redomenuitem.addActionListener(undolistener);
			editmenu.add(redomenuitem);
			
			
			editmenu.addSeparator();
			
			cutmenuitem = new JMenuItem(__.cutkey, cuticon);
			cutmenuitem.addActionListener(cutlistener);
			editmenu.add(cutmenuitem);
			
			copymenuitem = new JMenuItem(__.copykey, copyicon);
			copymenuitem.addActionListener(copylistener);
			editmenu.add(copymenuitem);
			
			pastemenuitem = new JMenuItem(__.pastekey, pasteicon);
			pastemenuitem.addActionListener(pastelistener);
			editmenu.add(pastemenuitem);
			
			editmenu.addSeparator();
			
			
			selectallmenuitem = new JMenuItem(__.selectallkey, selectallicon);
			selectallmenuitem.addActionListener(selectalllistener);
			editmenu.add(selectallmenuitem);
			
			selectrangemenuitem = new JMenuItem(__.selectrange);
			selectrangemenuitem.addActionListener(selectrangelistener);
			editmenu.add(selectrangemenuitem);
			
			editmenu.addSeparator();
			
			findmenuitem = new JMenuItem(__.findkey, findicon);
			findmenuitem.addActionListener(findlistener);
			editmenu.add(findmenuitem);
			
			replacemenuitem = new JMenuItem(__.replacekey);
			replacemenuitem.addActionListener(replacelistener);
			editmenu.add(replacemenuitem);
			
			replaceallmenuitem = new JMenuItem(__.replaceall);
			replaceallmenuitem.addActionListener(replacealllistener);
			editmenu.add(replaceallmenuitem);
			
			highlighttextmenuitem = new JMenuItem(__.highlighttext);
			highlighttextmenuitem.addActionListener(highlighttextlistener);
			editmenu.add(highlighttextmenuitem);
			
			gotolinemenuitem = new JMenuItem(__.gotolinekey, gotolineicon);
			gotolinemenuitem.addActionListener(gotolinelistener);
			editmenu.add(gotolinemenuitem);
			
			editmenu.addSeparator();
			
			upperlowercasemenuitem = new JMenuItem(__.upperlowercase);
			upperlowercasemenuitem.addActionListener(upperlowercaselistener);
			editmenu.add(upperlowercasemenuitem);
			
			editmenu.addSeparator();
			
			
			converttextmenuitem = new JMenuItem(__.converttext);
			converttextmenuitem.addActionListener(converttextlistener);
			editmenu.add(converttextmenuitem);
			
			editmenu.addSeparator();
			
			
			indentmenuitem = new JMenuItem(__.indentunindent, indenticon);
			indentmenuitem.addActionListener(indentlistener);
			editmenu.add(indentmenuitem);
			
			editmenu.addSeparator();
			
			
			settitlemenuitem = new JMenuItem(__.setprogramtitle);
			settitlemenuitem.addActionListener(settitlelistener);
			editmenu.add(settitlemenuitem);
			
			
			//  ...
			
			menubar.add(editmenu);
			
			
			
			
			
			//  View menu
			
			
			viewmenu = new JMenu(__.view);
			viewmenu.setFont(menufont);
			
			linewrapmenuitem = new JMenuItem(__.lineunwrapkey);
			
			linewrapmenuitem.addActionListener(linewraplistener);
			viewmenu.add(linewrapmenuitem);
			
			viewmenu.addSeparator();
			
			fontsizemenuitem = new JMenuItem(__.fontsizekey, fonticon);
			fontsizemenuitem.addActionListener(fontsizelistener);
			viewmenu.add(fontsizemenuitem);
			
			fonttypemenuitem = new JMenuItem(__.fonttype);
			fonttypemenuitem.addActionListener(fonttypelistener);
			viewmenu.add(fonttypemenuitem);
			
			boldmenuitem = new JMenuItem(__.bold_unbold, textboldicon);
			boldmenuitem.addActionListener(textboldlistener);
			viewmenu.add(boldmenuitem);
			
			viewmenu.addSeparator();
			
			colormenuitem = new JMenuItem(__.textscreencolor, textscreencoloricon);
			colormenuitem.addActionListener(colorlistener);
			viewmenu.add(colormenuitem);
			
			viewmenu.addSeparator();
			
			wordlinecountmenuitem = new JMenuItem(__.wordlinecount);
			wordlinecountmenuitem.addActionListener(wordlinecountlistener);
			viewmenu.add(wordlinecountmenuitem);
			
			viewmenu.addSeparator();
			
			showhidebuttonsmenuitem = new JMenuItem(__.showhidebuttons);
			showhidebuttonsmenuitem.addActionListener(showhidebuttonslistener);
			viewmenu.add(showhidebuttonsmenuitem);
			
			viewmenu.addSeparator();
			
			tableeditormenuitem = new JMenuItem(__.tableeditor, tableeditoricon);
			tableeditormenuitem.addActionListener(tableeditorlistener);
			viewmenu.add(tableeditormenuitem);
			
			imageviewermenuitem = new JMenuItem(__.imageviewer, imageviewericon);
			imageviewermenuitem.addActionListener(imageviewerlistener);
			viewmenu.add(imageviewermenuitem);
			
			htmleditorpanemenuitem = new JMenuItem(__.htmleditorpane);
			htmleditorpanemenuitem.addActionListener(htmleditorpanelistener);
			viewmenu.add(htmleditorpanemenuitem);
			
			
			viewmenu.addSeparator();
			
			hashmenuitem = new JMenuItem(__.hashtext);
			hashmenuitem.addActionListener(hashlistener);
			viewmenu.add(hashmenuitem);
			
			hashfilemenuitem = new JMenuItem(__.hashfile);
			hashfilemenuitem.addActionListener(hashfilelistener);
			viewmenu.add(hashfilemenuitem);
			
			hashpublickeymenuitem = new JMenuItem(__.hashpublickey);
			hashpublickeymenuitem.addActionListener(hashpublickeylistener);
			viewmenu.add(hashpublickeymenuitem);
			
			//  ...
			
			menubar.add(viewmenu);
			
			
			
			
			//  Encrypt menu
			
			
			encryptmenu = new JMenu(__.encrypt);
			encryptmenu.setFont(menufont);
			
			encryptmessagemenuitem = new JMenuItem(__.encryptmessage, encryptmessageicon);
			encryptmessagemenuitem.addActionListener(encryptmessagelistener);
			encryptmenu.add(encryptmessagemenuitem);
			
			decryptmessagemenuitem = new JMenuItem(__.decryptmessage);
			decryptmessagemenuitem.addActionListener(decryptmessagelistener);
			encryptmenu.add(decryptmessagemenuitem);
			
			encryptmenu.addSeparator();
			
			
			//  The encrypt directory and encrypt file menu items could be
			//  merged into one menu item like the hash file / dir menu item
			
			encryptdirectorymenuitem = new JMenuItem(__.encryptdirectory, encryptdirectoryicon);
			encryptdirectorymenuitem.addActionListener(encryptdirectorylistener);
			encryptmenu.add(encryptdirectorymenuitem);
			
			decryptdirectorymenuitem = new JMenuItem(__.decryptdirectory);
			decryptdirectorymenuitem.addActionListener(decryptdirectorylistener);
			encryptmenu.add(decryptdirectorymenuitem);
			
			encryptmenu.addSeparator();
			
			encryptfilemenuitem = new JMenuItem(__.encryptfile, encryptfileicon);
			encryptfilemenuitem.addActionListener(encryptfilelistener);
			encryptmenu.add(encryptfilemenuitem);
			
			decryptfilemenuitem = new JMenuItem(__.decryptfile);
			decryptfilemenuitem.addActionListener(decryptfilelistener);
			encryptmenu.add(decryptfilemenuitem);
			
			encryptmenu.addSeparator();
			
			
			
			signkeymenuitem = new JMenuItem(__.signaturekey);
			signkeymenuitem.addActionListener(signkeylistener);
			encryptmenu.add(signkeymenuitem);
			
			signdocumentmenuitem = new JMenuItem(__.signdocument, signdocumenticon);
			signdocumentmenuitem.addActionListener(signdocumentlistener1);
			encryptmenu.add(signdocumentmenuitem);
			
			signmessagemenuitem = new JMenuItem(__.signmessage, signdocumenticon);
			signmessagemenuitem.addActionListener(signdocumentlistener2);
			///  encryptmenu.add(signmessagemenuitem);
			
			verifysignaturemenuitem = new JMenuItem(__.verifysignature, verifysignatureicon);
			verifysignaturemenuitem.addActionListener(verifysignaturelistener);
			encryptmenu.add(verifysignaturemenuitem);
			
			encryptmenu.addSeparator();
			
			
			
			
			privatekeymenuitem = new JMenuItem(__.privatekeyencryption);
			privatekeymenuitem.addActionListener(privatekeylistener);
			encryptmenu.add(privatekeymenuitem);
			
			encryptmenu.addSeparator();
			
			newpublickeymenuitem = new JMenuItem(__.newpublickey, newpublickeyicon);
			newpublickeymenuitem.addActionListener(publickeylistener);
			encryptmenu.add(newpublickeymenuitem);
			
			//  keyhashmenuitem = new JMenuItem(__.keyhash);
			//  keyhashmenuitem.addActionListener(keyhashlistener);
			//  encryptmenu.add(keyhashmenuitem);
			
			//  ...
			
			menubar.add(encryptmenu);
			
			
			
			
			//  Internet menu
			
			
			internetmenu = new JMenu(__.Internet);
			internetmenu.setFont(menufont);
			
			retrievemenuitem = new JMenuItem(__.sendretrievemail, sendreceiveicon);
			retrievemenuitem.addActionListener(retrievemaillistener);
			internetmenu.add(retrievemenuitem);
			
			
			//  sendmenuitem = new JMenuItem(__.sendemail);
			//  sendmenuitem.addActionListener(
			//  	sendmaillistener);
			//  internetmenu.add(sendmenuitem);
			
			////  internetmenu.addSeparator();
			
			menubar.add(internetmenu);
			
			
			
			//  Help menu
			
			
			helpmenu = new JMenu(__.help);
			helpmenu.setFont(menufont);
			
			aboutmenuitem = new JMenuItem(__.about, abouticon);
			aboutmenuitem.addActionListener(aboutlistener);
			helpmenu.add(aboutmenuitem);
			
			
			//  ...
			
			menubar.add(helpmenu);
			
			
			
			menuitems = new JMenuItem[]
			{
			
				newmenuitem, openmenuitem, deletemenuitem, exitmenuitem,
				savemenuitem, saveasmenuitem, printmenuitem, closemenuitem,
				
				undomenuitem, redomenuitem,
				cutmenuitem, copymenuitem, pastemenuitem,
				selectallmenuitem, selectrangemenuitem,
				
				findmenuitem, replacemenuitem, replaceallmenuitem,
				highlighttextmenuitem, gotolinemenuitem,
				upperlowercasemenuitem, indentmenuitem,
				converttextmenuitem, settitlemenuitem,
				
				hashmenuitem, hashfilemenuitem, hashpublickeymenuitem,
				
				fontsizemenuitem, fonttypemenuitem, boldmenuitem,
				colormenuitem, linewrapmenuitem,
				wordlinecountmenuitem, showhidebuttonsmenuitem,
				
				htmleditorpanemenuitem,	tableeditormenuitem, imageviewermenuitem,
				
				encryptmessagemenuitem, decryptmessagemenuitem,
				encryptdirectorymenuitem, decryptdirectorymenuitem,
				encryptfilemenuitem, decryptfilemenuitem,
				
				signkeymenuitem, signdocumentmenuitem,
				signmessagemenuitem, verifysignaturemenuitem,
				privatekeymenuitem,
				
				newpublickeymenuitem,
				
				retrievemenuitem, aboutmenuitem
			};
			
			
			
			//  Use the window opened method to read the
			//  settings and then initialize the color buttons
			//
			//  colorbuttonlistener.init();
			
			
			
			foreground = Color.black;
			background = Color.white;
			
			
			
			//  Set the font of the textareapanel
			
			defaultfont = this.getFont();
			
			font = new Font(fontname, fontstyle, (int) fontsize);
			
			setFont1(font);
			
			
			
			//  Add the window and component listener
			
			frame.addWindowListener(windowlistener1);
			
			frame.addComponentListener(componentlistener1);
			
			
			filenamelist = new ArrayList<String>();
			
			textfieldlist = new ArrayList<JTextField>();
			
			listmenuitem = new ArrayList<JMenuItem>();
			
			
			
			//  Create a new TextAreaPanel
			
			newlistener.run();
			
			
			//  ...
			
			//  ...
		}
		
		
		//  End TextFrame constructor
		
		
		
		
		
		
		
		private JPanel createIconPanel()
		{
		
			newbutton = new JButton();
			openbutton = new JButton();
			savebutton = new JButton();
			closebutton = new JButton();
			
			undobutton = new JButton();
			redobutton = new JButton();
			
			cutbutton = new JButton();
			copybutton = new JButton();
			pastebutton = new JButton();
			findbutton = new JButton();
			
			linewrapbutton = new JButton();
			fontsizebutton = new JButton();
			fonttypebutton = new JButton();
			textboldbutton = new JButton();
			colorbutton = new JButton();
			sendretrievemailbutton = new JButton();
			
			tableeditorbutton = new JButton();
			imageviewerbutton = new JButton();
			htmlviewerbutton = new JButton();
			
			
			newbutton.addActionListener(newlistener);
			openbutton.addActionListener(openlistener);
			savebutton.addActionListener(savelistener);
			closebutton.addActionListener(closelistener);
			
			undobutton.addActionListener(undolistener);
			redobutton.addActionListener(undolistener);
			
			cutbutton.addActionListener(cutlistener);
			copybutton.addActionListener(copylistener);
			pastebutton.addActionListener(pastelistener);
			
			findbutton.addActionListener(findlistener);
			
			fontsizebutton.addActionListener(fontsizelistener);
			textboldbutton.addActionListener(textboldlistener);
			colorbutton.addActionListener(colorlistener);
			sendretrievemailbutton.addActionListener(
			    retrievemaillistener);
			
			
			
			newbutton.setToolTipText(__.new_);
			openbutton.setToolTipText(__.open);
			savebutton.setToolTipText(__.save);
			closebutton.setToolTipText(__.close);
			
			undobutton.setToolTipText(__.undo);
			redobutton.setToolTipText(__.redo);
			cutbutton.setToolTipText(__.cut);
			copybutton.setToolTipText(__.copy);
			pastebutton.setToolTipText(__.paste);
			findbutton.setToolTipText(__.find);
			
			fontsizebutton.setToolTipText(__.font);
			textboldbutton.setToolTipText(__.text_bold);
			colorbutton.setToolTipText(__.textscreencolor);
			sendretrievemailbutton.setToolTipText(__.sendretrievemail);
			
			
			imageicons = new ImageIcon[]
			{
				newicon, openicon, saveicon, closeicon,
				undoicon, redoicon, cuticon, copyicon, pasteicon,
				findicon, fonticon, textboldicon, coloricon,
				sendreceiveicon,
			};
			
			iconbuttons = new JButton[]
			{
				newbutton, openbutton, savebutton, closebutton,
				undobutton, redobutton, cutbutton, copybutton, pastebutton,
				findbutton, fontsizebutton, textboldbutton, colorbutton,
				sendretrievemailbutton,
			};
			
			
			Box box = Box.createHorizontalBox();
			
			for (JButton button : iconbuttons)
			{
				if (button == null) continue;
				
				button.setContentAreaFilled(false);
				button.setBorderPainted(false);
				
				Component hstrut = Box
				    .createHorizontalStrut(0);
				
				box.add(button);
				box.add(hstrut);
			}
			
			JPanel panel = new JPanel();
			
			panel.add(box);
			
			return panel;
		}
		
		
		
		
		
		private class TextAreaPanel extends JPanel
		{
		
			private static final long serialVersionUID = 1L;
			
			private JTextArea textarea;
			
			private File file;
			
			private boolean filechanged;
			private boolean encrypted;
			private boolean gotoline;
			private boolean indenting;
			
			private boolean autoindent = true;
			private boolean linewrap = true;
			
			private Undo undo;
			
			
			public TextAreaPanel()
			{
			
				this.setLayout(new GridBagLayout());
				
				textarea = new JTextArea();
				
				textarea.setLineWrap(true);
				textarea.setWrapStyleWord(true);
				textarea.setFont(font);
				
				textarea.setForeground(foreground);
				textarea.setBackground(background);
				textarea.setCaretColor(foreground);
				
				undo = new Undo(textarea);
				
				
				JScrollPane scrollpane = new JScrollPane(textarea,
				
				    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
				    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
				
				scrollpane.addMouseWheelListener(mousewheellistener1);
				
				
				textarea.addMouseListener(mouselistener);
				textarea.addFocusListener(focuslistener);
				textarea.addKeyListener(keylistener1);
				
				this.addKeyListener(keylistener1);
				
				//  ...
				
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(scrollpane, gbc);
			}
		}
		
		
		//  End class TextAreaPanel
		
		
		
		
		
		private class ComponentListener1 extends ComponentAdapter
		{
			public void componentResized(ComponentEvent e)
			{
				if (e.getSource() instanceof JFrame)
				{
					for (TextAreaPanel textareapanel : textareapanellist)
					{
						JTextArea textarea = textareapanel.textarea;
						
						//  Restore the screen position
						
						int cp = textarea.getCaretPosition();
						
						int cp1 = cp > 0 ? cp - 1 : 0;
						
						textarea. setCaretPosition(cp);
						textarea.moveCaretPosition(cp1);
						textarea. setCaretPosition(cp);
					}
				}
			}
		}
		
		
		
		private class ChangeListener1 implements ChangeListener
		{
			public void stateChanged(ChangeEvent e)
			{
				textareapanel = (TextAreaPanel)
				
				    tabbedpane.getSelectedComponent();
				
				if (textareapanel != null)
				
				    textareapanel.textarea
				
					.requestFocusInWindow();
				
				setFrameTitle();
			}
		}
		
		
		
		
		private void setMenuItemsEnabled(boolean bool)
		{
			JMenuItem[] menuitems = new JMenuItem[]
			{
				//  newmenuitem, openmenuitem, deletemenuitem, exitmenuitem,
				savemenuitem, saveasmenuitem, printmenuitem, closemenuitem,
				
				undomenuitem, redomenuitem,
				cutmenuitem, copymenuitem, pastemenuitem,
				selectallmenuitem, selectrangemenuitem,
				
				findmenuitem, replacemenuitem, replaceallmenuitem,
				highlighttextmenuitem, gotolinemenuitem,
				upperlowercasemenuitem, indentmenuitem,
				converttextmenuitem, // settitlemenuitem,
				
				hashmenuitem, // hashfilemenuitem,
				hashpublickeymenuitem,
				
				fontsizemenuitem, fonttypemenuitem, boldmenuitem,
				colormenuitem, linewrapmenuitem,
				wordlinecountmenuitem, // showhidebuttonsmenuitem,
				
				htmleditorpanemenuitem,
				//  tableeditormenuitem, imageviewermenuitem,
				
				encryptmessagemenuitem, decryptmessagemenuitem,
				// encryptdirectorymenuitem, decryptdirectorymenuitem,
				// encryptfilemenuitem, decryptfilemenuitem,
				
				signkeymenuitem, signdocumentmenuitem,
				signmessagemenuitem, verifysignaturemenuitem,
				privatekeymenuitem,
				
				newpublickeymenuitem,
				
				//  retrievemenuitem, aboutmenuitem
			};
			
			for (JMenuItem menuitem : menuitems)
			
			    menuitem.setEnabled(bool);
		}
		
		
		
		private void setCurrentLineTextField()
		{
			//  Find the current line
			
			if (textareapanel == null) return;
			
			String text = textareapanel.textarea.getText();
			
			int cp = textareapanel.textarea.getCaretPosition();
			
			int line = 1;
			
			for (int i = 0; i < cp; i++)
			{
				//  Count the lines up to the caret position
				
				if (text.charAt(i) == '\n') line += 1;
			}
			
			int col = 0;
			
			if (cp > 0) for (int i = 0; i < cp; i++, col++)
			{
				char c = text.charAt(cp -1 - i);
				
				if (c == '\n') break;
			}
			
			String linestr = String.valueOf(line);
			String  colstr = String.valueOf(col);
			String  posstr = String.valueOf(cp);
			
			currentlinefield.setText(linestr);
			currentcolfield .setText(colstr);
			currentposfield .setText(posstr);
		}
		
		
		
		
		private class MouseListener extends MouseAdapter
		{
		
			private JPopupMenu popupmenu;
			private JPopupMenu tabpopupmenu;
			
			private JMenuItem cutmenuitem;
			private JMenuItem copymenuitem;
			private JMenuItem pastemenuitem;
			private JMenuItem selectallmenuitem;
			private JMenuItem hashmenuitem;
			
			
			public MouseListener()
			{
			
				popupmenu = new JPopupMenu();
				
				tabpopupmenu = new JPopupMenu();
				
				
				//  Create the text area popup menu
				
				cutmenuitem = new JMenuItem(__.cut);
				cutmenuitem.addActionListener(new CutListener());
				cutmenuitem.setFont(menuitemfont);
				popupmenu.add(cutmenuitem);
				
				copymenuitem = new JMenuItem(__.copy);
				copymenuitem.addActionListener(new CopyListener());
				copymenuitem.setFont(menuitemfont);
				popupmenu.add(copymenuitem);
				
				pastemenuitem = new JMenuItem(__.paste);
				pastemenuitem.addActionListener(new PasteListener());
				pastemenuitem.setFont(menuitemfont);
				popupmenu.add(pastemenuitem);
				
				popupmenu.addSeparator();
				
				selectallmenuitem = new JMenuItem(__.selectall);
				selectallmenuitem.addActionListener(new SelectAllListener());
				selectallmenuitem.setFont(menuitemfont);
				popupmenu.add(selectallmenuitem);
				
				hashmenuitem = new JMenuItem(__.hash);
				hashmenuitem.addActionListener(new HashListener());
				hashmenuitem.setFont(menuitemfont);
				popupmenu.add(hashmenuitem);
				
				
				
				//  Create the tabbed pane popup menu
				
				JMenuItem menuitem;
				
				menuitem = new JMenuItem(__.close);
				menuitem.addActionListener(new CloseListener());
				menuitem.setFont(menuitemfont);
				tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.saveas);
				menuitem.addActionListener(new SaveAsListener());
				menuitem.setFont(menuitemfont);
				tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.save);
				menuitem.addActionListener(new SaveListener());
				menuitem.setFont(menuitemfont);
				tabpopupmenu.add(menuitem);
				
				//  ...
			}
			
			
			public void mousePressed(MouseEvent e)
			{
				if (textareapanel != null)
				{
					if (e.getSource() == textareapanel.textarea)
					
					    setCurrentLineTextField();
					
					if (e.getSource() == currentlinefield)
					
					    //  Select the current line field text
					
					    currentlinefield.selectAll();
				}
				
				if ((textareapanel != null) && (e.getButton() != MouseEvent.BUTTON1))
				{
					String selectedtext = textareapanel.textarea.getSelectedText();
					
					boolean selected = (selectedtext != null) && !selectedtext.isEmpty();
					
					 cutmenuitem.setEnabled(selected);
					copymenuitem.setEnabled(selected);
					
					if (e.getSource() == textareapanel.textarea)
					
					    popupmenu.show(textareapanel.textarea, e.getX(), e.getY());
					
					if (e.getSource() == tabbedpane)
					
					    tabpopupmenu.show(tabbedpane, e.getX(), e.getY());
				}
			}
			
			
			public void mouseReleased(MouseEvent e)
			{
				if (textareapanel != null)
				
				    textareapanel.indenting = false;
			}
			
			
			public void mouseClicked(MouseEvent e)
			{
				
			}
		}
		
		
		
		private class MouseWheelListener1 implements MouseWheelListener
		{
			public void mouseWheelMoved(MouseWheelEvent e)
			{
				int rotation = e.getWheelRotation();
				
				//  ...
				
				if (keylistener1.control)
				{
					if (rotation > 0) fontsizelistener.incrementSize();
					if (rotation < 0) fontsizelistener.decrementSize();
				}
			}
		}
		
		
		
		
		
		
		private class KeyListener1 implements KeyListener
		{
		
			private boolean shift, control, alt, keypressed;
			
			private int start, end; // indent / unindent
			
			public boolean getShift() { return shift; }
			public boolean getControl() { return control; }
			public boolean getAlt() { return alt; }
			
			
			public void keyTyped(KeyEvent e)
			{
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = true;
				if (keycode == vk_control) control = true;
				if (keycode == vk_alt) alt = true;
				
				if ( ((keychar >= '0') && (keychar <= '9'))
				  || ((keychar >= 'A') && (keychar <= 'Z'))
				  || ((keychar >= 'a') && (keychar <= 'z'))
				  
				  ||  (keychar == '+') || (keychar == '-')
				  ||  (keychar == '/') || (keychar == '\\')
				  ||  (keychar == '[') || (keychar == ']')
				  ||  (keychar == ',') || (keychar == '.')
				  ||  (keychar == ';') || (keychar == '\'')
				  ||  (keychar == '\'')|| (keychar == '"')
				  ||  (keychar == '`') || (keychar == '@')
				  ||  (keychar == '#') || (keychar == '$')
				  ||  (keychar == '%') || (keychar == '^')
				  ||  (keychar == '&') || (keychar == '*')
				  ||  (keychar == '(') || (keychar == ')')
				  ||  (keychar == '_') || (keychar == '=')
				  
				  ||  (keychar == vk_space)
				  ||  (keychar == vk_backspace)
				  ||  (keychar == vk_delete)
				  ||  (keychar == vk_enter)
				  ||  (keychar == vk_tab) )
				
				     if (control == false)
				
					textareapanel.filechanged = true;
				
				
				if ((keycode == __.undokeycode)
				 || (keycode == __.redokeycode))
				
				//  ctrl + a == 1,  ctrl + b == 2, ctrl + c == 3, ...
				
				if (control && (keychar == 'x' - 'a' + 1))
				{
					textareapanel.filechanged = true;
				}
				
				else if (control && (keychar == 'v' - 'a' + 1))
				{
					textareapanel.filechanged = true;
				}
				
				
				//  auto indent / auto tab each time the enter key is typed
				//
				//  The auto indent feature is useful for programming
				
				if (e.getSource() == textareapanel.textarea)
				{
					if (textareapanel.autoindent
					
					    && (keychar == vk_enter))
					
						autoindent();
				}
				
				//  There may be a virtual key code for control i
				
				if (keychar == 9)  //  ctrl + i
				{
					currentlinefield.setText("");
					currentcolfield .setText("");
					currentposfield .setText("");
				}
			}
			
			
			
			
			public void keyPressed(KeyEvent e)
			{
			
				keypressed = true;
				
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = true;
				if (keycode == vk_control) control = true;
				if (keycode == vk_alt) alt = true;
				
				
				if (textareapanel == null) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				int cp = textareapanel.textarea.getCaretPosition();
				
				String selectedtext = textarea.getSelectedText();
				
				boolean selected = (selectedtext != null) && !selectedtext.isEmpty();
				
				//  Indent or un-indent the selected text
				
				if ((selected || textareapanel.indenting)
				
				    && (((keychar == vk_tab) || (keycode == vk_right)) && !shift))
				
					indent();
				
				else if ((selected || textareapanel.indenting)
				
				    && ((keycode == vk_left) && !shift))
				
					unindent();
				
				else textareapanel.indenting = false;
				
				
				//  Stop the bell from ringing
				
				if ((cp == 0) && (keycode == vk_backspace)
				
				    && !selected) e.consume();
				
				
				
				
				if (false) {  }
				
				
				//  Don't set control to false for font size
				//  and undo key codes so the user can hold
				//  ctrl and type the key code multiple times
				
				else if (control && (keychar == __.pluskeychar))
				{
					fontsizelistener.incrementSize();
					
					//  control = false;
				}
				
				else if (control && (keychar == __.minuskeychar))
				{
					fontsizelistener.decrementSize();
					
					//  control = false;
				}
				
				else if (control && (keycode == __.newkeycode))
				{
					newlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.openkeycode))
				{
					openlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.deletekeycode))
				{
					deletefilelistener.run();
					
					control = false;
				}
				
				else if (!shift && control && (keycode == __.savekeycode))
				{
					savelistener.run();
					
					control = false;
				}
				
				else if (shift && control && (keycode == __.saveaskeycode))
				{
					saveaslistener.run();
					
					control = false;
					
					shift = false;
				}
				
				else if (control && (keycode == __.printkeycode))
				{
					printlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.closekeycode))
				{
					closelistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.exitkeycode))
				{
					exitlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.findkeycode))
				{
					findlistener.setVisible(true);
					
					control = false;
				}
				
				else if (control && (keycode == __.replacekeycode))
				{
					replacelistener.setVisible(true);
					
					control = false;
				}
				
				else if (control && (keycode == __.gotolinekeycode))
				{
					gotolinelistener.setVisible(true);
					
					control = false;
				}
				
				else if (control && (keycode == __.undokeycode))
				{
					if (!shift) undolistener.undo();
					else        undolistener.redo();
					
					//  control = false;
				}
				
				else if (control && (keycode == __.linewrapkeycode))
				{
					linewraplistener.run();
					
					control = false;
				}
				
				
				//  No programming is required for
				//
				//  Ctrl X, C, V, and A (cut, copy, paste, and select all)
				//  Ctrl X, C, V, and A work on all text components
				
				
				if (textareapanel != null)
				
				if (e.getSource() == textarea)
				
				    setCurrentLineTextField();
			}
			
			
			
			public void keyReleased(KeyEvent e)
			{
				keypressed = false;
				
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = false;
				
				if (keycode == vk_control) control = false;
				
				if (keycode == vk_alt) alt = false;
				
				if ((textareapanel != null) &&
				
				    (e.getSource() == textareapanel.textarea))
				
				    setCurrentLineTextField();
			}
			
			
			
			private class MouseWheelListener1 implements MouseWheelListener
			{
				public void mouseWheelMoved(MouseWheelEvent e)
				{
					int rotation = e.getWheelRotation();
					
					//  ...
					
					if (control == true)
					{
						if (rotation > 0) fontsizelistener.incrementSize();
						if (rotation < 0) fontsizelistener.decrementSize();
					}
				}
			}
			
			
			
			//  Select text and indent (unindent) using the right (left) arrow key
			//
			//  The block indent feature is useful for writing software because
			//  code blocks have to be indented or unindented if a conditional
			//  loop is changed or software is copied and pasted from another
			//  class or program.
			
			
			
			public void indent()
			{
			
				//  To indent paragraphs of text,
				//
				//  select the text to be indented (with the
				//  mouse or with the shift and down arrow keys)
				//  and then press the tab or right-arrow key
				
				
				textareapanel.indenting = true;
				
				String selectedtext = "";
				
				JTextArea textarea = textareapanel.textarea;
				
				if ((textarea.getSelectedText() != null)
				 && !textarea.getSelectedText().isEmpty())
				{
					selectedtext = textarea.getSelectedText();
					
					start = textarea.getSelectionStart();
					end   = textarea.getSelectionEnd();
				}
				
				else selectedtext = textarea .getText()
				
				    .substring(start, end);
				
				int length = end - start;
				
				textarea.replaceRange("", start, end);
				
				StringBuilder sb = new StringBuilder();
				
				for (int i = 0; i < selectedtext.length(); i++)
				{
					sb.append(selectedtext.charAt(i));
					
					if (selectedtext.charAt(i) == '\n')
					
					    sb.append('\t');
				}
				
				textarea.insert(sb.toString(), start);
				
				end = start + sb.length();
				
				textareapanel.filechanged = true;
			}
			
			
			
			
			public void unindent()
			{
			
				//  To un-indent paragraphs of text,
				//
				//  select the text to be indented (with the
				//  mouse or with the shift and down arrow keys)
				//  and then press the left-arrow key
				
				
				JTextArea textarea = textareapanel.textarea;
				
				if ((textarea.getSelectedText() != null)
				 && (textarea.getSelectedText().length() < 64))
				
					return;
				
				textareapanel.indenting = true;
				
				String selectedtext = "";
				
				if ((textarea.getSelectedText() != null)
				 && !textarea.getSelectedText().isEmpty())
				{
					selectedtext = textarea.getSelectedText();
					
					start = textarea.getSelectionStart();
					end   = textarea.getSelectionEnd();
				}
				
				else selectedtext = textarea.getText().substring(start, end);
				
				
				//  Don't un-indent if any selected line is not indented
				//  (All selected lines have to be indented to unindent)
				
				if (selectedtext.split("\n{1,}[ \t]{0}\n{1,}").length > 1)
				
					return;
				
				//  Un-indent the selected text
				
				int length = end - start;
				
				textarea.replaceRange("", start, end);
				
				StringBuilder sb = new StringBuilder();
				
				boolean bool = false;
				
				for (int i = 0; i < selectedtext.length(); i++)
				{
					sb.append(selectedtext.charAt(i+0));
					
					if (bool == true)
					{
						sb.deleteCharAt(sb.length()-1);
						
						bool = false;
					}
					
					if ((i < selectedtext.length() -1)
					
					  && (selectedtext.charAt(i+0) == '\n')
					  && (selectedtext.charAt(i+1) == '\t') )
					
						bool = true;
				}
				
				textarea.insert(sb.toString(), start);
				
				end = start + sb.length();
				
				textareapanel.filechanged = true;
			}
			
			
			
			private void autoindent()
			{
				//  indents each time the enter key is pressed
				
				JTextArea textarea = textareapanel.textarea;
				
				if (textarea.getSelectedText() != null) return;
				
				int cp = textarea.getCaretPosition() -2;
				
				int indentposition = 0;
				
				String str = textarea.getText();
				
				while ((cp >= 0) && (str.charAt(cp) != '\n'))
				{
					char c = str.charAt(cp);
					
					if (str.charAt(cp--) == '\t')
					
					    indentposition += 8;
					
					//  if (str.charAt(cp) == ' ')
					//
					//      indentposition += 1;
				}
				
				int tabs = indentposition / 8;
				
				//  int spaces = indentposition % 8;
				
				String s = "";
				
				for (int i = 0; i < tabs; i++)  s += '\t';
				
				//  for (int i = 0; i < spaces; i++)  s += ' ';
				
				cp = textarea.getCaretPosition();
				
				textarea.insert(s, cp);
			}
		}
		
		
		//  End class KeyListener1
		
		
		
		
		
		
		
		private class FocusListener extends FocusAdapter
		{
		
			public void focusGained(FocusEvent e)
			{
				if ((textareapanel != null)
				
				 && (e.getSource() == textareapanel.textarea))
				{
					//  Read the clipboard public key
					
					if (e.getSource() == textareapanel.textarea)
					{
						String[] name_key = publickeyring.readClipboardKey();
						
						if ((name_key != null) && (name_key.length == 2))
						
						    publickeyring.add(name_key);
						
						//  ...
					}
					
					//  else if (e.getSource() == ...
					
					//  ...
				}
				
				//  ...
			}
			
			
			public void focusLost(FocusEvent e)
			{
				if ((textareapanel != null)
				
				 && (e.getSource() == textareapanel.textarea))
				{
					//  Read the clipboard public key
					
					if (e.getSource() == textareapanel.textarea)
					{
						String[] name_key = publickeyring.readClipboardKey();
						
						if ((name_key != null) && (name_key.length == 2))
						
						    publickeyring.add(name_key);
						
						//  ...
					}
					
					//  else if (e.getSource() == ...
				}
			}
		}
		
		
		
		
		private void setFrameTitle()
		{
			String title = ((textareapanel != null)
			
			    && (textareapanel.file != null)) ?
			
			//	textareapanel.file.getName() : "";
				textareapanel.file.getPath() : "";
			
			if (!titlename.isEmpty())
			{
				if (!title.isBlank())
				
				     title += titleseparator + titlename;
				else title += titlename;
			}
			
			frame.setTitle(title);
		}
		
		
		
		
		private class NewListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Create a new tab and text area
				
				TextAreaPanel textareapanel = new TextAreaPanel();
				
				textareapanellist.add(textareapanel);
				
				tabbedpane.addTab(__.untitled, textareapanel);
				
				tabbedpane.setSelectedComponent(textareapanel);
				
				setMenuItemsEnabled(true);
			}
		}
		
		
		
		
		
		
		private class OpenListener implements ActionListener
		{
		
			private ImageFrame imageframe;
			private HTMLFrame htmlframe;
			
			private String title;
			
			//  If the user opens an image file instead of a text file,
			//  open the file in the image viewer instead of the text editor
			
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public void run()
			{
			
				//  Choose a file
				
				File file = chooseFile(directory);
				
				if (file == null) return;
				
				directory = file.getParent();
				
				String filename = file.getName();
				
				
				if  ( filename.endsWith("png")
				   || filename.endsWith("jpg")
				   || filename.endsWith("jpeg"))
				// || filename.endsWith("...")
				{
				//	//  Open the image viewer and return
				//	
				//	imageframe = new ImageFrame();
				//	
				//	imageframe.openlistener .setImage(file.getPath());
				//	
				//	//  ...
				//	
				//	return;
				}
				
				
				if (filename.toLowerCase() .endsWith("html"))
				{
					//  Open the editor frame and return
					
					htmlframe = new HTMLFrame();
					
					htmlframe .openlistener.setPage(file.getPath());
					
					//  ...
					
					return;
				}
				
				
				//  Open and decrypt the file
				
				byte[] plaindata = open(file);
				
				if (plaindata == null) return;
				
				String text = new String(plaindata);
				
				
				//  If a file becomes corrupted or the user tries to open an image
				//  file, setting the text area will cause the program to become
				//  unresponsive for several minutes until the text is displayed.
				//
				//  The program has to test for binary data and ask if the user
				//  wants to open the file so the program doesn't hang or become
				//  unresponsive.
				
				
				//  Verify that the plaintext is valid
				
				try
				{	byte[] utf8Bytes = text.getBytes("UTF8");
					
					String str = new String(utf8Bytes, "UTF8");
					
					if (!str.equals(text)) return;
				}
				
				catch (UnsupportedEncodingException ex)
				{
					System.out.println(ex);
					
					return;
				}
				
				
				//  Create a new text area panel
				
				if ((textareapanel == null)
				
				 || !textareapanel.textarea.getText().isEmpty())
				
					newlistener.run();
				
				
				//  Remember to save the file
				//  as encrypted or unencrypted
				//
				//  (newlistener creates a new textareapanel)
				
				if (Cipher.isEncrypted(file))
				
				     textareapanel.encrypted = true;
				else textareapanel.encrypted = false;
				
				
				
				//  Display the text
				
				JTextArea textarea = textareapanel.textarea;
				
				textarea.setText(text);
				textarea.setCaretPosition(0);
				
				boolean wrap = linewraplistener.autoWrap(text);
				
				textarea.setLineWrap(wrap);
				
				linewrapmenuitem.setText(wrap ?
				
				    __.lineunwrapkey : __.linewrapkey);
				
				
				textareapanel.file = file;
				textareapanel.filechanged = false;
				textarea.requestFocusInWindow();
				
				
				//  Clear the stack and save a copy of the new text
				
				textareapanel.undo.clear();
				textareapanel.undo.push();
				
				
				//  Set the frame title
				
				setFrameTitle();
				
				
				//  Set the tab title and color
				
				tabbedpane.setTitleAt(tabbedpane
				
				    .getSelectedIndex(), title );
				
				if (textareapanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = textareapanel.textarea.getForeground();
					Color background = textareapanel.textarea.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
			}
			
			
			
			
			private File chooseFile(String directory)
			{
			
				File file = null;
				
				JFileChooser fc;
				
				fc = new FileChooser(directory);
				
				fc.setFont(font);
				
				int choice = fc.showOpenDialog(frame);
				
				if (choice == JFileChooser.APPROVE_OPTION)
				{
					file = fc.getSelectedFile();
					
					return file;
				}
				
				else if (choice == JFileChooser.CANCEL_OPTION)
				
				     return null;
				
				else return null;
			}
			
			
			
			
			private byte[] open(File file)
			{
			
				title = file.getName();
				
				if (file.length() > 16*1024*1024)
				{
					String message = __.largefile;
					
					JLabel label = new JLabel(message);
					
					label.setFont(labelfont);
					
					JOptionPane.showMessageDialog(frame,
					
					    label, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] input = null;
				
				try { input = DataStream.read(file); }
				
				catch (IOException ex)
				{
					String message = __.filenotfound;
					
					JOptionPane.showMessageDialog(frame,
					
					    message, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] plaindata = input;
				
				
				//  Create a new text area panel
				
				if ((textareapanel == null)
				
				 || !textareapanel.textarea.getText().isEmpty())
				
					newlistener.run();
				
				
				//  Remember to save the file
				//  as encrypted or unencrypted
				
				if (Cipher.isEncrypted(file))
				
				     textareapanel.encrypted = true;
				else textareapanel.encrypted = false;
				
				
				if (textareapanel.encrypted)
				{
					JTextArea textarea = textareapanel.textarea;
					
					FileDecryptor fd;
					
					fd = new FileDecryptor(frame);
					fd.setFileKey(filekey);
					fd.setPassphrase(SP);
					fd.setFont(textarea.getFont());
					fd.setForeground(textarea.getForeground());
					fd.setBackground(textarea.getBackground());
					
					//  Decrypt the file input
					
					plaindata = fd.decrypt(input);
					
					if (plaindata == null)
					{
						textareapanel.encrypted = false;
						
						return null;
					}
					
					filekey = fd.getFileKey();
					
					
					//  Decrypt the file name to set the tab title
					
					String name1 = FileNameEncryptor
					
					  .decryptFileName(file.getName(), filekey);
					
					title = name1;
				}
				
				return plaindata;
			}
		}
		
		
		
		
		
		
		private class OpenListFileListener implements ActionListener
		{
		
			//  The user clicks on a file name in the file menu list
			
			//  (the file menu list should contain recently or commonly
			//  used files or files that are important to the user)
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				//  Create a new text area panel to display the file
				//
				//  unless there is an open panel and the panel text area is empty
				
				if ((textareapanellist.size() == 0) || (textareapanel == null)
				
				  || !textareapanel.textarea.getText().isEmpty())
				
					newlistener.run();
				
				String filename = e.getActionCommand();
				
				for (String filename1 : filenamelist)
				{
					if (filename1.endsWith(filename))
					{
						//  Get the full file name
						
						filename = filename1;
						
						break;
					}
				}
				
				File file = new File(filename);
				
				directory = file.getParent();
				
				
				//  Open and decrypt the file
				
				byte[] plaindata = openlistener.open(file);
				
				if (plaindata == null) return;
				
				String text = new String(plaindata);
				
				boolean wrap = linewraplistener.autoWrap(text);
				
				JTextArea textarea = textareapanel.textarea;
				
				textarea.setLineWrap(wrap);
				
				textarea.setText(text);
				
				textarea.setCaretPosition(0);
				
				textareapanel.file = file;
				textareapanel.filechanged = false;
				textarea.requestFocusInWindow();
				
				
				//  Clear the stack and save a copy of the new text
				
				textareapanel.undo.clear();
				
				textareapanel.undo.push();
				
				
				linewrapmenuitem.setText(wrap ?
				
				    __.lineunwrapkey : __.linewrapkey);
				
				tabbedpane.setTitleAt(tabbedpane.getSelectedIndex(),
				
				    textareapanel.file.getName() );
				
				if (textareapanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = textarea.getForeground();
					Color background = textarea.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				setFrameTitle();
			}
		}
		
		
		
		
		
		private class SaveListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				run();
			}
			
			public int run()
			{
			
				if (textareapanel == null) return 0;
				
				JTextArea textarea = textareapanel.textarea;
				
				try
				{
				
				File file = textareapanel.file;
				
				//  If file is null use save as instead of save
				
				if (file == null)
				{
					saveaslistener.run();
					
					return 0;
				}
				
				
				//  File already exists
				
				boolean encrypted = Cipher.isEncrypted(file);
				
				byte[] data = textarea.getText().getBytes();
				
				
				//  Encrypt the data if the textarea
				//  panel encrypted variable is true
				
				if (textareapanel.encrypted)
				
				    data = Cipher.encrypt(data, filekey);
				
				
				//  Save the file
				
				int result = new SaveFile(frame, __.save)
				
				    .setDirectory(directory) .setFont(font)
				
					.save(data, file, false);
				
				if ((result == JOptionPane.NO_OPTION)
				 || (result == JOptionPane.CANCEL_OPTION)
				 || (result == JOptionPane.CLOSED_OPTION)
				
				 || (result == -1))  return result;
				
				
				String filename = textareapanel.file.getName();
				
				tabbedpane.setTitleAt(tabbedpane
				
				   .getSelectedIndex(), filename );
				
				
				
				if (textareapanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = textarea.getForeground();
					Color background = textarea.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				tabbedpane.setTitleAt(tabbedpane
				
				   .getSelectedIndex(), file.getName() );
				
				textareapanel.filechanged = false;
				
				setFrameTitle();
				
				return JOptionPane.YES_OPTION;
				
				}  finally { textarea.requestFocusInWindow(); }
			}
		}
		
		
		
		
		
		private class SaveAsListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public void run()
			{
			
				//  Choose a file name,
				//
				//  save the data to the file and
				//
				//  update the current file path
				
				
				JTextArea textarea = textareapanel.textarea;
				
				File newfile = new SaveFile(frame, __.saveas)
				
				    .setDirectory(directory) .setFont(font)
				
					.chooseFile();
				
				if (newfile == null) return;
				
				
				directory = newfile.getParent();
				
				byte[] data = textarea.getText() .getBytes();
				
				
				//  If the existing file is already encrypted
				//  ask if the user wants to encrypt the new file
				
				if (textareapanel.file != null)
				
				if (Cipher.isEncrypted(textareapanel.file)
				 || Cipher.isEncrypted(newfile))
				{
					String message = __.encryptfile + "?";
					
					JLabel label = new JLabel(message);
					
					label.setFont(labelfont);
					
					Object[] options = new Object[] { __.Yes, __.No };
					
					int choice = JOptionPane.showConfirmDialog(
					
					    frame, label, null,
					
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE, null);
					
					//  If yes encrypt the data
					
					if (choice == 0)
					{
						//  Display a dialog to select a file key
						
						FileEncryptor fe = new FileEncryptor(frame);
						
						fe.setFont(textarea.getFont());
						fe.setForeground(foreground);
						fe.setBackground(background);
						
						if (filekey != null) fe.setFileKey(filekey);
						
						else if ((SP != null) && !SP.isEmpty())
						
						    fe.setFileKey(Cipher.passphraseToKey(SP));
						
						//  Select and/or confirm the file key
						
						if (fe.selectAndConfirmFileKey(__.encryptfilewithkey))
						{
							//  Update the file key and encrypt the data
							
							filekey = fe.getFileKey();
							
							data = Cipher.encrypt(data, filekey);
						}
					}
				}
				
				
				//  Save the encrypted or unencrypted data to file
				
				int result = new SaveFile(frame, __.save)
				
				    .setDirectory(directory) .setFont(font)
				
					.save(data, newfile, true);
				
				if ((result == JOptionPane.NO_OPTION)
				 || (result == JOptionPane.CANCEL_OPTION)
				 || (result == JOptionPane.CLOSED_OPTION))
				
				    return;
				
				
				textareapanel.encrypted = 
				
				    Cipher.isEncrypted(newfile);
				
				
				//  Set the tab color to the encrypted or unencrypted color
				
				int index = tabbedpane.getSelectedIndex();
				
				if (textareapanel.encrypted)
				{
					Color foreground = textarea.getForeground();
					Color background = textarea.getBackground();
					
					if (!foreground.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					
					else tabbedpane.setForegroundAt(index,
					
					     textarea.getBackground());
				}
				
				else
				{	tabbedpane.setForegroundAt(index, Color.black);
					tabbedpane.setBackgroundAt(index, background);
				}
				
				tabbedpane.setTitleAt(tabbedpane
				
				    .getSelectedIndex(), newfile.getName() );
				
				textareapanel.filechanged = false;
				textareapanel.file = newfile;
				
				setFrameTitle();
			}
		}
		
		
		
		private class DeleteListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				deletefilelistener.run();
			}
		}
		
		
		private class PrintListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			private void run() { Print.print(textareapanel.textarea); }
		}
		
		
		private class CloseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public int run()
			{
				if (textareapanellist.size() == 0) return -1;
				
				int choice = JOptionPane.NO_OPTION;
				
				if (textareapanel.filechanged)
				{
					//  String message = __.savefile + " ?";
					
					String message = __.save + " "
					
					    + (textareapanel.file != null ?
					       textareapanel.file.getName() : "") + " ?";
					
					JLabel label = new JLabel(message);
					
					label.setFont(labelfont);
					
					choice = JOptionPane.showConfirmDialog(frame, label);
					
					if ((choice == JOptionPane.CANCEL_OPTION)
					 || (choice == JOptionPane.CLOSED_OPTION))
					
					    return choice;
					
					else if (choice == JOptionPane.YES_OPTION)
					
					    savelistener.run();
				}
				
				if (textareapanellist.size() == 1)
				{
					JTextArea textarea = textareapanel.textarea;
					textareapanel.linewrap = textarea.getLineWrap();
					
					foreground = textarea.getForeground();
					background = textarea.getBackground();
					caretcolor = textarea.getCaretColor();
					
					font = textarea.getFont();
				}
				
				if (textareapanellist.size() == 1)
				{
				        findlistener.setVisible(false);
				    gotolinelistener.setVisible(false);
				}
				
				textareapanellist.remove(textareapanel);
				
				tabbedpane.remove(tabbedpane.getSelectedIndex());
				
				if (tabbedpane.getSelectedIndex() < 0)
				
				    setMenuItemsEnabled(false);
				
				setFrameTitle();
				
				return choice;
			}
		}
		
		
		
		private class ExitListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public void run()
			{
				if (saveFiles() == -1) return;
				
				saveSettings();
				
				frame.dispose();
			}
			
			
			private int saveFiles()
			{
				//  Save the file for each tab
				
				while (textareapanellist.size() > 0)
				{
					if (textareapanel.filechanged)
					{
						String message = __.save + " "
						
						    + (textareapanel.file != null ?
						       textareapanel.file.getName() : __.file) + " ?";
						
						while (true)
						{
							//  Display the JOptionPane
							
							JLabel label = new JLabel(message);
							
							label.setFont(labelfont);
							
							int choice = JOptionPane
							
							   .showConfirmDialog(frame, label);
							
							if ((choice == JOptionPane.CANCEL_OPTION)
							 || (choice == JOptionPane.CLOSED_OPTION)) return -1;
							
							else if (choice == JOptionPane.NO_OPTION) break;
							
							else if (choice == JOptionPane.YES_OPTION)
							{
								choice = savelistener.run();
								
								if ((choice == JOptionPane.YES_OPTION)
								 || (choice == JOptionPane. NO_OPTION))
								
								    break;
							}
						}
					}
					
					textareapanellist.remove(textareapanel);
					
					tabbedpane.remove(tabbedpane.getSelectedIndex());
				}
				
				//  Create a new textarea panel so that if the user
				//  closes the text editor frame from another program
				//  (such as an email program) and then reopens the text
				//  editor frame, the user will have an open panel.
				
				newlistener.run();
				
				return 0;
			}
		}
		
		
		
		
		
		private class FileListListener implements ActionListener
		{
		
			private int maxfontsize = 24;
			
			private ArrayList<JButton> buttonlist;
			
			private int buttonindex = -1;
			
			
			public void actionPerformed(ActionEvent e)
			{
				//  To open the file list dialog, the user clicks
				//  on the empty menu item below the exit menu item
				
				listFileList();
			}
			
			
			
			private class MouseListener extends MouseAdapter
			{
				public void mousePressed(MouseEvent e)
				{
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						cutAndPaste();
					}
				}
				
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					{
						for (int i = 0; i < buttonlist.size(); i++)
						
						    if (buttonlist.get(i).equals((JButton) e.getSource()))
						
							buttonindex = i;
						
						if ((buttonindex >= 0) && buttonindex < buttonlist.size()-1)
						{
							if (textfieldlist.get(buttonindex).getText().isBlank())
							{
								//  Remove the blank space
								
								for (int i = buttonindex; i < textfieldlist.size()-1; i++)
								{
									String text = textfieldlist.get(i+1).getText();
									
									textfieldlist.get(i).setText(text);
									
									if (i+1 == textfieldlist.size()-1)
									
									    textfieldlist.get(i+1).setText("");
								}
								
								return;
							}
							
							boolean spaceavailable = false;
							
							for (int i = buttonindex; i < textfieldlist.size(); i++)
							
							    if (textfieldlist.get(i).getText().isBlank())
							
								{ spaceavailable = true; break; }
							
							if (spaceavailable)
							{
								//  Insert a blank space
								
								int emptyspaceindex = 0;
								
								for (int i = buttonindex; i < textfieldlist.size(); i++)
								{
									if (textfieldlist.get(i).getText().isBlank())
									
									    { emptyspaceindex = i; break; }
								}
								
								for (int i = emptyspaceindex; i > buttonindex; i--)
								{
									String text = textfieldlist.get(i-1).getText();
									
									textfieldlist.get(i).setText(text);
									
									if (i-1 == buttonindex)
									
									    textfieldlist.get(i-1).setText("");
								}
								
								return;
							}
						}
					}
				}
			}
			
			
			
			private class FocusListener extends FocusAdapter
			{
				public void focusGained(FocusEvent e)
				{
					
				}
				
				public void focusLost(FocusEvent e)
				{
					if (e.getSource() instanceof JTextField)
					{
						JTextField textfield = (JTextField) e.getSource();
						
						textfield.setText(textfield.getText());
					}
				}
			}
			
			
			
			private void listFileList()
			{
			
				//  creates and displays a dialog that allows the user
				//  to add or remove commonly used or important files
				
				textfieldlist = new ArrayList<JTextField>();
				   buttonlist = new ArrayList<JButton>();
				
				MouseListener mouselistener = new MouseListener();
				FocusListener focuslistener = new FocusListener();
				
				for (int i = 0; i < numberoffiles; i++)
				{
					JTextField textfield = new JTextField(48);
					
					JButton textbutton = new JButton();
					
					Font font1 = font.deriveFont((float)
					
					    Math.min(font.getSize(), maxfontsize));
					
					textfield.setFont(font1);
					
					textfield.setForeground(foreground);
					textfield.setCaretColor(foreground);
					textfield.setBackground(background);
					
					textfield.addMouseListener(mouselistener);
					textfield.addFocusListener(focuslistener);
					
					textbutton.addMouseListener(mouselistener);
					
					textfieldlist.add(textfield);
					   buttonlist.add(textbutton);
				}
				
				Box vbox = Box.createVerticalBox();
				
				for (int i = 0; i < textfieldlist.size(); i++)
				{
					Box hbox = Box.createHorizontalBox();
					
					hbox.add(   buttonlist.get(i));
					hbox.add(textfieldlist.get(i));
					
					vbox.add(hbox);
					
					vbox.add(Box.createVerticalStrut(5));
				}
				
				JButton button = new JButton(__.addfiletolist,
				
				    Icons.get(Icons.add_24x24));
				
				vbox.add(button);
				
				button.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						JFileChooser fc;
						
						fc = new FileChooser(directory);
						
						fc.setFont(font);
						
						File selectedfile = null;
						
						fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
						
						String title = __.addfilename;
						
						fc.setDialogTitle(title);
						
						fc.setApproveButtonText(title);
						
						int choice = fc.showDialog(frame, null);
						
						if (choice == JFileChooser.APPROVE_OPTION)
						
						    selectedfile = fc.getSelectedFile();
						
						else if (choice == JFileChooser.CANCEL_OPTION)
						
						    return;
						
						if (selectedfile == null) return;
						
						directory = selectedfile.getParent();
						
						String filepath = selectedfile.getPath();
						
						//  System.out.println("file path == " + filepath);
						
						if ((buttonindex >= 0) && textfieldlist
						
						    .get(buttonindex).getText().isBlank())
						
							textfieldlist.get(buttonindex).setText(filepath);
						
						else for (JTextField textfield : textfieldlist)
						
						    if (textfield.getText().isBlank())
						
							{ textfield.setText(filepath); break; }
					}
				});
				
				
				for (int i = 0; i < textfieldlist.size(); i++)
				{
					JTextField textfield = textfieldlist.get(i);
					
					if (i < filenamelist.size())
					{
						textfield.setText(filenamelist.get(i));
						textfield.setCaretPosition(0);
						textfieldlist.set(i, textfield);
					}
				}
				
				for (int i = 0; i < filenamelist.size(); i++)
				{
					if (listmenuitem.size() != 0)
					{
						if ((filenamelist.get(i) != null)
						 && !filenamelist.get(i).isEmpty())
						
						    filemenu.remove(listmenuitem.get(i));
					}
				}
				
				Object object = (Object) vbox;
				
				String title = "";  //  File List
				
				JOptionPane.showMessageDialog(frame,
				
				    object, title, JOptionPane.PLAIN_MESSAGE);
				
				
				filenamelist = new ArrayList<String>();
				
				listmenuitem = new ArrayList<JMenuItem>();
				
				for (JTextField textfield : textfieldlist)
				{
					String filename = textfield.getText().trim();
					
					if (!filename.isEmpty() && !filenamelist.contains(filename))
					
						filenamelist.add(filename);
				}
				
				for (int i = 0; i < filenamelist.size(); i++)
				{
					String filename = new File(filenamelist.get(i)).getName();
					
					JMenuItem menuitem;
					
					ImageIcon fileicon   = Icons.get(Icons.file);
					ImageIcon javaicon   = Icons.get(Icons.java);
					ImageIcon pythonicon = Icons.get(Icons.python);
					
					if (filename.endsWith("java"))
					
					     menuitem = new JMenuItem(filename, javaicon);
					
					else if (filename.endsWith("py"))
					
					     menuitem = new JMenuItem(filename, pythonicon);
					
					else menuitem = new JMenuItem(filename, fileicon);
					
					menuitem.setFont(menuitemfont);
					
					listmenuitem.add(menuitem);
					
					listmenuitem.get(i).addActionListener(
					
					    openlistfilelistener);
					
					filemenu.add(listmenuitem.get(i));
				}
			}
			
			
			
			
			private void cutAndPaste()
			{
			
				//  This method is used for the file list cut and paste.
				//
				//  The secondary mouse button is the cut and paste button.
				//
				//  Select a file by clicking to the right of the file path with the
				//  primary mouse button and moving the mouse up to highlight the file
				//  path.
				//
				//  When the file path is highlighted, click the secondary mouse button
				//  to cut (copy and delete) the file path text. (Clicking again will
				//  restore the file path to the textfield.)
				//
				//  Then move the focus to an empty line by clicking the primary mouse
				//  button (or by using the tab button, or shift + tab button) and paste
				//  the file path to the empty line with the secondary mouse button.
				//
				//  You can also use Ctrl + A to select the textfield and then
				//  Ctrl + X, C and Ctrl + V to cut, copy and paste.
				
				
				for (JTextField textfield : textfieldlist)
				{
					if (textfield.hasFocus() && textfield.getText().isEmpty())
					{
						//  Paste from clipboard
						
						//  int cp = textfield .getCaretPosition();
						
						DataFlavor flavor = DataFlavor.stringFlavor;
						
						//  Read the clipboard text
						
						String clipboardtext = "";
						
						try { clipboardtext = (String) cb.getData(flavor); }
						
						catch (UnsupportedFlavorException ex) {  }
						catch (IOException ex) { System.out.println(ex); return; }
						
						if ((clipboardtext != null) && !clipboardtext.isEmpty()
						 && (clipboardtext.length() <= 128))
						
						    textfield.replaceSelection(clipboardtext);
					}
				}
				
				
				for (JTextField textfield : textfieldlist)
				{
					if (   textfield.hasFocus()
					   && (textfield.getSelectionStart() == 0)
					   && (textfield.getSelectionEnd()
					    == textfield.getText().length())
					   && (textfield.getSelectedText() != null) )
					{
						//  Cut and Copy to clipboard
						
						textfield.cut();
					}
				}
			}
		}
		
		
		
		
		private class UndoListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel == null) return;
				
				if (e.getSource() == undomenuitem) undo();
				if (e.getSource() == redomenuitem) redo();
				
				if (e.getSource() == undobutton) undo();
				if (e.getSource() == redobutton) redo();
			}
			
			public void undo()
			{
				textareapanel.undo.undo();
				
				textareapanel.filechanged = true;
				textareapanel.textarea.requestFocusInWindow();
			}
			
			public void redo()
			{
				textareapanel.undo.redo();
				
				textareapanel.filechanged = true;
				textareapanel.textarea.requestFocusInWindow();
			}
		}
		
		
		
		
		private class CutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel == null) return;
				
				textareapanel.filechanged = true;
				
				//  Save a copy of the text
				
				textareapanel.undo.push();
				textareapanel.textarea.cut();
				textareapanel.textarea.requestFocusInWindow();
			}
		}
		
		
		private class CopyListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel == null) return;
				
				textareapanel.textarea.copy();
				textareapanel.textarea.requestFocusInWindow();
			}
		}
		
		
		private class PasteListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel == null) return;
				
				//  Save a copy of the text
				
				textareapanel.undo.push();
				textareapanel.textarea.paste();
				textareapanel.filechanged = true;
				textareapanel.textarea.requestFocusInWindow();
			}
		}
		
		
		
		
		
		private class FindAndReplace
		{
		
			//  class FindListener
			//  class ReplaceListener
			
			
			//  the find field, replace field, and number field
			
			private JTextField textfield1;
			private JTextField textfield2;
			private JTextArea textarea3;
			
			
			private class FindListener implements ActionListener
			{
			
				private JPanel panel;
				
				private JLabel findreplacelabel;
				
				private JTextArea closearea;
				private JTextArea matchcasearea;
				
				private boolean matchcase;
				
				
				private Character closechar // x
				
				    = Character.valueOf((char) 10007);
				
				private Character capschar // o
				
				    = Character.valueOf((char) 11093);
				
				
				public void actionPerformed(ActionEvent e)
				{
					setVisible(true);
				}
				
				
				public void setVisible(boolean bool)
				{
					if (menubar.getComponentIndex(panel) == -1)
					{
						//  Add the panel to the menubar
						
						menubar.add(panel);
						
						menubar.setVisible(false);
						menubar.setVisible(true);
					}
					
					findreplacelabel.setText(__.Find);
					
					textfield1.setText("");
					textfield2.setText("");
					textarea3 .setText("");
					
					panel.setVisible(bool);
					
					textfield1 .setVisible(bool);
					textfield2 .setVisible(false);
					textarea3  .setVisible(true);
					
					if (!textfield2.isVisible())
					
					     textfield1.requestFocusInWindow();
					
					setFont(font);
					
					setColor();
				}
				
				
				
				public FindListener()
				{
				
					textfield1 = new JTextField(16);
					textfield2 = new JTextField(16);
					textarea3  = new JTextArea(1, 6);
					
					textarea3.setEditable(false);
					textarea3.setForeground(new Color(0x080808));
					textarea3.setBackground(new JPanel()
					    .getBackground());
					
					matchcasearea = new JTextArea(1, 1);
					closearea     = new JTextArea(1, 1);
					
					matchcasearea.setToolTipText(__.matchcase);
					
					matchcasearea.setEditable(false);
					matchcasearea.setBackground(
					    new JPanel().getBackground());
					
					closearea.setEditable(false);
					closearea.setBackground(
					    new JPanel().getBackground());
					
					findreplacelabel = new JLabel(__.find);
					findreplacelabel.setToolTipText(__.click);
					
					
					panel = new JPanel();
					
					Gbc gbc = new Gbc();
					
					gbc.setPosition(0, 0);
					panel.add(closearea, gbc);
					
					gbc.setPosition(1, 0);
					panel.add(findreplacelabel, gbc);
					
					gbc.setPosition(2, 0);
					panel.add(matchcasearea, gbc);
					
					gbc.setPosition(3, 0);
					panel.add(textfield1, gbc);
					
					gbc.setPosition(4, 0);
					panel.add(textfield2, gbc);
					
					gbc.setPosition(5, 0);
					panel.add(textarea3, gbc);
					
					
					matchcasearea.addMouseListener(new MouseListener()
					{
						public void mousePressed(MouseEvent e)
						{
							if (!matchcasearea.getText().isBlank())
							{
								matchcasearea.setText("");
								
								matchcase = false;
							}
							
							else
							{	matchcasearea.setText(
								
								    Character.toString(capschar));
								
								matchcase = true;
							}
						}
					});
					
					
					
					findreplacelabel.addMouseListener(new MouseListener()
					{
						public void mouseClicked(MouseEvent e)
						{
							if (findreplacelabel.getText().equals(__.Find))
							{
								findreplacelabel.setText(__.Replace);
								
								textfield2.setVisible(true);
							}
							
							else if (findreplacelabel.getText().equals(__.Replace))
							{
								findreplacelabel.setText(__.Find);
								
								if (textfield2.hasFocus())
								
								    textfield1.requestFocusInWindow();
								
								textfield2.setVisible(false);
							}
						}
					});
					
					
					closearea.addMouseListener(new MouseListener()
					{
						public void mouseEntered(MouseEvent e)
						{
							closearea.setText(
							
							    Character.toString(closechar));
						}
						
						public void mouseExited(MouseEvent e)
						{
							closearea.setText("");
						}
						
						public void mouseClicked(MouseEvent e)
						{
							findlistener.setVisible(false);
							
							textfield1.setText("");
							textfield2.setText("");
							textarea3 .setText("");
							
							if (textareapanel != null)
							
							    textareapanel.textarea
							
								.requestFocusInWindow();
						}
					});
					
					
					FocusAdapter focusadapter = new FocusAdapter()
					{
						public void focusGained(FocusEvent e)
						{
							if (e.getSource() == textfield1)
							
							    textfield1.selectAll();
							
							if (e.getSource() == textfield2)
							
							    textfield2.selectAll();
						}
						
						public void focusLost(FocusEvent e)
						{
							if (textareapanel != null)
							{
								Highlighter h = textareapanel
								
								    .textarea.getHighlighter();
								
								h.removeAllHighlights();
								
								textarea3.setText("");
							}
						}
					};
					
					KeyListener1 keylistener1 = new KeyListener1();
					
					textfield1.addKeyListener(keylistener1);
					textfield2.addKeyListener(keylistener1);
					
					textfield1.addFocusListener(focusadapter);
					textfield2.addFocusListener(focusadapter);
				}
				
				
				
				
				private class KeyListener1 implements KeyListener
				{
				
					private boolean shift, control, keypressed;
					
					
					public void keyPressed(KeyEvent e)
					{
						keypressed = true;
						
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_shift)
						
						    shift = true;
						
						else if (keycode == vk_control)
						
						    control = true;
						
						
						String text1 = textfield1.getText();
						String text2 = textfield2.getText();
						
						if (control && (keycode == __.findkeycode))
						{
							if (shift == false)
							
							     findNext(    text1, matchcase);
							else findPrevious(text1, matchcase);
						}
						
						
						if (control && (keycode == __.replacekeycode))
						
						    if (findreplacelabel.getText().equals(__.Replace))
						{
							String text = textareapanel.textarea.getSelectedText();
							
							if ((text == null) || text.isEmpty() ||
							
							    !text.equalsIgnoreCase(textfield1.getText()))
							{
								if (shift == false)
								
								     findNext(    textfield1.getText(), matchcase);
								else findPrevious(textfield1.getText(), matchcase);
							}
							
							else replace(text1, text2, matchcase);
						}
						
						if (keycode == vk_escape)
						{
							findlistener.setVisible(false);
							
							textfield1.setText("");
							textfield2.setText("");
							textarea3 .setText("");
							
							if (textareapanel != null)
							
							    textareapanel.textarea
							
								.requestFocusInWindow();
						}
						
						if ((control && (keycode == __.findkeycode))
						 || (control && (keycode == __.replacekeycode)))
						
						    textarea3.setText(countNumber(text1, matchcase));
					}
					
					
					public void keyReleased(KeyEvent e)
					{
						keypressed = false;
						
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_shift)
						
						    { shift = false; return; }
						
						else if (keycode == vk_control)
						
						    { control = false; return; }
						
						
						//  If there are any capital letters in the string,
						//  match the case of the string
						
						if ((keychar != vk_enter) && textfield1.hasFocus())
						{
							matchcase = false;
							
							String text1 = textfield1.getText().trim();
							
							for (int i = 0; i < text1.length(); i++)
							{
								int ch = text1.charAt(i);
								
								if ((ch >= 'A') && (ch <= 'Z'))
								{
									matchcase = true;
									
									break;
								}
							}
							
							if (matchcase == true)
							
							    matchcasearea.setText(
							
								Character.toString(capschar));
							
							else matchcasearea.setText("");
						}
					}
					
					
					public void keyTyped(KeyEvent e)
					{
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						String text1 = textfield1.getText();
						String text2 = textfield2.getText();
						
						if (keychar == vk_enter)
						{
							//  Deselect the text in the text fields
							
							textfield1.setText(text1);
							textfield2.setText(text2);
							
							if (e.getSource() == textfield1)
							{
								if (shift == false)
								
								     findNext(    text1, matchcase);
								else findPrevious(text1, matchcase);
							}
							
							else if ((e.getSource() == textfield2) && (textareapanel != null))
							{
								String text = textareapanel.textarea.getSelectedText();
								
								if ((text == null) || text.isEmpty() ||
								
								    !text.equalsIgnoreCase(textfield1.getText()))
								{
									if (shift == false)
									
									     findNext(    textfield1.getText(), matchcase);
									else findPrevious(textfield1.getText(), matchcase);
								}
								
								else replace(text1, text2, matchcase);
							}
						}
						
						if (keychar == vk_enter)
						
						   textarea3.setText(countNumber(text1, matchcase));
						
						setCurrentLineTextField();
					}
				}
				
				
				private void setColor()
				{
					if (textareapanel == null) return;
					
					Color foreground = textareapanel.textarea.getForeground();
					Color background = textareapanel.textarea.getBackground();
					
					textfield1.setForeground(foreground);
					textfield2.setForeground(foreground);
					
					textfield1.setCaretColor(foreground);
					textfield2.setCaretColor(foreground);
					
					textfield1.setBackground(background);
					textfield2.setBackground(background);
				}
				
				
				private void setFont(Font font)
				{
					//  Sets the font of the find and replace fields
					
					Font font1 = font.deriveFont((float)
					
					    Math.min(font.getSize(), 24));
					
					textfield1.setFont(font1);
					textfield2.setFont(font1);
					textarea3 .setFont(labelfont);
				}
			}
			
			
			//  End class FindListener
			
			
			
			
			
			
			
			private class ReplaceListener implements ActionListener
			{
			
				private JDialog dialog;
				
				private JTextField textfield1;
				private JTextField textfield2;
				private JTextArea textarea3;
				
				private String replacestring;
				
				private JCheckBox matchcasebox;
				
				private boolean matchcase;
				
				private JButton prevbutton;
				private JButton findbutton;
				private JButton replacebutton;
				
				private boolean shift, control;
				
				
				public void actionPerformed(ActionEvent e)
				{
					setVisible(true);
				}
				
				
				public void setVisible(boolean bool)
				{
					if (!dialog.isVisible())
					{
						textfield1.setText("");
						textfield2.setText("");
						textarea3.setText("");
						
						matchcasebox.setSelected(false);
						
						textfield1.requestFocusInWindow();
					}
					
					dialog.setVisible(bool);
					
					setFont(font); setColor();
					
					textfield1.requestFocusInWindow();
				}
				
				
				
				public ReplaceListener()
				{
				
					KeyListener keylistener = new KeyListener()
					{
					
						public void keyPressed(KeyEvent e)
						{
						
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							if (keycode == vk_shift) shift = true;
							
							else if (keycode == vk_control) control = true;
							
							String text1 = textfield1.getText();
							String text2 = textfield2.getText();
							
							if (control && (keycode == __.findkeycode))
							{
								if (shift == false)
								
								     findNext(    text1, matchcase);
								else findPrevious(text1, matchcase);
							}
							
							else if (control && (keycode == __.replacekeycode))
							{
								String text = textareapanel.textarea.getSelectedText();
								
								if ((text == null) || !text.equalsIgnoreCase(text1))
								{
									if (shift == false)
									
									     findNext(    text1, matchcase);
									else findPrevious(text1, matchcase);
								}
								
								else replace(text1, text2, matchcase);
							}
							
							else if (keychar == vk_escape)
							{
								setVisible(false);
							}
						}
						
						
						
						public void keyReleased(KeyEvent e)
						{
						
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							if (keycode == vk_shift)
							
							    { shift = false; return; }
							
							else if (keycode == vk_control)
							
							    { control = false; return; }
							
							
							String text1 = textfield1.getText().trim();
							
							if ((e.getSource() == textfield1) && (keychar != vk_enter))
							{
								//  If there are any capital letters in the string,
								//  match the case of the string
								
								matchcase = false;
								
								for (int i = 0; i < text1.length(); i++)
								{
									int ch = text1.charAt(i);
									
									if ((ch >= 'A') && (ch <= 'Z'))
									{
										matchcase = true;
										
										break;
									}
								}
								
								if (matchcase == true)
								
								     matchcasebox.setSelected(true);
								else matchcasebox.setSelected(false);
							}
							
							textarea3.setText(countNumber(text1, matchcase));
						}
						
						
						public void keyTyped(KeyEvent e)
						{
							int clicktime = 33;
							
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							String text1 = textfield1.getText();
							String text2 = textfield2.getText();
							
							if (keychar == vk_enter)
							{
								if (e.getSource() == textfield1)
								{
									if (shift == false)
									
									     findbutton.doClick(clicktime);
									else prevbutton.doClick(clicktime);
								}
								
								else if (e.getSource() == textfield2)
								{
									replacebutton.doClick(clicktime);
								}
								
								setCurrentLineTextField();
							}
						}
					};
					
					
					
					ActionListener actionlistener = new ActionListener()
					{
					
						public void actionPerformed(ActionEvent e)
						{
						
							if (textareapanel == null) return;
							
							String text1 = textfield1.getText();
							String text2 = textfield2.getText();
							
							if (e.getSource() == prevbutton)
							
							    findPrevious(text1, matchcase);
							
							else if (e.getSource() == findbutton)
							
							    findNext(text1, matchcase);
							
							else if (e.getSource() == replacebutton)
							{
								String text = textareapanel
								
								    .textarea.getSelectedText();
								
								if ((text == null) || !text.
								
								    equalsIgnoreCase(text1))
								{
									if (shift == false)
									
									     findNext(    text1, matchcase);
									else findPrevious(text1, matchcase);
								}
								
								else replace(text1, text2, matchcase);
							}
							
							textarea3.setText(countNumber(text1, matchcase));
							
							setCurrentLineTextField();
						}
					};
					
					
					textfield1 = new JTextField(14);
					textfield2 = new JTextField(14);
					textarea3  = new JTextArea(1, 6);
					
					textarea3.setEditable(false);
					textarea3.setForeground(new Color(0x080808));
					textarea3.setBackground(new JPanel().getBackground());
					
					
					FocusAdapter focusadapter = new FocusAdapter()
					{
						public void focusLost(FocusEvent e)
						{
							if (textareapanel != null)
							{
								Highlighter h = textareapanel
								
								    .textarea.getHighlighter();
								
								h.removeAllHighlights();
								
								//  De-select the selected text
								
								textareapanel.textarea.setCaretPosition(
								textareapanel.textarea.getCaretPosition());
								
								textarea3.setText("");
							}
						}
					};
					
					
					matchcasebox = new JCheckBox();
					
					matchcasebox.setToolTipText(__.matchcase);
					
					matchcasebox.addActionListener(new ActionListener()
					
					{ public void actionPerformed(ActionEvent e)
					{ textfield1.requestFocusInWindow();
					  matchcase = matchcasebox.isSelected(); } });
					
					
					   prevbutton = new JButton(__.Prev);
					   findbutton = new JButton(__.Find);
					replacebutton = new JButton(__.Replace);
					
					   prevbutton.addActionListener(actionlistener);
					   findbutton.addActionListener(actionlistener);
					replacebutton.addActionListener(actionlistener);
					
					   findbutton.addFocusListener(focusadapter);
					   prevbutton.addFocusListener(focusadapter);
					replacebutton.addFocusListener(focusadapter);
					
					textfield1.addFocusListener(focusadapter);
					textfield2.addFocusListener(focusadapter);
					
					textfield1.addKeyListener(keylistener);
					textfield2.addKeyListener(keylistener);
					
					
					Box hbox1 = Box.createHorizontalBox();
					
					hbox1.add(matchcasebox);
					
					hbox1.add(textfield1);
					hbox1.add(Box.createHorizontalStrut(10));
					
					hbox1.add(textfield2);
					hbox1.add(Box.createHorizontalStrut(10));
					
					hbox1.add(textarea3);
					
					
					Box hbox2 = Box.createHorizontalBox();
					
					hbox2.add(prevbutton);
					hbox2.add(Box.createHorizontalStrut(10));
					
					hbox2.add(findbutton);
					hbox2.add(Box.createHorizontalStrut(10));
					
					hbox2.add(replacebutton);
					
					
					JPanel panel = new JPanel();
					
					panel.setLayout(new GridBagLayout());
					
					Gbc gbc = new Gbc();
					gbc.setPosition(0, 0);
					gbc.setFill(Gbc.both);
					gbc.setWeight(100, 100);
					
					panel.add(hbox1, gbc);
					
					gbc = new Gbc();
					gbc.setPosition(0, 1);
					gbc.setFill(Gbc.both);
					gbc.setWeight(100, 100);
					
					panel.add(hbox2, gbc);
					
					
					String title = __.replace;
					
					textfield1.setText("");
					textfield2.setText("");
					textarea3 .setText("");
					
					dialog = new JDialog(frame);
					dialog.setResizable(false);
					dialog.add(panel);
					
					dialog.setDefaultCloseOperation(
					
					    JFrame.HIDE_ON_CLOSE);
					
					dialog.setSize(dialog.getPreferredSize());
					
					dialog.setAlwaysOnTop(true);
					dialog.setVisible(false);
				}
				
				
				
				private void setColor()
				{
					//  sets the color of the replace field
					
					if (textareapanel == null) return;
					
					Color foreground = textareapanel.textarea.getForeground();
					Color background = textareapanel.textarea.getBackground();
					
					textfield1.setForeground(foreground);
					textfield2.setForeground(foreground);
					
					textfield1.setCaretColor(foreground);
					textfield2.setCaretColor(foreground);
					
					textfield1.setBackground(background);
					textfield2.setBackground(background);
				}
				
				
				
				private void setFont(Font font)
				{
					//  Sets the font of the find and replace fields
					
					Font font1 = font.deriveFont((float)
					
					    Math.min(font.getSize(), 24));
					
					textfield1.setFont(font1);
					textfield2.setFont(font1);
					textarea3 .setFont(labelfont);
					
					prevbutton.setFont(font1);
					findbutton.setFont(font1);
					replacebutton.setFont(font1);
					
					//  Pack the frame
					
					dialog.setSize(dialog
					
					   .getPreferredSize());
				}
			}
			
			//  End class ReplaceListener
			
			
			
			
			
			
			private void highlight()
			{
				//  highlights the text
				
				Highlighter h = textareapanel
				
				    .textarea .getHighlighter();
				
				h.removeAllHighlights();
				
				JTextArea textarea = textareapanel.textarea;
				
				String selectedtext = textarea.getSelectedText();
				
				if ((selectedtext == null)
				  || selectedtext.isEmpty()) return;
				
				int start = textarea.getSelectionStart();
				int end   = textarea.getSelectionEnd();
				
				try { h.addHighlight(start, end,
				
				    DefaultHighlighter.DefaultPainter); }
				
				catch (BadLocationException ex) {  }
			}
			
			
			
			
			private void findNext(String text, boolean matchcase)
			{
				if (textareapanel == null) return;
				
				String str = text;
				
				if ((str == null) || str.isEmpty()) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				int cp = textarea.getCaretPosition();
				
				int sp = findNext(str, cp, matchcase);
				
				if (sp != -1) textarea
				
				    .select(sp, sp + str.length());
				
				else if (sp == -1)
				{
					sp = findNext(str, 0, matchcase);
					
					if (sp != -1) textarea
					
					    .select(sp, sp + str.length());
				}
				
				highlight();
			}
			
			
			
			
			private void findPrevious(String text, boolean matchcase)
			{
				if (textareapanel == null) return;
				
				String str = text;
				
				if ((str == null) || str.isEmpty()) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				int cp = textarea.getCaretPosition();
				
				int sp = findPrevious(str, cp, matchcase);
				
				if (sp != -1) textarea.select(
				
				    sp, sp + str.length());
				
				else if (sp == -1)
				{
					textarea.setText(textarea.getText());
					
					sp = findPrevious(str, textareapanel
					
					    .textarea.getText().length() +1, matchcase);
					
					if (sp != -1) textareapanel
					
					    .textarea.select(sp, sp + str.length());
				}
				
				highlight();
			}
			
			
			
			private int findNext(String str, int position, boolean matchcase)
			{
				if (str == null) return -1;
				
				int sp = 0;
				
				if (matchcase == true)
				
				     sp = textareapanel.textarea.getText().indexOf(str, position);
				else sp = textareapanel.textarea.getText().toLowerCase()
				
				    .indexOf(str.toLowerCase(), position);
				
				return sp;
			}
			
			
			
			private int findPrevious(String str, int position, boolean matchcase)
			{
				if (str == null) return -1;
				
				int sp = 0, length = str.length();
				
				JTextArea textarea = textareapanel.textarea;
				
				if (textarea.getSelectedText() != null)
				
				    length = textarea.getSelectedText().length();
				
				if (matchcase == true)
				
				   sp = textarea.getText()
				
				      .lastIndexOf(str, position - length -1);
				
				else sp = textarea.getText().toLowerCase()
				
				      .lastIndexOf(str.toLowerCase(), position - length -1);
				
				return sp;
			}
			
			
			
			
			private void replace(String find_string, String replace_string, boolean matchcase)
			{
				if (textareapanel == null) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getSelectedText();
				
				int start = textarea.getSelectionStart();
				int end   = textarea.getSelectionEnd();
				
				int length = end - start;
				
				if (length == 0) return;
				
				textarea.replaceRange(replace_string, start, end);
				textarea.setCaretPosition(start + replace_string.length());
				textareapanel.filechanged = true;
				
				highlight();
			}
			
			
			
			private String countNumber(String text1, boolean matchcase)
			{
				//  counts the number of occurrences of the search string
				//  and the index of the current selection and returns
				//  index / number of occurrences
				
				if (textareapanel == null) return "";
				
				if (text1.isEmpty()) return "";
				
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getText();
				
				if (!matchcase) text = text.toLowerCase();
				
				String[] tokens = null;
				
				//  Pattern.quote(String) returns a literal pattern String
				//  for the specified String. Meta characters or escape se-
				//  quences in the input are given no special meaning.
				
				String regex = Pattern.quote(text1);
				
				try { tokens = text.split(regex); }
				
				catch (java.util.regex.PatternSyntaxException ex) { return ""; }
				
				int cp = textarea.getCaretPosition(), cp1 = 0;
				
				int index = 0;
				
				for (int i = 0; i < tokens.length; i++)
				{
					cp1 += text1.length() + tokens[i].length();
					
					if (cp1 >= cp) { index = i+1; break; }
				}
				
				if (tokens.length - 1 <= 1) return "";
				
				return index + "/" + (tokens.length - 1);
			}
		}
		
		//  End class FindAndReplace
		
		
		
		
		
		
		
		
		private class ReplaceAllListener implements ActionListener
		{
		
			//  The replace all dialog box uses the String replaceAll method
			//  which matches regular expressions while the find and replace
			//  dialog uses JTextArea replaceRange which matches literal strings
			
			
			//  Examples
			//
			//  Delete all newline (or tab) chars
			//
			//  Type \n (or \t) in the first text field and press replace all
			//
			//  Delete the sequence of two chars \n (or \t)
			//
			//  Type \\n (or \\t) in the first text field and press replace all
			//
			//  (A second slash is required to escape the first slash or else the
			//  String replaceAll method will replace the newline chars instead of \n)
			//
			//  Replace all periods with commas
			//
			//  Type [.] in the first text field and , in the second field
			//
			//  Replace the carriage return with the empty string.
			//
			//  Type [\r] in the first text field
			//
			//  This removes carriage returns but leaves newline chars
			
			
			private JTextField textfield1;
			private JTextField textfield2;
			
			private JButton replaceallbutton;
			
			private int maxfontsize = 24;
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				textfield1 = new JTextField(12);
				textfield2 = new JTextField(12);
				
				float fontsize = font.getSize();
				
				if (fontsize > maxfontsize)
				    fontsize = maxfontsize;
				
				Font font1 = font.deriveFont(fontsize);
				
				textfield1.setFont(font1);
				textfield2.setFont(font1);
				
				replaceallbutton = new JButton(__.replaceall);
				
				replaceallbutton .setFont(font1);
				
				replaceallbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						String document = textareapanel.textarea.getText();
						
						String regex = textfield1.getText();
						
						String replacement = textfield2.getText();
						
						document = document.replaceAll(regex, replacement);
						
						textareapanel.textarea.setText(document);
						textareapanel.textarea.setCaretPosition(0);
						
						textareapanel.filechanged = true;
					}
				}) ;
				
				
				Box vbox = Box.createVerticalBox();
				Box hbox = Box.createHorizontalBox();
				
				hbox.add(textfield1);
				hbox.add(Box.createHorizontalStrut(10));
				hbox.add(textfield2);
				
				vbox.add(hbox);
				vbox.add(Box.createVerticalStrut(10));
				
				hbox = Box.createHorizontalBox();
				hbox.add(replaceallbutton);
				
				vbox.add(hbox);
				
				String title = __.replaceall;
				
				//  Comp, Obj, String, int, int, Icon, Obj[], Obj
				
				//  Use the empty array instead of null or else
				//  the JOptionPane will display an OK button
				
				Object[] options = new Object[] {  };
				
				JOptionPane.showOptionDialog(frame, vbox, title,
				
				    JOptionPane.DEFAULT_OPTION,
				    JOptionPane.PLAIN_MESSAGE,
				
					null, options, null);
				
				textfield1.setText("");
				textfield2.setText("");
			}
		}
		
		
		
		
		
		private class ConvertTextListener implements ActionListener
		{
		
			//   ______________________________________________________
			//  |  _________   _________   ________   ________   ____  |
			//  | |_base 64_| |_base 16_| |_string_| |_revert_| |_80_| |
			//  |                   ____   ________                    |
			//  |                  |_OK_| |_Cancel_|                   |
			//  |______________________________________________________|
			
			
			//  Encode / decode text or document
			//
			//  base 64, base 16, string, revert
			
			private int maxfontsize = 24;
			
			private int linewidth = 80;
			
			private JTextField linewidthfield;
			
			private String text0;
			
			private int caretposition;
			
			private boolean isstring;
			private boolean isbase16;
			private boolean isbase64;
			
			
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			private void run()
			{
			
				//  Display options  linewidth,
				//
				//  base 64, base 16, string, revert
				
				linewidthfield = new JTextField(3);
				linewidthfield.setFont(labelfont);
				linewidthfield.setText(String.valueOf(linewidth));
				
				linewidthfield.addKeyListener(new KeyListener()
				{
					public void keyPressed (KeyEvent e) {  }
					public void keyReleased(KeyEvent e) {  }
					
					public void keyTyped(KeyEvent e)
					{
						int keycode = e.getKeyCode();
						int keychar = e.getKeyChar();
						
						String text = linewidthfield.getText();
						
						if ( ((keychar < '0') || (keychar > '9'))
						
						  && (keycode != vk_backspace)) e.consume();
						
						if ((text.length() >= 3)
						
						  && (keycode != vk_backspace)) e.consume();
					}
				});
				
				linewidthfield.addFocusListener(new FocusAdapter()
				{
					public void focusGained(FocusEvent e)
					{
						if (e.getSource() == linewidthfield)
						
						    linewidthfield.selectAll();
					}
				});
				
				JButton[] buttons = new JButton[4];
				
				buttons[0] = new JButton(__.base64);
				buttons[1] = new JButton(__.base16);
				buttons[2] = new JButton(__.string);
				buttons[3] = new JButton(__.revert);
				
				float fontsize = font.getSize();
				
				if (fontsize > maxfontsize)
				    fontsize = maxfontsize;
				
				Font font1 = font.deriveFont(fontsize);
				
				for (JButton button : buttons)
				
				    button .setFont(font1);
				
				Box hbox = Box.createHorizontalBox();
				
				for (JButton button : buttons)
				
				    hbox.add(button);
				
				hbox.add(linewidthfield);
				
				
				ActionListener actionlistener = new ActionListener1();
				
				for (JButton button : buttons)
				
				    button .addActionListener(actionlistener);
				
				String title = __.converttext;
				
				JTextArea textarea = textareapanel.textarea;
				
				text0 = textarea.getText();
				
				caretposition = textarea.getCaretPosition();
				
				int choice = JOptionPane.showConfirmDialog(frame, hbox, null,
				
					JOptionPane.OK_CANCEL_OPTION,
					JOptionPane.PLAIN_MESSAGE, null);
				
				if (choice != JOptionPane.OK_OPTION)
				{
					textarea.setText(text0);
					
					textarea.setCaretPosition(caretposition);
				}
			}
			
			
			
			
			private class ActionListener1 implements ActionListener
			{
				private boolean clicked;
				
				public void actionPerformed(ActionEvent e)
				{
					try
					{
					//  Disable the button until the
					//
					//  finally block is executed
					
					if (clicked) return;
					
					else clicked = true;
					
					
					//  Read the partition size
					
					String linewidthstr = linewidthfield.getText();
					
					if (!linewidthstr.isEmpty())
					
					     linewidth = Integer.parseInt(linewidthstr);
					
					else linewidth = 0;
					
					
					//  Read the text area or selected text
					
					JTextArea textarea = textareapanel.textarea;
					
					String         text = textarea.getText();
					String selectedtext = textarea.getSelectedText();
					
					//  If there is selected text then use the selected text
					
					if (selectedtext != null)
					
					    text = selectedtext;
					
					String text1 = text;
					
					if (!text.isBlank())
					
					    text1 = text1.trim();
					
					if (text1.length() == 0) return;
					
					
					//  Remove tabs / indents
					
					text1 = text1 .replaceAll("[\t]", "");
					
					
					//  If the text is partitioned with single
					//  newlines then remove the partitioning
					
					if (!text1.contains("\n\n") && text1.contains("\n"))
					
					    text1 = text1 .replaceAll("\n", "");
					
					
					if (Number.isDigitString(text1, 16))
					
					     isbase16 = true;
					else isbase16 = false;
					
					if (Number.isBase64(text1) &&
					
					    convertToBase64(convertFromBase64(text1))
					
						.replaceAll("\n", "") .equals(text1) )
					
					     isbase64 = true;
					else isbase64 = false;
					
					
					String[] strarray = text.split("[+]\n");
					
					boolean bool = true;
					
					for (String str : strarray)
					{
						str = str.trim();
						
						if (!str.startsWith("\"")
						 || !str.  endsWith("\"")
						 ||  str.    equals("\""))
						
						    { bool = false;  break; }
					}
					
					isstring = bool;
					
					
					JButton button = (JButton) e.getSource();
					
					String buttontext = button.getText();
					
					if (buttontext.equals(__.string.trim()))
					{
						if (text.length() < 4) return;
						
						if (!isstring)
						
						     text = convertToString(text);
						else text = convertFromString(text.trim());
					}
					
					
					else if (buttontext.equals(__.base16))
					{
						if (text.length() < 8) return;
						
						if (!isbase16)
						
						     text = convertToBase16(text);
						else text = convertFromBase16(text1);
					}
					
					else if (buttontext.equals(__.base64))
					{
						if (text.length() < 1) return;
						
						if (!isbase64)
						
						     text = convertToBase64(text);
						else text = convertFromBase64(text1);
					}
					
					else if (buttontext.equals(__.revert))
					{
						text = text0;
					}
					
					
					if (textarea.getSelectedText() == null)
					{
						textarea.setText(text);
						textarea.setCaretPosition(0);
						
						textarea.setLineWrap(true);
					}
					
					else //  if (selectedtext != null)
					
						textarea.replaceSelection(text.trim());
					
					}
					
					//  end try
					
					
					finally { clicked = false; }
				}
			}
			
			
			
			
			private String convertToBase16(String text)
			{
				//  Encode the text in base 16
				
				char[] charray = text.toCharArray();
				
				charray = Convert.byteArrayToCharArray(
				
				    Convert.byte256ArrayToByte16Array(
				
					Convert.charArrayToByteArray(charray)));
				
				StringBuilder sb = new StringBuilder();
				
				for (int i = 0; i < charray.length; i++)
				{
					if ((linewidth != 0) && ((i % linewidth) == 0))
					
					    sb.append("\n");
					
					sb.append(charray[i]);
				}
				
				return sb.toString();
			}
			
			
			
			private String convertToBase64(String text)
			{
				//  Encode the text in base 64
				
				String base64str = Convert.stringToBase64(text);
				
				//  Partition the base-64 string
				
				base64str = Convert.partition(
				
				    base64str, "\n", linewidth);
				
				return base64str;
			}
			
			
			
			private String convertFromBase16(String text)
			{
				//  Remove the partitions
				
				text = text.replaceAll("\n", "");
				
				//  Convert the text from base 16
				
				char[] charray = text.toCharArray();
				
				text = new String(
				
				   Convert.byteArrayToCharArray(
				
				      Convert.byte16ArrayToByte256Array(
				
				         Convert.charArrayToByteArray(charray))));
				
				return text;
			}
			
			
			
			private String convertFromBase64(String text)
			{
				//  Remove the partitions
				
				text = text.replaceAll("\n", "");
				
				if (!Number.isBase64(text)) throw
				
				    new IllegalArgumentException();
				
				//  Convert the text from base 64
				
				return Convert.base64ToString(text);
			}
			
			
			
			private String convertToString(String text)
			{
				//  Condense and partition a document
				//  so it can be stored in a program
				
				//  Replace \ with \\ in the text document
				//  or program source code
				
				for (int i = 0;  ; i += 2)
				{
					i = text.indexOf("\\", i);
					
					if (i == -1)  break;
					
					textareapanel.textarea.insert("\\", i);
				}
				
				String document = text;
				
				// Remove the newlines for base 64
				
				if (Number.isBase64(document.trim()))
				
				    document = document .trim();
				
				
				//  Use the stringToStringArray method to partition the string
				
				if (linewidth == 0) return "\"" + document + "\"";
				
				String[] array = stringToStringArray(document, linewidth);
				
				//  Convert the string array to a partitioned string
				
				StringBuilder sb = new StringBuilder();
				
				
				//  For each string in the array, add an opening quote,
				//  a string, a closing quote, a plus sign, and a newline
				
				for (int i = 0; i < array.length; i++)
				{
					//  Start with a quote
					
					sb.append("\"");
					
					//  Append the text
					
					sb.append(array[i]);
					
					//  End with a quote
					
					sb.append("\"");
					
					if (i < array.length -1)
					
					    sb.append(" +" + "\n");
				}
				
				return sb.toString();
			}
			
			
			
			private String convertFromString(String text)
			{
				//  two or more \n (newlines)
				
				String[] tokens = text.split("\n{2,}");
				
				StringBuilder sb = new StringBuilder();
				
				for (String token : tokens)
				{
					String[] strarray = token.split("[+]\n");
					
					//  Concatenate the strings
					
					for (String str : strarray)
					{
						str = str.trim();
						
						if (str.startsWith("\"") && str.endsWith("\""))
						{
							str = str.substring(1);
							str = str.substring(0, str.length() -1);
						}
						
						//  Replace the two chars \n with a newline char
						//  Replace the two chars \t with a tab char
						//  Replace the two chars \" with a quotation mark
						
						str = str.replace("\\n", "\n");
						str = str.replace("\\t", "\t");
						str = str.replace("\\\"", "\"");
						
						//  Replace the substituted chars ////n
						//  and ////t with the double chars \n and \t
						
						str = str.replaceAll("////n", "\\\\n");
						str = str.replaceAll("////t", "\\\\t");
						
						sb.append(str);
					}
				}
				
				String str = sb.toString();
				
				return str;
			}
			
			
			
			private String[] stringToStringArray(String str, int linewidth)
			{
			
				//  splits a string into an array of strings
				
				//  This method is used to partition large strings or documents
				
				
				//  Replace the double chars \n and \t with something else
				//  so that they are not converted to newlines and tabs
				
				str = str.replaceAll("\\\\n", "////n");
				str = str.replaceAll("\\\\t", "////t");
				
				//  Replace newlines and tabs (single chars) with \n
				//  and \t (double chars) to compress the document
				
				str = str.replaceAll("\n", "\\\\n");
				str = str.replaceAll("\t", "\\\\t");
				str = str.replaceAll("\"", "\\\\\"");
				
				ArrayList<String> stringlist;
				
				stringlist = new ArrayList<String>();
				
				ArrayList<Character> charlist;
				
				int position = 0;
				
				
				//  Partition the string into an array of strings
				
				while (position <= (str.length() - linewidth))
				{
					charlist = new ArrayList<Character>();
					
					for (int i = 0; i < linewidth; i++)
					{
						charlist.add(str.charAt(position + i));
						
						//  Don't end with a back slash (\)
						
						if (i == linewidth -1)
						{
							int j = 0;
							
							while (str.charAt(position + i + j) == '\\')
							
							    charlist.add(str.charAt(position + i + ++j));
							
							position += j;
						}
					}
					
					Object[] objarray = charlist.toArray();
					
					Character[] charray = new Character[objarray.length];
					
					for (int i = 0; i < charray.length; i++)
					
					    charray[i] = (Character) objarray[i];
					
					StringBuilder sb = new StringBuilder();
					
					for (char ch : charray) sb.append(ch);
					
					if (!sb.toString().isEmpty())
					
					    stringlist.add(sb.toString());
					
					String s = stringlist.get(stringlist.size() -1);
					
					position += linewidth;
				}
				
				
				if ((str.length() - position) != linewidth)
				{
					//  Append the fractional string
					
					charlist = new ArrayList<Character>();
					
					for (int i = 0; i < (str.length() - position); i++)
					
					    charlist.add( str.charAt(position + i) );
					
					Object[] objarray = charlist.toArray();
					
					Character[] charray = new Character[objarray.length];
					
					for (int i = 0; i < charray.length; i++)
					
					    charray[i] = (Character) objarray[i];
					
					StringBuilder sb = new StringBuilder();
					
					for (char ch : charray) sb.append(ch);
					
					if (!sb.toString().isEmpty())
					
					    stringlist.add(sb.toString());
				}
				
				String[] array = new String[stringlist.size()];
				
				return stringlist.toArray(array);
			}
		}
		
		//  End class ConvertTextListener
		
		
		
		
		
		
		private class HighlightTextListener implements ActionListener
		{
			private JTextField textfield;
			
			public void actionPerformed(ActionEvent e)
			{
				String title = __.highlighttext;
				
				textfield = new JTextField(16);
				
				textfield.setFont(font);
				textfield.setForeground(foreground);
				textfield.setCaretColor(foreground);
				textfield.setBackground(background);
				textfield.requestFocus();
				
				JOptionPane.showMessageDialog(frame, textfield,
				
				    title, JOptionPane.PLAIN_MESSAGE, null);
				
				String text = textfield.getText();
				
				if ((text == null) || text.isEmpty())
				{
					Highlighter h = textareapanel
					
					    .textarea.getHighlighter();
					
					h.removeAllHighlights();
					
					return;
				}
				
				ArrayList<int[]> startendlist = new ArrayList<int[]>();
				
				String document = textareapanel.textarea.getText();
				
				for (int index = 0; index < document.length(); )
				{
					index = document.indexOf(text, index);
					
					if (index == -1) break;
					
					int[] startend = new int[2];
					
					startend[0] = index;
					startend[1] = index + text.length();
					
					startendlist.add(startend);
					
					index++;
				}
				
				highlight(startendlist);
			}
			
			
			private void highlight(ArrayList<int[]> startendlist)
			{
				Highlighter h = textareapanel.textarea.getHighlighter();
				
				for (int[] startendpos : startendlist)
				{
					int start = startendpos[0];
					int end   = startendpos[1];
					
					try { h.addHighlight(start, end,
					
					    DefaultHighlighter.DefaultPainter); }
					
					catch (BadLocationException ex) {  }
				}
			}
		}
		
		
		
		
		
		private class GoToLineListener implements ActionListener
		{
		
			private JPanel panel;
			
			private JTextField closefield;
			
			private JLabel gotolabel;
			
			private Character closechar
			
			    = Character.valueOf((char) 10007);
			
			
			public void actionPerformed(ActionEvent e)
			{
				setVisible(true);
			}
			
			
			public void setVisible(boolean bool)
			{
				if (menubar.getComponentIndex(panel) == -1)
				{
					menubar.add(panel);
					menubar.setVisible(false);
					menubar.setVisible(true);
				}
				
				panel.setVisible(bool);
				
				currentlinefield.requestFocusInWindow();
				
				currentlinefield.setText("");
				currentcolfield .setText("");
				currentposfield .setText("");
				
				setFont(font);
				
				setColor();
			}
			
			
			
			public GoToLineListener()
			{
			
				//  gotolabel = new JLabel(__.gotoline + " ");
				
				gotolabel = new JLabel();
				
				closefield = new JTextField(1); // x
				closefield.setEditable(false);
				closefield.setBorder(null);
				closefield.setBackground(
				    new JPanel().getBackground());
				
				
				currentlinefield = new JTextField(6);
				currentcolfield  = new JTextField(4);
				currentposfield  = new JTextField(8);
				
				//  the default JTextField setting is JTextField.LEADING;
				//  JTextField.LEADING expands the text from left to right as the user types
				//  JTextField.TRAILING expands from right to left as in a calculator text field
				//  JTextField.CENTER expands the text symmetrically from center to left and right
				
				//  currentlinefield.setHorizontalAlignment(JTextField.TRAILING);
				currentlinefield.setHorizontalAlignment(JTextField.CENTER);
				
				//  currentcolfield.setVisible(false);
				//  currentposfield.setVisible(false);
				
				currentlinefield.setEditable(true);
				currentcolfield .setEditable(false);
				currentposfield .setEditable(false);
				
				Color darkgray = Color.gray.darker().darker();
				
				currentlinefield.setForeground(darkgray);
				currentcolfield .setForeground(darkgray);
				currentposfield .setForeground(darkgray);
				
				currentlinefield.setBackground(new JPanel().getBackground());
				currentcolfield .setBackground(new JPanel().getBackground());
				currentposfield .setBackground(new JPanel().getBackground());
				
				currentlinefield.setBorder(null);
				currentcolfield .setBorder(null);
				currentposfield .setBorder(null);
				
				currentlinefield.setToolTipText(__.line);
				currentcolfield .setToolTipText(__.column);
				currentposfield .setToolTipText(__.position);
				
				currentlinefield.addMouseListener(mouselistener);
				currentposfield .addMouseListener(mouselistener);
				
				currentlinefield.addFocusListener( new FocusAdapter()
				{
					public void focusGained(FocusEvent e) {  }
					
					public void focusLost(FocusEvent e) {  }
				} );
				
				
				KeyListener keylistener = new KeyListener()
				{
					private boolean shift, control;
					
					public void keyPressed(KeyEvent e)
					{
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_control) control = true;
						
						if (control && (keycode == __.gotolinekeycode))
						{
							if (textareapanel != null)
							
							    textareapanel.textarea
							
								.requestFocusInWindow();
							
							control = false;
						}
						
						if (keychar == vk_escape)
						{
							gotolinelistener.setVisible(false);
							
							if (textareapanel != null)
							
							    textareapanel.textarea
							
								.requestFocusInWindow();
						}
					}
					
					public void keyReleased(KeyEvent e)
					{
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_shift)
						
						    shift = false;
						
						else if (keycode == vk_control)
						
						    control = false;
					}
					
					public void keyTyped(KeyEvent e)
					{
						int keycode = e.getKeyCode();
						int keychar = e.getKeyChar();
						
						if (e.getSource() == currentlinefield)
						{
							if ((currentlinefield.getText().length() >= 7)
							
							    || (!Character.isDigit(keychar) && (keychar != '\n')))
							{
								e.consume();
								
								return;
							}
						}
						
						if ((keychar == '\n') && !shift)
						{
							//  De-select the text field
							
							currentlinefield.setText(
							currentlinefield.getText());
							
							
							//  Read the line number
							
							String str = currentlinefield.getText();
							
							if ((str == null) || str.isBlank()
							
							   || (textareapanel == null))  return;
							
							
							//  Goto line number
							
							int index = Integer.parseInt(str);
							
							if (index == -1) return;
							
							String text = textareapanel.textarea.getText();
							
							int cp, line = 1;
							
							for (cp = 0; cp < text.length(); cp++)
							{
								//  Count the lines
								
								if (text.charAt(cp) == '\n') line += 1;
								
								if (line >= index)  break;
							}
							
							if ((cp + 1) < text.length())
							{
								textareapanel.textarea.setCaretPosition(cp + 1);
								
								//  Return the focus to the textarea
								
								textareapanel.textarea
								
								    .requestFocusInWindow();
								
								control = false;
							}
						}
					}
				};
				
				
				currentlinefield.addKeyListener(keylistener);
				
				closefield.addMouseListener(new MouseListener()
				{
					public void mouseEntered(MouseEvent e)
					{
						closefield.setText(
						
						    Character.toString(closechar));
					}
					
					public void mouseExited(MouseEvent e)
					{
						closefield.setText("");
					}
					
					public void mouseClicked(MouseEvent e)
					{
						gotolinelistener.setVisible(false);
						
						if (textareapanel != null)
						
						    textareapanel.textarea
						
							.requestFocusInWindow();
					}
				});
				
				
				panel = new JPanel();
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				panel.add(closefield, gbc);
				
				gbc.setPosition(1, 0);
				panel.add(gotolabel, gbc);
				
				gbc.setPosition(2, 0);
				panel.add(currentlinefield, gbc);
				
				gbc.setPosition(3, 0);
				panel.add(currentcolfield, gbc);
				
				gbc.setPosition(4, 0);
				panel.add(currentposfield, gbc);
				
				
				//  a box is smaller than a panel
				//  Box hbox = Box.createHorizontalBox();
				//  hbox.add(textlabel);
				//  hbox.add(textfield);
			}
			
			
			public void setColor()
			{
				if (textareapanel == null) return;
				
				Color foreground = textareapanel.textarea.getForeground();
				Color background = textareapanel.textarea.getBackground();
				
				//  currentlinefield.setForeground(foreground);
				//  currentlinefield.setCaretColor(foreground);
				//  currentlinefield.setBackground(background);
			}
			
			
			public void setFont(Font font)
			{
				//  Sets the font of the current line,
				//  column, and position fields
				
				int maxfontsize = 24;
				
				float fontsize = font.getSize();
				
				fontsize = Math.min(fontsize, maxfontsize);
				
				Font font1 = labelfont.deriveFont(fontsize);
				
				font1 = font1.deriveFont((font1.getSize() > 16) ?
				
				    Font.PLAIN : Font.BOLD);
				
				currentlinefield.setFont(font1);
				currentcolfield .setFont(font1);
				currentposfield .setFont(font1);
			}
		}
		
		
		//  End class GotoLineListener
		
		
		
		
		
		private class UpperLowerCaseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getSelectedText();
				
				if ((text == null) || text.isEmpty())
				{
					String errormessage = __.noselectedtext;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, null, JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				int start = textarea.getSelectionStart();
				int end   = textarea.getSelectionEnd();
				
				int length = end - start;
				
				if (length == 0) return;
				
				int upperchars = 0, lowerchars = 0;
				
				for (int i = 0; i < text.length(); i++)
				{
					Character c = text.charAt(i);
					
					if      (Character.isUpperCase(c)) upperchars++;
					else if (Character.isLowerCase(c)) lowerchars++;
				}
				
				if (upperchars >= lowerchars)
				{
					String lowercase = text.toLowerCase();
					
					textarea.replaceRange(lowercase, start, end);
					textarea.setCaretPosition(start);
				}
				
				else
				{	String uppercase = text.toUpperCase();
					
					textarea.replaceRange(uppercase, start, end);
					textarea.setCaretPosition(start);
				}
			}
		}
		
		
		
		
		private class IndentListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String text = textareapanel.textarea.getSelectedText();
				
				if ((text == null) || text.isEmpty())
				{
					String errormessage = __.noselectedtext
					
					  + "\n" + __.usearrowkeystoindent;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, null, JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				//  Click the right arrow key
				
				System.out.println(
				
				    "Use the left / right arrow keys to indent a block of text");
				
				if (!keylistener1.shift) keylistener1.  indent();
				if ( keylistener1.shift) keylistener1.unindent();
			}
		}
		
		
		
		
		private class SetTitleListener implements ActionListener
		{
			private int maxfontsize = 24;
			
			public void actionPerformed(ActionEvent e)
			{
				JTextField textfield = new JTextField(16);
				
				float fontsize = font.getSize();
				
				if (fontsize > maxfontsize) fontsize = maxfontsize;
				
				textfield.setText(titlename);
				
				textfield.setFont(font.deriveFont(fontsize));
				
				textfield.setForeground(foreground);
				textfield.setCaretColor(foreground);
				textfield.setBackground(background);
				
				String title = __.setprogramtitle;
				
				textfield.addKeyListener(new KeyAdapter()
				{
					public void keyReleased(KeyEvent e)
					{
						titlename = textfield.getText().trim();
						
						frame.setTitle(titlename);
						
						int maxlen = 20;
						
						aboutmenuitem.setText(__.about + " "
						
						  + ((titlename.length()   > maxlen) ?
						      titlename.substring(0, maxlen) : titlename));
					}
				});
				
				textfield.requestFocusInWindow();
				
				int messagetype = JOptionPane.PLAIN_MESSAGE;
				
				JPanel panel = new JPanel(); panel.add(textfield);
				
				JOptionPane.showMessageDialog(frame, panel, title, messagetype);
				
				setFrameTitle();
			}
		}
		
		
		
		
		private class HashListener implements ActionListener
		{
		
			//  Selecting any hash digits and right clicking in the JOptionPane
			//  copies the selected hash digits to the clipboard w/o using Ctrl+C
			
			
			private JTextArea textarea;
			
			private MouseListener mouselistener;
			
			private class MouseListener extends MouseAdapter
			{
				//  If the user clicks the secondary mouse button
				
				public void mousePressed(MouseEvent e)
				{
					//  Copy the selected hash digits
					
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						textarea.copy();
					}
				}
			}
			
			
			public HashListener()
			{
				textarea = new JTextArea(1, 0);
				
				textarea.setEditable(false);
				
				mouselistener = new MouseListener();
				
				textarea.addMouseListener(mouselistener);
			}
			
			
			public void actionPerformed(ActionEvent e)
			{
				//  Read the text and selected text
				
				JTextArea textarea = textareapanel.textarea;
				
				String         text = textarea.getText();
				String selectedtext = textarea.getSelectedText();
				
				//  If there is selected text then use the selected text
				
				if (selectedtext != null) text = selectedtext;
				
				//  Compute the hash with and without white space
				
				//  (The text could be trimmed before hashing)
				
				String hash1 = Cipher.hash1(text);
				String hash2 = Cipher.hash2(text);
				
				
				//  A type 1 hash is used for hashing programs.
				//  A type 2 hash is used for hashing documents such as the GPL
				//  because it ignores white space before hashing. This allows
				//  the user to reformat the spacing of the lines or paragraphs
				//  without breaking the hash.
				
				
				//  Display the partitioned hashes
				
				int maxfontsize = 24;
				
				Font font1 = font.deriveFont(1.0f *
				
				    Math.min(font.getSize(), maxfontsize));
				
				JTextArea textarea1 = new JTextArea();
				JTextArea textarea2 = new JTextArea();
				
				textarea1.setEditable(false);
				textarea2.setEditable(false);
				textarea1.setFont(font1);
				textarea2.setFont(font1);
				
				textarea1.setBackground(new JPanel().getBackground());
				textarea2.setBackground(new JPanel().getBackground());
				
				String message1 = Convert.partition(hash1, " ", 4);
				String message2 = Convert.partition(hash2, " ", 4);
				
				textarea1.setText(message1);
				textarea2.setText(message2);
				
				Box vbox = Box.createVerticalBox();
				
				vbox.add(textarea1);
				vbox.add(Box.createVerticalStrut(8));
				vbox.add(textarea2);
				
				JOptionPane.showMessageDialog(frame,
				
				    vbox, "", JOptionPane.PLAIN_MESSAGE);
			}
		}
		
		
		
		
		
		//  The file hash and the text / document (type 1) hash are identical
		
		
		private class HashFileListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				File selectedfile = null;
				
				JFileChooser fc;
				
				fc = new FileChooser();
				fc.setFont(font);
				fc.setDialogTitle(__.hashfile);
				
				int choice = fc.showOpenDialog(frame);
				
				if (choice == JFileChooser.APPROVE_OPTION)
				
				    selectedfile = fc.getSelectedFile();
				
				else if (choice == JFileChooser.CANCEL_OPTION) return;
				
				hashFile(selectedfile);
			}
			
			
			private void hashFile(File file)
			{
			
				byte[] hash;
				
				if (file.length() >= 2L*1024*1024*1024)
				{
					try { hash = Cipher.hashLargeFile(file); }
					
					catch (IOException ex) { ex.printStackTrace(); return; }
				}
				
				else if (!Cipher.isEncrypted(file))
				{
					try { hash = Cipher.hash(file); }
					
					catch (IOException ex) { ex.printStackTrace(); return; }
				}
				
				else // if (Cipher.isEncrypted(file))
				{
					System.out.println("decrypting before hashing");
					
					FileDecryptor fd;
					
					fd = new FileDecryptor(frame);
					fd.setFileKey(filekey);
					fd.setPassphrase(SP);
					
					if (textareapanel != null)
					{
						JTextArea textarea = textareapanel.textarea;
						
						fd.setFont(textarea.getFont());
						fd.setForeground(textarea.getForeground());
						fd.setBackground(textarea.getBackground());
					}
					
					//  Decrypt the file input
					
					byte[] cipherdata;
					
					try { cipherdata = DataStream.read(file); }
					
					catch (IOException ex) { System.out.println(ex); return; }
					
					byte[] plaindata = fd.decrypt(cipherdata);
					
					if (plaindata == null) return;
					
					filekey = fd.getFileKey();
					
					hash = Cipher.hash(plaindata);
				}
				
				String hashstr = new Number(hash).toString(64, 16);
				
				System.out.println(hashstr);
				
				hashstr = Convert.partition(hashstr.substring(0, 40), " ", 4);
				
				String message = hashstr;
				
				String title = file.getName();
				
				
				JTextArea textarea = new JTextArea();
				
				textarea.setText(hashstr);
				textarea.setFont(font);
				textarea.setEditable(false);
				textarea.setBackground(
				    new JPanel().getBackground());
				
				textarea.addMouseListener( new MouseAdapter()
				{
					public void mouseClicked(MouseEvent e)
					{
						if (e.getButton() != MouseEvent.BUTTON1)
						{
							String text = textarea.getSelectedText();
							
							if (text != null) textarea.copy();
						}
					}
				} );
				
				//  Display the JOptionPane dialog
				
				JOptionPane.showMessageDialog(frame, textarea, title,
				
				    JOptionPane.INFORMATION_MESSAGE);
			}
		}
		
		
		
		
		
		
		
		//  The public key hash method sorts the keys by size and then removes
		//  the white space before hashing so that the user's public key hash
		//  doesn't have to change each time a new version of the software is
		//  released and the order of the public key ciphers is changed; or if
		//  the user indents the public key by selecting the text with the mouse
		//  and then clicking the right arrow key; or if the user changes the
		//  width or partition size of the key so that the public key fits on
		//  a webpage.
		//
		//  The public key hash does not include the email address but the
		//  private key usually hashes the passphrase and the email address
		//  to make the public key different for each email address.
		
		
		
		private class HashPublicKeyListener implements ActionListener
		{
			private JTextArea textarea;
			
			private MouseListener mouselistener;
			
			private class MouseListener extends MouseAdapter
			{
				//  If the user clicks the secondary mouse button
				
				public void mousePressed(MouseEvent e)
				{
					//  Copy the selected hash digits
					
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						textarea.copy();
					}
				}
			}
			
			
			public HashPublicKeyListener()
			{
				textarea = new JTextArea(1, 0);
				
				textarea.setEditable(false);
				
				mouselistener = new MouseListener();
				
				textarea.addMouseListener(mouselistener);
			}
			
			
			public void actionPerformed(ActionEvent e)
			{
				//  Read the text and selected text
				
				JTextArea textarea = textareapanel.textarea;
				
				String         text = textarea.getText();
				String selectedtext = textarea.getSelectedText();
				
				
				//  If there is selected text then use the selected text
				
				if (selectedtext != null) text = selectedtext;
				
				
				//  Verify that the text or selected text is a valid public key
				
				if (!PublicKey.isPublicKeyDocument(text))
				{
					JOptionPane.showMessageDialog(frame,
					
					    __.nopublickey, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				//  Compute the public key hash
				
				String hash = PublicKey.hashPublicKey(text);
				
				
				//  Display the public key hash in a dialog
				
				Font font1 = font.deriveFont(
				
				    (float) Math.min(font.getSize(), 24));
				
				JTextArea textarea1 = new JTextArea();
				
				textarea1.setFont(font1);
				
				textarea1.setBackground(new JPanel().getBackground());
				
				String message = Convert.partition(hash, " ", 4);
				
				textarea1.setText(message);
				
				String title = __.publickeyhash;
				
				JOptionPane.showMessageDialog(frame,
				
				    textarea1, title, JOptionPane.PLAIN_MESSAGE);
			}
		}
		
		
		
		
		private class SelectAllListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				JTextArea textarea = textareapanel.textarea;
				
				if (keylistener1.getShift() || keylistener1.getControl())
				{
					//  Select forward
					
					textarea.selectAll();
				}
				
				else  //  Select backward
				{
					String text = textarea.getText();
					
					textarea.setCaretPosition(text.length());
					
					textarea.moveCaretPosition(0);
				}
			}
		}
		
		
		
		private class SelectRangeListener implements ActionListener
		{
		
			private int maxfontsize = 24;
			
			private JTextField textfield1;
			private JTextField textfield2;
			
			private JButton selectrangebutton;
			
			public void actionPerformed(ActionEvent e)
			{
				//  Request the focus because if the find text field
				//  has the focus then the range will not be high-
				//  lighted even if it is selected
				
				JTextArea textarea = textareapanel.textarea;
				
				textarea.requestFocusInWindow();
				
				float fontsize = font.getSize();
				
				if (fontsize > maxfontsize) fontsize = maxfontsize;
				
				Font font1 = font.deriveFont(fontsize);
				
				selectrangebutton = new JButton(__.selectrange);
				
				selectrangebutton .setFont(font1);
				
				selectrangebutton.addActionListener(new ActionListener()
				{
					//  bool reverses direction for each click so
					//  the user can see the selected text
					
					private boolean bool;
					
					int pos1 = textarea.getCaretPosition(), pos2 = pos1;
					
					public void actionPerformed(ActionEvent e)
					{
						String startstr = textfield1.getText() .toLowerCase();
						String   endstr = textfield2.getText() .toLowerCase();
						
						if (startstr.isEmpty() || endstr.isEmpty()) return;
						
						String text = textarea.getText() .toLowerCase();
						
						if (Number.isDigitString(startstr, 10) && (startstr.length() < 6)
						 && Number.isDigitString(  endstr, 10) && (  endstr.length() < 6))
						{
							//  Use line numbers instead of strings
							
							String[] tokens = text.split("\n");
							
							int lines = tokens.length;
							
							int int1 = Integer.parseInt(startstr);
							int int2 = Integer.parseInt(  endstr);
							
							if ((int1 < lines) && (int2 < lines))
							{
								pos1 = 0;  pos2 = 0;
								
								for (int i = 0; i < int1 -2; i++)
								
								    pos1 = text.indexOf("\n", pos1+1);
								
								for (int i = 0; i < int2 -1; i++)
								
								    pos2 = text.indexOf("\n", pos2+1);
							}
						}
						
						else
						{	//  Search for the start / end from the caret position
							
							pos1 = text.indexOf(startstr, pos1);
							pos2 = text.indexOf(endstr, pos1 + 1);
							
							if ((pos1 < 0) || (pos2 < 0))
							{
								//  Search for the start string and end string
								
								pos1 = text.indexOf(startstr);
								pos2 = text.indexOf(endstr, pos1 + 1);
							}
						}
						
						if ((pos1 < 0) || (pos2 <= pos1)) return;
						
						
						if (bool == false)
						{
							textarea . setCaretPosition(pos1);
							textarea .moveCaretPosition(pos2);
						}
						
						else
						{	textarea . setCaretPosition(pos2);
							textarea .moveCaretPosition(pos1);
						}
						
						bool = ! bool;
					}
				});
				
				
				textfield1 = new JTextField(20);
				textfield2 = new JTextField(20);
				
				textfield1.setFont(font1);
				textfield2.setFont(font1);
				
				textfield1.setForeground(foreground);
				textfield2.setForeground(foreground);
				
				textfield1.setCaretColor(foreground);
				textfield2.setCaretColor(foreground);
				
				textfield1.setBackground(background);
				textfield2.setBackground(background);
				
				
				//   _____________________________
				//  |  _________________________  |
				//  | |_________________________| |
				//  |  _________________________  |
				//  | |_________________________| |
				//  |       _______________       |
				//  |      |_Select Range _|      |
				//  |_____________________________|
				
				
				Box vbox = Box.createVerticalBox();
				
				vbox.add(textfield1);
				vbox.add(Box.createVerticalStrut(10));
				vbox.add(textfield2);
				vbox.add(Box.createVerticalStrut(10));
				
				String title = __.selectrange;
				
				Object[] options = new Object[] { selectrangebutton };
				
				JOptionPane.showOptionDialog(frame, vbox, title,
				
				    JOptionPane.DEFAULT_OPTION,
				    JOptionPane.PLAIN_MESSAGE,
				
					null, options, null);
				
				//  Clear the text fields
				
				textfield1.setText("");
				textfield2.setText("");
			}
		}
		
		
		
		
		private void setFont1(Font font)
		{
		
			//  Sets the fonts and fontsizes of
			//  all text areas and text fields
			
			for (TextAreaPanel textareapanel : textareapanellist)
			
			     textareapanel.textarea.setFont(font);
			
			this.font = font;
			
			this.fontname  = font.getName();
			this.fontsize  = font.getSize();
			this.fontstyle = font.getStyle();
			
			    findlistener.setFont(font);
			 replacelistener.setFont(font);
			gotolinelistener.setFont(font);
			
			
			//  Change the icon panel sizes
			
			for (int i = 0; i < iconbuttons.length; i++)
			{
				//  Read the original image so the
				//  icon doesn't get distorted
				
				if (imageicons[i] == null) continue;
				
				Image image = imageicons[i].getImage();
				
				int width = font.getSize();
				
				//  Set the max and min icon sizes
				
				if (width > maxiconsize) width = maxiconsize;
				if (width < miniconsize) width = miniconsize;
				
				int height = -1, hints = Image.SCALE_SMOOTH;
				
				if (width == 0) width = 1;
				
				image = image.getScaledInstance(width, height, hints);
				
				ImageIcon scaledicon = new ImageIcon(image);
				
				iconbuttons[i].setIcon(scaledicon);
			}
			
			
			for (JMenuItem menuitem : menuitems)
			
			    if (menuitem != null) menuitem
			
				.setFont(menuitemfont);
		}
		
		
		
		
		private class TextBoldListener
		
			extends MouseAdapter implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String fontname = font.getName();
				int fontstyle = font.getStyle();
				int fontsize = font.getSize();
				
				if (fontstyle == Font.PLAIN)
				
				    font = new Font(fontname, Font.BOLD, fontsize);
				
				if (fontstyle == Font.BOLD)
				
				    font = new Font(fontname, Font.PLAIN, fontsize);
				
				setFont1(font);
				
				if (textareapanel != null)
				
				    textareapanel.textarea.requestFocusInWindow();
			}
		}
		
		
		
		
		private class FontSizeListener implements ActionListener
		{
		
			private JPanel panel;
			
			private JButton plusbutton;
			private JButton minusbutton;
			
			private JTextField textfield;
			
			private JCheckBox fontstylebox;
			
			
			private final int k = 16;
			
			//  1/16 magnification per click
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				if (textareapanel == null) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				try
				{
				
				plusbutton  = new JButton("+");
				minusbutton = new JButton("-");
				
				textfield = new JTextField(4);
				
				textfield.setFont(textfield
				
				    .getFont().deriveFont(20.0f));
				
				panel = new JPanel();
				
				panel.add(textfield);
				panel.add(minusbutton);
				panel.add(plusbutton);
				
				
				ActionListener actionlistener = new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						if (e.getSource() == plusbutton)
						{
							incrementSize();
						}
						
						else if (e.getSource() == minusbutton)
						{
							decrementSize();
						}
						
						else if (e.getSource() == textfield)
						{
							textarea.setFont(font.deriveFont((float)
							
							   Integer.parseInt(textfield.getText())));
						}
						
						textfield.setText(String.valueOf(
						
						    textarea.getFont().getSize()));
					}
				};
				
				
				plusbutton .addActionListener(actionlistener);
				minusbutton.addActionListener(actionlistener);
				
				
				textfield.addKeyListener(new KeyAdapter()
				{
					public void keyReleased(KeyEvent e)
					{
						String text = textfield.getText();
						
						int fontsize = !text.isBlank() ?
						
						    Integer.parseInt(textfield.getText()) : 1;
						
						if (fontsize > 1000)
						{
							fontsize = 1000;
							
							textfield.setText(
							
							  String.valueOf(fontsize));
						}
						
						else if (fontsize == 0)
						{
							fontsize = 1;
						}
						
						font = new Font(font.getName(),
						
						    font.getStyle(), fontsize);
						
						textarea.setFont(font);
					}
					
					public void keyTyped(KeyEvent e)
					{
						if ((textfield.getText().trim().length() == 4)
						
						    || !Character.isDigit(e.getKeyChar()))
						
							e.consume();
					}
				});
				
				
				Object[] objarray = new Object[] { panel };
				
				String title = __.changethefontsize;
				
				textfield.setText( String.valueOf(
				
				    textarea.getFont().getSize()) );
				
				JOptionPane.showMessageDialog(frame, objarray, title, 3);
				
				int size = Integer.parseInt(textfield.getText());
				
				if (size != 0)
				{
					font = new Font(font.getName(),
					
					    font.getStyle(), size);
					
					textarea.setFont(font);
					
					setFont1(font);
				}
				
				}  finally { textarea.requestFocusInWindow(); }
			}
			
			
			
			private void incrementSize()
			{
			
				String name = font.getName();
				int style   = font.getStyle();
				int size    = font.getSize();
				
				
				if (size > 1000) return;
				
				if (size < 30)
				
				     { font = new Font(name, style, size += 1); }
				else { font = new Font(name, style, size += size / k); }
				
				//  Set the font
				
				setFont1(font);
				
				//  Restore the screen position
				
				JTextArea textarea = textareapanel.textarea;
				
				int cp = textarea.getCaretPosition();
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				textarea. setCaretPosition(cp);
				textarea.moveCaretPosition(cp1);
				textarea. setCaretPosition(cp);
			}
			
			
			
			private void decrementSize()
			{
			
				String name = font.getName();
				int style = font.getStyle();
				int size  = font.getSize();
				
				if ((size < 30) && (size > 1))
				
					font = new Font(name, style, size -= 1);
				
				else
				{	size -= size / k; if (size < 1) size = 1;
					
					font = new Font(name, style, size);
				}
				
				//  Set the font
				
				setFont1(font);
				
				//  Restore the screen position
				
				JTextArea textarea = textareapanel.textarea;
				
				int cp = textarea.getCaretPosition();
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				textarea. setCaretPosition(cp);
				textarea.moveCaretPosition(cp1);
				textarea. setCaretPosition(cp);
			}
		}
		
		
		
		
		private class FontTypeListener implements ActionListener
		{
		
			private JTextField[] textfields;
			
			private String fontname;
			
			private int style;
			
			private JCheckBox stylebox;
			
			Font font0;
			
			
			public void actionPerformed(ActionEvent e)
			{
				font0 = font;
				
				style = (font != null) ?
				
				    font.getStyle() : Font.PLAIN;
				
				JDialog dialog = getFontDialog(font);
				
				//  JDialog setVisible() blocks
				//  until the dialog is disposed
				//  only if modal is set to true
				
				dialog.setVisible(true);
			}
			
			
			private class MouseListener extends MouseAdapter
			{
				public void mouseClicked(MouseEvent e)
				{
					Object obj = e.getSource();
					
					if (obj instanceof JTextField)
					{
						fontname = ((JTextField) obj).getText();
						
						displayFont();
					}
					
					if (obj instanceof JCheckBox)
					{
						style = stylebox.isSelected() ?
						
						    Font.BOLD : Font.PLAIN;
						
						displayFont();
					}
					
					if (obj instanceof JLabel)
					{
						 stylebox.setSelected(
						!stylebox.isSelected());
						
						style = stylebox.isSelected() ?
						
						    Font.BOLD : Font.PLAIN;
						
						displayFont();
					}
				}
			}
			
			
			private JDialog getFontDialog(Font font)
			{
				//  The font dialog allows the user to select a font type
				//  and shows the user what each font type looks like as
				//  the arrow key is pressed or the mouse is clicked
				
				JLabel stylelabel, fontlabel;
				
				GraphicsEnvironment ge;
				
				ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
				
				String[] fonts = ge.getAvailableFontFamilyNames();
				
				//  for (String font1 : fonts) System.out.println(
				//
				//      Arrays.toString(font1.toCharArray()));
				
				textfields = new JTextField[fonts.length];
				
				MouseListener mouselistener = new MouseListener();
				
				for (int i = 0; i < textfields.length; i++)
				{
					textfields[i] = new JTextField(fonts[i]);
					textfields[i] .setEditable(false);
					textfields[i] .setForeground(foreground);
					textfields[i] .setBackground(background);
					textfields[i] .addMouseListener(mouselistener);
					textfields[i] .setFont(new Font(
					     fonts[i], fontstyle, font.getSize()));
				}
				
				JScrollPane scrollpane = new JScrollPane();
				
				scrollpane.setVerticalScrollBarPolicy(
				    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				
				scrollpane.getVerticalScrollBar().setUnitIncrement(32);
				
				Box vbox = Box.createVerticalBox();
				
				for (JTextField textfield : textfields)
				
				    vbox.add(textfield);
				
				scrollpane.setViewportView(vbox);
				
				
				//   ____________________________
				//  |                            |
				//  |     [ OK ] [ Cancel ]      |
				//  |                            |
				//  |    [x] bold  font name     |
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				
				stylebox = new JCheckBox();
				stylelabel = new JLabel(__.bold);
				 fontlabel = new JLabel(font.getName());
				JButton okbutton = new JButton(__.OK);
				JButton cancelbutton = new JButton(__.cancel);
				
				stylebox.setSelected(style == Font.BOLD);
				
				stylebox  .addMouseListener(mouselistener);
				stylelabel.addMouseListener(mouselistener);
				
				stylelabel.setFont(font);
				 fontlabel.setFont(font);
				
				Box hbox1 = Box.createHorizontalBox();
				Box hbox2 = Box.createHorizontalBox();
				
				hbox1.add(okbutton);
				hbox1.add(Box.createHorizontalStrut(10));
				hbox1.add(cancelbutton);
				
				hbox2.add(stylebox);
				hbox2.add(stylelabel);
				hbox2.add(Box.createHorizontalStrut(20));
				hbox2.add(fontlabel);
				
				vbox = Box.createVerticalBox();
				
				vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox1);
				vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox2);
				vbox.add(Box.createVerticalStrut(10)); vbox.add(scrollpane);
				
				
				boolean modal = false;
				
				String title = __.selectfonttype;
				
				JDialog dialog = new JDialog(frame, modal);
				
				dialog.setTitle(title);
				
				
				//  Clicking ok or cancel or pressing
				//  the escape key closes the dialog
				
				okbutton .addActionListener( new ActionListener()
				{
				    public void actionPerformed(ActionEvent e)
				    {
					//  Set the new font
					
					Font font1 = font0;
					
					if ((fontname != null) && !fontname.isEmpty())
					
					    font1 = new Font(fontname, style, (int) fontsize);
					
					fontname  = font1.getName();
					fontstyle = font1.getStyle();
					fontsize  = font1.getSize();
					
					setFont1(font1);
					
					dialog.dispose();
				} } );
				
				
				cancelbutton .addActionListener( new ActionListener()
				{ public void actionPerformed(ActionEvent e)
				{ setFont1(font0); dialog.dispose(); } } );
				
				KeyAdapter closelistener = new KeyAdapter()
				{ public void keyPressed(KeyEvent e)
				{ if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				  setFont1(font0); dialog.dispose(); } };
				
				
				scrollpane.addKeyListener(closelistener);
				scrollpane.requestFocusInWindow();
				scrollpane.setHorizontalScrollBarPolicy(
				    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				
				Dimension d = new Dimension(400, 800);
				
				dialog.add(vbox);
				dialog.setResizable(false);
				dialog.setDefaultCloseOperation(
				    JDialog.DISPOSE_ON_CLOSE);
				dialog.setMinimumSize(d);
				
				return dialog;
			}
			
			
			private void displayFont()
			{
				for (JTextField textfield : textfields)
				{
					Font textfieldfont = textfield.getFont();
					
					textfield.setFont(new Font(textfieldfont.getName(),
					
					    style, textfieldfont.getSize()));
				}
				
				if ((fontname == null) || fontname.isEmpty())
				
				    fontname = font.getName();
				
				Font font1 = new Font(fontname, style, font.getSize());
				
				setFont1(font1);
			}
		}
		
		
		
		
		private class ColorListener implements ActionListener
		{
		
			private JColorChooser cc;
			
			public ColorListener()
			{
				cc = new JColorChooser();
			}
			
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel == null) return;
				
				JTextArea textarea = textareapanel.textarea;
				
				try
				{
				
				JButton textcolorbutton   = new JButton(__.textcolor);
				JButton screencolorbutton = new JButton(__.screencolor);
				JButton swapcolorsbutton  = new JButton(__.swapcolors);
				
				String title = "";
				
				Object[] options = new Object[]
				
				    { textcolorbutton, screencolorbutton, swapcolorsbutton };
				
				
				Color screencolor1 = textarea.getBackground();
				Color   textcolor1 = textarea.getForeground();
				
				textcolorbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						Color color = cc.getColor();
						
						if (color != null)
						{
							if (!textarea.getForeground().equals(color))
							
							     setForeground(color);
							
							else setForeground(textcolor1);
						}
					}
				});
				
				
				screencolorbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						Color color = cc.getColor();
						
						if (color != null)
						{
							if (!textarea.getBackground().equals(color))
							
							     setBackground(color);
							
							else setBackground(screencolor1);
						}
					}
				});
				
				
				swapcolorsbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						Color background = textarea.getBackground();
						Color foreground = textarea.getForeground();
						
						setForeground(background);
						setBackground(foreground);
						
						    findlistener.setColor();
						gotolinelistener.setColor();
					}
				});
				
				int choice = JOptionPane.showOptionDialog(frame, cc, null,
				
				    JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
				
					null, options, options[0]);
				
				if (choice != JOptionPane.OK_OPTION) return;
				
				else {    }
				
				}  finally { textarea.requestFocusInWindow(); }
			}
			
			
			
			public void setForeground(Color color)
			{
				if (textareapanel == null) return;
				
				for (TextAreaPanel textareapanel : textareapanellist)
				{
					textareapanel.textarea.setForeground(color);
					textareapanel.textarea.setCaretColor(color);
				}
				
				    findlistener.setColor();
				 replacelistener.setColor();
				gotolinelistener.setColor();
				
				foreground = color;
				caretcolor = color;
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					Component comp = tabbedpane.getComponentAt(i);
					
					TextAreaPanel textareapanel = (TextAreaPanel) comp;
					
					if (textareapanel.encrypted)
					{
						if (!foreground.equals(Color.white))
						
						     tabbedpane.setForegroundAt(i, foreground);
						
						else tabbedpane.setForegroundAt(i,
						
						    textareapanel.textarea.getBackground());
					}
				}
			}
			
			
			public void setBackground(Color color)
			{
				if (textareapanel == null) return;
				
				for (TextAreaPanel textareapanel : textareapanellist)
				
				    textareapanel.textarea.setBackground(color);
				
				    findlistener.setColor();
				 replacelistener.setColor();
				gotolinelistener.setColor();
				
				background = color;
			}
		}
		
		
		
		
		private class LineWrapListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Change the line wrap to true or false
				
				JTextArea textarea = textareapanel.textarea;
				
				if (!textarea.getLineWrap())
				{
					textarea.setLineWrap(true);
					
					textareapanel.linewrap = true;
					
					linewrapmenuitem.setText(__.lineunwrapkey);
				}
				
				else if (textarea.getLineWrap())
				{
					textarea.setLineWrap(false);
					
					textareapanel.linewrap = false;
					
					linewrapmenuitem.setText(__.linewrapkey);
				}
				
				//  Restore the screen position
				
				int cp = textarea.getCaretPosition();
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				textarea. setCaretPosition(cp);
				textarea.moveCaretPosition(cp1);
				textarea. setCaretPosition(cp);
			}
			
			
			//  text line auto-wrapping feature
			//
			//  If a text file has a line with more than 160 characters,
			//  the autowrap feature will set the linewrap to true.
			
			private boolean autoWrap(String text)
			{
				int maxlinechars = 160;
				
				boolean linewrap = false;
				
				//  String[] strings = text.split("\n");
				//
				//  for (String str : strings)
				//
				//    if (str.length() > maxlinechars)
				//
				//	linewrap = true;
				
				
				char[] array = text.toCharArray();
				
				int j = 0;
				
				for (int i = 0; i < array.length; i++)
				{
					if (array[i] == '\n')
					{
						if ((i - j) > maxlinechars)
						
						    { linewrap = true;  break; }
						
						else j = i;
					}
				}
				
				if (j == 0) linewrap = true; // no \n char
				
				return linewrap;
			}
		}
		
		
		
		
		private class WordLineCountListener implements ActionListener
		{
		
			//  counts words or tokens, lines and newlines
			
			public void actionPerformed(ActionEvent e)
			{
				String text = textareapanel.textarea.getSelectedText();
				
				if ((text == null) || text.isEmpty())
				
				    text = textareapanel.textarea.getText();
				
				
				//  Count the words
				
				String[] tokens = text.split("[ \t\n]{1,}");
				
				int words = tokens.length;
				
				if (text.isEmpty()) words = 0;
				
				
				//  Count the lines
				
				int lines = text.replaceAll("[ \t]", "")
				
				    .split("[\n]{1,}").length;
				
				int newlines = 1;
				
				int length = text.length();
				
				for (int i = 0; i < length; i++)
				
				    if (text.charAt(i) == '\n')
				
					newlines ++;
				
				
				//  Count the bytes
				
				int chars = text.length();
				
				int newln = newlines;
				
				String  wordstr = Convert.partition(String.valueOf(words), ",", -3);
				String  charstr = Convert.partition(String.valueOf(chars), ",", -3);
				String  linestr = Convert.partition(String.valueOf(lines), ",", -3);
				String newlnstr = Convert.partition(String.valueOf(newln), ",", -3);
				
				String message = "";
				
				//  message += __.words + " = " + wordstr + "\n";
				//  message += __.chars + " = " + charstr + "\n";
				//  message += __.newlines + " = " + linestr + " / " + newlnstr;
				
				message += __.words + " = " + words + "\n";
				message += __.chars + " = " + chars + "\n";
				message += __.newlines + " = " + lines + " / " + newlines;
				
				
				//  Display the message
				
				Font font = textareapanel.textarea.getFont();
				
				JTextArea textarea = new JTextArea(message);
				
				textarea.setEditable(false);
				textarea.setFont(font);
				textarea.setBackground(
				    new JPanel().getBackground());
				
				int msgtype = JOptionPane.INFORMATION_MESSAGE;
				
				JOptionPane.showMessageDialog(frame, textarea, "", msgtype);
			}
		}
		
		
		
		private class ShowHideButtonsListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				showhidebuttons = !showhidebuttons;
				
				iconpanel.setVisible(showhidebuttons);
			}
		}
		
		
		
		private class TableEditorListener implements ActionListener
		{
			private TableFrame tableframe;
			
			public void actionPerformed(ActionEvent e)
			{
				if (tableframe == null)	init();
				
				if (tableframe.getPassphrase() == null)
				    tableframe.setPassphrase(SP);
				
				tableframe.setVisible(true);
				
				tableframe.toFront();
			}
			
			
			private void init()
			{
				//  creates a tableframe
				
				//  Only one frame is created when the
				//  actionPerformed method is called.
				
				tableframe = new TableFrame();
			}
		}
		
		
		
		private class ImageViewerListener implements ActionListener
		{
			private ImageFrame imageframe;
			
			public void actionPerformed(ActionEvent e)
			{
				if (imageframe == null) init();
				
				if (imageframe.getPassphrase() == null)
				    imageframe.setPassphrase(SP);
				
				imageframe.setVisible(true);
				
				imageframe.toFront();
			}
			
			
			private void init()
			{
				//  creates an imageframe
				
				//  Only one frame is created when the
				//  actionPerformed method is called.
				
				imageframe = new ImageFrame();
			}
		}
		
		
		
		
		private class HTMLEditorPaneListener implements ActionListener
		{
			private HTMLFrame htmlframe;
			
			public void actionPerformed(ActionEvent e)
			{
				if (htmlframe == null) init();
				
				if (htmlframe.getPassphrase() == null)
				    htmlframe.setPassphrase(SP);
				
				htmlframe.setVisible(true);
				
				htmlframe.toFront();
			}
			
			
			private void init()
			{
				//  creates an editor frame
				
				//  Only one frame is created when the
				//  actionPerformed method is called.
				
				htmlframe = new HTMLFrame();
			}
		}
		
		
		
		
		///////////////////////////////////////////////
		
		//  Define the cipher to be used for signatures
		//
		//  (The sign document menu item should have an
		//  option to select the signature algorithm)
		
	////	private final String cipher = Signature.lsd;
		
		//  (Latin square discrete log cipher, 120 digits)
		
		private final String cipher = Signature.lsdl;
		
		///////////////////////////////////////////////
		
		
		private class SignKeyListener implements ActionListener
		{
		
			//  This method opens a signature key passphrase
			//  dialog and displays a new signature key
			//
			//  The dialog will allow the user to select the type
			//  of signature key (if there is more than one signa-
			//  ture algorithm). It also computes the signature key
			//  and displays the signature key hash as the user
			//  types the passphrase.
			//
			//  Choose a signature key
			//   _______________________________________
			//  |  ___________________________________  |
			//  | |                                   | |
			//  | |                                   | |
			//  | |                                   | |
			//  | |___________________________________| |
			//  |                                       |
			//  |  0123 4567 89ab cdef                  |
			//  |                                       |
			//  |  xxxx xxxx xxxx xxxx xxxx xxxx - xxxx |
			//  |                 ____                  |
			//  |                |_OK_|                 |
			//  |_______________________________________|
			
			
			
			private int hashtype = 1;
			
			private int minlength = 16;
			
			private JLabel passphrasehashlabel;
			private JTextField passphrasefield;
			private JTextField hashfield;
			private JTextField signkeyfield;
			private JTextArea passphrasearea;
			private String passphrase;
			
			public void actionPerformed(ActionEvent e)
			{
				//  Create a JOptionPane dialog
				
				JPanel panel = getPanel();
				
				JOptionPane.showMessageDialog(frame,
				
				    panel, "", JOptionPane.PLAIN_MESSAGE);
				
				if ((passphrase != null) && (passphrase.length() >= 12))
				{
					byte[] signatureSK1 = Cipher
					
					    .passphraseToKey(passphrase);
					
					signatureSK = signatureSK1;
				}
			}
			
			
			private class MouseListener extends MouseAdapter
			{
				private JPopupMenu popupmenu;
				
				private JTextComponent comp;
				
				public MouseListener(JTextComponent comp)
				{
					this.comp = comp;
					
					popupmenu = new JPopupMenu();
					
					JMenuItem  copymenuitem = new JMenuItem(__.copy);
					JMenuItem pastemenuitem = new JMenuItem(__.paste);
					
					copymenuitem.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							comp.copy();
							
							if (comp.getSelectedText() == null)
							{
								comp.selectAll();
								comp.copy();
								comp.setCaretPosition(0);
							}
						}
					});
					
					pastemenuitem.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							comp .paste();
						}
					});
					
					popupmenu.add(copymenuitem);
					popupmenu.addSeparator();
					popupmenu.add(pastemenuitem);
				}
				
				public void mousePressed(MouseEvent e)
				{
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						popupmenu.show(comp, e.getX(), e.getY());
					}
				}
			}
			
			
			private JPanel getPanel()
			{
				final int length = 30;
				
				passphrasehashlabel = new JLabel("");
				
				passphrasefield = new JTextField(length);
				passphrasearea = new JTextArea(3, length);
				passphrasearea.setLineWrap(true);
				
				passphrasearea.setFont(font);
				passphrasearea.setForeground(foreground);
				passphrasearea.setCaretColor(foreground);
				passphrasearea.setBackground(background);
				
				hashfield = new JTextField(length);
				hashfield.setBorder(null);
				hashfield.setEditable(false);
				hashfield.setFont(font);
				hashfield.setForeground(Color.gray);
				hashfield.setBackground(
				    new JPanel().getBackground());
				
				signkeyfield = new JTextField(length);
				signkeyfield.setBorder(null);
				signkeyfield.setEditable(false);
				signkeyfield.setFont(font);
				signkeyfield.setForeground(foreground);
				signkeyfield.setCaretColor(foreground);
				signkeyfield.setBackground(background);
				
				JScrollPane scrollpane1 =
				
				  new JScrollPane(passphrasearea,
				
				      JScrollPane  .VERTICAL_SCROLLBAR_NEVER,
				      JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				
				MouseListener mouselistener1 = new MouseListener(passphrasearea);
				MouseListener mouselistener2 = new MouseListener(signkeyfield);
				
				KeyListener1 keylistener1 = new KeyListener1();
				
				passphrasearea.addMouseListener(mouselistener1);
				signkeyfield  .addMouseListener(mouselistener2);
				
				passphrasearea.addKeyListener(keylistener1);
				
				
				JPanel panel = new JPanel();
				
				Box vbox = Box.createVerticalBox();
				
				//  vbox.add(passphrasefield);
				
				vbox.add(scrollpane1);
				
				vbox.add(Box.createVerticalStrut(5)); vbox.add(hashfield);
				vbox.add(Box.createVerticalStrut(5)); vbox.add(signkeyfield);
				
				panel.add(vbox);
				
				return panel;
			}
			
			
			
			private class KeyListener1 extends KeyAdapter
			{
				private boolean control;
				
				public void keyPressed(KeyEvent e)
				{
					if (e.getKeyCode() == KeyEvent.VK_CONTROL)
					
					    control = true;
				}
				
				public void keyReleased(KeyEvent e)
				{
					if (e.getKeyCode() == KeyEvent.VK_CONTROL)
					
					    control = false;
					
					setPassphraseHash();
					
					setSignKey();
				}
			}
			
			
			private void setPassphraseHash()
			{
				String passphrase = passphrasefield.getText() + passphrasearea.getText();
				
				passphrase = passphrase.toLowerCase() .replaceAll("[ \t\n]", "");
				
				String passphrasehash = Cipher.hash2(passphrase) .substring(0, 16);
				
				passphrasehash = Convert.partition(passphrasehash, " ", 4);
				
				hashfield.setText(passphrasehash);
			}
			
			
			private void setSignKey()
			{
				//  Generate the signature key
				
				passphrase = passphrasefield.getText().trim()
				           + passphrasearea .getText().trim();
				
				passphrase = passphrase.toLowerCase() .replaceAll("[ \t\n]", "");
				
				if (passphrase.isBlank()) { signkeyfield.setText(""); return; }
				
				byte[] signatureSK = Cipher.passphraseToKey(passphrase);
				
				Signature signature = new Signature(signatureSK, cipher);
				
				String keyid = Signature.getKeyID(signature.getKey());
				
				keyid = Convert.partition(keyid, " ", 4);
				
				signkeyfield.setText(keyid);
				
				signkeyfield.setCaretPosition(0);
			}
		}
		
		
		
		
		private class SignDocumentListener implements ActionListener
		{
		
			//  The message is trimmed before hashing
			
			
			//  For example, if the text is indented, the text
			//  will be hashed starting from the first hyphen
			//  on the first line and ending at the last hyphen
			//  on the last line
			
			
			
			//  Signing source code
			//
			//  The user can sign the source code using the
			//  Encrypt -> Sign Document menu item, and then
			//  type /******** and ********/ above and below
			//  the signature block so the compiler will ig-
			//  nore the signature. Otherwise the source code
			//  won't compile.
			//
			//  /***************************************
			//
			//  7a514412b792d856e79d017f7f97d82fe57eae16
			//  0e6654447fc99b422879852198824d231e5dc1f8
			//  e8d3d6e5c886949b5d2547f272c66521dbd50bc8
			//  0123456789abcdef0123456789abcdef01234567
			//
			//  ***************************************/
			
			
			
			private int hashtype;
			
			private int minlength = 16;
			
			
			public SignDocumentListener(int hashtype)
			{
				this.hashtype = hashtype;
			}
			
			
			private class MouseListener extends MouseAdapter
			{
				private JPopupMenu popupmenu;
				
				private JTextComponent comp;
				
				public MouseListener(JTextComponent comp)
				{
					this.comp = comp;
					
					popupmenu = new JPopupMenu();
					
					JMenuItem menuitem = new JMenuItem(__.copy);
					
					menuitem.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							comp.copy();
						}
					});
					
					popupmenu.add(menuitem);
				}
				
				public void mousePressed(MouseEvent e)
				{
					if (e.getButton() != MouseEvent.BUTTON1)
					
					    popupmenu.show(comp, e.getX(), e.getY());
				}
			}
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				JTextArea textarea = textareapanel.textarea;
				
				if (textarea.getText().isBlank())
				{
					String errormessage = __.nothingtosign;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				String signmessage = "";
				
				if (hashtype == 1) signmessage = __.signdocumentwithkey;
				if (hashtype == 2) signmessage = __.signmessagewithkey;
				
				
				//  Confirm the signature key
				
				boolean choice = selectAndConfirmSignKey(signmessage);
				
				if (!choice) return;
				
				
				//  Generate the signature key and sign the message
				
				Signature signature = new Signature(signatureSK, cipher);
				
				String message = null;  String[] mrsy = null;
				
				if (textarea.getSelectedText() != null)
				{
					message = textarea.getSelectedText();
					
					mrsy = signature .signMessage(message.trim(), this.hashtype);
				}
				
				else // if selected text == null
				{
					message = textarea.getText();
					
					mrsy = signature .signMessage(message.trim(), this.hashtype);
					
					textarea.setCaretPosition(
					
					    textarea.getText().length());
				}
				
				
				if (textarea.getSelectedText() != null)
				
				    textarea.setCaretPosition(
				    textarea.getSelectionEnd());
				
				int digits = 40;
				
				
				//  Convert a jagged array (mrsy) to a
				//  non-jagged array that can be printed
				
				String[] signarray = Signature.mrsyToSignature(mrsy);
				
				if (signarray == null) throw new ArithmeticException();
				
				//  Convert the signature array to a signature block
				
				StringBuilder sb = new StringBuilder();
				
				for (String str : signarray)
				
				    sb.append(str + "\n");
				
				
				//  Count the number of tabs at the end of the document
				
				int tabs = 0;  String m = textarea.getText();
				
				while (m.charAt(m.length() -1 -tabs) == '\t') tabs++;
				
				
				//  Align the signature with the tabs
				
				for (int i = 0; i < tabs; i++)
				
				    for (int j = 0; j < sb.length(); j++)
				
					if (sb.charAt(j) == '\n')
					
					    sb.insert(j+1, "\t");
				
				
				String str = new String();
				
				//  three newlines
				
				if      (tabs == 0)  str = "\n\n";
				else if (tabs == 1)  str = "\n\t\n\t";
				else if (tabs == 2)  str = "\n\t\t\n\t\t";
				else if (tabs == 3)  str = "\n\t\t\t\n\t\t\t";
				else if (tabs == 4)  str = "\n\t\t\t\t\n\t\t\t\t";
				
				sb.insert(0, str);
				
				
				//  Append or subjoin the signature to the document
				
				int cp = textarea.getCaretPosition();
				
				textarea.insert(sb.toString(), cp);
			}
			
			
			
			private boolean selectAndConfirmSignKey(String title)
			{
			
				if (signatureSK == null)
				{
					//  Display the passphrase dialog
					
					PassphraseDialog pd = new PassphraseDialog(
					
					   frame, PassphraseDialog.passphrase_only);
					
					pd.setMinimumLength(minlength);
					
					pd.setFont1((font != null) ?
					
					    font : frame.getFont());
					
					pd.setForeground1(foreground);
					pd.setBackground1(background);
					
					String passphrase = pd.readPassphrase();
					
					if ((passphrase != null) && !passphrase.isEmpty())
					
					    signatureSK = Cipher.passphraseToKey(passphrase);
					
					else return false;
				}
				
				
				//  Confirm the key
				
				JTextArea textarea = new JTextArea();
				
				textarea.addMouseListener(
				        new MouseListener(textarea));
				
				
				while (true)
				{
					//  Show the confirm dialog using the sign key
					
					int digits = 16, radix = 16;
					
					Signature sig = new Signature(signatureSK, cipher);
					
					String keyid;
					
					keyid = sig.getKeyID();
					keyid = keyid.substring(0, 32);
					keyid = Convert.partition(keyid, " ", 4);
					
					int maxfontsize = 40;
					
					textarea.setText(keyid);
					textarea.setEditable(false);
					textarea.setFont((font.getSize() <= maxfontsize) ?
					     font : font.deriveFont((float) maxfontsize));
					textarea.setBackground(new JPanel().getBackground());
					
					
					//  Display the JOptionPane dialog
					
					int choice = JOptionPane.showConfirmDialog(
					
					    frame, textarea, title, JOptionPane.YES_NO_CANCEL_OPTION,
					
						JOptionPane.PLAIN_MESSAGE, null);
					
					if (choice == JOptionPane.YES_OPTION)
					{
						return true;
					}
					
					else if ((choice == JOptionPane.CANCEL_OPTION)
					      || (choice == JOptionPane.CLOSED_OPTION))
					{
						return false;
					}
					
					else if (choice == JOptionPane.NO_OPTION)
					{
						//  Create a passphrase dialog
						
						PassphraseDialog pd = new PassphraseDialog(
						
						   frame, PassphraseDialog.passphrase_only);
						
						pd.setMinimumLength(minlength);
						pd.setForeground1(foreground);
						pd.setBackground1(background);
						pd.setFont1((font != null) ?
						    font : frame.getFont());
						
						String passphrase = pd.readPassphrase();
						
						if ((passphrase == null) || passphrase.isEmpty())
						{
							return false;
						}
						
						else
						{	signatureSK = Cipher
							
							    .passphraseToKey(passphrase);
							
							continue;
						}
					}
				}
			}
		}
		
		
		
		
		private class VerifySignatureListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
			
				//  Read the selected text or document
				
				String document = null;
				
				JTextArea textarea = textareapanel.textarea;
				
				String selectedtext = textarea.getSelectedText();
				
				if ((selectedtext != null) && !selectedtext.isEmpty())
				
				     document = selectedtext;
				
				else document = textarea.getText();
				
				document = document.trim();
				
				
				if (document.isBlank())
				{
					String errormessage = __.nothingtoverify;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				
				if (document.endsWith("*/"))
				{
				
					//  The document is a signed source code program
					//  
					//  The comment lines hide the signature from the
					//  compiler. The signer appends the copyright notice,
					//  signs the document, and then appends the comment
					//  lines above and below the signature block. The
					//  verification ignores the two comment lines.
					//  
					//  
					//  /***************************************
					//  
					//  Copyright (c) 2020  Company name or sign key
					//  
					//  All rights reversed
					//  
					//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
					//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
					//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
					//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
					//  
					//  ***************************************/
					
					
					String[] lines = document.split("\n");
					
					int index1 = -1, index2 = -1;
					
					for (int i = lines.length -1; i >= 0; i--)
					{
						//  Find the last line ********/
						
						String line = lines[i].trim();
						
						if (!line.endsWith("*/")) continue;
						
						for (int j = line.length() -2; j >= 0; j--)
						
						    if (line.charAt(j) != '*') { i = -1; break; }
						
						index2 = i; break;
					}
					
					for (int i = index2 -1; i >= 0; i--)
					{
						//  Find the first line /*******
						
						String line = lines[i].trim();
						
						if (!line.startsWith("/*")) continue;
						
						for (int j = 1; j < line.length(); j++)
						
						    if (line.charAt(j) != '*') { i = -1; break; }
						
						index1 = i; break;
					}
					
					StringBuilder sb = new StringBuilder();
					
					for (int i = 0; i < lines.length; i++)
					
					    if ((i != index1) && (i != index2))
						
						 sb.append(lines[i] + "\n");
					
					document = sb.toString();
				}
				
				
				//  Detach the signature
				
				String[] text_sign = Signature
				
				    .detachSignature(document);
				
				String text = text_sign[0].trim();
				
				String signature = text_sign[1];
				
				if ((signature == null) || signature.isEmpty())
				{
					String errormessage = __.nosignature;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				if (!Signature.verifyFormat(signature) )
				{
					String errormessage = __.invalidsignature;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				if (!Signature.isSigned(document, 1)
				 && !Signature.isSigned(document, 2))
				{
					String errormessage = __.invalidhash;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				
				String str = "";
				
				String[] mrsy = Signature.parseSignature(signature);
				
				String keyid = Signature.getKeyID(mrsy[3]);
				
				
				//  Verify the signature by trying all the signature ciphers
				//
				//  boolean bool = false;
				//
				//  for (int i = 0; i < Signature.ciphers.length; i++)
				//
				//    if (verifySignature(mrsy, cipher))  bool = true;
				
				
				boolean result = Signature.verifySignature(mrsy, cipher);
				
				
				if (result == true)
				{
					String signkey32 = Convert.partition(
					
					    keyid.substring(0, 32), " ", 4 );
					
					//  xxxx xxxx xxxx xxxx xxxx xxxx - xxxx xxxx
					
					signkey32 = new StringBuilder(signkey32)
					
					    .replace(29, 30, " - ").toString();
					
					JLabel label1 = new JLabel();
					JLabel label2 = new JLabel();
					
					label1.setText(__.thisdocumentwassignedby + " ");
					label2.setText(signkey32);
					
					int maxfontsize = 40;
					
					Font font1 = ((font.getSize() <= maxfontsize) ?
					  font : font.deriveFont((float) maxfontsize));
					
					label1.setFont(font1);
					label2.setFont(font1);
					
					Box vbox = Box.createVerticalBox();
					
					vbox .add(label1);
					vbox .add(Box.createVerticalStrut(5));
					vbox .add(label2);
					
					JOptionPane.showMessageDialog(frame, vbox,
					
					    "", JOptionPane.INFORMATION_MESSAGE);
				}
				
				
				else // if (result == false)
				{
					//  System.out.println(__.signatureisfalse);
					
					JOptionPane.showMessageDialog(frame,
					
					    __.signatureisfalse, "",
					
						JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				
				//  Search a key hash file (this feature is not yet implemented)
				//
				//  If the user has previously entered a name or comment for this
				//  signature key, display the name and/or comment.
				//
				//  If the signature key hash has previously been verified by the user,
				//  the method could inform the user if the signature key is on a list
				//  of verified keys by displaying an icon such as a check mark or a
				//  question mark in the dialog box.
				//
				//  Note that it is the user's responsibility to verify signature keys.
				//  The program can only store the keys and alert the user if a public
				//  key or key hash has changed.
			}
		}
		
		
		
		
		private class EncryptMessageListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				//  Convert the plaintext to ciphertext
				
				JTextArea textarea = textareapanel.textarea;
				
				String plaintext = textarea.getText();
				
				String ciphertext = encrypt(frame, plaintext);
				
				//  Display the ciphertext and prepended keys
				
				if (ciphertext != null)
				{
					textarea.setText(ciphertext);
					textarea.setCaretPosition(0);
				}
			}
			
			
			
			private String encrypt(Component parent, String message)
			{
			
				JList<String> list;
				
				DefaultListModel<String> emailmodel;
				
				//  DefaultListModel<String> publickeymodel;
				
				int visiblerowcount = 6;
				
				
				String plaintext = new String(message);
				
				if (plaintext.isEmpty())
				{
					String errormessage = __.nothingtoencrypt;
					
					JOptionPane.showMessageDialog(parent,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				if (PublicKey.isEncrypted(plaintext))
				{
					String errormessage = __.messageisalreadyencrypted;
					
					JOptionPane.showMessageDialog(parent,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				
				if (publickeyring.size() == 0)
				{
					//  A public key is required to encrypt a message
					
					JTextArea textarea = new JTextArea(1, 24);
					
					textarea.setBorder(null);
					textarea.setEditable(false);
					textarea.setText(__.publickeyerror);
					textarea.setFont(labelfont);
					textarea.setBackground(
					    new JPanel().getBackground());
					
					JOptionPane.showMessageDialog(parent, textarea,
					
					    "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				
				else
				{	emailmodel = new DefaultListModel<String>();
					
					for (int i = 0; i < publickeyring.size(); i++)
					{
						String name = publickeyring.get(i)[0];
						
						if (name != null)
						{
							if (name.length() > 32)
							
							    name = name .substring(0, 32);
							
							emailmodel.addElement(name);
						}
					}
					
					list = new JList<String>(emailmodel);
					
					JScrollPane scrollpane = new JScrollPane(list);
					
					list.setVisibleRowCount(visiblerowcount);
					
					
					JButton deletebutton = new JButton(__.del);
					
					Box hbox = Box.createHorizontalBox();
					
					hbox.add(scrollpane);
					hbox.add(deletebutton);
					
					deletebutton.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							int choice = list.getSelectedIndex();
							
							if (choice == -1) return;
							
							emailmodel.remove(choice);
							
							publickeyring.remove(choice);
							
							//  Clear the clipboard or else the key will not
							//  delete from the list because the focus listener
							//  will keep finding the key on the clipboard
							//  every time the focus is changed
							
							cb.setContents(new StringSelection(""), null);
						}
					});
					
					
					Box vbox = Box.createVerticalBox();
					
					vbox.add(hbox);
					
					
					list         .setFont(font);
					scrollpane   .setFont(font);
					deletebutton .setFont(font);
					
					deletebutton .setToolTipText(__.shiftarrow);
					
					
					JPanel panel1 = new JPanel();
					
					panel1.add(hbox);
					
					String title = __.selectanaddress;
					
					int result = JOptionPane.showOptionDialog(frame,
					
					    panel1, title, 0, JOptionPane.PLAIN_MESSAGE,
					
						null, new Object[] { __.OK }, null);
					
					if (result == JOptionPane.CLOSED_OPTION)
					
						return null;
					
					
					int choice = list.getSelectedIndex();
					
					if (choice == -1)  return null;
					
					
					String publickey = publickeyring.get(choice)[1];
					
					if (publickey == null)  return null;
					
					
					//  Encrypt the message
					
					String ciphertext;
					
					try
					{	ciphertext = PublicKey.encrypt(
						
						    plaintext, publickey);
					}
					
					catch (Exception ex)
					{
						System.out.println(ex);
						
						System.out.println("public key is defective");
						
						return null;
					}
					
					return ciphertext;
				}
			}
		}
		
		
		
		
		
		private class DecryptMessageListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				//  Read the text from the text area
				
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getText().trim();
				
				if (text.isEmpty() || !PublicKey.isEncrypted(text))
				{
					JOptionPane.showMessageDialog(frame,
					
					    __.nothingtodecrypt, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				
				//  Remove any partitioning from the trimmed text
				
				if (!text.trim().contains("\n\n"))
				
				    text = text.replaceAll("[\t\n]", "");
				
				
				//  Convert the ciphertext to plaintext
				
				String ciphertext = text;
				
				String plaintext = decrypt(ciphertext);
				
				
				//  Display the plaintext
				
				if (plaintext != null)
				{
					textarea.setText(plaintext);
					
					textarea.setCaretPosition(0);
				}
			}
			
			
			
			private String decrypt(String ciphertext)
			{
			
				String plaintext;
				
				if ((SP != null) && !SP.isEmpty())
				{
					byte[] SK = Cipher.passphraseToKey(SP);
					
					plaintext = PublicKey.decrypt(ciphertext, SK);
					
					if ((plaintext != null) && !plaintext.isEmpty())
					
					    return plaintext;
				}
				
				
				String title = __.enteryoursecretpassphrase;
				
				String passphraselabeltext = __.secretpassphrase;
				
				String emaillabeltext = __.emailaddress;
				
				
				PassphraseDialog pd = new PassphraseDialog(frame,
				
				    PassphraseDialog.passphrase_email_decrypt)
				
					.setPassphrase0(SP0)
					
				          .setForeground1(foreground)
				          .setBackground1(background)
					
					     .setFont1(font)
					
					         .showKeyboard(showkeyboard);
				
				
				while (true)
				{
					//  Read passphrase and email
					
					String email = "";
					
					String[] input = pd.readDialogInput();
					
					if (input == null)  return null;
					
					String passphrase0 = input[0].trim();
					String passphrase1 = input[1].trim();
					
					String passphrase = passphrase0 + passphrase1;
					
					if ((input[2] != null) && !input[2].isBlank())
					
					    email = input[2].trim();
					
					
					//  Try decrypting with and without the email address
					
					SK = Cipher.passphraseToKey(passphrase + email);
					
					plaintext = PublicKey.decrypt(ciphertext, SK);
					
					if (plaintext == null)
					{
						JOptionPane.showMessageDialog(frame,
						
						    __.nothingtodecrypt, "",
						
							JOptionPane.ERROR_MESSAGE);
						
						return null;
					}
					
					if (plaintext.isEmpty())
					{
						//  The user may have typed the email onto the public key
						//  instead of using the email field on the passphrase dia-
						//  log box to display the email address on the public key.
						
						//  Try the passphrase without the address to decrypt
						
						SK = Cipher.passphraseToKey(passphrase);
						
						plaintext = PublicKey.decrypt(ciphertext, SK);
					}
					
					else if (!plaintext.isEmpty())
					{
						SK = Cipher.passphraseToKey(passphrase);
						
						break;
					}
				}
				
				return plaintext;
			}
		}
		
		
		
		
		private class EncryptDirectoryListener implements ActionListener
		{
			EncryptDirectory ed = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel != null)
				{
					JTextArea textarea = textareapanel.textarea;
					
					ed.setFont      (textarea.getFont());
					ed.setForeground(textarea.getForeground());
					ed.setBackground(textarea.getBackground());
				}
				
				ed.setFileKey(filekey);
				
				ed.encryptDecryptDirectory();
				
				//  Update the file key
				
				if (ed.getFileKey() != null)
				
				    filekey = ed.getFileKey();
			}
		}
		
		
		
		
		private class DecryptDirectoryListener implements ActionListener
		{
			EncryptDirectory dd = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (textareapanel != null)
				{
					JTextArea textarea = textareapanel.textarea;
					
					dd.setFont      (textarea.getFont());
					dd.setForeground(textarea.getForeground());
					dd.setBackground(textarea.getBackground());
				}
				
				//  Set the dialog file key, decrypt the directory,
				//  and update the file key if the key changes
				
				dd.setFileKey(filekey);
				
				dd.encryptDecryptDirectory();
				
				if (dd.getFileKey() != null)
				
				    filekey = dd.getFileKey();
			}
		}
		
		
		
		
		private class EncryptFileListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Choose a file key
				
				FileEncryptor fe = new FileEncryptor(frame);
				
				if (textareapanel != null)
				{
					JTextArea textarea = textareapanel.textarea;
					
					fe.setFont      (textarea.getFont());
					fe.setForeground(textarea.getForeground());
					fe.setBackground(textarea.getBackground());
				}
				
				else fe.setFont(defaultfont);
				
				
				if (filekey != null) fe.setFileKey(filekey);
				
				else if ((SP != null) && !SP.isEmpty())
				
				    fe.setFileKey(Cipher.passphraseToKey(SP));
				
				
				while (true)
				{
					//  Choose a file
					
					File file = fe.chooseFile(directory);
					
					if (file == null) return;
					
					directory = file.getParent();
					
					
					if (Cipher.isEncrypted(file))
					{
						System.out.println(
						
						    __.fileisalreadyencrypted);
						
						continue;
					}
					
					
					//  Encrypt the file
					
					boolean bool = fe.encrypt(file);
					
					if (bool == false) return;
					
					
					//  Update the file key
					
					filekey = fe.getFileKey();
					
					
					//  if file name is a tab, set encrypted = true
					
					for (TextAreaPanel textareapanel : textareapanellist)
					
					    if ((textareapanel != null) && (textareapanel.file != null)
					
						&& textareapanel.file.getName().equals(file.getName()))
					
						    textareapanel.encrypted = true;
					
					//  if (file name == a current open file)
					//
					//  set the tab color to the unencrypted color
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						String title = tabbedpane.getTitleAt(i);
						
						//  System.out.println("title == " + title);
						
						if (file.getName().contains(title.trim()))
						{
							int index = tabbedpane.indexOfTab(title);
							
							Color foreground = textareapanel.textarea.getForeground();
							Color background = textareapanel.textarea.getBackground();
							
							tabbedpane.setForegroundAt(index, foreground);
							tabbedpane.setBackgroundAt(index, background);
						}
					}
				}
			}
		}
		
		
		
		
		private class DecryptFileListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				while (true)
				{
					//  Choose a file
					
					FileDecryptor fd = new FileDecryptor(frame);
					
					if (textareapanel != null)
					{
						JTextArea textarea = textareapanel.textarea;
						
						fd.setFont      (textarea.getFont());
						fd.setForeground(textarea.getForeground());
						fd.setBackground(textarea.getBackground());
					}
					
					else fd.setFont(defaultfont);
					
					
					if (filekey != null) fd.setFileKey(filekey);
					
					else if ((SP != null) && !SP.isEmpty())
					
					    fd.setFileKey(Cipher.passphraseToKey(SP));
					
					File file = fd.chooseFile(directory);
					
					if (file == null) return;
					
					directory = file.getParent();
					
					if (!Cipher.isEncrypted(file))
					{
						System.out.println(
						
						    __.fileisnotencrypted);
						
						continue;
					}
					
					//  Decrypt the file
					
					boolean bool = fd.decrypt(file);
					
					if (bool == false) return;
					
					
					//  Update the file key
					
					filekey = fd.getFileKey();
					
					
					//  if file name is a tab, set encrypted = false
					
					for (TextAreaPanel textareapanel : textareapanellist)
					
					    if ((textareapanel != null) && (textareapanel.file != null)
					
						&& textareapanel.file.getName().equals(file.getName()))
						
						    textareapanel.encrypted = false;
					
					//  If file name is a tab, set the tab
					//  color to the unencrypted color
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						String title = tabbedpane.getTitleAt(i);
						
						//  System.out.println("title == " + title);
						
						if (file.getName().contains(title.trim()))
						{
							int index = tabbedpane.indexOfTab(title);
							
							tabbedpane.setForegroundAt(index,
							
							    tabbedpane.getForeground());
							
							tabbedpane.setBackgroundAt(index,
							
							    tabbedpane.getBackground());
						}
					}
				}
			}
		}
		
		
		
		
		
		private class PrivateKeyListener implements ActionListener
		{
		
			//   _________________________________________
			//  |  Private key encryption + base 64 enc   |
			//  |  ____________________________  ____  _  |
			//  | |_Passphrase_________________||_76_||x| |
			//  |                                         |
			//  |  0123 4567 89ab cdef                    |
			//  |          _________   _________          |
			//  |         |_Encrypt_| |_Decrypt_|         |
			//  |_________________________________________|
			
			
			//  The private key class encrypts the text area without format-
			//  ting the data or prepending the hash of the plaintext.
			//
			//  The user can get cipherdata or ciphertext by encoding or de-
			//  coding the data in base 64 using the check box. (The cipher-
			//  text is partitioned using newline chars.)
			//
			//  The encrypt button will only encrypt once, but the user can
			//  keep re-encrypting the cipherdata (not ciphertext) by reopen-
			//  ing the menu item. Unlike the encrypt button, the decrypt but-
			//  ton will keep decrypting the cipher each time the button is
			//  pressed until the data is no longer decryptable or the decrypt-
			//  ed padding is not valid or contains random data instead of se-
			//  quential or repeating bytes. (Note that repeating bytes are
			//  also sequential bytes in which the increment equals 0 instead
			//  of 1, 2, 3, ...)
			//
			//  If the user saves the encrypted data to disk without encrypting
			//  the file and attaches the file to an email, the program will
			//  not prompt the user to enter a passphrase to decrypt the data
			//  because the encrypted data is not formatted.
			
			
			
			private int maxfontsize = 24;
			
			private JTextField passphrasefield;
			private JTextField sizefield;
			private JTextField hashfield;
			
			private JTextArea passphrasearea;
			
			private JButton encryptbutton;
			private JButton decryptbutton;
			
			private JCheckBox base64box;
			
			private boolean encrypted;
			
			private String passphrase = "";
			
			public void actionPerformed(ActionEvent e)
			{
				encrypted = false;
				
				String text = textareapanel.textarea.getText();
				
				if (text.isBlank())
				{
					String errormessage = __.nothingtoencrypt;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				textareapanel.textarea.requestFocusInWindow();
				
				float fontsize = font.getSize();
				
				if (fontsize > maxfontsize) fontsize = maxfontsize;
				
				Font font1 = font.deriveFont(fontsize);
				
				encryptbutton = new JButton(__.encrypt);
				decryptbutton = new JButton(__.decrypt);
				
				passphrasefield = new JTextField(24);
				passphrasearea = new JTextArea();
				
				sizefield = new JTextField(3);
				hashfield = new JTextField(16);
				
				sizefield.setText(String.valueOf(80));
				sizefield.setToolTipText(__.charsperline);
				
				base64box = new JCheckBox();
				base64box.setSelected(false);
				base64box.setToolTipText(__.viewcipherdata);
				
				
				ButtonListener buttonlistener = new ButtonListener();
				MouseListener mouselistener = new MouseListener();
				KeyListener keylistener1 = new KeyListener();
				
				encryptbutton.addActionListener(buttonlistener);
				decryptbutton.addActionListener(buttonlistener);
				
				
				hashfield.setBorder(null);
				hashfield.setEditable(false);
				hashfield.setForeground(Color.gray);
				hashfield.setBackground(
				    new JPanel().getBackground());
				
				passphrasefield.setFont(font1);
				sizefield.setFont(font1);
				hashfield.setFont(font1);
				
				encryptbutton.setFont(font1);
				decryptbutton.setFont(font1);
				
				passphrasefield.setForeground(foreground);
				passphrasefield.setCaretColor(foreground);
				passphrasefield.setBackground(background);
				
				sizefield.setForeground(foreground);
				sizefield.setCaretColor(foreground);
				sizefield.setBackground(background);
				
				passphrasefield.addKeyListener(keylistener1);
				sizefield.addKeyListener(keylistener1);
				
				sizefield.addMouseListener(mouselistener);
				base64box.addMouseListener(mouselistener);
				
				passphrasefield.addFocusListener(new FocusAdapter()
				{
					public void focusGained(FocusEvent e)
					{
						if (encrypted) decryptbutton.doClick();
					}
				});
				
				
				//  Create a horizontal box for the fields
				
				Box hbox1 = Box.createHorizontalBox();
				
				hbox1.add(passphrasefield);
				hbox1.add(sizefield);
				hbox1.add(base64box);
				
				
				//  Create a horizontal box for the buttons
				
				Box hbox2 = Box.createHorizontalBox();
				
				hbox2.add(encryptbutton);
				hbox2.add(decryptbutton);
				
				
				//  Create a vertical box for the fields and buttons
				
				Box vbox = Box.createVerticalBox();
				
				vbox.add(hbox1);
				vbox.add(Box.createVerticalStrut(10));
				vbox.add(hashfield);
				
				vbox.add(Box.createVerticalStrut(10));
				vbox.add(hbox2);
				
				passphrasefield.setText(passphrase);
				
				
				//  Show the dialog
				
				String title = __.privatekeyencryption;
				
				JOptionPane.showOptionDialog(frame, null,
				
				    title, 0, JOptionPane.PLAIN_MESSAGE, null,
				
					new Object[] { vbox }, null);
			}
			
			
			private class ButtonListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if (e.getSource() == encryptbutton) encrypt();
					if (e.getSource() == decryptbutton) decrypt();
				}
			}
			
			
			private class MouseListener extends MouseAdapter
			{
				//  clicking the base-64 checkbox
				//
				//  converts ciphertext to cipherdata
				//        or cipherdata to ciphertext
				
				public void mousePressed(MouseEvent e)
				{
					if (e.getSource() == base64box)
					{
						String text = textareapanel.textarea
						
						    .getText().trim().replaceAll("\n", "");
						
						if (encrypted && Number.isBase64(text))
						{
							decodeBase64();
							
							base64box.setToolTipText(
							    __.viewciphertext);
						}
						
						else if (encrypted && !Number.isBase64(text))
						{
							encodeBase64();
							
							base64box.setToolTipText(
							    __.viewcipherdata);
						}
					}
				}
				
				public void mouseReleased(MouseEvent e)
				{
					if (e.getSource() == base64box)
					{
						if (base64box.isSelected())
						    base64box.setSelected(false);
					}
				}
				
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() == sizefield)
					
					    sizefield.setText("");
				}
			}
			
			
			
			private void encrypt()
			{
				if (encrypted) return;
				
				String passphrase = passphrasefield
				
				    .getText() + passphrasearea.getText();
				
				JTextArea textarea = textareapanel.textarea;
				
				String         text = textarea.getText();
				String selectedtext = textarea.getSelectedText();
				
				//  If there is selected text then use the selected text
				
				if (selectedtext != null) text = selectedtext;
				
				String plaintext = text;
				
				
				//  If the text is already partitioned in base 64 then return
				
				if ( Number.isBase64( plaintext.trim()
				
				    .replaceAll("\n", "") .replaceAll("\t", "") )
				
					&& !plaintext.trim().contains("\n\n") )
				{
					String[] tokens = plaintext.trim().split("\n");
					
					if (tokens.length < 3) return;
					
					for (int i = 1; i < tokens.length -1; i++)
					
					    if (tokens[i].length() == tokens[i-1].length())
					
						return;
				}
				
				
				if ((passphrase == null) || passphrase.isBlank()) return;
				
				byte[] privatekey = Cipher.passphraseToKey(passphrase);
				
				if (privatekey == null) return;
				
				byte[] randbytes = Cipher.hash(privatekey);
				
				//  Encrypt the plaindata
				
				byte[] plaindata = plaintext.getBytes();
				
				byte[] cipherdata = Cipher.encrypt(plaindata,
				
				    privatekey, Cipher.encrypt_method_3, randbytes);
				
				countFrequencies(cipherdata);
				
				String text1 = Convert
				
				    .byteArrayToBase64(cipherdata);
				
				text = partition(text1);
				
				//  If the ciphertext is un-partitioned
				//  and the size is > maxlen, return
				//  without diplaying the ciphertext
				
				int maxlen = 256 * 1024; // 256 K bytes
				
				if ((text.length() > maxlen)
				 && !text.contains("\n")) return;
				
				//  Display the ciphertext
				
				if (selectedtext == null)
				
				     textarea.setText(text);
				
				else textarea.replaceSelection(text);
				
				textarea.setLineWrap(true);
				
				encrypted = true;
			}
			
			
			private void decrypt()
			{
				String passphrase = passphrasefield.getText()
				
				    + passphrasearea.getText();
				
				JTextArea textarea = textareapanel.textarea;
				
				String         text = textarea.getText();
				String selectedtext = textarea.getSelectedText();
				
				//  If there is selected text then use the selected text
				
				if (selectedtext != null) text = selectedtext;
				
				String ciphertext = unpartition(text);
				
				byte[] cipherdata;
				
				if (Number.isBase64(ciphertext))
				
				     cipherdata = Convert.base64ToByteArray(ciphertext);
				else cipherdata = Convert.base64ToByteArray(
				
				    Convert.stringToBase64(ciphertext));
				
				byte[] privatekey = Cipher.passphraseToKey(passphrase);
				
				if (privatekey == null) return;
				
				byte[] plaindata;
				
				try { plaindata = Cipher.decrypt(cipherdata, privatekey); }
				
				catch (Exception ex) { return; }
				
				if (plaindata == null) { return; }
				
				String plaintext = new String(plaindata);
				
				if (selectedtext == null)
				
				     textarea.setText(plaintext);
				
				else textarea.replaceSelection(plaintext);
				
				if (encrypted) encrypted = false;
			}
			
			
			private String partition(String text)
			{
				int linewidth = 0;
				
				String sizestr = sizefield.getText().trim();
				
				if (!sizestr.isEmpty())
				
				    linewidth = Integer.valueOf(sizestr);
				
				String text1 = text;
				
				if (linewidth > 0) text1 = Convert
				
				    .partition(text, "\n", linewidth);
				
				return text1;
			}
			
			
			private String unpartition(String text)
			{
				if (!Number.isBase64(text.trim()
				
				    .replaceAll("\n", ""))) return text;
				
				String text1 = text .replaceAll(" ", "")
				
				    .replaceAll("\n", "") .replaceAll("\t", "");
				
				return text1;
			}
			
			
			private void encodeBase64()
			{
				//  converts cipherdata to ciphertext
				
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getText();
				
				if (Number.isBase64(text)) return;
				
				String text1 = Convert.stringToBase64(text);
				
				//  Partition the base-64 string
				
				String sizestr = sizefield.getText();
				
				int linewidth = Integer.valueOf(sizestr);
				
				if (linewidth > 0) text1 = Convert
				
				    .partition(text1, "\n", linewidth);
				
				textarea.setText(text1);
				
				return;
			}
			
			
			private void decodeBase64()
			{
				//  converts ciphertext to cipherdata
				
				JTextArea textarea = textareapanel.textarea;
				
				String text = textarea.getText()
				
				    .trim() .replaceAll("\n", "");
				
				String text1;
				
				if (Number.isBase64(text))
				{
					text1 = Convert.base64ToString(text);
					
					if (!text.equals(Convert.stringToBase64(text1)))
					
					    System.out.println("error");
				}
				
				else return;
				
				textarea.setText(text1);
				
				return;
			}
			
			
			private void countFrequencies(byte[] bytes)
			{
				//  tests the randomness of the cipherdata
				//  by counting the frequencies of the bytes
				//  0, 1, 2, 3, ..., 253, 254, 255
				
				int[] counters = new int[256];
				
				for (byte b : bytes)
				{
					int j = b + 128;
					
					counters[j] += 1;
				}
				
				//  System.out.println("frequencies of bytes 0 to 255");
				//  System.out.println(Arrays.toString(counters));
			}
			
			
			private class KeyListener extends KeyAdapter
			{
				private boolean control;
				
				public void keyTyped(KeyEvent e)
				{
					if (e.getSource() == sizefield)
					{
						if ((sizefield.getText().length() >= 3)
						
						    || !Character.isDigit(e.getKeyChar()))
						
							e.consume();
					}
				}
				
				public void keyPressed(KeyEvent e)
				{
					if (e.getSource() == passphrasefield)
					{
						if (e.getKeyChar() == '\n')
						
						    passphrasefield.transferFocus();
					}
					
					if (e.getSource() == passphrasearea)
					{
					
					}
					
					if (e.getKeyCode() == KeyEvent.VK_CONTROL)
					
					    control = true;
				}
				
				
				public void keyReleased(KeyEvent e)
				{
					if (e.getKeyCode() == KeyEvent.VK_CONTROL)
					
					    control = false;
					
					setPassphraseHash();
				}
			}
			
			
			private void setPassphraseHash()
			{
				passphrase = passphrasefield.getText()
				
				    + passphrasearea.getText();
				
				passphrase = passphrase.toLowerCase();
				
				String passphrasehash = Cipher
				
				    .hash2(passphrase) .substring(0, 16);
				
				passphrasehash = Convert
				
				    .partition(passphrasehash, " ", 4);
				
				hashfield.setText(passphrasehash);
			}
		}
		
		
		//  End class PrivateKeyListener
		
		
		
		
		
		
		
		private class PublicKeyListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				//  This method opens the public key passphrase
				//  dialog and prints a new public key
				
				JTextArea textarea = textareapanel.textarea;
				
				String SP1 = "";
				
				if ((SP != null) && (SP0 != null))
				
				    SP.substring(SP0.length());
				
				PublicKeyDialog pkd = new PublicKeyDialog(frame);
				
				pkd.setFont(textarea.getFont());
				pkd.setForeground(textarea.getForeground());
				pkd.setBackground(textarea.getBackground());
				pkd.setPassphrase0(SP0);
				pkd.setPassphrase1(SP1);
				
				String[] array = pkd.generatePublicKey();
				
				if (array == null) return;
				
				String passphrase0  = array[0];
				String passphrase1  = array[1];
				String publickeystr = array[2];
				
				if (publickeystr == null) return;
				
				SP0 = passphrase0;
				
				SP = passphrase0 + passphrase1;
				
				//  Create a new tab to display the public key or use the
				//  Documents class to create a window to display the key
				
				newlistener.run();
				
				textarea = textareapanel.textarea;
				
				//  Insert the public key in the text area
				
				int cp = textarea.getCaretPosition();
				
				textarea.insert(publickeystr, cp);
			}
		}
		
		
		
		
		
		private class AboutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String title = __.about;
				String copyright = "Copyright (c) 2020";
				String authors = "The Java Editor authors";
				
				String message = program + "  ";
				message += __.version + " " + version + "\n";
				message += copyright + " " + authors;
				
				JTextArea textarea = new JTextArea(message);
				
				textarea.setEditable(false);
				textarea.setFont(labelfont);
				textarea.setBackground(
				    new JPanel().getBackground());
				
				Object[] options = { __.license };
				
				int choice = JOptionPane.showOptionDialog(frame,
				
				    textarea, title, JOptionPane.DEFAULT_OPTION,
				
					JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION))
				
					return;
				
				else new LicenseListener().run();
			}
		}
		
		
		
		
		private class LicenseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				String title = __.softwarelicense;
				
				String document = Documents.gpl;
				
				Documents .display(frame, title,
				
				    document, font, foreground, background);
			}
		}
		
		
		
		
		private class WindowListener1 extends WindowAdapter
		{
		
			public void windowClosing(WindowEvent e)
			{
				exitmenuitem.doClick();
			}
			
			public void windowOpened(WindowEvent e)
			{
				readSettings();
				
				colorbuttonlistener.init();
				
				//  ...
			}
		}
		
		
		
		
		private class ColorButtonListener
		{
		
			//  The ColorButtonListener could be replaced by a Color
			//  Palette Listener that uses a Popup and a color palette
			//  that has 4 x 8 or 5 x 8 colors but there could be an
			//  option to use buttons to change the colors.
			//
			//  There should also be an option to enable the user
			//  to hide the checkbox and color buttons from the
			//  ColorListener class or Text/Screen Color menu item.
			//
			//  Clicking on the checkbox makes the buttons disappear
			//  but the checkbox | doesn't disappear.
			
			
			private void init()
			{
			
				Colors colors = new Colors();
				
				JLabel colorlabel = new JLabel();
				JLabel closelabel = new JLabel();
				
				colorlabel.setVisible(true);
				
				closelabel.setVisible(false);
				
				JCheckBox checkbox = new JCheckBox();
				
				checkbox .setEnabled(false);
				checkbox .setForeground(
				   new JPanel().getBackground() );
				
				checkbox .add(closelabel);
				
				checkbox .setToolTipText(__.click);
				
				JButton colorbutton1 = new JButton();
				JButton colorbutton2 = new JButton();
				
				colorbutton1 .setVisible(false);
				colorbutton2 .setVisible(false);
				
				colorbutton1 .setForeground(
				 new JPanel().getBackground());
				
				colorbutton2 .setForeground(
				 new JPanel().getBackground());
				
				colorbutton1.addKeyListener(keylistener1);
				colorbutton2.addKeyListener(keylistener1);
				
				
				//  Set the color buttons to the current foreground or background
				
				if ((foreground != null) && !foreground.equals(Color.white))
				{
					for (int i = 0; i < Colors.rgb.length; i++)
					
					    if (foreground .equals(new Color(Colors.rgb[i])))
					
						{ colors.index = i; break; }
				}
				
				else if ((background != null) && !background.equals(Color.white))
				{
					for (int i = 0; i < Colors.rgb.length; i++)
					
					    if (background .equals(new Color(Colors.rgb[i])))
					
						{ colors.index = i; break; }
				}
				
				menubar.add(checkbox);
				menubar.add(colorbutton1);
				menubar.add(colorbutton2);
				menubar.add(colorlabel);
				
				MouseListener mouselistener = new MouseListener()
				{
					public void mouseEntered(MouseEvent e)
					{
						colorbutton1.setVisible(true);
						colorbutton2.setVisible(true);
						colorlabel  .setVisible(true);
						
						if (colorbutton1.isVisible()
						 || colorbutton2.isVisible())
						{
							if (colors.index >= 0)
							{
								String message = Colors.colors[colors.index];
								
								colorlabel.setText(message);
							}
						}
					}
					
					public void mouseExited(MouseEvent e)
					{
						colorlabel.setText("");
					}
					
					public void mouseClicked( MouseEvent e) {  }
					public void mouseReleased(MouseEvent e) {  }
					
					public void mousePressed(MouseEvent e)
					{
						if (e.getSource() == checkbox)
						{
							colorbutton1.setVisible(!colorbutton1.isVisible());
							colorbutton2.setVisible(!colorbutton2.isVisible());
							colorlabel  .setVisible(!colorlabel.isVisible());
							
							if (colorbutton1.isVisible()
							 || colorbutton2.isVisible())
							{
								if (colors.index >= 0)
								{
									String message =
									
									    Colors.colors[colors.index];
									
									colorlabel.setText(message);
								}
							}
						}
						
						if (e.getSource() == colorbutton1)
						{
							colors.index--;
							
							if (colors.index < 0) colors.index
							
							    = Colors.rgb.length -1;
						}
						
						if (e.getSource() == colorbutton2)
						{
							colors.index++;
							
							if (colors.index >= Colors.rgb.length)
							
							    colors.index = 0;
						}
						
						if ((e.getSource() == colorbutton1)
						 || (e.getSource() == colorbutton2))
						{
							Color color = new Color(Colors.rgb[colors.index]);
							
							if (!keylistener1.control)
							{
								colorlistener.setForeground(color);
								colorlistener.setBackground(Color.white);
							}
							
							else // if (keylistener1.control)
							{
								colorlistener.setBackground(color);
								colorlistener.setForeground(Color.white);
							}
							
							String message = Colors.colors[colors.index];
							
							colorlabel.setText(message);
						}
					}
				};
				
				checkbox     .addMouseListener(mouselistener);
				colorlabel   .addMouseListener(mouselistener);
				colorbutton1 .addMouseListener(mouselistener);
				colorbutton2 .addMouseListener(mouselistener);
			}
		}
		
		
		
		
		
		
		
		private void readSettings()
		{
		
			//  From System.java   System properties.
			//
			//  The following properties are guaranteed to be defined:
			//
			//  java.version        Java version number
			//  java.vendor         Java vendor specific string
			//  java.vendor.url     Java vendor URL
			//
			//  java.home           Java installation directory
			//  java.class.version  Java class version number
			//  java.class.path     Java classpath
			//
			//  os.name             Operating System Name
			//  os.arch             Operating System Architecture
			//  os.version          Operating System Version
			//
			//  file.separator      File separator ("/")
			//  path.separator      Path separator (":")
			//  line.separator      Line separator ("\n")
			//
			//  user.name           User account name
			//  user.home           User home directory
			//  user.dir            User's current working directory
			
			
			String homedir     = System.getProperty("user.home");
			String workingdir  = System.getProperty("user.dir");
			String javahomedir = System.getProperty("java.home");
			String classpath   = System.getProperty("java.class.path");
			
			//  System.out.println("home directory = " + homedir);
			//  System.out.println("working directory = " + workingdir);
			//  System.out.println("java home dir = " + javahomedir);
			//  System.out.println("classpath = " + classpath); // = .
			//
			//  running these commands as "user" ...
			//
			//  home directory = /home/username
			//  working directory = /home/username/EditorClassFiles
			//  java home dir = /usr/jdk/jdk-xx
			//  classpath = .
			//
			//  running the program as superuser
			//
			//  home directory = /root
			//
			//  ...
			
			
			
			String filename = homedir + File.separator
			
			    + __.java_editor + " " + __.settings;
			
			File file = new File(filename);
			
			//  System.out.println(filename);
			
			
			int x = 0,   y = 0;
			int w = width, h = height;
			
			int findx = 0, findy = 0;
			int replacex = 0, replacey = 0;
			int gotolinex = 0, gotoliney = 0;
			
			
			//  Don't allow the frame to disappear from the screen
			//  if the settings file has an x or y position that is
			//  greater than the screen size
			
			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			
			int screenwidth  = (int) d.getWidth();
			int screenheight = (int) d.getHeight();
			
			int xmax = screenwidth;
			int ymax = screenheight;
			
			
			String fontname = null;
			
			int fontstyle = Font.PLAIN;
			
			int textrgb   = Color.black.getRGB();
			int screenrgb = Color.white.getRGB();
			
			
			if (file.exists())
			{
			
				try (Scanner in = new Scanner(file))
				{
					String line = null, line1 = null;
					
					if (in.hasNextLine())
					
					    line = in.nextLine().trim();
					
					while (in.hasNextLine())
					{
						if ((line1 != null) && !line1.isEmpty())
						
						    line = line1;
						
						if (line.isBlank()) continue;
						
						while (in.hasNextLine() &&
						
						    (line1 = in.nextLine()).isBlank())
						
							continue;
						
						
						if (line.equalsIgnoreCase(__.frameposition))
						{
							String str = line1;
							
							String[] tokens = str.split(" {1,}");
							
							if (tokens.length == 2)
							{
								x = Integer.valueOf(tokens[0]);
								y = Integer.valueOf(tokens[1]);
								
								if (x > xmax) x = xmax;
								if (y > ymax) y = ymax;
							}
						}
						
						else if (line.equalsIgnoreCase(__.framesize))
						{
							String str = line1;
							
							String[] tokens = str.split(" {1,}");
							
							if (tokens.length == 2)
							{
								w = Integer.valueOf(tokens[0]);
								h = Integer.valueOf(tokens[1]);
							}
						}
						
						else if (line.equalsIgnoreCase(__.font))
						{
							String str = line1;
							
							String[] tokens = str.split(",");
							
							if (tokens.length == 3)
							{
								fontname = tokens[0].trim();
								
								fontstyle = Integer.valueOf(tokens[1].trim());
								
								//  Test the font size
								
								if ((fontsize > 0) && (fontsize < 50))
								
								     fontsize = Integer.valueOf(
								
									tokens[2].trim());
								
								else fontsize = 20;
							}
						}
						
						
						else if (line.equalsIgnoreCase(__.textrgb))
						{
							try { textrgb = Integer.parseInt(line1); }
							
							catch (NumberFormatException ex)
							
							    { ex.printStackTrace(); continue; }
							
							foreground = new Color(textrgb);
						}
						
						else if (line.equalsIgnoreCase(__.screenrgb))
						{
							try { screenrgb = Integer.parseInt(line1); }
							
							catch (NumberFormatException ex)
							
							    { ex.printStackTrace(); continue; }
							
							background = new Color(screenrgb);
						}
						
						else if (line.equalsIgnoreCase(__.showpanel))
						{
							showhidebuttons = Boolean.valueOf(line1);
							
							iconpanel.setVisible(showhidebuttons);
						}
						
						else if (line.equalsIgnoreCase(__.titlename))
						{
							titlename = line1;
							
							frame.setTitle(line1);
							
							int maxlen = 20;
							
							aboutmenuitem.setText(__.about + " "
							
							  + ((titlename.length()   > maxlen) ?
							      titlename.substring(0, maxlen) : titlename));
						}
						
						else if (line.equalsIgnoreCase(__.filename))
						{
							filenamelist.add(line1);
						}
						
						
						//  else if ...
						
						//  ...
					}
				}
				
				
				catch (Exception ex)
				{
					System.out.println(ex);
					
					return;
				}
				
				frame.setLocation(x, y);
				
				frame.setSize(w, h);
				
				
				if ((fontname == null) || fontname.isEmpty())
				
				    fontname = __.monospaced;
				
				if (fontstyle == 0) fontstyle = Font.PLAIN;
				
				if (fontsize == 0) fontsize = 16;
				
				this.font = new Font(fontname, fontstyle, (int) fontsize);
				
				this.fontname  = fontname;
				this.fontstyle = fontstyle;
				this.fontsize  = fontsize;
				
				setFont1(this.font);
				
				
				JTextArea textarea = textareapanel.textarea;
				
				textarea.setFont(font);
				
				this.fontsize = fontsize;
				
				
				if (textrgb != 0)
				{
					textarea.setForeground(new Color(textrgb));
					textarea.setCaretColor(new Color(textrgb));
				}
				
				
				if (screenrgb != 0)
				{
					Color color = new Color(screenrgb);
					
					textarea.setBackground(color);
				}
				
				
				int size = filenamelist.size();
				
				for (int i = 0; i < size; i++)
				{
					if ((filenamelist.get(i) != null) && !filenamelist.get(i).isEmpty())
					{
						String filename1 = new File(filenamelist.get(i)).getName();
						
						JMenuItem menuitem;
						
						ImageIcon fileicon   = Icons.get(Icons.file);
						ImageIcon javaicon   = Icons.get(Icons.java);
						ImageIcon pythonicon = Icons.get(Icons.python);
						
						if (filename1.endsWith("java"))
						
						     menuitem = new JMenuItem(filename1, javaicon);
						
						else if (filename1.endsWith("py"))
						
						     menuitem = new JMenuItem(filename1, pythonicon);
						
						else menuitem = new JMenuItem(filename1, fileicon);
						
						menuitem.setFont(menuitemfont);
						
						listmenuitem.add(menuitem);
						
						listmenuitem.get(i).addActionListener(
						
						    openlistfilelistener);
						
						filemenu.add(listmenuitem.get(i));
					}
				}
			}
		}
		
		
		
		
		
		private void saveSettings()
		{
		
			ArrayList<Object> list;
			
			list = new ArrayList<Object>();
			
			int textrgb, screenrgb;
			
			try
			{	if ((frame != null) && frame.isVisible())
				{
					list.add(__.frameposition);
					list.add(frame.getLocationOnScreen().x + "  "
					       + frame.getLocationOnScreen().y);
					
					list.add(__.framesize);
					list.add(frame.getSize().width + "  "
					       + frame.getSize().height);
					
					list.add(__.showpanel);
					list.add(showhidebuttons);
				}
				
				if ( (foreground != null) && (background != null) )
				{
					textrgb   = foreground.getRGB();
					screenrgb = background.getRGB();
					
					list.add(__.textrgb);   list.add(Integer.valueOf(textrgb));
					list.add(__.screenrgb); list.add(Integer.valueOf(screenrgb));
				}
				
				if (font != null)
				
				    { list.add(__.font); list.add(font.getName() + ","
				
				        + font.getStyle() + "," + font.getSize()); }
				
				if ((titlename != null) && !titlename.isEmpty())
				
				    { list.add(__.titlename);  list.add(titlename); }
				
				boolean fileexists = false; // file is listed on filelist
				
				
				list.add("");
				
				for (String filename : filenamelist)
				{
					list.add(__.filename);
					
					list.add(filename);
				}
				
				
				//  Save other settings
				
				//  ...   ...
			}
			
			catch (Exception ex)
			{
				ex.printStackTrace();
				
				return;
			}
			
			
			String homedir    = System.getProperty("user.home");
			String workingdir = System.getProperty("user.dir");
			String classpath  = System.getProperty("java.class.path");
			
			
			String filename = homedir + File.separator
			
			    + __.java_editor + " " + __.settings;
			
			
			File file = new File(filename);
			
			
			if (!file.exists() && !homedir.equals("/root"))
			{
				String message = "";
				
				message += "Create a file to save the settings\n";
				
				message += file.getName();
				
				//  Display the JOptionPane
				
				int choice = JOptionPane
				
				   .showConfirmDialog(frame, message);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
					return;
			}
			
			
			try { file.createNewFile(); }
			
			catch (IOException ex)
			{
				System.out.println(ex);
				
				return;
			}
			
			
			try (PrintWriter out =
			
			   new PrintWriter(
			
			     new BufferedWriter(
			
			       new FileWriter(file))))
			{
				for (Object object : list)
				
				    out.println(object);
				
				out.flush();
			}
			
			catch (IOException ex)
			{
				System.out.println(ex);
				
				return;
			}
		}
		
		
		
		
		
		
		
		
		private class RetrieveMailListener implements ActionListener
		{
		
			private Mail mail;
			
			private Mail.RetrieveMailFrame retrievemailframe;
			
			public void actionPerformed(ActionEvent e)
			{
				//  Only one frame is created when the actionPerformed
				//  method is called by testing if (frame == null)
				
				if (retrievemailframe == null) init();
				
				if (retrievemailframe.getPassphrase() == null)
				    retrievemailframe.setPassphrase(SP);
				
				retrievemailframe.toFront();
				
				retrievemailframe.setVisible(true);
				
				
				//  The following code corrects for a bug in Java
				//
				//  If the user has two tabs open and the second tab is selected,
				//  and then the user closes and re-opens the frame (without closing
				//  the text editor frame so the program doesn't exit), the second
				//  tab will still be selected but the first component will be dis-
				//  played, and the user has to click the first tab and then the
				//  second tab to update the component.
				
				JTabbedPane tabbedpane = retrievemailframe.tabbedpane;
				
				int index = tabbedpane.getSelectedIndex();
				
				for (int i = 0; i <= index; i++)
				
				    tabbedpane.setSelectedIndex(i);
			}
			
			
			private void init()
			{
				//  creates a retrievemailframe
				
				mail = new Mail();
				
				retrievemailframe = mail.new RetrieveMailFrame();
				
				retrievemailframe.setResizable(true);
				
				retrievemailframe.setDefaultCloseOperation(
				
				    JFrame.DO_NOTHING_ON_CLOSE);
			}
		}
		
		
		
		private class EditorListener implements ActionListener
		{
			private HTMLFrame htmlframe;
			
			public void actionPerformed(ActionEvent e)
			{
				if (htmlframe == null) init();
				
				if (htmlframe.getPassphrase() == null)
				    htmlframe.setPassphrase(SP);
				
				htmlframe.setVisible(true);
				
				htmlframe.toFront();
			}
			
			private void init()
			{
				//  creates an Editor Frame
				
				htmlframe = new HTMLFrame();
			}
		}
	}
	
	
	//  End class TextFrame
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	public class TableFrame extends JFrame
	{
	
		private static final long serialVersionUID = 1L;
		
		private String version = "0.0";
		
		
		private JFrame frame;
		
		private JDraggableTabbedPane tabbedpane;
		
		private TablePanel tablepanel;
		
		private ArrayList<TablePanel> tablepanellist;
		
		
		private String fontname = __.monospaced;
		
		private int fontstyle = Font.PLAIN;
		
		private int fontsize = textfont.getSize();
		
		private Font font = new Font(
		
		    fontname, fontstyle, fontsize);
		
		private Color foreground = Color.black;
		private Color background = Color.white;
		
		private int height =  600;
		private int width  = 1000;
		
		private String program = __.table_editor;
		
		private String titlename = "";
		
		
		
		NewListener newlistener;
		OpenListener openlistener;
		SaveListener savelistener;
		SaveAsListener saveaslistener;
		DeleteFileListener deletefilelistener;
		CloseListener closelistener;
		PrintListener printlistener;
		ExitListener exitlistener;
		
		TableSizeListener tablesizelistener;
		
		UndoListener undolistener;
		
		CutListener cutlistener;
		CopyListener copylistener;
		PasteListener pastelistener;
		
		FindAndReplace.FindListener findlistener;
		FindAndReplace.ReplaceListener replacelistener;
		
		AutoSumListener autosumlistener;
		TransposeListener transposelistener;
		
		InsertRowsListener insertrowslistener;
		DeleteRowsListener deleterowslistener;
		
		
		FontSizeListener fontsizelistener;
		FontTypeListener fonttypelistener;
		TextBoldListener textboldlistener;
		
		ColorListener colorlistener;
		ShowGridListener showgridlistener;
		EnableReorderingListener enablereorderinglistener;
		EnableSortingListener enablesortinglistener;
		SetAutoResizeListener setautoresizelistener;
		
		
		EncryptDirectoryListener encryptdirectorylistener;
		DecryptDirectoryListener decryptdirectorylistener;
		
		EncryptFileListener encryptfilelistener;
		DecryptFileListener decryptfilelistener;
		
		AboutListener aboutlistener;
		LicenseListener licenselistener;
		
		
		ColorButtonListener colorbuttonlistener;
		
		
		//  Opening the file list
		
		////  FileListListener filelistlistener;
		
		//  Opening a file on the file list
		
		OpenListFileListener openlistfilelistener;
		
		
		KeyListener1 keylistener1;
		MouseWheelListener1 mousewheellistener1;
		
		FocusListener focuslistener;
		MouseListener mouselistener;
		MouseMotionListener mousemotionlistener;
		
		WindowListener windowlistener1;
		ChangeListener1 changelistener1;
	//	ComponentListener1 componentlistener1;
		
		
		
		ArrayList<String> filenamelist;
		
		
		
		ArrayList<String> filelist;
		
		ArrayList<JTextField> textfieldlist;
		
		ArrayList<JMenuItem> listmenuitem;
		
		
		JMenuBar menubar;
		
		JMenuItem[] menuitems;
		
		JMenu filemenu, editmenu,
		viewmenu, encryptmenu, helpmenu;
		
		
		JMenuItem newmenuitem, openmenuitem,
		savemenuitem, saveasmenuitem, deletemenuitem,
		printmenuitem, closemenuitem, exitmenuitem;
		
		
		JMenuItem tablesizemenuitem,
		undomenuitem, redomenuitem,
		cutmenuitem, copymenuitem, pastemenuitem,
		findmenuitem, replacemenuitem,
		replaceallmenuitem, selectallmenuitem,
		autosummenuitem, transposemenuitem;
		
		JMenuItem fontsizemenuitem, fonttypemenuitem,
		boldmenuitem, colormenuitem,
		showgridmenuitem, enablesortingmenuitem,
		enablereorderingmenuitem, setautoresizemenuitem;
		
		JMenuItem encryptdirectorymenuitem,
		decryptdirectorymenuitem,
		encryptfilemenuitem, decryptfilemenuitem;
		
		JMenuItem aboutmenuitem, licensemenuitem;
		
		
		
		
		private JPanel iconpanel;
		
		private ImageIcon[] imageicons;
		private JButton[] iconbuttons;
		
		
		private JButton
		
		newbutton, openbutton,
		savebutton, closebutton,
		
		undobutton, redobutton,
		cutbutton, copybutton,
		pastebutton, findbutton,
		
		fontsizebutton, fonttypebutton,
		textboldbutton, colorbutton
		
		;
		
		
		private boolean showhidebuttons = true;
		
		
		
		
		
		public TableFrame()
		{
		
			//  TableFrame constructor
			
			frame = this;
			frame.setSize(width, height);
			frame.setResizable(true);
			frame.setVisible(true);
			frame.setTitle(titlename);
			frame.setLayout(new GridBagLayout());
			frame.setDefaultCloseOperation(
			    DO_NOTHING_ON_CLOSE);
			
			//  frame.setLocationRelativeTo(null);
			
			
			windowlistener1 = new WindowListener1();
			changelistener1 = new ChangeListener1();
			
			keylistener1 = new KeyListener1();
			
			focuslistener = new FocusListener();
			mouselistener = new MouseListener();
			mousemotionlistener = new MouseMotionListener();
			
			mousewheellistener1 = new MouseWheelListener1();
			
			
			
			newlistener = new NewListener();
			openlistener = new OpenListener();
			savelistener = new SaveListener();
			saveaslistener = new SaveAsListener();
			deletefilelistener = new DeleteFileListener(frame);
			printlistener = new PrintListener();
			closelistener = new CloseListener();
			exitlistener = new ExitListener();
			
			tablesizelistener = new TableSizeListener();
			
			undolistener = new UndoListener();
			
			cutlistener = new CutListener();
			copylistener = new CopyListener();
			pastelistener = new PasteListener();
			
			findlistener = new FindAndReplace() .new FindListener();
			replacelistener = new FindAndReplace() .new ReplaceListener();
			
			autosumlistener = new AutoSumListener();
			transposelistener = new TransposeListener();
			
			insertrowslistener = new InsertRowsListener();
			deleterowslistener = new DeleteRowsListener();
			
			setautoresizelistener = new SetAutoResizeListener();
			
			fontsizelistener = new FontSizeListener();
			fonttypelistener = new FontTypeListener();
			textboldlistener = new TextBoldListener();
			
			colorlistener = new ColorListener();
			showgridlistener = new ShowGridListener();
			enablereorderinglistener = new EnableReorderingListener();
			enablesortinglistener = new EnableSortingListener();
			
			encryptdirectorylistener = new EncryptDirectoryListener();
			decryptdirectorylistener = new DecryptDirectoryListener();
			
			encryptfilelistener = new EncryptFileListener();
			decryptfilelistener = new DecryptFileListener();
			
			aboutlistener = new AboutListener();
			licenselistener = new LicenseListener();
			
			
			
			//  Create an array list of TablePanel to hold the table panels
			
			tablepanellist = new ArrayList<TablePanel>();
			
			
			//  Create a Draggable TabbedPane
			
			tabbedpane = new JDraggableTabbedPane();
			
			tabbedpane.setDragEnabled(true);
			tabbedpane.setFocusTraversalPolicy();
			tabbedpane.addMouseListener(mouselistener);
			
			
			
			//  Add an EventListener or ChangeListener to the JTabbedPane
			//
			//  to update the reference to the selected tab
			
			tabbedpane.addChangeListener(new ChangeListener1());
			
			
			
			//  Create an icon panel
			
			iconpanel = createIconPanel();
			
			
			//  Add the icon panel and the
			//  JTabbedPane to the frame
			
			Gbc gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setFill(Gbc.none);
			gbc.setAnchor(Gbc.left);
			
			frame.add(iconpanel, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			frame.add(tabbedpane, gbc);
			
			
			
			//  MenuBar,  Menu, Menu Items,  Menu, Menu Items, ...
			
			
			menubar = new JMenuBar();
			
			frame.setJMenuBar(menubar);
			
			
			
			//  File menu
			
			
			filemenu = new JMenu(__.file);
			filemenu.setFont(menufont);
			
			newmenuitem = new JMenuItem(__.newkey, newicon);
			newmenuitem.addActionListener(newlistener);
			newmenuitem.setFont(menuitemfont);
			filemenu.add(newmenuitem);
			
			openmenuitem = new JMenuItem(__.openkey, openicon);
			openmenuitem.addActionListener(openlistener);
			openmenuitem.setFont(menuitemfont);
			filemenu.add(openmenuitem);
			
			savemenuitem = new JMenuItem(__.savekey, saveicon);
			savemenuitem.addActionListener(savelistener);
			savemenuitem.setFont(menuitemfont);
			filemenu.add(savemenuitem);
			
			saveasmenuitem = new JMenuItem(__.saveaskey, saveasicon);
			saveasmenuitem.addActionListener(saveaslistener);
			saveasmenuitem.setFont(menuitemfont);
			filemenu.add(saveasmenuitem);
			
			
			
			deletemenuitem = new JMenuItem(__.deletekey, deleteicon);
			deletemenuitem.addActionListener(deletefilelistener);
			deletemenuitem.setFont(menuitemfont);
			filemenu.add(deletemenuitem);
			
			
			printmenuitem = new JMenuItem(__.printkey, printicon);
			printmenuitem.addActionListener(printlistener);
			printmenuitem.setFont(menuitemfont);
			filemenu.add(printmenuitem);
			
			closemenuitem = new JMenuItem(__.closekey, closeicon);
			closemenuitem.addActionListener(closelistener);
			closemenuitem.setFont(menuitemfont);
			filemenu.add(closemenuitem);
			
			exitmenuitem = new JMenuItem(__.exitkey, exiticon);
			exitmenuitem.addActionListener(exitlistener);
			exitmenuitem.setFont(menuitemfont);
			filemenu.add(exitmenuitem);
			
		//	filemenu.addSeparator();
		//	
		//	JMenuItem menuitem = new JMenuItem("");
		//	menuitem.addActionListener(filelistlistener);
		//	filemenu.add(menuitem);
			
			//  ...
			
			menubar.add(filemenu);
			
			
			
			
			//  Edit menu
			
			
			editmenu = new JMenu(__.edit);
			editmenu.setFont(menufont);
			
			tablesizemenuitem = new JMenuItem(__.tablesize);
			tablesizemenuitem.addActionListener(tablesizelistener);
			tablesizemenuitem.setFont(menuitemfont);
			editmenu.add(tablesizemenuitem);
			
			
			editmenu.addSeparator();
			
			undomenuitem = new JMenuItem(__.undokey, undoicon);
			undomenuitem.addActionListener(undolistener);
			undomenuitem.setFont(menuitemfont);
			editmenu.add(undomenuitem);
			
			redomenuitem = new JMenuItem(__.redokey, redoicon);
			redomenuitem.addActionListener(undolistener);
			redomenuitem.setFont(menuitemfont);
			editmenu.add(redomenuitem);
			
			
			editmenu.addSeparator();
			
			cutmenuitem = new JMenuItem(__.cutkey, cuticon);
			cutmenuitem.addActionListener(cutlistener);
			cutmenuitem.setFont(menuitemfont);
			editmenu.add(cutmenuitem);
			
			copymenuitem = new JMenuItem(__.copykey, copyicon);
			copymenuitem.addActionListener(copylistener);
			copymenuitem.setFont(menuitemfont);
			editmenu.add(copymenuitem);
			
			pastemenuitem = new JMenuItem(__.pastekey, pasteicon);
			pastemenuitem.addActionListener(pastelistener);
			pastemenuitem.setFont(menuitemfont);
			editmenu.add(pastemenuitem);
			
			
			editmenu.addSeparator();
			
			findmenuitem = new JMenuItem(__.findkey, findicon);
			findmenuitem.addActionListener(findlistener);
			findmenuitem.setFont(menuitemfont);
			editmenu.add(findmenuitem);
			
			replacemenuitem = new JMenuItem(__.replacekey);
			replacemenuitem.addActionListener(replacelistener);
			replacemenuitem.setFont(menuitemfont);
			editmenu.add(replacemenuitem);
			
			
			editmenu.addSeparator();
			
			transposemenuitem = new JMenuItem(__.transposerowscols);
			transposemenuitem.addActionListener(transposelistener);
			transposemenuitem.setFont(menuitemfont);
			editmenu.add(transposemenuitem);
			
			editmenu.addSeparator();
			
			ImageIcon autosumicon = Icons.get(Icons.summation_sign);
			autosummenuitem = new JMenuItem(__.autosum, autosumicon);
			autosummenuitem.addActionListener(autosumlistener);
			autosummenuitem.setFont(menuitemfont);
			editmenu.add(autosummenuitem);
			
			
			//  ...
			
			menubar.add(editmenu);
			
			
			
			
			//  View menu
			
			
			viewmenu = new JMenu(__.view);
			viewmenu.setFont(menufont);
			
			fontsizemenuitem = new JMenuItem(__.fontsizekey, fonticon);
			fontsizemenuitem.addActionListener(fontsizelistener);
			fontsizemenuitem.setFont(menuitemfont);
			viewmenu.add(fontsizemenuitem);
			
			fonttypemenuitem = new JMenuItem(__.fonttype);
			fonttypemenuitem.addActionListener(fonttypelistener);
			fonttypemenuitem.setFont(menuitemfont);
			viewmenu.add(fonttypemenuitem);
			
			boldmenuitem = new JMenuItem(__.bold_unbold, textboldicon);
			boldmenuitem.addActionListener(textboldlistener);
			boldmenuitem.setFont(menuitemfont);
			viewmenu.add(boldmenuitem);
			
			viewmenu.addSeparator();
			
			colormenuitem = new JMenuItem(
			    __.textscreencolor, textscreencoloricon);
			colormenuitem.addActionListener(colorlistener);
			colormenuitem.setFont(menuitemfont);
			viewmenu.add(colormenuitem);
			
			viewmenu.addSeparator();
			
			showgridmenuitem = new JMenuItem(__.showgrid);
			showgridmenuitem.addActionListener(showgridlistener);
			showgridmenuitem.setFont(menuitemfont);
			viewmenu.add(showgridmenuitem);
			
			viewmenu.addSeparator();
			
			enablereorderingmenuitem = new JMenuItem(__.enablereordering);
			enablereorderingmenuitem.addActionListener(enablereorderinglistener);
			enablereorderingmenuitem.setFont(menuitemfont);
			viewmenu.add(enablereorderingmenuitem);
			
			viewmenu.addSeparator();
			
			enablesortingmenuitem = new JMenuItem(__.enablesorting);
			enablesortingmenuitem.addActionListener(enablesortinglistener);
			enablesortingmenuitem.setFont(menuitemfont);
			viewmenu.add(enablesortingmenuitem);
			
			//  viewmenu.addSeparator();
			//
			//  setautoresizemenuitem = new JMenuItem(__.setautoresize);
			//  setautoresizemenuitem.addActionListener(setautoresizelistener);
			//  setautoresizemenuitem.setFont(menuitemfont);
			//  viewmenu.add(setautoresizemenuitem);
			
			//  ...
			
			menubar.add(viewmenu);
			
			
			
			//  Encrypt menu
			
			
			encryptmenu = new JMenu(__.encrypt);
			encryptmenu.setFont(menufont);
			
			//  The encrypt directory and encrypt file menu items could be
			//  merged into one menu item like the hash file / dir menu item
			
			encryptdirectorymenuitem = new JMenuItem(
			    __.encryptdirectory, encryptdirectoryicon);
			encryptdirectorymenuitem.addActionListener(encryptdirectorylistener);
			encryptdirectorymenuitem.setFont(menuitemfont);
			encryptmenu.add(encryptdirectorymenuitem);
			
			decryptdirectorymenuitem = new JMenuItem(__.decryptdirectory);
			decryptdirectorymenuitem.addActionListener(decryptdirectorylistener);
			decryptdirectorymenuitem.setFont(menuitemfont);
			encryptmenu.add(decryptdirectorymenuitem);
			
			encryptmenu.addSeparator();
			
			encryptfilemenuitem = new JMenuItem(__.encryptfile, encryptfileicon);
			encryptfilemenuitem.addActionListener(encryptfilelistener);
			encryptfilemenuitem.setFont(menuitemfont);
			encryptmenu.add(encryptfilemenuitem);
			
			decryptfilemenuitem = new JMenuItem(__.decryptfile);
			decryptfilemenuitem.addActionListener(decryptfilelistener);
			decryptfilemenuitem.setFont(menuitemfont);
			encryptmenu.add(decryptfilemenuitem);
			
			menubar.add(encryptmenu);
			
			
			
			
			//  Help menu
			
			
			helpmenu = new JMenu(__.help);
			helpmenu.setFont(menufont);
			
			aboutmenuitem = new JMenuItem(__.about, abouticon);
			aboutmenuitem.addActionListener(aboutlistener);
			aboutmenuitem.setFont(menuitemfont);
			helpmenu.add(aboutmenuitem);
			
			//  ...
			
			menubar.add(helpmenu);
			
			
			colorbuttonlistener = new ColorButtonListener();
			
			
			
			//  Add the Window listener
			
			frame.addWindowListener(windowlistener1);
			
			
			
			filenamelist = new ArrayList<String>();
			
			textfieldlist = new ArrayList<JTextField>();
			
			listmenuitem = new ArrayList<JMenuItem>();
			
			
			
			//  Create a new TablePanel to add to the JTabbedPane
			
			newlistener.run();
		}
		
		
		//  End TableFrame constructor
		
		
		
		
		
		
		private JPanel createIconPanel()
		{
		
			newbutton = new JButton();
			openbutton = new JButton();
			savebutton = new JButton();
			closebutton = new JButton();
			
			undobutton = new JButton();
			redobutton = new JButton();
			cutbutton = new JButton();
			copybutton = new JButton();
			pastebutton = new JButton();
			findbutton = new JButton();
			
			fontsizebutton = new JButton();
			fonttypebutton = new JButton();
			textboldbutton = new JButton();
			colorbutton = new JButton();
			
			
			
			  newbutton.addActionListener(newlistener);
			 openbutton.addActionListener(openlistener);
			 savebutton.addActionListener(savelistener);
			closebutton.addActionListener(closelistener);
			
			undobutton.addActionListener(undolistener);
			redobutton.addActionListener(undolistener);
			 cutbutton.addActionListener(cutlistener);
			copybutton.addActionListener(copylistener);
			pastebutton.addActionListener(pastelistener);
			 findbutton.addActionListener(findlistener);
			
			fontsizebutton.addActionListener(fontsizelistener);
			textboldbutton.addActionListener(textboldlistener);
			colorbutton.addActionListener(colorlistener);
			
			
			
			 newbutton.setToolTipText(__.new_);
			openbutton.setToolTipText(__.open);
			savebutton.setToolTipText(__.save);
			closebutton.setToolTipText(__.close);
			
			undobutton.setToolTipText(__.undo);
			redobutton.setToolTipText(__.redo);
			cutbutton.setToolTipText(__.cut);
			copybutton.setToolTipText(__.copy);
			pastebutton.setToolTipText(__.paste);
			findbutton.setToolTipText(__.find);
			
			fontsizebutton.setToolTipText(__.font);
			textboldbutton.setToolTipText(__.text_bold);
			colorbutton.setToolTipText(__.textscreencolor);
			
			
			imageicons = new ImageIcon[]
			{
				newicon, openicon, saveicon, closeicon,
				undoicon, redoicon, cuticon, copyicon,
				pasteicon, findicon, fonticon, textboldicon,
				coloricon,
			};
			
			iconbuttons = new JButton[]
			{
				newbutton, openbutton, savebutton, closebutton,
				undobutton, redobutton, cutbutton, copybutton,
				pastebutton, findbutton, fontsizebutton,
				textboldbutton, colorbutton,
			};
			
			
			Box box = Box.createHorizontalBox();
			
			for (JButton button : iconbuttons)
			{
				if (button == null) continue;
				
				button.setContentAreaFilled(false);
				button.setBorderPainted(false);
				
				Component hstrut = Box
				    .createHorizontalStrut(0);
				
				box.add(button);
				box.add(hstrut);
			}
			
			JPanel panel = new JPanel();
			
			panel.add(box);
			
			return panel;
		}
		
		
		
		
		
		private class TablePanel extends JPanel
		{
		
			private static final long serialVersionUID = 1L;
			
			private JTextField textfield;
			
			private JScrollPane scrollpane;
			
			private JTableHeader tableheader;
			
			private JTable table, rowheader;
			
			private int rows = 256, cols = 16;
			
			
			private File file;
			
			private String delimiter;
			private boolean filechanged;
			private boolean encrypted;
			
			private boolean showgrid = true;
			
			private Undo undo;
			
			
			public TablePanel()
			{
				createTablePanel(this, 0, 0);
			}
			
			public TablePanel(int rows, int cols)
			{
				createTablePanel(this, rows, cols);
			}
			
			private void createTablePanel(
			
				TablePanel tablepanel, int rows, int cols)
			{
				this.setLayout(new GridBagLayout());
				
				if (rows > 0) this.rows = rows;
				if (cols > 0) this.cols = cols;
				
				if (rows <= 0) rows = this.rows;
				if (cols <= 0) cols = this.cols;
				
				table = new JTable(rows, cols);
				
				//  table.setAutoCreateRowSorter(true);
				
				//  table.setDragEnabled(true);
				
				//  Disable auto resize so the column widths can be set
				
				table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
				
				TableColumnModel cm = table.getColumnModel();
				
				int height = font.getSize() + 16;
				
				for (int i = 0; i < table.getColumnCount(); i++)
				{
					TableColumn col = cm.getColumn(i);
					
					col.setPreferredWidth(5 * height);
				}
				
				table.setRowHeight(40);
				table.setColumnSelectionAllowed(true);
				
				table.setForeground(foreground);
				table.setBackground(background);
				
				table.addMouseListener(mouselistener);
				table.addFocusListener(focuslistener);
				table.addKeyListener(keylistener1);
				
				undo = new Undo(table);
				
				scrollpane = new JScrollPane();
				
				scrollpane.setViewportView(table);
				
				TableModel rowheadermodel = new DefaultTableModel()
				{
					public int getColumnCount() { return 1; }
					public int getRowCount() { return table.getRowCount(); }
					public Object getValueAt(int row, int col)
					{
						String str = String.valueOf(row + 1);
						
						if      ((row + 1) <   10) str = "   " + str;
						else if ((row + 1) <  100) str =  "  " + str;
						else if ((row + 1) < 1000) str =   " " + str;
						
						return str;
					}
					
					public boolean isCellEditable(int r, int c)
					
					    { return false; }
				};
				
				
				rowheader = new JTable(rowheadermodel);
				rowheader.setRowHeight(table.getRowHeight());
				
				tableheader = table.getTableHeader();
				tableheader.addMouseListener(mouselistener);
				
				rowheader.setBackground(tableheader.getBackground());
				
				int width = 80 + (int) Math.log10(rows) * 4;
				
				Dimension d = new Dimension(width, 0);
				
 				rowheader.setPreferredScrollableViewportSize(d);
				rowheader.addMouseListener(mouselistener);
				rowheader.addMouseMotionListener(mousemotionlistener);
				
				JLabel cornerlabel = new JLabel();
				
				cornerlabel.addMouseListener(mouselistener);
				
				scrollpane.setRowHeaderView(rowheader);
				scrollpane.setCorner(ScrollPaneConstants
				
				    .UPPER_LEFT_CORNER, cornerlabel);
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(scrollpane, gbc);
			}
		}
		
		//  End class TablePanel
		
		
		
		
		
		
		public boolean setTableSize(int rows, int cols)
		{
			//  Set the minimum row and col size
			
			int minrowsize = getHighestSetRow();
			int mincolsize = getHighestSetColumn();
			
			if (rows <= minrowsize) rows = 1 + minrowsize;
			if (cols <= mincolsize) cols = 1 + mincolsize;
			
			
			//  If the user selects a large number of cells (rows x cols)
			//  or tries to open a file that has a large number of values
			//  it could cause the program to become unresponsive
			
			int product = rows * cols;
			
			if (((product >= 2048*1024) && (cols >   4))
			 || ((product >= 1024*1024) && (cols >   8))
			 || ((product >=  512*1024) && (cols >  16))
			 || ((product >=  256*1024) && (cols >  32))
			 || ((product >=  128*1024) && (cols >  64))
			 || ((product >=   64*1024) && (cols > 128))
			 || ((product >=   32*1024) && (cols > 256)))
			{
				String message =
				
				    "Cols is too large for this number of rows (cells)";
				
				JOptionPane.showMessageDialog(frame, message);
				
				return false;
			}
			
			
			//  Read the data from the table
			
			String str = getData();
			
			
			//  Read the tablepanel members
			
			File file = tablepanel.file;
			
			String delimiter = tablepanel.delimiter;
			boolean filechanged = tablepanel.filechanged;
			boolean encrypted = tablepanel.encrypted;
			boolean showgrid = tablepanel.showgrid;
			
			//  undo is not copied because the table is resized
			
			
			//  Remove the old table panel
			
			int[] r = tablepanel.table.getSelectedRows();
			
			int index = tabbedpane.getSelectedIndex();
			
			String title = tabbedpane.getTitleAt(index);
			
			tablepanellist.remove(tabbedpane.getComponentAt(index));
			
			tabbedpane.removeTabAt(index);
			
			
			//  Create and add a new table panel
			
			TablePanel tablepanel = new TablePanel(rows, cols);
			
			tablepanellist.add(tablepanel);
			
			tabbedpane.add(tablepanel, index);
			tabbedpane.setTitleAt(index, title);
			tabbedpane.setSelectedComponent(tablepanel);
			
			tablepanel.table.requestFocusInWindow();
			
			setFont1(font);
			
			
			//  Copy the previous table panel members
			
			tablepanel.file = file;
			tablepanel.delimiter = delimiter;
			tablepanel.filechanged = filechanged;
			tablepanel.encrypted = encrypted;
			tablepanel.showgrid = showgrid;
			
			tablepanel.table.setShowGrid(showgrid);
			
			
			//  Copy the previous data to the new table
			
			setData(str, false);
			
			setFrameTitle();
			
			setFont1(font);
			
			return true;
		}
		
		
		
		private class ChangeListener1 implements ChangeListener
		{
			public void stateChanged(ChangeEvent e)
			{
				tablepanel = (TablePanel)
				
				    tabbedpane.getSelectedComponent();
				
				setFrameTitle();
			}
		}
		
		
		
		private void setMenuItemsEnabled(boolean bool)
		{
			JMenuItem[] menuitems = new JMenuItem[]
			{
				savemenuitem, saveasmenuitem,
				
				printmenuitem, closemenuitem,
				
				tablesizemenuitem, undomenuitem, redomenuitem,
				
				cutmenuitem, copymenuitem, pastemenuitem,
				
				findmenuitem, replacemenuitem,
				
				transposemenuitem, autosummenuitem,
				
				fontsizemenuitem, fonttypemenuitem,
				
				boldmenuitem, colormenuitem,
				
				showgridmenuitem, enablereorderingmenuitem,
				
				enablesortingmenuitem,
				
				//  setautoresizemenuitem,
			};
			
			for (JMenuItem menuitem : menuitems)
			
			    menuitem.setEnabled(bool);
		}
		
		
		
		
		private class MouseListener extends MouseAdapter
		{
		
			private JPopupMenu popupmenu, tabpopupmenu;
			
			private JMenuItem cutmenuitem, copymenuitem, pastemenuitem,
			
			    insertrowsmenuitem, deleterowsmenuitem;
			
			
			public MouseListener()
			{
			
				popupmenu = new JPopupMenu();
				
				tabpopupmenu = new JPopupMenu();
				
				JMenuItem menuitem;
				
				
				//  Create the table cell popup menu
				
				cutmenuitem = new JMenuItem(__.cut);
				cutmenuitem.addActionListener(new CutListener());
				popupmenu.add(cutmenuitem);
				
				copymenuitem = new JMenuItem(__.copy);
				copymenuitem.addActionListener(new CopyListener());
				popupmenu.add(copymenuitem);
				
				pastemenuitem = new JMenuItem(__.paste);
				pastemenuitem.addActionListener(new PasteListener());
				popupmenu.add(pastemenuitem);
				
				
				popupmenu.addSeparator();
				
				insertrowsmenuitem = new JMenuItem(__.insertrows);
				insertrowsmenuitem.addActionListener(new InsertRowsListener());
				popupmenu.add(insertrowsmenuitem);
				
				deleterowsmenuitem = new JMenuItem(__.deleterows);
				deleterowsmenuitem.addActionListener(new DeleteRowsListener());
				popupmenu.add(deleterowsmenuitem);
				
				
				
				//  Create the tabbed pane popup menu
				
				menuitem = new JMenuItem(__.close);
				menuitem.addActionListener(new CloseListener());
				tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.saveas);
				menuitem.addActionListener(new SaveAsListener());
				tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.save);
				menuitem.addActionListener(new SaveListener());
				tabpopupmenu.add(menuitem);
				
				//  ...
			}
			
			
			public void mousePressed(MouseEvent e)
			{
				if (tablepanel == null) return;
				
				JTable table = tablepanel.table;
				JTable rowheader = tablepanel.rowheader;
				JScrollPane scrollpane = tablepanel.scrollpane;
				
				if (e.getButton() != MouseEvent.BUTTON1)
				{
					//  if nothing is selected disable cut and copy
					
					int[] rows = table.getSelectedRows();
					int[] cols = table.getSelectedColumns();
					
					boolean selected = ((rows.length > 0) || (cols.length > 0));
					
					 cutmenuitem.setEnabled(selected);
					copymenuitem.setEnabled(selected);
					
					//  if one or more rows are selected
					//  enable insert and delete rows menu items
					
					boolean rowselected = table.getSelectedColumns()
					    .length == table.getColumnCount();
					
					insertrowsmenuitem.setEnabled(rowselected);
					deleterowsmenuitem.setEnabled(rowselected);
					
					if (e.getSource() == table)
					
					    popupmenu.show(table, e.getX(), e.getY());
					
					if (e.getSource() == tabbedpane)
					
					    tabpopupmenu.show(tabbedpane, e.getX(), e.getY());
				}
				
				if (e.getSource() == tablepanel.rowheader)
				{
					int cols = table.getColumnCount();
					
					Point point = e.getPoint();
					
					int r = rowheader.rowAtPoint(point);
					
					table.setRowSelectionInterval(r, r);
					table.setColumnSelectionInterval(0, cols-1);
				}
				
				if (e.getSource() instanceof JTableHeader)
				{
					int rows = table.getRowCount();
					
					Point point = e.getPoint();
					
					int c = table.columnAtPoint(point);
					
					table.setColumnSelectionInterval(c, c);
					table.setRowSelectionInterval(0, rows-1);
				}
				
				if (e.getSource() instanceof JLabel)
				if (e.getSource() == tablepanel.scrollpane.getCorner(
				
				    ScrollPaneConstants.UPPER_LEFT_CORNER))
				
					table.selectAll();
			}
			
			
			public void mouseReleased(MouseEvent e)
			{
				if (tablepanel != null)
				{
					JTable rowheader = tablepanel.rowheader;
					
					rowheader.clearSelection();
				}
			}
			
			public void mouseClicked (MouseEvent e) {  }
		}
		
		
		
		
		private class MouseMotionListener extends MouseMotionAdapter
		{
			public void mouseMoved  (MouseEvent e) {  }
			
			public void mouseDragged(MouseEvent e)
			{
				if (tablepanel == null) return;
				
				if (e.getSource() == tablepanel.rowheader)
				{
					JTable     table = tablepanel.table;
					JTable rowheader = tablepanel.rowheader;
					
					int cols = table.getColumnCount();
					
					int[] r = rowheader.getSelectedRows();
					
					if (r.length != 0)
					{
					    table.setRowSelectionInterval(r[0], r[r.length-1]);
					    table.setColumnSelectionInterval(0, cols-1);
					}
					
					//  Scroll the table so the user can see the table selection
					//  while dragging the mouse; otherwise the row header will
					//  scroll by itself without the table until the user moves
					//  the mouse wheel to see the row selection.
					
					Rectangle rect = new Rectangle(e.getX(), e.getY(), 1, 1);
					tablepanel.table.scrollRectToVisible(rect);
				}
			}
		}
		
		
		
		
		private class KeyListener1 implements KeyListener
		{
		
			//  The key listener class doesn't work if the user
			//  double clicks in a cell before typing or deleting
			//  because the key listener doesn't get a key event
			
			
			private boolean shift, control, alt, keypressed;
			
			public boolean getShift() { return shift; }
			public boolean getControl() { return control; }
			public boolean getAlt() { return alt; }
			
			
			public void keyTyped(KeyEvent e)
			{
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = true;
				if (keycode == vk_control) control = true;
				if (keycode == vk_alt) alt = true;
				
				if ( ((keychar >= '0') && (keychar <= '9'))
				  || ((keychar >= 'A') && (keychar <= 'Z'))
				  || ((keychar >= 'a') && (keychar <= 'z'))
				  
				  ||  (keychar == '+') || (keychar == '-')
				  ||  (keychar == '/') || (keychar == '\\')
				  ||  (keychar == '[') || (keychar == ']')
				  ||  (keychar == ',') || (keychar == '.')
				  ||  (keychar == ';') || (keychar == '\'')
				  ||  (keychar == '\'')|| (keychar == '"')
				  ||  (keychar == '`') || (keychar == '@')
				  ||  (keychar == '#') || (keychar == '$')
				  ||  (keychar == '%') || (keychar == '^')
				  ||  (keychar == '&') || (keychar == '*')
				  ||  (keychar == '(') || (keychar == ')')
				  ||  (keychar == '_') || (keychar == '=')
				  
				  ||  (keychar == vk_space)
				  ||  (keychar == vk_backspace)
				  ||  (keychar == vk_delete) )
				
					if (control == false)
					
					    tablepanel.filechanged = true;
				
				
				//  ctrl + a == 1,  ctrl + b == 2, ctrl + c == 3, ...
				
				if (control && (keychar == 'x' - 'a' + 1))
				{
					tablepanel.filechanged = true;
				}
				
				else if (control && (keychar == 'v' - 'a' + 1))
				{
					tablepanel.filechanged = true;
				}
			}
			
			
			
			
			public void keyPressed(KeyEvent e)
			{
			
				keypressed = true;
				
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = true;
				if (keycode == vk_control) control = true;
				if (keycode == vk_alt) alt = true;
				
				
				
				//  If the user types the backspace or delete key
				//  the delete variable is set to true until the user
				//  clicks a different key so that the program doesn't
				//  keep pushing text onto the stack for each backspace
				//  or delete key event.
				
				if ((keychar == vk_backspace) || (keychar == vk_delete))
				{
					//  the first delete key event
					
					if (!tablepanel.undo.delete)
					     tablepanel.undo.push();
					
					tablepanel.undo.delete = true;
				}
				
				else  tablepanel.undo.delete = false;
				
				
				
				if (keychar == vk_enter)
				{
					//  the first enter key event
					
					if (!tablepanel.undo.enter)
					     tablepanel.undo.push();
					
					else  //  multiple enter key events
					{
						//  Don't do anything because pressing enter
						//  more than once just moves the focus to the
						//  next cell; it doesn't change the table.
					}
					
					tablepanel.undo.enter = true;
				}
				
				else  tablepanel.undo.enter = false;
				
				
				
				
				if (false) {  }
				
				//  Don't set control to false for font size
				//  and undo key codes so the user can hold
				//  ctrl and type the key code multiple times
				
				else if (control && (keychar == __.pluskeychar))
				{
					fontsizelistener.incrementSize();
					
					//  control = false;
				}
				
				else if (control && (keychar == __.minuskeychar))
				{
					fontsizelistener.decrementSize();
					
					//  control = false;
				}
				
				else if (control && (keycode == __.newkeycode))
				{
					newlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.openkeycode))
				{
					openlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.deletekeycode))
				{
					deletefilelistener.run();
					
					control = false;
				}
				
				else if (!shift && control && (keycode == __.savekeycode))
				{
					savelistener.run();
					
					control = false;
				}
				
				else if (shift && control && (keycode == __.saveaskeycode))
				{
					saveaslistener.run();
					
					control = false;
					
					shift = false;
				}
				
				else if (control && (keycode == __.printkeycode))
				{
					printlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.closekeycode))
				{
					closelistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.exitkeycode))
				{
					exitlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.findkeycode))
				{
					findlistener.setVisible(true);
					
					control = false;
				}
				
				else if (control && (keycode == __.replacekeycode))
				{
					replacelistener.setVisible(true);
					
					control = false;
				}
				
				else if (control && (keycode == __.undokeycode))
				{
					if (!shift) undolistener.undo();
					else        undolistener.redo();
					
					//  control = false;
				}
			}
			
			
			public void keyReleased(KeyEvent e)
			{
				keypressed = false;
				
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift) shift = false;
				if (keycode == vk_control) control = false;
				if (keycode == vk_alt) alt = false;
			}
		}
		
		
		//  End class KeyListener1
		
		
		
		
		
		private class MouseWheelListener1 implements MouseWheelListener
		{
			public void mouseWheelMoved(MouseWheelEvent e)
			{
				int rotation = e.getWheelRotation();
				
				//  ...
				
				if (keylistener1.control)
				{
					if (rotation > 0) fontsizelistener.incrementSize();
					if (rotation < 0) fontsizelistener.decrementSize();
				}
			}
		}
		
		
		
		
		
		private class FocusListener extends FocusAdapter
		{
			public void focusGained(FocusEvent e)
			{
				if ((tablepanel != null)
				
				 && (e.getSource() == tablepanel.table))
				{
					//  if (e.getSource() == ...
				}
			}
			
			public void focusLost(FocusEvent e)
			{
				if ((tablepanel != null)
				
				 && (e.getSource() == tablepanel.table))
				{
					//  ...
				}
			}
		}
		
		
		
		private void setFrameTitle()
		{
			String title = ((tablepanel != null)
			
			    && (tablepanel.file != null)) ?
			
			//	tablepanel.file.getName() : "";
				
				tablepanel.file.getPath() : "";
			
			if (!titlename.isEmpty())
			{
				if (!title.isBlank())
				
				     title += titleseparator + titlename;
				
				else title += titlename;
			}
			
			frame.setTitle(title);
		}
		
		
		
		
		private class NewListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run() { run(0, 0); }
			
			public void run(int rows, int cols)
			{
				//  Create a new tab and table
				
				TablePanel tablepanel = new TablePanel(rows, cols);
				
				tablepanellist.add(tablepanel);
				
				tabbedpane.addTab(__.untitled, tablepanel);
				
				tabbedpane.setSelectedComponent(tablepanel);
				
				tablepanel.table.requestFocusInWindow();
				
				setMenuItemsEnabled(true);
				
				setFont1(font);
			}
		}
		
		
		
		
		private class OpenListener implements ActionListener
		{
			private String title;
			
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Choose a file
				
				File file = chooseFile(directory);
				
				if (file == null) return;
				
				directory = file.getParent();
				
				String filename = file.getName();
				
				
				//  Open and decrypt the file
				
				byte[] plaindata = open(file);
				
				if (plaindata == null) return;
				
				String text = new String(plaindata);
				
				
				//  Find the number of rows and columns by
				//  counting the number of tabs in the first
				//  (zeroth) row and the number of newlines
				
				String delimiter;
				
				if (text.contains("\t")) delimiter = "\t";
				
				else if (text.contains(";")) delimiter = ";";
				
				else delimiter = ",";
				
				tablepanel.delimiter = delimiter;
				
				String[] tokens = text.split("\n");
				
				int rows = tokens.length;
				
				String token1 = tokens[0];
				
				token1 = token1.replaceAll( delimiter,
				
				    " " + delimiter + " ");
				
				int cols = token1.split(delimiter).length;
				
				
				//  Verify that the file contains
				//  character separated values or csv
				
				if (!FileType.isTable(text))
				{
					String errormessage = __.noncsvfile;
					
					JOptionPane.showMessageDialog(
					
					    frame, errormessage);
					
					return;
				}
				
				
				//  Close the existing table panel if blank
				
				if (getData().replaceAll(",", "").isBlank())
				{
					setData("");
					
					closelistener.run();
				}
				
				//  Create a new table panel
				
				newlistener.run(rows, cols);
				
				
				tablepanel.file = file;
				tablepanel.filechanged = false;
				
				if (Cipher.isEncrypted(file))
				
				     tablepanel.encrypted = true;
				else tablepanel.encrypted = false;
				
				
				//  Display the data
				
				setData(text);
				
				
				//  Clear the stack and save a copy of the new text
				
				tablepanel.undo.clear();
				tablepanel.undo.push();
				
				
				//  Set the frame title
				
				setFrameTitle();
				
				
				//  Set the tab title and color
				
				tabbedpane.setTitleAt(
				
				    tabbedpane.getSelectedIndex(),
				
					tablepanel.file.getName() );
				
				if (tablepanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = tablepanel.table.getForeground();
					Color background = tablepanel.table.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
			}
			
			
			
			private byte[] open(File file)
			{
				title = file.getName();
				
				if (file.length() > 16*1024*1024)
				{
					String errormessage = __.largefile;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] input = null;
				
				try { input = DataStream.read(file); }
				
				catch (IOException ex)
				{
					String message = __.filenotfound;
					
					JOptionPane.showMessageDialog(frame,
					
					    message, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] plaindata = input;
				
				
				if ((tablepanel != null) && getData().isBlank())
				
				    closelistener.run();
				
				if (tablepanel == null)
				
				    newlistener.run();
				
				
				//  Remember to save the file
				//  as encrypted or unencrypted
				
				if (Cipher.isEncrypted(file))
				
				     tablepanel.encrypted = true;
				else tablepanel.encrypted = false;
				
				
				if (tablepanel.encrypted)
				{
					FileDecryptor fd;
					
					fd = new FileDecryptor(frame);
					fd.setFileKey(filekey);
					fd.setPassphrase(SP);
					
					if (tablepanel != null)
					{
						fd.setFont(tablepanel.table.getFont());
						fd.setForeground(tablepanel.table.getForeground());
						fd.setBackground(tablepanel.table.getBackground());
					}
					
					//  Decrypt the file input
					
					plaindata = fd.decrypt(input);
					
					if (plaindata == null)
					{
						tablepanel.encrypted = false;
						
						return null;
					}
					
					filekey = fd.getFileKey();
					
					
					
					//  Decrypt the file name to set the tab title
					
					String name1 = FileNameEncryptor
					
					  .decryptFileName(file.getName(), filekey);
					
					title = name1;
				}
				
				return plaindata;
			}
			
			
			
			private File chooseFile(String directory)
			{
				File file = null;
				
				JFileChooser fc;
				
				fc = new FileChooser(directory);
				
				fc.setFont(font);
				
				int choice = fc.showOpenDialog(frame);
				
				if (choice == JFileChooser.APPROVE_OPTION)
				{
					file = fc.getSelectedFile();
					
					return file;
				}
				
				else if (choice == JFileChooser.CANCEL_OPTION)
				
				     return null;
				
				else return null;
			}
		}
		
		
		
		
		
		private class OpenListFileListener implements ActionListener
		{
		
			//  The user clicks on a file name in the file menu list
			
			//  (the file menu list should contain recently or commonly
			//  used files or files that are important to the user)
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				//  Create a new table panel to display the file
				//
				//  unless there is an open panel and the panel text area is empty
				
				if ((tablepanellist.size() == 0)
				
				 || (tablepanel == null) || !getData().isEmpty())
				
					newlistener.run();
				
				String filename = e.getActionCommand();
				
				for (String filename1 : filenamelist)
				{
					if (filename1.endsWith(filename))
					{
						//  Get the full file name
						
						filename = filename1;
						
						break;
					}
				}
				
				File file = new File(filename);
				
				
				//  Open and decrypt the file
				
				byte[] plaindata = openlistener.open(file);
				
				if (plaindata == null) return;
				
				String text = new String(plaindata);
				
				setData(text);
				
				
				//  Clear the stack and save a copy of the new text
				
				tablepanel.undo.clear();
				tablepanel.undo.push();
				
				
				tablepanel.file = file;
				tablepanel.filechanged = false;
				tablepanel.table.requestFocusInWindow();
				
				tabbedpane.setTitleAt(tabbedpane.getSelectedIndex(),
				
				    tablepanel.file.getName() );
				
				if (tablepanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = tablepanel.table.getForeground();
					Color background = tablepanel.table.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				setFrameTitle();
			}
		}
		
		
		
		
		
		private class SaveListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public int run()
			{
			
				if (tablepanel == null) return 0;
				
				File file = tablepanel.file;
				
				//  If file is null use save as instead of save
				
				if (file == null)
				{
					saveaslistener.run();
					
					return 0;
				}
				
				//  File already exists
				
				boolean encrypted = Cipher.isEncrypted(file);
				
				byte[] data = getData().getBytes();
				
				
				//  Encrypt the data if the table
				//  panel encrypted variable is true
				
				if (tablepanel.encrypted)
				
				    data = Cipher.encrypt(data, filekey);
				
				
				//  Save the file
				
				int result = new SaveFile(frame, __.save)
				
				    .setDirectory(directory) .setFont(font)
				
					.save(data, file, false);
				
				if ((result == JOptionPane.NO_OPTION)
				 || (result == JOptionPane.CANCEL_OPTION)
				 || (result == JOptionPane.CLOSED_OPTION)
				
				 || (result == -1))  return result;
				
				
				
				String filename = tablepanel.file.getName();
				
				tabbedpane.setTitleAt(tabbedpane
				
				   .getSelectedIndex(), filename );
				
				
				if (tablepanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = tablepanel.table.getForeground();
					Color background = tablepanel.table.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				tabbedpane.setTitleAt(tabbedpane
				
				   .getSelectedIndex(), file.getName() );
				
				tablepanel.filechanged = false;
				
				setFrameTitle();
				
				return JOptionPane.YES_OPTION;
			}
		}
		
		
		
		
		
		private class SaveAsListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public void run()
			{
			
				//  Choose a file name,
				//
				//  save the data to the file and
				//
				//  update the current file path
				
				
				JTable table = tablepanel.table;
				
				File file = new SaveFile(frame, __.saveas)
				
				  .setDirectory(directory) .setFont(font) .chooseFile();
				
				if (file == null) return;
				
				directory = file.getParent();
				
				
				byte[] data = getData().getBytes();
				
				//  If the user is reading an existing encrypted file
				//  then the table panel encrypted variable is true
				
				if (tablepanel.encrypted)
				
				    data = Cipher.encrypt(data, filekey);
				
				
				//  If the old file is already encrypted ask if
				//  the user wants to encrypt the new file
				
				boolean encrypted = Cipher.isEncrypted(file);
				
				if (encrypted && !Cipher.isEncrypted(data))
				{
					String message = __.encryptfile + "?";
					
					Object[] options = new Object[] { __.Yes, __.No };
					
					JLabel label = new JLabel(message);
					
					label.setFont(labelfont);
					
					int choice = JOptionPane.showOptionDialog(
					
					    frame, label, null,
					
						JOptionPane.DEFAULT_OPTION,
						JOptionPane.QUESTION_MESSAGE,
						
						    null, options, options[0]);
					
					//  If yes encrypt the data
					
					if (choice == 0)
					{
						//  Display a dialog to select a file key
						
						FileEncryptor fe = new FileEncryptor(frame);
						
						if (tablepanel != null)
						{
							fe.setFont(table.getFont());
							fe.setForeground(table.getForeground());
							fe.setBackground(table.getBackground());
						}
						
						if (filekey != null) fe.setFileKey(filekey);
						
						else if ((SP != null) && !SP.isEmpty())
						
						    fe.setFileKey(Cipher.passphraseToKey(SP));
						
						//  Select and/or confirm the file key
						
						if (fe.selectAndConfirmFileKey(__.encryptfilewithkey))
						{
							//  Update the file key and encrypt the data
							
							filekey = fe.getFileKey();
							
							data = Cipher.encrypt(data, filekey);
						}
					}
				}
				
				
				//  Save the encrypted or unencrypted data to file
				
				int result = new SaveFile(frame, __.save)
				
				    .setDirectory(directory) .setFont(font)
				
					.save(data, file, true);
				
				if ((result == JOptionPane.NO_OPTION)
				 || (result == JOptionPane.CANCEL_OPTION)
				 || (result == JOptionPane.CLOSED_OPTION))
				
				    return;
				
				
				if (Cipher.isEncrypted(file))
				
				    tablepanel.encrypted = true;
				
				
				String filename = file.getName();
				
				if (tablepanel.encrypted && (filename.length() >= 64)
				
				    && Number.isBase16(filename))
				{
					int choice = JOptionPane
					
					   .showConfirmDialog(frame,
					
						__.encryptfilename + " ?");
					
					if (choice == JOptionPane.YES_OPTION)
					{
						//  Re-encrypt the new file name
						
						String name0 = FileNameEncryptor
						
						  .decryptFileName(file.getName(), filekey);
						
						String name1 = FileNameEncryptor
						
						  .encryptFileName(name0, filekey);
						
						String path1 = file.getParent()
						
						    + File.separator + name1;
						
						file.renameTo(new File(path1));
					}
				}
				
				
				
				if (tablepanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = table.getForeground();
					Color background = table.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				
				tabbedpane.setTitleAt(tabbedpane
				
				    .getSelectedIndex(), file.getName() );
				
				tablepanel.filechanged = false;
				tablepanel.file = file;
				
				setFrameTitle();
			}
		}
		
		
		
		private String getData()
		{
			//  reads values from the table and
			//  converts to a csv string
			
			String delimiter = tablepanel.delimiter;
			
			if (delimiter == null) delimiter = "\t";
			
			JTable table = tablepanel.table;
			
			int maxrow = table.getRowCount();
			int maxcol = table.getColumnCount();
			
			StringBuilder sb = new StringBuilder();
			
			for (int i = 0; i < maxrow; i++, sb.append("\n"))
			for (int j = 0; j < maxcol; j++)
			{
				Object value = table.getValueAt(i, j);
				
				if ((value == null) && (j < maxcol -1))
				
				    { sb.append(delimiter); }
				
				if (value == null) continue;
				
				String str = (String) value;
				
				sb.append(str);
				
				if (j < maxcol -1)
				
				    sb.append(delimiter);
			}
			
			String data = sb.toString();
			
			if (data.isBlank())
			
			    data = data.trim();
			
			return data;
		}
		
		
		private void setData(String text)
		{
			setData(text, true);
		}
		
		
		private void setData(String text, boolean expand)
		{
			//  converts a csv string to values
			//  and writes the values to the table
			
			String delimiter = "\t";
			
			if (text.contains("\t")) delimiter = "\t";
			
			else if (text.contains(";")) delimiter = ";";
			
			else delimiter = ",";
			
			tablepanel.delimiter = delimiter;
			
			JTable table = tablepanel.table;
			
			for (int i = 0; i < table.getRowCount(); i++)
			for (int j = 0; j < table.getColumnCount(); j++)
			
			    table.setValueAt("", i, j);
			
			String[] vectors = text.split("\n");
			
			String row = vectors[0];
			
			if (delimiter.equals("\t"))
			
			    row = row .replaceAll("\t", " \t ");
			
			
			//  Count the number of rows and cols and
			//  expand the size of the table if necessary
			
			int rows = vectors.length;
			int cols = row.split(delimiter).length;
			
			if (expand == true)
			
			if (rows > table.getRowCount()
			 || cols > table.getColumnCount())
			{
				setTableSize(rows, cols);
				
				table = tablepanel.table;
			}
			
			for (int i = 0; i < rows && i < table.getRowCount(); i++)
			{
				String[] values = vectors[i].split(delimiter);
				
				for (int j = 0; j < values.length
				
				    && j < table.getColumnCount(); j++)
				
				    table.setValueAt(values[j], i, j);
			}
			
			setColumnWidths(table);
		}
		
		
		
		private void setColumnWidths(JTable table)
		{
			//  auto sizes the column widths to fit the average text length
			
			//  Determine the column widths from the text length
			
			int minlen = 7, maxlen = 32;
			
			int[] lengths = new int[table.getColumnCount()];
			
			for (int j = 0; j < table.getColumnCount(); j++)
			for (int i = 0; i < table.   getRowCount(); i++)
			{
				int len = ((String) table.getValueAt(i, j)).length();
				
				lengths[j] += len;
			}
			
			for (int i = 0; i < lengths.length; i++)
			{
				lengths[i] /= table.getRowCount();
				
				int len = lengths[i];
				
				if (len < minlen) len = minlen;
				if (len > maxlen) len = maxlen;
				
				lengths[i] = len;
			}
			
			//  Disable auto resize so the column widths can be set
			
			table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
			
			//  Set the column widths
			
			int height = font.getSize() + 16;
			
			TableColumnModel cm = table.getColumnModel();
			
			for (int i = 0; i < table.getColumnCount(); i++)
			{
				TableColumn col = cm.getColumn(i);
				
				int len = lengths[i];
				
				int width = (int) (len * height / 2.4);
				
				col.setPreferredWidth(width);
			}
		}
		
		
		
		private void packTable()
		{
			//  shrinks the table size to fit the data
			
			int highrow = getHighestSetRow();
			int highcol = getHighestSetColumn();
			
			setTableSize(highrow, highcol);
		}
		
		
		private int getHighestSetRow()
		{
			//  finds the highest non-empty row
			
			JTable table = tablepanel.table;
			
			int rows = table.getRowCount();
			int cols = table.getColumnCount();
			
			int maxrow = 0, maxcol = 0;
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			{
				Object value = table.getValueAt(i, j);
				
				if ((value != null) && !((String) value).isEmpty())
				{
					if (i > maxrow) maxrow = i;
					if (j > maxcol) maxcol = j;
				}
			}
			
			return maxrow;
		}
		
		
		private int getHighestSetColumn()
		{
			//  finds the highest non-empty column
			
			JTable table = tablepanel.table;
			
			int rows = table.getRowCount();
			int cols = table.getColumnCount();
			
			int maxrow = 0, maxcol = 0;
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			{
				Object value = table.getValueAt(i, j);
				
				if ((value != null) && !((String) value).isEmpty())
				{
					if (i > maxrow) maxrow = i;
					if (j > maxcol) maxcol = j;
				}
			}
			
			return maxcol;
		}
		
		
		
		
		private class DeleteListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				deletefilelistener.run();
			}
		}
		
		
		
		private class PrintListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				try { tablepanel.table.print(); }
				
				catch (PrinterException ex) { System.out.println(ex); }
			}
		}
		
		
		
		private class CloseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public int run()
			{
				if (tablepanellist.size() == 0) return -1;
				
				int choice = JOptionPane.NO_OPTION;
				
				if (tablepanel.filechanged)
				{
					//  String message = __.savefile + " ?";
					
					String message = __.save + " "
					
					    + (tablepanel.file != null ?
					       tablepanel.file.getName() : "") + " ?";
					
					JLabel label = new JLabel(message);
					
					label.setFont(labelfont);
					
					choice = JOptionPane.showConfirmDialog(frame, label);
					
					if ((choice == JOptionPane.CANCEL_OPTION)
					 || (choice == JOptionPane.CLOSED_OPTION))
					
					    return choice;
					
					else if (choice == JOptionPane.YES_OPTION)
					
					    savelistener.run();
				}
				
				if (tablepanellist.size() == 1)
				{
					JTable table = tablepanel.table;
					
					font = table.getFont();
					
					foreground = table.getForeground();
					background = table.getBackground();
				}
				
				tablepanellist.remove(tablepanel);
				
				tabbedpane.remove(tabbedpane.getSelectedIndex());
				
				if (tabbedpane.getSelectedIndex() < 0)
				
				    setMenuItemsEnabled(false);
				
				findlistener.setVisible(false);
				
				setFrameTitle();
				
				return choice;
			}
		}
		
		
		
		private String getPassphrase()
		{
			return SP;
		}
		
		
		private void setPassphrase(String passphrase)
		{
			SP = passphrase;
			
			if (SP == null) return;
			
			SK = Cipher.passphraseToKey(SP);
		}
		
		
		
		private class ExitListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				if (saveFiles() == -1) return;
				
				//  this feature is not implemented yet
				//
				//	saveSettings();
				
				//  If the table frame was created from the
				//  text editor menu item, then disposing
				//  the table frame just hides the frame.
				
				frame.dispose();
			}
			
			
			private int saveFiles()
			{
				//  Save the file for each tab
				
				while (tablepanellist.size() > 0)
				{
					if (tablepanel.filechanged)
					{
						String message = __.save + " "
						
						    + (tablepanel.file != null ?
						       tablepanel.file.getName() : __.file) + " ?";
						
						while (true)
						{
							//  Display the JOptionPane
							
							JLabel label = new JLabel(message);
							
							label.setFont(labelfont);
							
							int choice = JOptionPane
							
							    .showConfirmDialog(frame, label);
							
							if ((choice == JOptionPane.CANCEL_OPTION)
							 || (choice == JOptionPane.CLOSED_OPTION)) return -1;
							
							else if (choice == JOptionPane.NO_OPTION) break;
							
							else if (choice == JOptionPane.YES_OPTION)
							{
								choice = savelistener.run();
								
								if ((choice == JOptionPane.YES_OPTION)
								 || (choice == JOptionPane. NO_OPTION))
								
								    break;
							}
						}
					}
					
					tablepanellist.remove(tablepanel);
					
					tabbedpane.remove(tabbedpane.getSelectedIndex());
				}
				
				//  Create a new table panel so that if the
				//  user closes the table frame from the text
				//  editor and then re-opens the table frame,
				//  the user will have an open table panel
				
				newlistener.run();
				
				return 0;
			}
		}
		
		
		
		private void setForeground1(Color foreground)
		{
			this.foreground = foreground;
			
			for (TablePanel tablepanel : tablepanellist)
			
			    tablepanel.table.setForeground(foreground);
		}
		
		private void setBackground1(Color background)
		{
			this.background = background;
			
			for (TablePanel tablepanel : tablepanellist)
			
			    tablepanel.table.setBackground(background);
		}
		
		
		private void setFont1(Font font)
		{
			//  sets the fonts of the tables and row headers
			//  and adjusts the row heights and column widths
			
			this.font = font;
			
			for (TablePanel tablepanel : tablepanellist)
			{
				JTable table = tablepanel.table;
				JTable rowheader = tablepanel.rowheader;
				
				int fontsize = font.getSize();
				
				int rowheadersize = Math.min(
				
				    24, font.getSize()*3/4);
				
				table.setFont(font);
				
				rowheader.setFont(new Font(font.getName(),
				    Font.PLAIN, rowheadersize));
				
				int height = fontsize + 16;
				
				table    .setRowHeight(height);
				rowheader.setRowHeight(height);
			}
			
			
			//  Change the icon panel sizes
			
			for (int i = 0; i < iconbuttons.length; i++)
			{
				//  Read the original image so the
				//  icon doesn't get distorted
				
				if (imageicons[i] == null) continue;
				
				Image image = imageicons[i].getImage();
				
				int width = font.getSize();
				
				//  Set the max and min icon sizes
				
				if (width > maxiconsize) width = maxiconsize;
				if (width < miniconsize) width = miniconsize;
				
				int height = -1, hints = Image.SCALE_SMOOTH;
				
				image = image.getScaledInstance(width, height, hints);
				
				ImageIcon scaledicon = new ImageIcon(image);
				
				iconbuttons[i].setIcon(scaledicon);
			}
		}
		
		
		
		
		private class TableSizeListener implements ActionListener
		{
		
			private int maxfontsize = 24;
			
			private JTextField textfield1;
			private JTextField textfield2;
			private JTextField textfield3;
			
			private JLabel  timeslabel;
			private JLabel equalslabel;
			
			private int rows, cols;
			
			private Number product;
			
			public void actionPerformed(ActionEvent e)
			{
				textfield1 = new JTextField(7);
				textfield2 = new JTextField(7);
				textfield3 = new JTextField(7);
				
				textfield3.setEditable(false);
				textfield3.setBorder(null);
				
				textfield1.setForeground(foreground);
				textfield2.setForeground(foreground);
				
				textfield1.setCaretColor(foreground);
				textfield2.setCaretColor(foreground);
				
				textfield1.setBackground(background);
				textfield2.setBackground(background);
				
				textfield1.setFont(font);
				textfield2.setFont(font);
				textfield3.setFont(font);
				
				 timeslabel = new JLabel("x");
				equalslabel = new JLabel("=");
				
				 timeslabel.setFont(font);
				equalslabel.setFont(font);
				
				KeyListener1 keylistener1 = new KeyListener1();
				
				textfield1.addKeyListener(keylistener1);
				textfield2.addKeyListener(keylistener1);
				
				Box hbox = Box.createHorizontalBox();
				
				hbox.add(textfield1);  hbox.add(Box.createHorizontalStrut(5));
				hbox.add(timeslabel);  hbox.add(Box.createHorizontalStrut(5));
				hbox.add(textfield2);  hbox.add(Box.createHorizontalStrut(10));
				hbox.add(equalslabel); hbox.add(Box.createHorizontalStrut(10));
				hbox.add(textfield3);
				
				rows = tablepanel.table.getRowCount();
				cols = tablepanel.table.getColumnCount();
				
				textfield1.setText(String.valueOf(rows));
				textfield2.setText(String.valueOf(cols));
				
				product = new Number(rows).multiply(cols);
				
				String M = "";
				
				if (product.longValue() > 1000*1000)
				
				   { product = product.divide(1000*1000); M = "M"; }
				
				String str = Convert.partition(product
				
				    .toString().trim(), ",", -3) + M;
				
				textfield3.setText(String.valueOf(str));
				
				String title = __.enterrowsandcols;
				
				int type = JOptionPane.PLAIN_MESSAGE;
				
				Object[] options = { "OK", "Cancel" };
				
				while (true)
				{
					int choice = JOptionPane.showOptionDialog(
					
					    frame, hbox, title,
					
					      JOptionPane.DEFAULT_OPTION,
					      JOptionPane.PLAIN_MESSAGE,
					
					          null, options, options[0]);
					
					if ((choice == 1) // cancel option
					 || (choice == JOptionPane.CLOSED_OPTION))
					
						return;
					
					String text1 = textfield1.getText();
					String text2 = textfield2.getText();
					
					if (!text1.isEmpty()) rows = Integer.valueOf(text1);
					if (!text2.isEmpty()) cols = Integer.valueOf(text2);
					
					boolean bool = setTableSize(rows, cols);
					
					if (bool) break; // else continue;
				}
			}
			
			
			private class KeyListener1 implements KeyListener
			{
				public void keyPressed (KeyEvent e) {  }
				
				public void keyReleased(KeyEvent e)
				{
					int keycode = e.getKeyCode();
					int keychar = e.getKeyChar();
					
					String text1 = textfield1.getText();
					String text2 = textfield2.getText();
					
					if (text1.isEmpty()) rows = 1;
					if (text2.isEmpty()) cols = 1;
					
					rows = !text1.isEmpty() ? Integer.valueOf(text1) : 1;
					cols = !text2.isEmpty() ? Integer.valueOf(text2) : 1;
					
					product = new Number(rows).multiply(cols);
					
					String M = "";
					
					if (product.intValue() > 1000*1000)
					
					    { M = " M"; }
					
					String str;
					
					if (product.intValue() > 1000*1000)
					
					     str = Convert.partition(product
					
						.divide(1000*1000).toString()
						
						    .trim(), ",", -3) + M;
					
					else str = Convert.partition(product
					
					    .toString().trim(), ",", -3) + M;
					
					textfield3.setText(String.valueOf(str));
				}
				
				public void keyTyped(KeyEvent e)
				{
					int keycode = e.getKeyCode();
					int keychar = e.getKeyChar();
					
					String text1 = textfield1.getText();
					String text2 = textfield2.getText();
					
					JTextField textfield = (JTextField) e.getSource();
					
					String text = textfield.getText();
					
					if ( ((keychar < '0') || (keychar > '9'))
					
					   && (keycode != vk_backspace)) e.consume();
					
					if (text.equals("0") && (keychar == '0')) e.consume();
					
					
					int maxrowdigits = 6, maxcoldigits = 3;
					
					if (e.getSource() == textfield1)
					
					    if (textfield.getText().trim().length() > maxrowdigits)
					
						e.consume();
					
					if (e.getSource() == textfield2)
					
					    if (textfield.getText().trim().length() > maxcoldigits)
					
						e.consume();
					
					if ((textfield2.getText().length() >= 3)
					
					    && (product.intValue() > 1000*1000))
					
						e.consume();
				}
			}
		}
		
		
		
		
		private class UndoListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel == null) return;
				
				if (e.getSource() == undomenuitem) undo();
				if (e.getSource() == redomenuitem) redo();
				
				if (e.getSource() == undobutton) undo();
				if (e.getSource() == redobutton) redo();
			}
			
			public void undo()
			{
				tablepanel.undo.undo();
				
				tablepanel.filechanged = true;
				tablepanel.table.requestFocusInWindow();
			}
			
			public void redo()
			{
				tablepanel.undo.redo();
				
				tablepanel.filechanged = true;
				tablepanel.table.requestFocusInWindow();
			}
		}
		
		
		
		
		private class Undo // table undo
		{
		
			//  This method undoes changes that were made up to the last back-
			//  space key, delete key, or enter key event. The first time that
			//  a delete / backspace / enter key is pressed, the text is pushed
			//  onto the stack, and then for multiple key events the keylistener
			//  keeps popping and pushing the text onto the stack until a non-
			//  delete / backspace / enter key is pressed. It would be wasteful
			//  of memory and inconvenient for the user to undo changes if the
			//  program pushed every key event onto the stack without first pop-
			//  ping the previous change off the stack for multiple key events.
			
			
			private JTable table;
			
			private int stacksize = 128;
			
			private int indexer = 0;
			
			private ArrayList<Object[]> stack;
			
			private boolean undo;
			private boolean redo;
			
			private boolean enter;
			private boolean delete;
			
			
			public Undo(JTable table)
			{
				stack = new ArrayList<Object[]>();
				
				this.table = table;
			}
			
			public void clear()
			{
				stack.clear(); indexer = 0;
			}
			
			public void undo()
			{
				if (stack.size() == 0) return;
				
				if (indexer >= stack.size()) return;
				
				if (indexer < 0) indexer++;
				
				
				//  Replace the current text with the previous text
				
				//  text, cell position, and size (rows, cols)
				
				Object[] text_cp_size = stack.get(indexer++);
				
				String prev = (String) text_cp_size[0];
				Integer[] cp = (Integer[]) text_cp_size[1];
				Integer[] size = (Integer[]) text_cp_size[2];
				
				int row = cp[0], col = cp[1];
				int rows = size[0], cols = size[1];
				
				if ((rows != table.getRowCount())
				 || (cols != table.getColumnCount()))
				{
					setTableSize(rows, cols);
					
					table = tablepanel.table;
				}
				
				setData(prev);
				
				table.changeSelection(
				
				    row, col, false, false);
				
				
				//  Set delete and enter to false so the key listener
				//  will push the next string onto the stack instead
				//  of popping and then pushing onto the stack which
				//  happens if the user keeps typing or clicking the
				//  backspace or enter key.
				
				enter  = false;
				delete = false;
				
				if (redo) { redo = false; undo(); }
				
				undo = true;
			}
			
			
			public void redo()
			{
				if (stack.size() == 0) return;
				
				if (indexer == stack.size()) indexer--;
				
				if (indexer <= 0) indexer++;
				
				
				//  Replace the current text with the previous text
				
				Object[] text_cp_size = stack.get(indexer---1);
				
				String next = (String) text_cp_size[0];
				
				Integer[] cp = (Integer[]) text_cp_size[1];
				
				int row = cp[0], col = cp[1];
				
				Integer[] size = (Integer[]) text_cp_size[2];
				
				int rows = size[0], cols = size[1];
				
				if ((rows != table.getRowCount())
				 || (cols != table.getColumnCount()))
				{
					setTableSize(rows, cols);
					
					table = tablepanel.table;
				}
				
				setData(next);
				
				table.changeSelection(
				
				    row, col, false, false);
				
				
				//  Set delete and enter to false so the key listener
				//  will push the next string onto the stack instead
				//  of popping and then pushing onto the stack which
				//  happens if the user keeps typing or clicking the
				//  backspace or enter key.
				
				enter  = false;
				delete = false;
				
				if (undo) { undo = false; redo(); }
				
				redo = true;
			}
			
			
			
			//  If the keylistener makes changes to the stack by
			//  pushing or popping the textarea text, then if the
			//  indexer is not zero because the user clicked the
			//  undo menu or the undo key code, the push method
			//  deletes the future history and resets the indexer
			//  so that the user is typing in the present instead
			//  of the past.
			
			
			public void push()
			{
				if (indexer != 0)
				{
					//  Delete the elements from 0 to i
					
					for (int i = 0; i < indexer; i++)
					
					    stack.remove(0);
					
					//  Reset the indexer
					
					indexer = 0;
				}
				
				
				String text = getData();
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				if (row < 0) row = 0;
				if (col < 0) col = 0;
				
				//  cp = caret position or cell position
				
				Integer[] cp = new Integer[] { row, col };
				
				int rows = table.getRowCount();
				int cols = table.getColumnCount();
				
				Integer[] size = new Integer[] { rows, cols };
				
				stack.add(0, new Object[] { text, cp, size });
				
				if (stack.size() > stacksize)
				
				    stack.remove(stack.size()-1);
			}
			
			
			public Object[] pop()
			{
				if (indexer != 0)
				{
					//  Delete the elements from 0 to i
					
					for (int i = 0; i < indexer; i++)
					
					    stack.remove(0);
					
					//  Reset the indexer
					
					indexer = 0;
				}
				
				Object[] text_cp_size = stack.remove(0);
				
				return text_cp_size;
			}
		}
		
		
		
		
		private class CutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel == null) return;
				
				//  Save a copy of the table
				
				tablepanel.undo.push();
				
				tablepanel.filechanged = true;
				
				copylistener.run(true);
			}
		}
		
		
		
		private class CopyListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel == null) return;
				
				run(false);
			}
			
			public void run(boolean delete)
			{
				JTable table = tablepanel.table;
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				if ((row < 0) || (col < 0)) return;
				
				int[] rows = table.getSelectedRows();
				int[] cols = table.getSelectedColumns();
				
				String[][] cellvalues = new String[
				
				    rows.length][cols.length];
				
				//  Copy (and delete) the cell data
				
				for (int i = 0; i < rows.length; i++)
				for (int j = 0; j < cols.length; j++)
				{
					cellvalues[i][j] = (String) table
					
					    .getValueAt(rows[0]+i, cols[0]+j);
					
					if (cellvalues[i][j] == null)
					
					     cellvalues[i][j] = "";
					
					if (delete) table.setValueAt("",
					
					    rows[0] + i, cols[0] + j);
				}
				
				//  Convert the cell values to string and copy the
				//  tab / character-separated values to clipboard
				
				StringBuilder sb = new StringBuilder();
				
				for (int i = 0; i < rows.length; i++, sb.append("\n"))
				for (int j = 0; j < cols.length; j++)
				{
					sb.append(cellvalues[i][j]);
					
					if (j < cols.length -1) sb.append("\t");
				}
				
				cb.setContents(new StringSelection(sb.toString()), null);
				
				tablepanel.filechanged = true;
				
				if (delete) table.clearSelection();
			}
		}
		
		
		
		private class PasteListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				//  Paste from clipboard
				
				if (tablepanel == null) return;
				
				JTable table = tablepanel.table;
				
				DataFlavor flavor = DataFlavor.stringFlavor;
				
				String clipboardtext = "";
				
				try { clipboardtext = (String) cb.getData(flavor); }
				
				catch (UnsupportedFlavorException ex) {  }
				catch (IOException ex) { System.out.println(ex); return; }
				
				if (clipboardtext.isEmpty()) return;
				
				//  Save a copy of the table
				
				tablepanel.undo.push();
				
				//  Convert the string to cell values
				
				String text = clipboardtext;
				
				String[] tokens = text.split("\n");
				
				int rows = tokens.length;
				
				String[][] cellvalues = new String[rows][];
				
				ArrayList<String> list;
				
				list = new ArrayList<String>();
				
				int cols = 0;
				
				for (int i = 0; i < tokens.length; i++)
				{
					String token = tokens[i];
					
					int index1 = 0, index2;
					
					while ((index2 = token.indexOf("\t", index1)) != -1)
					{
						String substr = token.substring(index1, index2);
						
						list.add(substr);
						
						index1 = index2 + 1;
					}
					
					list.add(token.substring(index1));
					
					cellvalues[i] = new String[list.size()];
					
					for (int j = 0; j < list.size(); j++)
					
					    cellvalues[i][j] = list.get(j);
					
					if (list.size() > cols) cols = list.size();
					
					list.clear();
				}
				
				
				//  Paste the cell values starting
				//  at the first selected cell
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				if ((row < 0) || (col < 0)) return;
				
				int tablerows = table.getRowCount();
				int tablecols = table.getColumnCount();
				
				if (((row + rows) > tablerows)
				 || ((col + cols) > tablecols))
				{
					int sum1 = row + rows;
					int sum2 = col + cols;
					
					String str1 = __.row + " + " + __.rows + " == " + sum1;
					String str2 = __.col + " + " + __.cols + " == " + sum2;
					
					String message = "";
					
					boolean b1 = sum1 > tablerows;
					boolean b2 = sum2 > tablecols;
					
					message += str1 + (b1 ? " > " + tablerows + " !" : "") + "\n";
					message += str2 + (b2 ? " > " + tablecols + " !" : "");
					
					JOptionPane.showMessageDialog(frame, message,
					
					    "", JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				for (int i = 0; i < cellvalues   .length; i++)
				for (int j = 0; j < cellvalues[i].length; j++)
				
				    table.setValueAt(cellvalues[i][j], row + i, col + j);
				
				tablepanel.filechanged = true;
			}
		}
		
		
		
		
		
		private class FindAndReplace
		{
		
			//  class FindListener
			//  class ReplaceListener
			
			
			private JTextField textfield1;
			private JTextField textfield2;
			
			
			private class FindListener implements ActionListener
			{
			
				private JPanel panel;
				
				private JLabel findreplacelabel;
				
				private JTextArea closearea;
				private JTextArea matchcasearea;
				
				private boolean matchcase;
				
				private Character closechar // x
				
				    = Character.valueOf((char) 10007);
				
				private Character capschar // o
				
				    = Character.valueOf((char) 11093);
				
				
				public void actionPerformed(ActionEvent e)
				{
					setVisible(true);
				}
				
				
				public void setVisible(boolean bool)
				{
					if (menubar.getComponentIndex(panel) == -1)
					{
						//  Add the panel to the menubar
						
						menubar.add(panel);
						
						menubar.setVisible(false);
						menubar.setVisible(true);
					}
					
					findreplacelabel.setText(__.Find);
					
					//  textfield1.setText("");
					//  textfield2.setText("");
					
					panel.setVisible(bool);
					
					textfield1 .setVisible(bool);
					textfield2 .setVisible(false);
					
					if (!textfield2.isVisible())
					
					     textfield1.requestFocusInWindow();
					
					setFont(font);
					
					setColor();
				}
				
				
				
				public FindListener()
				{
				
					textfield1 = new JTextField(16);
					textfield2 = new JTextField(16);
					
					matchcasearea = new JTextArea(1, 1);
					closearea     = new JTextArea(1, 1);
					
					matchcasearea.setToolTipText(__.matchcase);
					
					matchcasearea.setEditable(false);
					matchcasearea.setBackground(
					    new JPanel().getBackground());
					
					closearea.setEditable(false);
					closearea.setBackground(
					    new JPanel().getBackground());
					
					
					findreplacelabel = new JLabel(__.find);
					
					findreplacelabel.setToolTipText(__.click);
					
					
					panel = new JPanel();
					
					Gbc gbc = new Gbc();
					
					gbc.setPosition(0, 0);
					panel.add(closearea, gbc);
					
					gbc.setPosition(1, 0);
					panel.add(findreplacelabel, gbc);
					
					gbc.setPosition(2, 0);
					panel.add(matchcasearea, gbc);
					
					gbc.setPosition(3, 0);
					panel.add(textfield1, gbc);
					
					gbc.setPosition(4, 0);
					panel.add(textfield2, gbc);
					
					
					matchcasearea.addMouseListener(new MouseListener()
					{
						public void mousePressed(MouseEvent e)
						{
							if (!matchcasearea.getText().isBlank())
							{
								matchcasearea.setText("");
								
								matchcase = false;
							}
							
							else
							{	matchcasearea.setText(
								
								    Character.toString(capschar));
								
								matchcase = true;
							}
							
							if (!textfield2.isVisible())
							
							     textfield1.requestFocusInWindow();
						}
					});
					
					
					
					findreplacelabel.addMouseListener(new MouseListener()
					{
						public void mouseClicked(MouseEvent e)
						{
							if (findreplacelabel.getText().equals(__.Find))
							{
								findreplacelabel.setText(__.Replace);
								
								textfield2.setVisible(true);
							}
							
							else if (findreplacelabel.getText().equals(__.Replace))
							{
								findreplacelabel.setText(__.Find);
								
								if (textfield2.hasFocus())
								
								    textfield1.requestFocusInWindow();
								
								textfield2.setVisible(false);
							}
						}
					});
					
					
					closearea.addMouseListener(new MouseListener()
					{
						public void mouseEntered(MouseEvent e)
						{
							closearea.setText(
							
							    Character.toString(closechar));
						}
						
						public void mouseExited(MouseEvent e)
						{
							closearea.setText("");
						}
						
						public void mouseClicked(MouseEvent e)
						{
							findlistener.setVisible(false);
							
							textfield1.setText("");
							textfield2.setText("");
							
							if (tablepanel != null)
							
							    tablepanel.table
							
								.requestFocusInWindow();
						}
					});
					
					
					FocusAdapter focusadapter = new FocusAdapter()
					{
						public void focusLost(FocusEvent e)
						{
							if (tablepanel != null)
							{
							
							}
						}
					};
					
					textfield1.addFocusListener(focusadapter);
					textfield2.addFocusListener(focusadapter);
					
					KeyListener1 keylistener1 = new KeyListener1();
					
					textfield1.addKeyListener(keylistener1);
					textfield2.addKeyListener(keylistener1);
				}
				
				
				
				private class KeyListener1 implements KeyListener
				{
					private boolean shift, control, keypressed;
					
					public void keyPressed(KeyEvent e)
					{
						keypressed = true;
						
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_shift)
						
						    shift = true;
						
						else if (keycode == vk_control)
						
						    control = true;
						
						
						String text1 = textfield1.getText();
						String text2 = textfield2.getText();
						
						if (control && (keycode == __.findkeycode))
						{
							if (shift == false)
							
							     findNext(    text1, matchcase);
							else findPrevious(text1, matchcase);
						}
						
						
						if (control && (keycode == __.replacekeycode))
						
						    if (findreplacelabel.getText().equals(__.Replace))
						{
							JTable table = tablepanel.table;
							
							int row = table.getSelectedRow();
							int col = table.getSelectedColumn();
							
							String text = (String) tablepanel.table.getValueAt(row, col);
							
							if ((text == null) || text.isEmpty() ||
							
							    !text.equalsIgnoreCase(textfield1.getText()))
							{
								if (shift == false)
								
								     findNext(    textfield1.getText(), matchcase);
								else findPrevious(textfield1.getText(), matchcase);
							}
							
							else replace(text1, text2, matchcase);
						}
						
						if (keycode == vk_escape)
						{
							findlistener.setVisible(false);
							
							textfield1.setText("");
							textfield2.setText("");
							
							if (tablepanel != null)
							
							    tablepanel.table
							
								.requestFocusInWindow();
						}
					}
					
					
					public void keyReleased(KeyEvent e)
					{
						keypressed = false;
						
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keycode == vk_shift)
						
						    { shift = false; return; }
						
						else if (keycode == vk_control)
						
						    { control = false; return; }
						
						
						//  If there are any capital letters in the string,
						//  match the case of the string
						
						if ((keychar != vk_enter) && textfield1.hasFocus())
						{
							matchcase = false;
							
							String text1 = textfield1.getText().trim();
							
							for (int i = 0; i < text1.length(); i++)
							{
								int ch = text1.charAt(i);
								
								if ((ch >= 'A') && (ch <= 'Z'))
								{
									matchcase = true;
									
									break;
								}
							}
							
							if (matchcase == true)
							
							    matchcasearea.setText(
							
								Character.toString(capschar));
							
							else matchcasearea.setText("");
						}
					}
					
					
					public void keyTyped(KeyEvent e)
					{
						int keychar = e.getKeyChar();
						int keycode = e.getKeyCode();
						
						if (keychar == vk_enter)
						{
							String text1 = textfield1.getText();
							String text2 = textfield2.getText();
							
							//  Deselect the text in the text fields
							
							textfield1.setText(text1);
							textfield2.setText(text2);
							
							if (e.getSource() == textfield1)
							{
								if (shift == false)
								
								     findNext(    text1, matchcase);
								else findPrevious(text1, matchcase);
							}
							
							else if (e.getSource() == textfield2)
							{
								JTable table = tablepanel.table;
								
								int row = table.getSelectedRow();
								int col = table.getSelectedColumn();
								
								if ((row < 0) || (col < 0)) { row = 0; col = 0; }
								
								String text = (String) table.getValueAt(row, col);
								
								if ((text == null) || text.isEmpty() ||
								
								    !text.equalsIgnoreCase(textfield1.getText()))
								{
									if (shift == false)
									
									     findNext(    textfield1.getText(), matchcase);
									else findPrevious(textfield1.getText(), matchcase);
								}
								
								else replace(text1, text2, matchcase);
							}
						}
					}
				}
				
				
				private void setColor()
				{
					if (tablepanel == null) return;
					
					Color foreground = tablepanel.table.getForeground();
					Color background = tablepanel.table.getBackground();
					
					textfield1.setForeground(foreground);
					textfield2.setForeground(foreground);
					
					textfield1.setCaretColor(foreground);
					textfield2.setCaretColor(foreground);
					
					textfield1.setBackground(background);
					textfield2.setBackground(background);
					
				}
				
				
				private void setFont(Font font)
				{
					//  sets the font of the find box
					
					Font font1 = font.deriveFont((float)
					
					    Math.min(font.getSize(), 24));
					
					textfield1.setFont(font1);
					textfield2.setFont(font1);
				}
			}
			
			//  End class FindListener
			
			
			
			
			
			
			private class ReplaceListener implements ActionListener
			{
			
				private JDialog dialog;
				
				private JTextField textfield1;
				private JTextField textfield2;
				
				private String replacestring;
				
				private JCheckBox matchcasebox;
				
				private boolean matchcase;
				
				private JButton prevbutton;
				private JButton findbutton;
				private JButton replacebutton;
				
				private boolean shift, control;
				
				
				public void actionPerformed(ActionEvent e)
				{
					setVisible(true);
				}
				
				public void setVisible(boolean bool)
				{
					if (!dialog.isVisible())
					{
						textfield1.setText("");
						textfield2.setText("");
						
						matchcasebox.setSelected(false);
						
						textfield1.requestFocusInWindow();
					}
					
					dialog.setVisible(bool);
					
					setFont(font);
					
					setColor();
					
					textfield1.requestFocusInWindow();
				}
				
				
				
				public ReplaceListener()
				{
					KeyListener keylistener = new KeyListener()
					{
						public void keyPressed(KeyEvent e)
						{
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							if (keycode == vk_shift) shift = true;
							
							else if (keycode == vk_control) control = true;
							
							if (control && (keycode == __.findkeycode))
							{
								if (shift == false)
								
								     findNext(    textfield1.getText(), matchcase);
								else findPrevious(textfield1.getText(), matchcase);
							}
							
							else if (control && (keycode == __.replacekeycode))
							{
								JTable table = tablepanel.table;
								
								int row = table.getSelectedRow();
								int col = table.getSelectedColumn();
								
								String text = (String) tablepanel.table.getValueAt(row, col);
								
								if ((text == null) || !text
								
								    .equalsIgnoreCase(textfield1.getText()))
								{
									if (shift == false)
									
									     findNext(    textfield1.getText(), matchcase);
									else findPrevious(textfield1.getText(), matchcase);
								}
								
								else replace(textfield1.getText(),
								             textfield2.getText(), matchcase);
							}
							
							else if (keychar == vk_escape)
							{
								setVisible(false);
							}
						}
						
						
						
						public void keyReleased(KeyEvent e)
						{
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							if (keycode == vk_shift)
							
							    { shift = false; return; }
							
							else if (keycode == vk_control)
							
							    { control = false; return; }
							
							
							if ((e.getSource() == textfield1) && (keychar != vk_enter))
							{
								//  If there are any capital letters in the string,
								//  match the case of the string
								
								matchcase = false;
								
								String str = textfield1.getText().trim();
								
								for (int i = 0; i < str.length(); i++)
								{
									int ch = str.charAt(i);
									
									if ((ch >= 'A') && (ch <= 'Z'))
									{
										matchcase = true;
										
										break;
									}
								}
								
								if (matchcase == true)
								
								     matchcasebox.setSelected(true);
								else matchcasebox.setSelected(false);
							}
						}
						
						
						public void keyTyped(KeyEvent e)
						{
							int keychar = e.getKeyChar();
							int keycode = e.getKeyCode();
							
							if (keychar == vk_enter)
							{
								if (e.getSource() == textfield1)
								{
									findbutton.doClick();
								}
								
								else if (e.getSource() == textfield2)
								{
									replacebutton.doClick();
								}
							}
						}
					};
					
					
					
					ActionListener actionlistener = new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							if (tablepanel == null) return;
							
							if (e.getSource() == prevbutton)
							
							    findPrevious(textfield1.getText(), matchcase);
							
							else if (e.getSource() == findbutton)
							
							    findNext(textfield1.getText(), matchcase);
							
							else if (e.getSource() == replacebutton)
							{
								JTable table = tablepanel.table;
								
								int row = table.getSelectedRow();
								int col = table.getSelectedColumn();
								
								String text = (String) table.getValueAt(row, col);
								
								if ((text == null) || !text.
								
								    equalsIgnoreCase(textfield1.getText()))
								{
									if (shift == false)
									
									     findNext(    textfield1.getText(), matchcase);
									else findPrevious(textfield1.getText(), matchcase);
								}
								
								else replace(textfield1.getText(),
								             textfield2.getText(), matchcase);
							}
						}
					};
					
					
					textfield1 = new JTextField(10);
					textfield2 = new JTextField(10);
					
					FocusAdapter focusadapter = new FocusAdapter()
					{
						public void focusLost(FocusEvent e)
						{
							if (tablepanel != null)
							{
							
							}
						}
					};
					
					
					matchcasebox = new JCheckBox();
					
					matchcasebox.setToolTipText(__.matchcase);
					
					matchcasebox.addActionListener( new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ textfield1.requestFocusInWindow();
					  matchcase = matchcasebox.isSelected(); } } );
					
					
					prevbutton = new JButton(__.Prev);
					findbutton     = new JButton(__.Find);
					replacebutton  = new JButton(__.Replace);
					
					prevbutton.addActionListener(actionlistener);
					findbutton.addActionListener(actionlistener);
					replacebutton .addActionListener(actionlistener);
					
					findbutton.addFocusListener(focusadapter);
					prevbutton.addFocusListener(focusadapter);
					replacebutton.addFocusListener(focusadapter);
					
					textfield1.addFocusListener(focusadapter);
					textfield2.addFocusListener(focusadapter);
					
					textfield1.addKeyListener(keylistener);
					textfield2.addKeyListener(keylistener);
					
					
					Box vbox = Box.createVerticalBox();
					Box hbox = Box.createHorizontalBox();
					
					hbox.add(matchcasebox);
					hbox.add(textfield1);
					hbox.add(Box.createHorizontalStrut(10));
					hbox.add(textfield2);
					
					vbox.add(hbox);
					vbox.add(Box.createVerticalStrut(20));
					hbox = Box.createHorizontalBox();
					
					hbox.add(prevbutton);
					hbox.add(Box.createHorizontalStrut(10));
					hbox.add(findbutton);
					hbox.add(Box.createHorizontalStrut(10));
					hbox.add(replacebutton);
					
					vbox.add(hbox);
					
					JPanel panel = new JPanel();
					
					panel.add(vbox);
					
					
					String title = __.replace;
					
					textfield1.setText("");
					textfield2.setText("");
					
					
					dialog = new JDialog(frame);
					dialog.setResizable(false);
					dialog.add(panel);
					
					dialog.setDefaultCloseOperation(
					
					    JFrame.HIDE_ON_CLOSE);
					
					dialog.setSize(dialog.getPreferredSize());
					
					dialog.setAlwaysOnTop(true);
					dialog.setVisible(false);
				}
				
				
				private void setColor()
				{
					//  sets the color of the replace box
					
					if (tablepanel == null) return;
					
					Color foreground = tablepanel.table.getForeground();
					Color background = tablepanel.table.getBackground();
					
					textfield1.setForeground(foreground);
					textfield2.setForeground(foreground);
					
					textfield1.setCaretColor(foreground);
					textfield2.setCaretColor(foreground);
					
					textfield1.setBackground(background);
					textfield2.setBackground(background);
				}
				
				
				private void setFont(Font font)
				{
					//  sets the font of the replace box
					
					Font font1 = font.deriveFont((float)
					
					    Math.min(font.getSize(), 24));
					
					textfield1.setFont(font1);
					textfield2.setFont(font1);
					
					   prevbutton.setFont(font1);
					   findbutton.setFont(font1);
					replacebutton.setFont(font1);
					
					dialog.setSize(dialog
					
					    .getPreferredSize());
				}
			}
			
			//  End class ReplaceListener
			
			
			
			
			
			
			private void findNext(String text, boolean matchcase)
			{
				if (tablepanel == null) return;
				
				String str = text;
				
				if ((str == null) || str.isEmpty()) return;
				
				JTable table = tablepanel.table;
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				if ((row < 0) || (col < 0)) { row = 0; col = 0; }
				
				int[] sp = findNext(str, row, col, matchcase);
				
				if (sp != null) select(sp[0], sp[1]);
				
				else if (sp == null)
				{
					sp = findNext(str, 0, 0, matchcase);
					
					if (sp != null) select(sp[0], sp[1]);
				}
				
				if (sp != null) table.changeSelection(
				
				    sp[0], sp[1], false, false);
			}
			
			
			
			private void findPrevious(String text, boolean matchcase)
			{
				if (tablepanel == null) return;
				
				String str = text;
				
				if ((str == null) || str.isEmpty()) return;
				
				JTable table = tablepanel.table;
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				int[] sp = findPrevious(str, row, col, matchcase);
				
				if (sp != null) select(sp[0], sp[1]);
				
				else if (sp == null)
				{
					row = table.getRowCount();
					col = table.getColumnCount();
					
					sp = findPrevious(str, row, col, matchcase);
					
					if (sp != null) select(sp[0], sp[1]);
				}
				
				if (sp != null) table.changeSelection(
				
				    sp[0], sp[1], false, false);
			}
			
			
			
			private int[] findNext(String str, int row, int col, boolean matchcase)
			{
				if (str == null) return null;
				
				JTable table = tablepanel.table;
				
				col += 1; if (col >= table.getColumnCount())
				{
					col = 0; row += 1;
					
					if (row >= table.getRowCount()) row = 0;
				}
				
				for (int i = 0; i < table.getRowCount(); i++)
				for (int j = 0; j < table.getColumnCount(); j++)
				{
					if ((i < row) || ((i == row) && (j < col))) continue;
					
					String cellstr = (String) table.getValueAt(i, j);
					
					if (cellstr == null) continue;
					
					if (matchcase == true)
					
					     { if (cellstr.contains(str))  return new int[] { i, j }; }
					else { if (cellstr.toLowerCase().contains(
						       str.toLowerCase())) return new int[] { i, j }; }
				}
				
				return null;
			}
			
			
			
			
			private int[] findPrevious(String str, int row, int col, boolean matchcase)
			{
				if (str == null) return null;
				
				JTable table = tablepanel.table;
				
				col -= 1; if (col < 0)
				{
					col = table.getColumnCount()-1; row -= 1;
					
					if (row < 0) row = 0;
				}
				
				for (int i = table.getRowCount()   -1; i >= 0; i--)
				for (int j = table.getColumnCount()-1; j >= 0; j--)
				{
					if ((i > row) || ((i == row) && (j > col))) continue;
					
					String cellstr = (String) table.getValueAt(i, j);
					
					if (cellstr == null) continue;
					
					if (matchcase == true)
					{
						if (cellstr.contains(str)
						
						     || cellstr.toLowerCase()
						  .contains(str.toLowerCase()))
						
						      return new int[] { i, j };
					}
				}
				
				return null;
			}
			
			
			
			private void replace(String find_string, String replace_string, boolean matchcase)
			{
				if (tablepanel == null) return;
				
				JTable table = tablepanel.table;
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				String celltext = (String) table.getValueAt(row, col);
				
				if (celltext.equalsIgnoreCase(find_string))
				
				    table.setValueAt(replace_string, row, col);
				
				table.setRowSelectionInterval(row, row);
				table.setColumnSelectionInterval(col, col);
				
				tablepanel.filechanged = true;
			}
			
			
			private void select(int row, int col)
			{
				JTable table = tablepanel.table;
				
				table.setRowSelectionInterval(row, row);
				table.setColumnSelectionInterval(col, col);
			}
		}
		
		
		//  End class FindAndReplace
		
		
		
		
		
		
		private class AutoSumListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel == null) return;
				
				JTable table = tablepanel.table;
				
				int[] rows = table.getSelectedRows();
				int[] cols = table.getSelectedColumns();
				
				if ((rows.length <= 1) && (cols.length <= 1))
				{
					String errormessage = __.noselectedcells;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, null, JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				ArrayList<Number> numberlist
				
				    = new ArrayList<Number>();
				
				String firstcell = null;
				String  lastcell = null;
				
				if (rows.length == 1)
				{
					int row = rows[0];
					
					for (int col : cols)
					{
						String celltext = (String) table.getValueAt(row, col);
						
						if ((celltext == null) || celltext.isBlank()) continue;
						
						if ((firstcell == null) || firstcell.isEmpty())
						
						     firstcell = table.getColumnName(col) + (row + 1);
						
						lastcell = table.getColumnName(col) + (row + 1);
						
						if (!Number.isNumberString(celltext, 10))
						{
							String colname = table.getColumnName(col);
							
							String message = __.Cell + " " + colname + " "
							
							    + (row + 1) + " is not a number";
							
							//  JOptionPane.showMessageDialog(frame, message);
							
							//  return;
							
							continue;
						}
						
						numberlist.add(new Number(celltext.trim()));
					}
				}
				
				
				else if (cols.length == 1)
				{
					int col = cols[0];
					
					for (int row : rows)
					{
						String celltext = (String) table.getValueAt(row, col);
						
						if ((celltext == null) || celltext.isBlank()) continue;
						
						if ((firstcell == null) || firstcell.isEmpty())
						
						     firstcell = table.getColumnName(col) + (row + 1);
						
						lastcell = table.getColumnName(col) + (row + 1);
						
						if (!Number.isNumberString(celltext, 10))
						{
							String colname = table.getColumnName(col);
							
							String message = __.Cell + " " + colname + " "
							
							    + (row + 1) + " is not a number";
							
							//  JOptionPane.showMessageDialog(frame, message);
							
							//  return;
							
							continue;
						}
						
						numberlist.add(new Number(celltext.trim()));
					}
				}
				
				if (numberlist.size() == 0) return;
				
				
				//  Sort the numbers
				
				int size = numberlist.size();
				
				Number[] numbers = new Number[size];
				
				for (int i = 0; i < size; i++)
				
				    numbers[i] = numberlist.get(i);
				
				Arrays.sort(numbers);
				
				for (int i = 0; i < size; i++)
				
				    numberlist.set(i, (Number) numbers[i]);
				
				
				Number sum = new Number(0).setPrecision(2);
				for (Number n : numberlist) sum = sum.add(n);
				Number average = sum .divide(numberlist.size());
				Number median = numberlist.get(size/2);
				Number min = numberlist.get(0);
				Number max = numberlist.get(size-1);
				
				String range = firstcell + ":" + lastcell;
				
				String message = "";
				
				message += __.Range + "  " + range + "\n";
				message += __.Sum + "  " + sum + "\n";
				message += __.Average + "  " + average + "\n";
				message += __.Median + "  " + median + "\n";
				message += __.Min + "  " + min + "\n";
				message += __.Max + "  " + max + "\n";
				
				//  Display the message
				
				Font font = tablepanel.table.getFont();
				
				JTextArea textarea = new JTextArea(message);
				
				textarea.setEditable(false);
				textarea.setBackground(
				    new JPanel().getBackground());
				textarea.setFont(font);
				
				int msgtype = JOptionPane.INFORMATION_MESSAGE;
				
				JOptionPane.showMessageDialog(frame, textarea, "", msgtype);
			}
		}
		
		
		
		
		private class TransposeListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e)
			{
			
				if (tablepanel == null) return;
				
				JTable table = tablepanel.table;
				
				int[] rows = table.getSelectedRows();
				int[] cols = table.getSelectedColumns();
				
				if ((rows.length <= 1) && (cols.length <= 1))
				{
					String errormessage = __.noselectedcells;
					
					JOptionPane.showMessageDialog(frame,
					
					    errormessage, null, JOptionPane.ERROR_MESSAGE);
					
					return;
				}
				
				
				//  Save the previous table
				
				tablepanel.undo.push();
				
				
				//  Read the previous table size
				
				int row = table.getSelectedRow();
				int col = table.getSelectedColumn();
				
				
				//  Read the row vectors
				
				String[][] vectors = new String[rows.length][cols.length];
				
				for (int i = 0; i < rows.length; i++)
				for (int j = 0; j < cols.length; j++)
				{
					vectors[i][j] = (String) table.getValueAt(rows[i], cols[j]);
					
					table.setValueAt("", rows[i], cols[j]);
				}
				
				
				//  Expand the table size if necessary
				
				boolean resized = false;
				
				if ((row + vectors[0].length > table.getRowCount())
				 || (col + vectors   .length > table.getColumnCount()))
				{
					resized = setTableSize(
					
					    row + vectors[0].length,
					    col + vectors   .length);
					
					if (!resized) return;
					
					table = tablepanel.table;
				}
				
				//  Rewrite the rows as columns
				
				//  row to row + vectors[0].length;
				//  col to col + vectors   .length;
				
				for (int i = 0; i < vectors   .length; i++)
				for (int j = 0; j < vectors[i].length; j++)
				
				    table.setValueAt(vectors[i][j], row + j, col + i);
				
				if (!resized)
				{
					int r1 = row, r2 = row + vectors[0].length-1;
					int c1 = col, c2 = col + vectors   .length-1;
					
					table.setRowSelectionInterval   (r1, r2);
					table.setColumnSelectionInterval(c1, c2);
				}
				
				setColumnWidths(table);
			}
		}
		
		
		
		
		private class FontSizeListener implements ActionListener
		{
		
			private JPanel panel;
			
			private JButton plusbutton;
			private JButton minusbutton;
			
			private JTextField textfield;
			
			private JCheckBox fontstylebox;
			
			private int fontstyle;
			
			
			private int k = 16;
			
			//  1/16 magnification per click
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				if (tablepanel == null) return;
				
				plusbutton  = new JButton("+");
				minusbutton = new JButton("-");
				
				textfield = new JTextField(4);
				
				textfield.setFont(textfield
				    .getFont().deriveFont(20.0f));
				
				panel = new JPanel();
				
				panel.add(textfield);
				panel.add(minusbutton);
				panel.add(plusbutton);
				
				
				ActionListener actionlistener = new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						if (e.getSource() == plusbutton) incrementSize();
						if (e.getSource() == minusbutton) decrementSize();
						
						if (e.getSource() == textfield)
						
						    tablepanel.table.setFont(
						
							font.deriveFont((float) Integer
							
							    .parseInt(textfield.getText())));
						
						textfield.setText(String.valueOf(
						
						    tablepanel.table.getFont().getSize()));
					}
				};
				
				
				plusbutton .addActionListener(actionlistener);
				minusbutton.addActionListener(actionlistener);
				
				
				textfield.addKeyListener(new KeyAdapter()
				{
					public void keyReleased(KeyEvent e)
					{
						String text = textfield.getText();
						
						int fontsize = !text.isBlank() ?
						
						    Integer.parseInt(textfield.getText()) : 1;
						
						if (fontsize > 1000)
						{
							fontsize = 1000;
							
							textfield.setText(
							
							   String.valueOf(fontsize));
						}
						
						else if (fontsize == 0)
						{
							fontsize = 1;
						}
						
						font = new Font(font.getName(),
						
						    font.getStyle(), fontsize);
						
						tablepanel.table.setFont(font);
					}
					
					
					public void keyTyped(KeyEvent e)
					{
						if ((textfield.getText().trim().length() == 4)
						
						    || !Character.isDigit(e.getKeyChar()))
						
							e.consume();
					}
				});
				
				
				Object[] objarray = new Object[] { panel };
				
				String title = __.changethefontsize;
				
				textfield.setText( String.valueOf(
				
				    tablepanel.table.getFont().getSize()) );
				
				JOptionPane.showMessageDialog(frame, objarray, title, 3);
				
				int size = Integer.parseInt(textfield.getText());
				
				if (size != 0)
				{
					font = new Font(font.getName(),
					
					    font.getStyle(), size);
					
					tablepanel.table.setFont(font);
					
					setFont1(font);
				}
			}
			
			
			
			private void incrementSize()
			{
				String name = font.getName();
				int style   = font.getStyle();
				int size    = font.getSize();
				
				if (size > 1000) return;
				
				if (size < 30)
				
				     font = new Font(name, style, size += 1);
				else font = new Font(name, style, size += size/k);
				
				
				//  Set the font
				
				setFont1(font);
			}
			
			
			
			private void decrementSize()
			{
				String name = font.getName();
				int style   = font.getStyle();
				int size    = font.getSize();
				
				if ((size < 30) && (size > 1))
				{
					font = new Font(name, style, size -= 1);
				}
				
				else
				{	size -= size / k; if (size < 1)  size = 1;
					
					font = new Font(name, style, size);
				}
				
				//  Set the font
				
				setFont1(font);
			}
		}
		
		
		
		
		
		private class TextBoldListener
		
			extends MouseAdapter implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String fontname = font.getName();
				int fontstyle = font.getStyle();
				int fontsize = font.getSize();
				
				if (fontstyle == Font.PLAIN)
				
				    font = new Font(fontname, Font.BOLD, fontsize);
				
				if (fontstyle == Font.BOLD)
				
				    font = new Font(fontname, Font.PLAIN, fontsize);
				
				setFont1(font);
			}
		}
		
		
		
		
		private class FontTypeListener implements ActionListener
		{
		
			private JTextField[] textfields;
			
			private String fontname;
			
			private int style;
			
			private JCheckBox stylebox;
			
			Font font0;
			
			
			public void actionPerformed(ActionEvent e)
			{
				font0 = font;
				
				style = (font != null) ?
				
				    font.getStyle() : Font.PLAIN;
				
				JDialog dialog = getFontDialog(font);
				
				//  JDialog setVisible() blocks
				//  until the dialog is disposed
				//  only if modal is set to true
				
				dialog.setVisible(true);
			}
			
			
			private class MouseListener extends MouseAdapter
			{
				public void mouseClicked(MouseEvent e)
				{
					Object obj = e.getSource();
					
					if (obj instanceof JTextField)
					{
						fontname = ((JTextField) obj).getText();
						
						displayFont();
					}
					
					if (obj instanceof JCheckBox)
					{
						style = stylebox.isSelected() ?
						
						    Font.BOLD : Font.PLAIN;
						
						displayFont();
					}
					
					if (obj instanceof JLabel)
					{
						 stylebox.setSelected(
						!stylebox.isSelected());
						
						style = stylebox.isSelected() ?
						
						    Font.BOLD : Font.PLAIN;
						
						displayFont();
					}
				}
			}
			
			
			private JDialog getFontDialog(Font font)
			{
				//  The font dialog allows the user to select a font type
				//  and shows the user what each font type looks like as
				//  the arrow key is pressed or the mouse is clicked
				
				JLabel stylelabel, fontlabel;
				
				GraphicsEnvironment ge;
				
				ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
				
				String[] fonts = ge.getAvailableFontFamilyNames();
				
				//  for (String font1 : fonts) System.out.println(
				//
				//      Arrays.toString(font1.toCharArray()));
				
				textfields = new JTextField[fonts.length];
				
				MouseListener mouselistener = new MouseListener();
				
				for (int i = 0; i < textfields.length; i++)
				{
					textfields[i] = new JTextField(fonts[i]);
					textfields[i] .setEditable(false);
					textfields[i] .setForeground(foreground);
					textfields[i] .setBackground(background);
					textfields[i] .addMouseListener(mouselistener);
					textfields[i] .setFont(new Font(
					     fonts[i], fontstyle, font.getSize()));
				}
				
				JScrollPane scrollpane = new JScrollPane();
				
				scrollpane.setVerticalScrollBarPolicy(
				    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				
				scrollpane.getVerticalScrollBar().setUnitIncrement(32);
				
				Box vbox = Box.createVerticalBox();
				
				for (JTextField textfield : textfields)
				
				    vbox.add(textfield);
				
				scrollpane.setViewportView(vbox);
				
				
				//   ____________________________
				//  |                            |
				//  |     [ OK ] [ Cancel ]      |
				//  |                            |
				//  |    [x] bold  font name     |
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				//  |____________________________|
				
				stylebox = new JCheckBox();
				stylelabel = new JLabel(__.bold);
				 fontlabel = new JLabel(font.getName());
				JButton okbutton = new JButton(__.OK);
				JButton cancelbutton = new JButton(__.cancel);
				
				stylebox.setSelected(style == Font.BOLD);
				
				stylebox  .addMouseListener(mouselistener);
				stylelabel.addMouseListener(mouselistener);
				
				stylelabel.setFont(font);
				 fontlabel.setFont(font);
				
				Box hbox1 = Box.createHorizontalBox();
				Box hbox2 = Box.createHorizontalBox();
				
				hbox1.add(okbutton);
				hbox1.add(Box.createHorizontalStrut(10));
				hbox1.add(cancelbutton);
				
				hbox2.add(stylebox);
				hbox2.add(stylelabel);
				hbox2.add(Box.createHorizontalStrut(20));
				hbox2.add(fontlabel);
				
				vbox = Box.createVerticalBox();
				
				vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox1);
				vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox2);
				vbox.add(Box.createVerticalStrut(10)); vbox.add(scrollpane);
				
				
				boolean modal = false;
				
				String title = __.selectfonttype;
				
				JDialog dialog = new JDialog(frame, modal);
				
				dialog.setTitle(title);
				
				
				//  Clicking ok or cancel or pressing
				//  the escape key closes the dialog
				
				okbutton .addActionListener( new ActionListener()
				{
				    public void actionPerformed(ActionEvent e)
				    {
					//  Set the new font
					
					Font font1 = font0;
					
					if ((fontname != null) && !fontname.isEmpty())
					
					    font1 = new Font(fontname, style, fontsize);
					
					fontname  = font1.getName();
					fontstyle = font1.getStyle();
					fontsize  = font1.getSize();
					
					setFont1(font1);
					
					dialog.dispose();
				} } );
				
				
				cancelbutton .addActionListener( new ActionListener()
				{ public void actionPerformed(ActionEvent e)
				{ setFont1(font0); dialog.dispose(); } } );
				
				KeyAdapter closelistener = new KeyAdapter()
				{ public void keyPressed(KeyEvent e)
				{ if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				  setFont1(font0); dialog.dispose(); } };
				
				
				scrollpane.addKeyListener(closelistener);
				scrollpane.requestFocusInWindow();
				scrollpane.setHorizontalScrollBarPolicy(
				    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				
				Dimension d = new Dimension(400, 800);
				
				dialog.add(vbox);
				dialog.setResizable(false);
				dialog.setDefaultCloseOperation(
				    JDialog.DISPOSE_ON_CLOSE);
				dialog.setMinimumSize(d);
				
				return dialog;
			}
			
			
			private void displayFont()
			{
				for (JTextField textfield : textfields)
				{
					Font textfieldfont = textfield.getFont();
					
					textfield.setFont(new Font(textfieldfont.getName(),
					
					    style, textfieldfont.getSize()));
				}
				
				if ((fontname == null) || fontname.isEmpty())
				
				    fontname = font.getName();
				
				Font font1 = new Font(fontname, style, font.getSize());
				
				setFont1(font1);
			}
		}
		
		
		
		
		private class ShowGridListener implements ActionListener
		{
			private boolean bool = true;
			
			public void actionPerformed(ActionEvent e)
			{
				tablepanel.table.setShowGrid(bool = !bool);
				
				tablepanel.showgrid = tablepanel.table.getShowHorizontalLines();
			}
		}
		
		
		private class EnableReorderingListener implements ActionListener
		{
			private boolean bool;
			
			public void actionPerformed(ActionEvent e)
			{
				JTableHeader tableheader = tablepanel.table.getTableHeader();
				
				tableheader.setReorderingAllowed(bool = !bool);
			}
		}
		
		
		private class EnableSortingListener implements ActionListener
		{
			private boolean bool;
			
			public void actionPerformed(ActionEvent e)
			{
				//  setting to false doesn't disable the sorter
				
				tablepanel.table.setAutoCreateRowSorter(bool = !bool);
			}
		}
		
		
		
		private class InsertRowsListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				run();
			}
			
			private void run()
			{
				//  for each row copy the cells to the next row(s)
				//  and then copy the row(s) to the target row
				
				JTable table = tablepanel.table;
				
				int rows = table.getRowCount();
				int cols = table.getColumnCount();
				
				int[] r = table.getSelectedRows();
				
				if (r.length == 0) return;
				
				int maxrow = getHighestSetRow();
				
				//  Save the previous table
				
				tablepanel.undo.push();
				
				//  Increase the size of the table
				//  to accommodate the extra rows
				//  if there is not enough space
				
				int d = r.length - (rows -1 - maxrow);
				
				if (d > 0)
				{
					setTableSize(rows + d, cols);
					
					table = tablepanel.table;
					table.setRowSelectionInterval(r[0], r[r.length-1]);
					table.setColumnSelectionInterval(0, cols-1);
					
					run();  return;
				}
				
				int first = r[0], last = r[r.length-1];
				
				rows = table.getRowCount();
				cols = table.getColumnCount();
				
				for (int i = rows-1; i >= last+1; i--)
				for (int j = 0;      j <  cols;   j++)
				
				    table.setValueAt(table
				         .getValueAt(i-r.length, j), i, j);
				
				for (int i = first; i <= last; i++)
				for (int j = 0;     j <  cols; j++)
				
				    table.setValueAt("", i, j);
				
				table.changeSelection(first, 0, false, false);
			}
		}
		
		
		private class DeleteRowsListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				//  for each row copy the cells to the previous row
				
				JTable table = tablepanel.table;
				
				int rows = table.getRowCount();
				int cols = table.getColumnCount();
				
				int[] r = table.getSelectedRows();
				
				int first = r[0], last = r[r.length-1];
				
				for (int i = last+1; i < rows; i++)
				for (int j = 0;      j < cols; j++)
				
				    table.setValueAt(table
				         .getValueAt(i, j), i-r.length, j);
				
				for (int i = rows-1; i > rows-1 -r.length; i--)
				for (int j = 0;      j < cols;             j++)
				
				    table.setValueAt("", i, j);
				
				table.changeSelection(first, 0, false, false);
			}
		}
		
		
		
		private class SetAutoResizeListener implements ActionListener
		{
			private int mode;
			
			public enum ResizeMode
			{
		            AUTO_RESIZE_OFF,
		            AUTO_RESIZE_NEXT_COLUMN,
		            AUTO_RESIZE_SUBSEQUENT_COLUMNS,
		            AUTO_RESIZE_LAST_COLUMN,
		            AUTO_RESIZE_ALL_COLUMNS
			}
			
			public void actionPerformed(ActionEvent e)
			{
				
			}
		}
		
		
		
		private class ColorListener implements ActionListener
		{
		
			private JColorChooser cc;
			
			public ColorListener()
			{
				cc = new JColorChooser();
			}
			
			public void actionPerformed(ActionEvent e)
			{
			
				if (tablepanel == null) return;
				
				JButton textcolorbutton, screencolorbutton, swapcolorsbutton;
				
				textcolorbutton   = new JButton(__.textcolor);
				screencolorbutton = new JButton(__.screencolor);
				swapcolorsbutton  = new JButton(__.swapcolors);
				
				String title = "";
				
				Object[] options = new Object[]
				
				    { textcolorbutton, screencolorbutton, swapcolorsbutton };
				
				
				JTable table = tablepanel.table;
				
				Color screencolor1 = table.getBackground();
				Color   textcolor1 = table.getForeground();
				
				textcolorbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						Color color = cc.getColor();
						
						if (color != null)
						{
							if (!table.getForeground().equals(color))
							
							     setForeground(color);
							
							else setForeground(textcolor1);
						}
					}
				});
				
				
				screencolorbutton.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						Color color = cc.getColor();
						
						if (color != null)
						{
							if (!table.getBackground().equals(color))
							
							     setBackground(color);
							
							else setBackground(screencolor1);
						}
					}
				});
				
				
				swapcolorsbutton.addActionListener(new ActionListener()
				{
					boolean swap;
					
					public void actionPerformed(ActionEvent e)
					{
						Color background = table.getBackground();
						Color foreground = table.getForeground();
						
						setForeground(background);
						setBackground(foreground);
						
						    findlistener.setColor();
						//  gotolinelistener.setColor();
					}
				});
				
				int choice = JOptionPane.showOptionDialog(frame, cc, null,
				
				    JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
				
					null, options, options[0]);
				
				if (choice != JOptionPane.OK_OPTION) return;
				
				else {    }
			}
			
			
			
			public void setForeground(Color color)
			{
				if (tablepanel == null) return;
				
				for (TablePanel tablepanel : tablepanellist)
				{
					tablepanel.table.setForeground(color);
			//		tablepanel.table.setCaretColor(color);
				}
				
				    findlistener.setColor();
			//	gotolinelistener.setColor();
				
				foreground = color;
			//	caretcolor = color;
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					Component comp = tabbedpane.getComponentAt(i);
					
					TablePanel tablepanel = (TablePanel) comp;
					
					if (tablepanel.encrypted)
					{
						if (!foreground.equals(Color.white))
						
						     tabbedpane.setForegroundAt(i, foreground);
						
						else tabbedpane.setForegroundAt(i,
						
						    tablepanel.table.getBackground());
					}
				}
			}
			
			
			public void setBackground(Color color)
			{
				if (tablepanel == null) return;
				
				for (TablePanel tablepanel : tablepanellist)
				
				    tablepanel.table.setBackground(color);
				
				    findlistener.setColor();
			//	gotolinelistener.setColor();
				
				background = color;
			}
		}
		
		
		
		
		private class EncryptDirectoryListener implements ActionListener
		{
			EncryptDirectory ed = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel != null)
				{
					JTable table = tablepanel.table;
					
					ed.setFont      (table.getFont());
					ed.setForeground(table.getForeground());
					ed.setBackground(table.getBackground());
				}
				
				ed.setFileKey(filekey);
				
				ed.encryptDecryptDirectory();
				
				//  Update the file key
				
				if (ed.getFileKey() != null)
				
				    filekey = ed.getFileKey();
			}
		}
		
		
		
		
		private class DecryptDirectoryListener implements ActionListener
		{
			EncryptDirectory dd = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (tablepanel != null)
				{
					JTable table = tablepanel.table;
					
					dd.setFont      (table.getFont());
					dd.setForeground(table.getForeground());
					dd.setBackground(table.getBackground());
				}
				
				dd.setFileKey(filekey);
				
				dd.encryptDecryptDirectory();
				
				//  Update the file key
				
				if (dd.getFileKey() != null)
				
				    filekey = dd.getFileKey();
			}
		}
		
		
		
		
		private class EncryptFileListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Choose a file key
				
				FileEncryptor fe = new FileEncryptor(frame);
				
				if (tablepanel != null)
				{
					JTable table = tablepanel.table;
					
					fe.setFont      (table.getFont());
					fe.setForeground(table.getForeground());
					fe.setBackground(table.getBackground());
				}
				
				//  else fe.setFont(defaultfont);
				
				
				if (filekey != null) fe.setFileKey(filekey);
				
				else if ((SP != null) && !SP.isEmpty())
				
				    fe.setFileKey(Cipher.passphraseToKey(SP));
				
				
				while (true)
				{
					//  Choose a file
					
					File file = fe.chooseFile(directory);
					
					if (file == null) return;
					
					directory = file.getParent();
					
					
					//  File sizes > 32 bits should use FileChannelReader and Writer
					
					if (file.length() >= 2L*1024*1024*1024) return;
					
					//   ...   ...
					
					
					if (Cipher.isEncrypted(file))
					{
						System.out.println(
						
						   __.fileisalreadyencrypted);
						
						continue;
					}
					
					
					//  Encrypt the file
					
					boolean bool = fe.encrypt(file);
					
					if (bool == false) return;
					
					//  Update the file key
					
					filekey = fe.getFileKey();
					
					
					//  if (file name == a current open file) set encrypted = true
					
					for (TablePanel tablepanel : tablepanellist)
					
					    if ((tablepanel != null) && (tablepanel.file != null)
					
						&& tablepanel.file.getName().equals(file.getName()))
					
						    tablepanel.encrypted = true;
					
					//  if (file name == a current open file)
					//
					//  set the tab color to the encrypted color
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						String title = tabbedpane.getTitleAt(i);
						
						//  System.out.println("title == " + title);
						
						if (file.getName().contains(title.trim()))
						{
							int index = tabbedpane.indexOfTab(title);
							
							Color foreground = tablepanel.table.getForeground();
							Color background = tablepanel.table.getBackground();
							
							tabbedpane.setForegroundAt(index, foreground);
							tabbedpane.setBackgroundAt(index, background);
						}
					}
				}
			}
		}
		
		
		
		
		
		private class DecryptFileListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				while (true)
				{
					//  Choose a file
					
					FileDecryptor fd = new FileDecryptor(frame);
					
					if (tablepanel != null)
					{
						JTable table = tablepanel.table;
						
						fd.setFont      (table.getFont());
						fd.setForeground(table.getForeground());
						fd.setBackground(table.getBackground());
					}
					
					//  else fd.setFont(defaultfont);
					
					
					if (filekey != null) fd.setFileKey(filekey);
					
					else if ((SP != null) && !SP.isEmpty())
					
					    fd.setFileKey(Cipher.passphraseToKey(SP));
					
					File file = fd.chooseFile(directory);
					
					if (file == null) return;
					
					directory = file.getParent();
					
					if (!Cipher.isEncrypted(file))
					{
						System.out.println(
						
						   __.fileisnotencrypted);
						
						continue;
					}
					
					//  Decrypt the file
					
					boolean bool = fd.decrypt(file);
					
					if (bool == false) return;
					
					//  Update the file key
					
					filekey = fd.getFileKey();
					
					
					//  if (file name == a current open file) set encrypted = false
					
					for (TablePanel tablepanel : tablepanellist)
					
					    if ((tablepanel != null) && (tablepanel.file != null)
					
						&& tablepanel.file.getName().equals(file.getName()))
						
						    tablepanel.encrypted = false;
					
					//  if (file name == a current open file)
					//
					//  set the tab color to the unencrypted color
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						String title = tabbedpane.getTitleAt(i);
						
						//  System.out.println("title == " + title);
						
						if (file.getName().contains(title.trim()))
						{
							int index = tabbedpane.indexOfTab(title);
							
							tabbedpane.setForegroundAt(index,
							
							    tabbedpane.getForeground());
							
							tabbedpane.setBackgroundAt(index,
							
							    tabbedpane.getBackground());
						}
					}
				}
			}
		}
		
		
		
		
		private class ColorButtonListener
		{
		
			//  The ColorButtonListener could be replaced by a Color
			//  Palette Listener that uses a Popup and a color palette
			//  that has 4 x 8 or 5 x 8 colors but there could be an
			//  option to use buttons to change the colors.
			//
			//  There should also be an option to enable the user
			//  to hide the checkbox and color buttons from the
			//  ColorListener class or Text/Screen Color menu item.
			//
			//  Clicking on the checkbox makes the buttons disappear
			//  but the checkbox | doesn't disappear.
			
			
			private void init()
			{
			
				Colors colors = new Colors();
				
				JLabel colorlabel = new JLabel();
				JLabel closelabel = new JLabel();
				
				colorlabel.setVisible(true);
				
				closelabel.setVisible(false);
				
				JCheckBox checkbox = new JCheckBox();
				
				checkbox .setEnabled(false);
				checkbox .setForeground(
				   new JPanel().getBackground() );
				
				checkbox .add(closelabel);
				
				checkbox .setToolTipText(__.click);
				
				JButton colorbutton1 = new JButton();
				JButton colorbutton2 = new JButton();
				
				colorbutton1 .setVisible(false);
				colorbutton2 .setVisible(false);
				
				colorbutton1 .setForeground(
				 new JPanel().getBackground());
				
				colorbutton2 .setForeground(
				 new JPanel().getBackground());
				
				colorbutton1.addKeyListener(keylistener1);
				colorbutton2.addKeyListener(keylistener1);
				
				
				//  Set the color buttons to the current foreground or background
				
				if ((foreground != null) && !foreground.equals(Color.white))
				{
					for (int i = 0; i < Colors.rgb.length; i++)
					
					    if (foreground .equals(new Color(Colors.rgb[i])))
					
						{ colors.index = i; break; }
				}
				
				else if ((background != null) && !background.equals(Color.white))
				{
					for (int i = 0; i < Colors.rgb.length; i++)
					
					    if (background .equals(new Color(Colors.rgb[i])))
					
						{ colors.index = i; break; }
				}
				
				
				menubar.add(checkbox);
				menubar.add(colorbutton1);
				menubar.add(colorbutton2);
				menubar.add(colorlabel);
				
				MouseListener mouselistener = new MouseListener()
				{
					public void mouseEntered(MouseEvent e)
					{
						colorbutton1.setVisible(true);
						colorbutton2.setVisible(true);
						colorlabel  .setVisible(true);
						
						if (colorbutton1.isVisible()
						 || colorbutton2.isVisible())
						{
							if (colors.index >= 0)
							{
								String message = Colors.colors[colors.index];
								
								colorlabel.setText(message);
							}
						}
					}
					
					public void mouseExited(MouseEvent e)
					{
						colorlabel.setText("");
					}
					
					public void mouseClicked( MouseEvent e) {  }
					public void mouseReleased(MouseEvent e) {  }
					
					public void mousePressed(MouseEvent e)
					{
						if (e.getSource() == checkbox)
						{
							colorbutton1.setVisible(!colorbutton1.isVisible());
							colorbutton2.setVisible(!colorbutton2.isVisible());
							colorlabel  .setVisible(!colorlabel.isVisible());
							
							if (colorbutton1.isVisible()
							 || colorbutton2.isVisible())
							{
								if (colors.index >= 0)
								{
									String message =
									
									    Colors.colors[colors.index];
									
									colorlabel.setText(message);
								}
							}
						}
						
						if (e.getSource() == colorbutton1)
						{
							colors.index--;
							
							if (colors.index < 0) colors.index
							
							    = Colors.rgb.length -1;
						}
						
						if (e.getSource() == colorbutton2)
						{
							colors.index++;
							
							if (colors.index >= Colors.rgb.length)
							
							    colors.index = 0;
						}
						
						if ((e.getSource() == colorbutton1)
						 || (e.getSource() == colorbutton2))
						{
							Color color = new Color(Colors.rgb[colors.index]);
							
							if (!keylistener1.control)
							{
								colorlistener.setForeground(color);
								colorlistener.setBackground(Color.white);
							}
							
							else // if (keylistener1.control)
							{
								colorlistener.setBackground(color);
								colorlistener.setForeground(Color.white);
							}
							
							String message = Colors.colors[colors.index];
							
							colorlabel.setText(message);
						}
					}
				};
				
				checkbox     .addMouseListener(mouselistener);
				colorlabel   .addMouseListener(mouselistener);
				colorbutton1 .addMouseListener(mouselistener);
				colorbutton2 .addMouseListener(mouselistener);
			}
		}
		
		
		
		
		private class AboutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String title = __.about;
				
				String message = program + "  " + version;
				
				Object[] options = { __.license };
				
				int choice = JOptionPane.showOptionDialog(frame,
				
				  message, title, JOptionPane.DEFAULT_OPTION,
				
				    JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION))
				
				    return;
				
				else new LicenseListener().run();
			}
		}
		
		
		
		private class LicenseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				String title = __.softwarelicense;
				
				String document = Documents.gpl;
				
				Documents .display(frame, title,
				
				    document, font, foreground, background);
			}
		}
		
		
		
		
		private class WindowListener1 extends WindowAdapter
		{
		
			public void windowClosing(WindowEvent e)
			{
				exitmenuitem.doClick();
			}
			
			public void windowOpened(WindowEvent e)
			{
				readSettings();
				
				colorbuttonlistener.init();
				
				//  ...   ...
			}
		}
		
		
		private void readSettings()
		{
		
			//  ...
			
			//  ...
		}
	}
	
	
	//  End class TableFrame
	
	
	
	
	
	
	
	
	
	
	public class ImageFrame extends JFrame
	{
	
	
		private static final long serialVersionUID = 1L;
		
		private String version = "0.0";
		
		private JFrame frame;
		
		private JDraggableTabbedPane tabbedpane;
		
		private LabelPanel labelpanel;
		
		private ArrayList<LabelPanel> labelpanellist;
		
		
		private JButton openbutton, closebutton;
		private JButton backbutton, forwardbutton;
		
		private JTextField titlefield;
		
		private String filename; // the current title
		
		
		
		private String fontname = __.monospaced;
		
		private int fontstyle = Font.PLAIN;
		
		private int maxfontsize = 28;
		
		private int fontsize = 20;
		
		private Font font = new Font(
		
		    fontname, fontstyle, fontsize);
		
		private Color foreground, background;
		
		
		private int width  = 800;
		private int height = 600;
		
		private int fitwidthheight = -1;
		
		
		private String program = __.imageviewer;
		
		private String titlename = __.imageviewer;
		
		//  title name can equal Image Viewer
		//  or any program name
		
		
		
		NewListener newlistener;
		OpenListener openlistener;
		OpenDirectoryListener opendirectorylistener;
		DeleteFileListener deletefilelistener;
		CloseListener closelistener;
		PrintListener printlistener;
		ExitListener exitlistener;
		
		
		BackListener backlistener;
		ForwardListener forwardlistener;
		
		ViewListener viewlistener;
		ShowTitleListener showtitlelistener;
		
		EncryptDirectoryListener encryptdirectorylistener;
		DecryptDirectoryListener decryptdirectorylistener;
		
		AboutListener aboutlistener;
		LicenseListener licenselistener;
		
		
		
		
		WindowListener1 windowlistener1;
		ActionListener1 actionlistener1;
		KeyListener1 keylistener1;
		KeyListener1.MouseWheelListener1 mousewheellistener1;
		
		ComponentListener1 componentlistener1;
		ChangeListener changelistener1;
		FocusListener focuslistener;
		MouseListener mouselistener;
		
		
		
		ArrayList<String> filenamelist;
		
		ArrayList<JTextField> textfieldlist;
		
		ArrayList<JMenuItem> listmenuitem;
		
		
		
		JMenuItem[] menuitems;
		
		JMenu filemenu, editmenu, viewmenu, encryptmenu, helpmenu;
		
		
		JMenuItem newmenuitem, openmenuitem, opendirectorymenuitem,
		
		printmenuitem, closemenuitem, exitmenuitem;
		
		JMenuItem copymenuitem, findmenuitem, selectallmenuitem, selectrangemenuitem;
		
		JMenuItem fitwidthmenuitem, fitheightmenuitem, fitimagemenuitem, showtitlemenuitem;
		
		JMenuItem encryptdirectorymenuitem, decryptdirectorymenuitem;
		
		JMenuItem aboutmenuitem, licensemenuitem;
		
		
		
		private JPanel iconpanel;
		
		private ImageIcon[] imageicons;
		private JButton[] iconbuttons;
		
		
		
		
		public ImageFrame()
		{
		
			frame = this;
			frame.setSize(width, height);
			frame.setResizable(true);
			frame.setVisible(true);
			frame.setTitle(titlename);
			frame.setLayout(new GridBagLayout());
			frame.setDefaultCloseOperation(
			    DO_NOTHING_ON_CLOSE);
			
			
			//  Create an array list of LabelPanel to hold the label panels
			
			labelpanellist = new ArrayList<LabelPanel>();
			
			
			//  Define the listeners
			
			windowlistener1 = new WindowListener1();
			actionlistener1 = new ActionListener1();
			
			keylistener1 = new KeyListener1();
			
			componentlistener1 = new ComponentListener1();
			
			changelistener1 = new ChangeListener1();
			
			mousewheellistener1 = keylistener1
			
			    .new MouseWheelListener1();
			
			mouselistener = new MouseListener();
			
			focuslistener = new FocusListener();
			
			
			newlistener = new NewListener();
			openlistener = new OpenListener();
			opendirectorylistener = new OpenDirectoryListener();
			deletefilelistener = new DeleteFileListener(frame);
			printlistener = new PrintListener();
			closelistener = new CloseListener();
			exitlistener = new ExitListener();
			
			backlistener = new BackListener();
			forwardlistener = new ForwardListener();
			
			viewlistener = new ViewListener();
			showtitlelistener = new ShowTitleListener();
			
			encryptdirectorylistener = new EncryptDirectoryListener();
			decryptdirectorylistener = new DecryptDirectoryListener();
			
			aboutlistener = new AboutListener();
			licenselistener = new LicenseListener();
			
			
			//  Create a draggable tabbed pane
			
			tabbedpane = new JDraggableTabbedPane();
			
			tabbedpane.setDragEnabled(true);
			
			tabbedpane.setFocusTraversalPolicy();
			
			//  Add an EventListener or ChangeListener to the JTabbedPane
			//  to update the reference to the selected tab
			
			tabbedpane.addChangeListener(new ChangeListener1());
			
			
			   backbutton = new JButton("<<");
			forwardbutton = new JButton(">>");
			
			ButtonListener buttonlistener = new ButtonListener();
			
			   backbutton  .addActionListener(buttonlistener);
			forwardbutton  .addActionListener(buttonlistener);
			
			   backbutton  .addKeyListener(keylistener1);
			forwardbutton  .addKeyListener(keylistener1);
			
			
			titlefield = new JTextField(32);
			titlefield.setEditable(false);
			titlefield.setFont(font);
			
			titlefield.addMouseListener(mouselistener);
			titlefield.addMouseWheelListener(mousewheellistener1);
			
			titlefield.addFocusListener(focuslistener);
			titlefield.addKeyListener(keylistener1);
			
			
			
			//  Create an icon panel
			
			iconpanel = createIconPanel();
			
			
			//  Add the icon panel and the
			//  JTabbedPane to the frame
			
			Gbc gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setFill(Gbc.horizontal);
			gbc.setAnchor(Gbc.left);
			
			frame.add(iconpanel, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			frame.add(tabbedpane, gbc);
			
			
			
			//  MenuBar,  Menu, Menu Items,  Menu, Menu Items, ...
			
			
			//  MenuBar
			
			
			JMenuBar menubar = new JMenuBar();
			
			frame.setJMenuBar(menubar);
			
			
			
			//  File menu
			
			filemenu = new JMenu(__.file);
			filemenu.setFont(menufont);
			
			newmenuitem = new JMenuItem(__.newkey);
			newmenuitem.addActionListener(newlistener);
			newmenuitem.setFont(menuitemfont);
			filemenu.add(newmenuitem);
			
			openmenuitem = new JMenuItem(__.openfilekey);
			openmenuitem.addActionListener(openlistener);
			openmenuitem.setFont(menuitemfont);
			filemenu.add(openmenuitem);
			
			opendirectorymenuitem = new JMenuItem(__.opendirectorykey);
			opendirectorymenuitem.addActionListener(opendirectorylistener);
			opendirectorymenuitem.setFont(menuitemfont);
			filemenu.add(opendirectorymenuitem);
			
			
			printmenuitem = new JMenuItem(__.printkey);
			printmenuitem.addActionListener(printlistener);
			printmenuitem.setFont(menuitemfont);
			filemenu.add(printmenuitem);
			
			closemenuitem = new JMenuItem(__.closekey);
			closemenuitem.addActionListener(closelistener);
			closemenuitem.setFont(menuitemfont);
			filemenu.add(closemenuitem);
			
			exitmenuitem = new JMenuItem(__.exitkey);
			exitmenuitem.addActionListener(exitlistener);
			exitmenuitem.setFont(menuitemfont);
			filemenu.add(exitmenuitem);
			
			menubar.add(filemenu);
			
			
			
			//  Edit menu
			
			editmenu = new JMenu(__.edit);
			editmenu.setFont(menufont);
			
			//  ...
			
			//  menubar.add(editmenu);
			
			
			
			//  View menu
			
			viewmenu = new JMenu(__.view);
			viewmenu.setFont(menufont);
			
			fitwidthmenuitem = new JMenuItem(__.fitwidth);
			fitwidthmenuitem.addActionListener(viewlistener);
			fitwidthmenuitem.setFont(menuitemfont);
			viewmenu.add(fitwidthmenuitem);
			
			fitheightmenuitem = new JMenuItem(__.fitheight);
			fitheightmenuitem.addActionListener(viewlistener);
			fitheightmenuitem.setFont(menuitemfont);
			viewmenu.add(fitheightmenuitem);
			
			fitimagemenuitem = new JMenuItem(__.fitimage);
			fitimagemenuitem.addActionListener(viewlistener);
			fitimagemenuitem.setFont(menuitemfont);
			viewmenu.add(fitimagemenuitem);
			
			viewmenu.addSeparator();
			
			showtitlemenuitem = new JMenuItem(__.showtitle);
			showtitlemenuitem.addActionListener(showtitlelistener);
			showtitlemenuitem.setFont(menuitemfont);
			viewmenu.add(showtitlemenuitem);
			
			menubar.add(viewmenu);
			
			
			
			//  Encrypt menu
			
			encryptmenu = new JMenu(__.encrypt);
			encryptmenu.setFont(menufont);
			
			encryptdirectorymenuitem = new JMenuItem(__.encryptdirectory);
			encryptdirectorymenuitem.addActionListener(encryptdirectorylistener);
			encryptdirectorymenuitem.setFont(menuitemfont);
			encryptmenu.add(encryptdirectorymenuitem);
			
			decryptdirectorymenuitem = new JMenuItem(__.decryptdirectory);
			decryptdirectorymenuitem.addActionListener(decryptdirectorylistener);
			decryptdirectorymenuitem.setFont(menuitemfont);
			encryptmenu.add(decryptdirectorymenuitem);
			
			
			menubar.add(encryptmenu);
			
			
			
			//  Help menu
			
			helpmenu = new JMenu(__.help);
			helpmenu.setFont(menufont);
			
			aboutmenuitem = new JMenuItem(__.about);
			aboutmenuitem.addActionListener(aboutlistener);
			aboutmenuitem.setFont(menuitemfont);
			helpmenu.add(aboutmenuitem);
			
			
			menubar.add(helpmenu);
			
			setMenuItemsEnabled(false);
			
			
			//  Add the Window and Component listeners
			
			frame.addWindowListener(windowlistener1);
			frame.addComponentListener(componentlistener1);
			
			
			filenamelist = new ArrayList<String>();
			
			textfieldlist = new ArrayList<JTextField>();
			
			listmenuitem = new ArrayList<JMenuItem>();
			
			
			//  ...
			
			//  ...
		}
		
		//  End ImageFrame constructor
		
		
		
		
		
		
		private JPanel createIconPanel()
		{
		
			 openbutton = new JButton();
			closebutton = new JButton();
			
			 openbutton.addActionListener(opendirectorylistener);
			closebutton.addActionListener(closelistener);
			
			 openbutton.setToolTipText(__.open);
			closebutton.setToolTipText(__.close);
			
			imageicons = new ImageIcon[] { openicon, closeicon, };
			iconbuttons = new JButton[] { openbutton, closebutton, };
			
			
			for (JButton button : iconbuttons)
			{
				if (button == null) continue;
				
				button.setContentAreaFilled(false);
				button.setBorderPainted(false);
			}
			
			
			//     backbutton.setContentAreaFilled(false);
			//  forwardbutton.setContentAreaFilled(false);
			
			   backbutton.setBorderPainted(false);
			forwardbutton.setBorderPainted(false);
			
			
			setIconSizes();
			
			
			
			JPanel panel = new JPanel();
			
			panel.setLayout(new GridBagLayout());
			
			
			
			//    open   close     back         forward        file name / title
			//   ______ ______ _____________ _____________ _________________________
			//  |      |      |             |             |                         |
			//  |______|______|_____________|_____________|_________________________|
			//  0      1      2    (14)     16   (14)     30         (20)           50
			
			
			Gbc gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setSize(1, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(2, 0);
			
			panel.add(openbutton, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(1, 0);
			gbc.setSize(1, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(2, 0);
			
			panel.add(closebutton, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(2, 0);
			gbc.setSize(14, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(28, 0);
			
			panel.add(backbutton, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(16, 0);
			gbc.setSize(14, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(28, 0);
			
			panel.add(forwardbutton, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(30, 0);
			gbc.setSize(20, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(40, 0);
			
			panel.add(titlefield, gbc);
			
			
			return panel;
		}
		
		
		
		private void setIconSizes()
		{
			//  sets the icon sizes for the image frame
			
			int miniconsize = 8;
			int maxiconsize = 40;
			
			int width = (int) (1.25*frameSizeToFontSize());
			
			for (int i = 0; i < iconbuttons.length; i++)
			{
				//  Read the original image so the
				//  icon doesn't get distorted
				
				if (imageicons[i] == null) continue;
				
				Image image = imageicons[i].getImage();
				
				//  Set the max and min icon sizes
				
				if (width > maxiconsize) width = maxiconsize;
				if (width < miniconsize) width = miniconsize;
				
				int height = -1, hints = Image.SCALE_SMOOTH;
				
				image = image.getScaledInstance(width, height, hints);
				
				ImageIcon scaledicon = new ImageIcon(image);
				
				iconbuttons[i].setIcon(scaledicon);
			}
		}
		
		
		
		private class ButtonListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (e.getSource() == backbutton)
				
				    backlistener.run();
				
				else if (e.getSource() == forwardbutton)
				
				    forwardlistener.run();
				
				//  else if (e.getSource() ...
				
				//  ...
			}
		}
		
		
		
		
		private class LabelPanel extends JPanel
		{
		
			private static final long serialVersionUID = 1L;
			
			// the scrollpane to hold the label
			
			private JScrollPane scrollpane;
			
			// the label to display the image
			
			private JLabel label;
			
			private boolean filechanged;
			
			private ArrayList<Boolean> encrypted;
			private ArrayList<Image> images;
			private ArrayList<String> pages;
			
			private int currentpage;
			
			
			public LabelPanel()
			{
			
				encrypted = new ArrayList<Boolean>();
				images = new ArrayList<Image>();
				pages  = new ArrayList<String>();
				
				this.setLayout(new GridBagLayout());
				
				label = new JLabel();
				
				label.addMouseListener(mouselistener);
				label.addFocusListener(focuslistener);
				label.addKeyListener(keylistener1);
				
				
				//  Create a scrollpane to hold the label
				
				scrollpane = new JScrollPane(label);
				scrollpane.addMouseWheelListener(mousewheellistener1);
				scrollpane.addKeyListener(keylistener1);
				
				JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
				
				//  System.out.println(scrollbar.getUnitIncrement()); // 1
				
				scrollbar.setUnitIncrement(4);
				
				
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(scrollpane, gbc);
			}
		}
		
		
		//  End class LabelPanel
		
		
		
		
		
		private class ChangeListener1 implements ChangeListener
		{
			public void stateChanged(ChangeEvent e)
			{
				labelpanel = (LabelPanel)
				
				    tabbedpane.getSelectedComponent();
				
				setFrameTitle();
			}
		}
		
		
		
		
		private void setMenuItemsEnabled(boolean bool)
		{
			JMenuItem[] menuitems = new JMenuItem[]
			{
				printmenuitem,
				
				//  ...
			};
			
			for (JMenuItem menuitem : menuitems)
			
			    menuitem.setEnabled(bool);
		}
		
		
		
		
		private class MouseListener extends MouseAdapter
		{
			private JPopupMenu popupmenu;
			
			public MouseListener()
			{
				popupmenu = new JPopupMenu();
				
				JMenuItem menuitem;
				
				//  ...
			}
			
			public void mousePressed(MouseEvent e)
			{
				if (e.getButton() != MouseEvent.BUTTON1)
				
				    popupmenu.show(labelpanel.label, e.getX(), e.getY());
			}
			
			public void mouseReleased(MouseEvent e)
			{
				resizeImage();
			}
		}
		
		
		
		
		private class ActionListener1 implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (e.getSource() == titlefield)
				{
					String command = e.getActionCommand().trim();
					
					if (command.toLowerCase().equals(" ... "))
					{
						String str = titlefield.getText();
						
						boolean bool = openlistener.setImage(str);
					}
				}
			}
		}
		
		
		
		private class KeyListener1 implements KeyListener
		{
		
			//  This is the ImageFrame KeyListener
			
			
			private boolean shift, control;
			
			
			public boolean getShift()
			{
				return shift;
			}
			
			public boolean getControl()
			{
				return control;
			}
			
			public void keyTyped(KeyEvent e)
			{
			
			}
			
			public void keyPressed(KeyEvent e)
			{
			
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				
				if (keycode == vk_shift)
				
				    shift = true;
				
				else if (keycode == vk_control)
				
				    control = true;
				
				
				if (control && (keychar == __.pluskeychar))
				{
					incrementSize();
					
					//  control = false;
				}
				
				else if (control && (keychar == __.minuskeychar))
				{
					decrementSize();
					
					//  control = false;
				}
				
				else if (control && (keycode == __.newkeycode))
				{
					newlistener.run();
					
					control = false;
				}
				
				else if (control && shift && (keycode == __.openkeycode))
				{
					System.out.println("Opening directory");
					
					opendirectorylistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.openkeycode))
				{
					openlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.deletekeycode))
				{
					deletefilelistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.printkeycode))
				{
					printlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.closekeycode))
				{
					closelistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.exitkeycode))
				{
					exitlistener.run();
					
					control = false;
				}
				
				else if ((keycode == vk_backspace) || (keycode == vk_left))
				{
					backlistener.run();
				}
				
				else if ((keycode == vk_space) || (keycode == vk_right))
				{
					forwardlistener.run();
				}
				
				//  else if (control && (keycode == ...))
				//  {
				//  	...
				//  }
			}
			
			
			
			public void keyReleased(KeyEvent e)
			{
			
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				
				if (keycode == vk_shift)
				
				    shift = false;
				
				else if (keycode == vk_control)
				
				    control = false;
				
				 if (keycode == vk_control)
				
				    resizeImage();
			}
			
			
			
			private class MouseWheelListener1 implements MouseWheelListener
			{
				//  This is the ImageFrame MouseWheelListener
				
				private boolean resized;
				
				private int freq = 32; // 32 x per sec
				
				public void mouseWheelMoved(MouseWheelEvent e)
				{
					if (resized) return;
					
					else resized = true;
					
					new Thread(() ->
					{
						try { Thread.sleep(1000 / freq); }
						
						catch (InterruptedException ex) {  };
						
						resized = false;
					
					}).start();
					
					
					int rotation = e.getWheelRotation();
					
					//  ...
					
					if (control == true)
					{
						if (rotation > 0) incrementSize();
						if (rotation < 0) decrementSize();
					}
				}
			}
		}
		
		
		//  End class KeyListener1
		
		
		
		
		
		
		private class FocusListener extends FocusAdapter
		{
			public void focusGained(FocusEvent e)
			{
				if ((labelpanel != null)
				
				 && (e.getSource() == labelpanel.label))
				{
					//  if (e.getSource() == ...)
					
					//  ...
				}
			}
			
			public void focusLost(FocusEvent e)
			{
				if ((labelpanel != null)
				
				  && (e.getSource() == labelpanel.label))
				{
					//  if (e.getSource() == ...)
					
					//  ...
				}
			}
		}
		
		
		
		private void setFrameTitle()
		{
			frame.setTitle(titlename);
		}
		
		
		
		private class NewListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Create a new ImageViewer tab
				
				LabelPanel labelpanel = new LabelPanel();
				
				labelpanellist.add(labelpanel);
				
				tabbedpane.addTab(__.untitled, labelpanel);
				
				tabbedpane.setSelectedComponent(labelpanel);
				
				setMenuItemsEnabled(false);
				
				labelpanel.label.requestFocusInWindow();
			}
		}
		
		
		
		
		private class OpenDirectoryListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Create a new text area panel
				
				if ((labelpanel == null) || (labelpanel.pages.size() != 0))
				
				    newlistener.run();
				
				
				//  Choose a file
				
				File file = openlistener.chooseFile(
				
				     JFileChooser.DIRECTORIES_ONLY);
				 //  JFileChooser.FILES_AND_DIRECTORIES);
				
				if (file == null) return;
				
				if (!file.exists()) // || !file.isDirectory())
				
				    return;
				
				
				String[] filepaths;
				
				if (file.isDirectory())
				{
					//  Read the file names in the directory
					
					String path = file.getPath();
					
					File filedir = new File(path);
					
					String[] filenames = filedir.list();
					
					//  Sort the file names
					
					Arrays.sort(filenames);
					
					filepaths = new String[filenames.length];
					
					for (int i = 0; i < filenames.length; i++)
					
					    filepaths[i] = path + File.separator + filenames[i];
				}
				
				else filepaths = new String[] { file.getPath() };
				
				//  Add the paths to the pages list
				
				for (String filepath : filepaths)
				{
					labelpanel.pages.add(filepath);
					
					labelpanel.images.add(null);
					
					labelpanel.encrypted.add(false);
				}
				
				labelpanel.currentpage = labelpanel.pages.size() -1;
				
				forwardlistener.run();
			}
		}
		
		
		
		
		private class OpenListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			
			public void run()
			{
			
				//  Create a new ImageViewer panel
				
				if ((labelpanel == null)
				
				 || (labelpanellist.size() == 0)
				
				 || (labelpanel.pages.size() != 0))
				
					newlistener.run();
				
				
				//  Choose a file
				
				File file = chooseFile(
				
				    JFileChooser.FILES_ONLY);
				
				if (file == null) return;
				
				String filename = file.getPath();
				
				
				//  Add the names to the pages list
				
				labelpanel.pages.add(filename);
				
				labelpanel.images.add(null);
				
				labelpanel.encrypted.add(false);
				
				labelpanel.currentpage = 0;
				
				
				//  Display the image
				
				boolean bool = this.setImage(filename);
			}
			
			
			
			private File chooseFile(int filetype)
			{
			
				File file = null;
				
				File currentdir = null;
				
				JFileChooser fc;
				
				fc = new FileChooser();
				
				fc.setFont(font);
				
				fc.setFileSelectionMode(filetype);
				
				
				while (true)
				{
					fc.setCurrentDirectory(currentdir);
					
					int choice = fc.showOpenDialog(frame);
					
					if (choice == JFileChooser.APPROVE_OPTION)
					{
						file = fc.getSelectedFile();
						
						if (file.isDirectory())
						{
							currentdir = file;
							
							File[] files = currentdir.listFiles();
							
							boolean containsdir = false;
							
							for (File file1 : files)
							
							    if (file1.isDirectory())
							
								containsdir = true;
							
							if (containsdir) continue;
						}
						
						return file;
					}
					
					else if (choice == JFileChooser.CANCEL_OPTION)
					
					     return null;
					
					else return null;
				}
			}
			
			
			
			private boolean setImage(String filename1)
			{
			
				boolean encrypted = false;
				
				File file = new File(filename1);
				
				if (!file.exists() || file.isDirectory())
				
				    return false;
				
				byte[] imagedata;
				
				try
				{	if (file.length() >= 64*1024*1024)
					
					    return false;
					
					imagedata = DataStream.read(file);
					
					
					if (Cipher.isEncrypted(file))
					{
						encrypted = true;
						
						FileDecryptor fd;
						
						fd = new FileDecryptor(frame);
						fd.setFileKey(filekey);
						fd.setPassphrase(SP);
						fd.setFont(font.deriveFont((float) fontsize));
						
						imagedata = fd.decrypt(imagedata);
						
						filekey = fd.getFileKey();
						
						if (filekey == null) return false;
						
						else filekey = filekey;
					}
					
					Image image = new ImageIcon(imagedata, "").getImage();
					
					if (labelpanel == null) newlistener.run();
					
					labelpanel.images.add(image);
					
					if (encrypted == true)
					
					     labelpanel.encrypted.add(true);
					else labelpanel.encrypted.add(false);
					
					
					Image scaledimage = changeImageSize(image);
					
					ImageIcon scaledicon = new ImageIcon(scaledimage);
					
					labelpanel.label.setIcon(scaledicon);
					
					labelpanel.images.set(labelpanel.currentpage, image);
					
					
					setMenuItemsEnabled(true);
				}
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				
				if (labelpanel.pages.contains(filename1))
				{
					int index = labelpanel.pages.indexOf(filename1);
					
					labelpanel.currentpage = index;
				}
				
				else
				{	labelpanel.pages.add(filename1);
					
					labelpanel.currentpage =
					
					    labelpanel.pages.size()-1;
				}
				
				
				String title = file.getName();
				
				
				//  Decrypt the file name to set the tab title
				
				if (encrypted)
				{
					String name1 = FileNameEncryptor
					
					  .decryptFileName(file.getName(), filekey);
					
					title = name1;
				}
				
				//  Save the decrypted file name
				
				filename = title;
				
				titlefield.setText(title);
				titlefield.setCaretPosition(0);
				
				
				//  Set the tab title and color
				
				String tabtitle = __.untitled;
				
				String parent = file.getParent();
				
				parent = parent.substring(1 + parent
				
				    .lastIndexOf(File.separator));
				
				tabtitle = parent;
				
				
				tabbedpane.setTitleAt(tabbedpane.getSelectedIndex(), tabtitle);
				
				if (labelpanel.encrypted.get(labelpanel.currentpage))
				{
				    tabbedpane.setForegroundAt(tabbedpane.getSelectedIndex(), foreground);
				    tabbedpane.setBackgroundAt(tabbedpane.getSelectedIndex(), background);
				}
				
				return true;
			}
		}
		
		
		
		private void resizeImage()
		{
			//  resizes the image to fit the frame size
			//
			//  (packing the frame would resize the frame to fit the image size)
			
			if ((labelpanel == null) || (labelpanel.images.size() == 0)) return;
			
			Image image = labelpanel.images.get(labelpanel.currentpage);
			
			if (image == null) return;
			
			Image scaledimage = changeImageSize(image);
			
			ImageIcon scaledicon = new ImageIcon(scaledimage);
			
			labelpanel.label.setIcon(scaledicon);
		}
		
		
		
		private Image changeImageSize(Image image)
		{
			//  returns a scaled instance of the image
			
			//  Read the screen width
			
			int width  = frame.getWidth();
			int height = frame.getHeight();
			
			int hints = Image.SCALE_SMOOTH;
			
			//  Set the width = frame width and set the height = -1 (vertical scroll)
			//  Set the height = frame height and set the width = -1 (horizontal scroll)
			//  Set the width and height to the frame width and height (no scroll bars)
			//  (If the width and height = -1 then the original image is not scaled)
			
			if      (fitwidthheight == 1) height = -1;
			else if (fitwidthheight == 0)  width = -1;
			
			image = image.getScaledInstance(width, height, hints);
			
			return image;
		}
		
		
		
		private void incrementSize()
		{
			//  increments the image frame size
			
			float x_y = 1.0f * componentlistener1.getx()
			                 / componentlistener1.gety();
			
			//  Define the magnification
			
			double m = 1.020;
			
			int x = frame.getSize().width;
			
			x = (int) (x * m) + 1;
			
			int y = (int) (x / x_y);
			
			Dimension d = new Dimension(x, y);
			
			frame.setSize(d);
			
			//  Set the font size
			
			float fontsize = frameSizeToFontSize();
			
			Font font = this.font.deriveFont(fontsize);
			
			setFont1(font);
		}
		
		
		private void decrementSize()
		{
			//  decrements the image frame size
			
			float x_y = 1.0f * componentlistener1.getx()
			                 / componentlistener1.gety();
			
			//  Define the minification
			
			double m = 1.020;
			
			int x = frame.getSize().width;
			
			x = (int) (x / m) - 1;
			
			int y = (int) (x / x_y);
			
			Dimension d = new Dimension(x, y);
			
			frame.setSize(d);
			
			//  Set the font size
			
			float fontsize = frameSizeToFontSize();
			
			Font font = this.font.deriveFont(fontsize);
			
			setFont1(font);
		}
		
		
		private int frameSizeToFontSize()
		{
			//  scales the font size to the frame size
			
			//  Read the screen size
			
			Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
			
			int x = frame.getSize().width;
			int y = frame.getSize().height;
			
			int avg = (d.width + d.height) / 2;
			
			double q = 1.0 * x / avg; // ~ 0 to 1
			
			double fontsize = maxfontsize * Math.sqrt(q);
			
			return (int) fontsize;
		}
		
		
		
		private String getPassphrase()
		{
			return SP;
		}
		
		
		private void setPassphrase(String passphrase)
		{
			SP = passphrase;
			
			if (SP == null) return;
			
			SK = Cipher.passphraseToKey(SP);
		}
		
		
		
		private class PrintListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			private void run()
			{
				
			}
		}
		
		
		
		private class CloseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public int run()
			{
				titlefield.setText("");
				
				if (labelpanellist.size() == 0) return -1;
				
				int choice = JOptionPane.NO_OPTION;
				
				labelpanellist.remove(labelpanel);
				
				tabbedpane.remove(tabbedpane.getSelectedIndex());
				
				if (tabbedpane.getSelectedIndex() < 0)
				
				    setMenuItemsEnabled(false);
				
				else
				{	if (labelpanel.label.getIcon() != null)
					
					     setMenuItemsEnabled(true);
					
					else setMenuItemsEnabled(false);
				}
				
				return choice;
			}
		}
		
		
		
		private class ExitListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				frame.dispose();
			}
		}
		
		
		
		private class BackListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				if (labelpanel == null) return;
				
				if (labelpanel.pages.size() < 2) return;
				
				labelpanel.currentpage--;
				
				if (labelpanel.currentpage < 0) // wrap around
				
				    labelpanel.currentpage = labelpanel.pages.size() -1;
				
				String str = labelpanel.pages.get(labelpanel.currentpage);
				
				if (labelpanel.currentpage < labelpanel.images.size())
				{
					Image image = labelpanel.images.get(labelpanel.currentpage);
					
					if (image != null)
					{
						labelpanel.label.setIcon(new ImageIcon(image));
						
						titlefield.setText(filename);
						titlefield.setCaretPosition(0);
						
						setMenuItemsEnabled(true);
					}
				}
				
				boolean bool = openlistener.setImage(str);
				
				titlefield.setText(filename);
				titlefield.setCaretPosition(0);
				
				resizeImage();
			}
		}
		
		
		
		private class ForwardListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				if (labelpanel == null) return;
				
				if (labelpanel.pages.size() < 1) return;
				
				labelpanel.currentpage++;
				
				if (labelpanel.currentpage == labelpanel.pages.size())
				
				    labelpanel.currentpage = 0; // wrap around
				
				String str = labelpanel.pages.get(labelpanel.currentpage);
				
				if (labelpanel.currentpage < labelpanel.images.size())
				{
					Image image = labelpanel.images.get(labelpanel.currentpage);
					
					if (image != null)
					{
						labelpanel.label.setIcon(new ImageIcon(image));
						
						titlefield.setText(filename);
						titlefield.setCaretPosition(0);
						
						setMenuItemsEnabled(true);
					}
				}
				
				boolean bool = openlistener.setImage(str);
				
				titlefield.setText(filename);
				titlefield.setCaretPosition(0);
				
				resizeImage();
			}
		}
		
		
		
		private void setFont1(Font font)
		{
			if ((labelpanel != null) && (titlefield != null))
			
			    titlefield.setFont(font);
			
			setIconSizes();
			
			this.font = font;
		}
		
		
		
		private class ViewListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if      (e.getSource() == fitwidthmenuitem)  { fitwidthheight =  1; }
				else if (e.getSource() == fitheightmenuitem) { fitwidthheight =  0; }
				else if (e.getSource() == fitimagemenuitem)  { fitwidthheight = -1; }
				
				resizeImage();
			}
		}
		
		
		
		private class ShowTitleListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				if (labelpanel == null) return;
				
				 titlefield.setVisible(
				!titlefield. isVisible());
				
				labelpanel.setVisible(false);
				labelpanel.setVisible(true);
			}
		}
		
		
		
		private class EncryptDirectoryListener implements ActionListener
		{
			EncryptDirectory ed = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (labelpanel != null)
				{
					JLabel label = labelpanel.label;
					
					ed.setFont(font);
					ed.setForeground(labelpanel.getForeground());
					ed.setBackground(labelpanel.getBackground());
				}
				
				ed.setFileKey(filekey);
				
				ed.encryptDecryptDirectory();
				
				//  Update the file key
				
				if (ed.getFileKey() != null)
				
				    filekey = ed.getFileKey();
			}
		}
		
		
		
		
		private class DecryptDirectoryListener implements ActionListener
		{
			EncryptDirectory dd = new EncryptDirectory(frame);
			
			public void actionPerformed(ActionEvent e)
			{
				if (labelpanel != null)
				{
					JLabel label = labelpanel.label;
					
					dd.setFont(font);
					dd.setForeground(labelpanel.getForeground());
					dd.setBackground(labelpanel.getBackground());
				}
				
				//  The decryption key is not set for the decrypt directory
				//  listener because many users or companies may want to allow
				//  other users or clients to be able to read or view files or
				//  directories on their computer but not to be able to decrypt
				//  directories to download information to a usb device. Users
				//  who travel to other countries may also be required to pro-
				//  vide access to files on their computers or smartphones but
				//  may not want to allow the directories to be decrypted.
				
				//  Don't set the file key
				
				//  dd.setFileKey(filekey);
				
				dd.encryptDecryptDirectory();
				
				//  Update the file key
				
				if (dd.getFileKey() != null)
				
				    filekey = dd.getFileKey();
			}
		}
		
		
		private class AboutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String title = __.about;
				
				String message = program + "  " + version;
				
				Object[] options = { __.license };
				
				int choice = JOptionPane.showOptionDialog(frame,
				
				  message, title, JOptionPane.DEFAULT_OPTION,
				
				    JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION))
				
					return;
				
				else new LicenseListener().run();
			}
		}
		
		
		private class LicenseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				String title = __.softwarelicense;
				
				String document = Documents.gpl;
				
				Documents .display(frame, title,
				
				    document, font.deriveFont(20.0f),
				
					foreground, background);
			}
		}
		
		
		
		private class ComponentListener1 extends ComponentAdapter
		{
			private boolean resized;
			
			private int freq = 4; // 4 x per sec
			
			//  The resize frequency must be limited or else
			//  the program would become unresponsive if the
			//  user spins the mouse wheel at high speed
			
			private int x = frame.getWidth();
			private int y = frame.getHeight();
			
			public int getx() { return this.x; };
			public int gety() { return this.y; };
			
			public void componentResized(ComponentEvent e)
			{
				if (e.getSource() instanceof JFrame)
				{
					if (resized) return;
					
					else resized = true;
					
					new Thread(() ->
					{
						try { Thread.sleep(1000 / freq); }
						
						catch (InterruptedException ex) {  };
						
						resized = false;
					
					}).start();
					
					
					//  if (!keylistener1.control)
					{
						//  Resize the image and the font
						
						resizeImage();
						
						float fontsize = frameSizeToFontSize();
						
						Font font1 = font.deriveFont(fontsize);
						
						setFont1(font1);
					}
					
					
					if (!keylistener1.control)
					{
						x = frame.getWidth();
						y = frame.getHeight();
					}
				}
			}
		}
		
		
		private class WindowListener1 extends WindowAdapter
		{
		
			public void windowClosing(WindowEvent e)
			{
				exitmenuitem.doClick();
			}
			
			public void windowOpened(WindowEvent e)
			{
				readSettings();
				
				//  ...
			}
			
			public void windowIconified(WindowEvent e)
			{
			
			}
		}
		
		
		private void readSettings()
		{
		
			//  ...
			
			//  ...
		}
	}
	
	
	//  End class ImageFrame
	
	
	
	
	
	
	
	
	
	public class HTMLFrame extends JFrame
	{
	
	
		//  This frame is useful for viewing encrypted HTML files
		
		
		private static final long serialVersionUID = 1L;
		
		private String version = "0.0";
		
		
		private JFrame frame;
		
		private JDraggableTabbedPane tabbedpane;
		
		private EditorPanePanel editorpanepanel;
		
		private ArrayList<EditorPanePanel> editorpanepanellist;
		
		private String fontname = __.monospaced;
		
		private int fontstyle = Font.PLAIN;
		
		private int fontsize = 19;
		
		private Font font = new Font(
		
		    fontname, fontstyle, fontsize);
		
		private Color foreground, background;
		
		private int height = 800, width = 1000;
		
		private String program = __.HTMLEditor;
		
		private String titlename = __.HTMLEditor;
		
		
		
		NewListener newlistener;
		OpenListener openlistener;
		DeleteFileListener deletefilelistener;
		SaveListener savelistener;
		SaveAsListener saveaslistener;
		CloseListener closelistener;
		PrintListener printlistener;
		ExitListener exitlistener;
		
		
		CopyListener copylistener;
		
		FindListener findlistener;
		TextHTMLListener texthtmllistener;
		
		FontSizeListener fontsizelistener;
		
		
		WindowListener1 windowlistener1;
		KeyListener1 keylistener1;
		KeyListener1.MouseWheelListener1 mousewheellistener1;
		
		FocusListener focuslistener;
		MouseListener mouselistener;
		
		Hyperactive hyperactive;
		
		
		
		ArrayList<String> filenamelist;
		
		ArrayList<JTextField> textfieldlist;
		
		ArrayList<JMenuItem> listmenuitem;
		
		
		
		
		//  Program Menus and Items
		
		
		JMenuItem[] menuitems;
		
		JMenu  filemenu, editmenu, viewmenu, helpmenu;
		
		JMenuItem newmenuitem, openmenuitem,
		savemenuitem, saveasmenuitem, printmenuitem,
		closemenuitem, exitmenuitem;
		
		JMenuItem copymenuitem, findmenuitem,
		selectallmenuitem, selectrangemenuitem;
		
		JMenuItem fontsizemenuitem, texthtmlmenuitem;
		
		JMenuItem aboutmenuitem, licensemenuitem;
		
		
		
		
		public HTMLFrame()
		{
		
			frame = this;
			frame.setSize(width, height);
			frame.setResizable(true);
			frame.setVisible(true);
			frame.setTitle(titlename);
			frame.setLayout(new GridBagLayout());
			frame.setDefaultCloseOperation(
			    DO_NOTHING_ON_CLOSE);
			
			
			//  Define the listeners
			
			windowlistener1 = new WindowListener1();
			keylistener1 = new KeyListener1();
			mousewheellistener1 = keylistener1
			    .new MouseWheelListener1();
			
			mouselistener = new MouseListener();
			focuslistener = new FocusListener();
			
			hyperactive = new Hyperactive();
			
			
			//  Create an array list of EditorPanePanel to hold the editor panels
			
			editorpanepanellist = new ArrayList<EditorPanePanel>();
			
			
			//  Create a draggable JTabbedPane
			
			tabbedpane = new JDraggableTabbedPane();
			
			tabbedpane.setDragEnabled(true);
			
			tabbedpane.addMouseListener(mouselistener);
			
			frame.add(tabbedpane);
			
			
			//  Add an EventListener or ChangeListener to the JTabbedPane
			//
			//  to update the reference to the current selected tab
			
			tabbedpane.addChangeListener(new ChangeListener1());
			
			
			//  Add the JTabbedPane to the frame
			
			Gbc gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setSize(1, 1);
			gbc.setAnchor(Gbc.center);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(tabbedpane, gbc);
			
			
			
			//  MenuBar,  Menu, Menu Items,  Menu, Menu Items, ...
			
			
			//  MenuBar
			
			
			JMenuBar menubar = new JMenuBar();
			
			frame.setJMenuBar(menubar);
			
			
			
			//  File menu
			
			filemenu = new JMenu(__.file);
			filemenu.setFont(menufont);
			
			newlistener = new NewListener();
			openlistener = new OpenListener();
			deletefilelistener = new DeleteFileListener(frame);
			savelistener = new SaveListener();
			saveaslistener = new SaveAsListener();
			printlistener = new PrintListener();
			closelistener = new CloseListener();
			exitlistener = new ExitListener();
			
			
			newmenuitem = new JMenuItem(__.newkey);
			newmenuitem.addActionListener(newlistener);
			newmenuitem.setFont(menuitemfont);
			filemenu.add(newmenuitem);
			
			openmenuitem = new JMenuItem(__.openkey);
			openmenuitem.addActionListener(openlistener);
			openmenuitem.setFont(menuitemfont);
			filemenu.add(openmenuitem);
			
			savemenuitem = new JMenuItem(__.savekey);
			savemenuitem.addActionListener(savelistener);
			savemenuitem.setFont(menuitemfont);
			//  filemenu.add(savemenuitem);
			
			saveasmenuitem = new JMenuItem(__.saveaskey);
			saveasmenuitem.addActionListener(saveaslistener);
			saveasmenuitem.setFont(menuitemfont);
			//  filemenu.add(saveasmenuitem);
			
			printmenuitem = new JMenuItem(__.printkey);
			printmenuitem.addActionListener(printlistener);
			printmenuitem.setFont(menuitemfont);
			filemenu.add(printmenuitem);
			
			closemenuitem = new JMenuItem(__.closekey);
			closemenuitem.addActionListener(closelistener);
			closemenuitem.setFont(menuitemfont);
			filemenu.add(closemenuitem);
			
			exitmenuitem = new JMenuItem(__.exitkey);
			exitmenuitem.addActionListener(exitlistener);
			exitmenuitem.setFont(menuitemfont);
			filemenu.add(exitmenuitem);
			
			menubar.add(filemenu);
			
			
			
			
			//  Edit menu
			
			copylistener = new CopyListener();
			findlistener = new FindListener();
			
			editmenu = new JMenu(__.edit);
			editmenu.setFont(menufont);
			
			copymenuitem = new JMenuItem(__.copykey);
			copymenuitem.addActionListener(new CopyListener());
			copymenuitem.setFont(menuitemfont);
			editmenu.add(copymenuitem);
			
			editmenu.addSeparator();
			
			findmenuitem = new JMenuItem(__.findkey);
			findmenuitem.addActionListener(findlistener);
			findmenuitem.setFont(menuitemfont);
			editmenu.add(findmenuitem);
			
			//  ...
			
			menubar.add(editmenu);
			
			
			
			//  View menu
			
			texthtmllistener = new TextHTMLListener();
			fontsizelistener = new FontSizeListener();
			
			viewmenu = new JMenu(__.view);
			viewmenu.setFont(menufont);
			
			texthtmlmenuitem = new JMenuItem(__.texthtml);
			texthtmlmenuitem.addActionListener(texthtmllistener);
			texthtmlmenuitem.setFont(menuitemfont);
			viewmenu.add(texthtmlmenuitem);
			
			
			viewmenu.addSeparator();
			
			fontsizemenuitem = new JMenuItem(__.fontsizekey, fonticon);
			fontsizemenuitem.addActionListener(fontsizelistener);
			fontsizemenuitem.setFont(menuitemfont);
			viewmenu.add(fontsizemenuitem);
			
			//  ...
			
			menubar.add(viewmenu);
			
			
			
			//  Help menu
			
			helpmenu = new JMenu(__.help);
			helpmenu.setFont(menufont);
			
			aboutmenuitem = new JMenuItem(__.about);
			aboutmenuitem.addActionListener(new AboutListener());
			aboutmenuitem.setFont(menuitemfont);
			helpmenu.add(aboutmenuitem);
			
			//  ...
			
			menubar.add(helpmenu);
			
			
			
			//  Add the Window listener
			
			frame.addWindowListener(windowlistener1);
			
			
			filenamelist = new ArrayList<String>();
			
			textfieldlist = new ArrayList<JTextField>();
			
			listmenuitem = new ArrayList<JMenuItem>();
			
			
			//  ...
			
			//  ...
		}
		
		
		//  End HTMLFrame constructor
		
		
		
		
		
		
		
		
		
		private class EditorPanePanel extends JPanel
		{
		
			private static final long serialVersionUID = 1L;
			
			private JEditorPane editorpane;
			
			private File file;
			
			private boolean encrypted;
			
			
			public EditorPanePanel()
			{
			
				this.setLayout(new GridBagLayout());
				
				editorpane = new JEditorPane();
				
				editorpane.setEditable(false);
				editorpane.setFont(font);
				
				editorpane.addMouseListener(mouselistener);
				editorpane.addFocusListener(focuslistener);
				editorpane.addKeyListener(keylistener1);
				editorpane.addHyperlinkListener(hyperactive);
				
				
				JScrollPane scrollpane;
				
				scrollpane = new JScrollPane(editorpane,
				
				    JScrollPane.  VERTICAL_SCROLLBAR_ALWAYS,
				    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
				
				scrollpane.addMouseWheelListener(mousewheellistener1);
				
				
				//  ...
				
				
				Gbc gbc = new Gbc();
				
				
				gbc.setSize(1, 0);
				gbc.setPosition(0, 0);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(scrollpane, gbc);
			}
		}
		
		
		//  End class EditorPanePanel
		
		
		
		
		
		private class ChangeListener1 implements ChangeListener
		{
			public void stateChanged(ChangeEvent e)
			{
				editorpanepanel = (EditorPanePanel)
				
				    tabbedpane.getSelectedComponent();
				
				setFrameTitle();
			}
		}
		
		
		
		private void setMenuItemsEnabled(boolean bool)
		{
			JMenuItem[] menuitems = new JMenuItem[]
			{
				savemenuitem, saveasmenuitem, printmenuitem,
				
				closemenuitem, copymenuitem, findmenuitem,
				
				texthtmlmenuitem,
			};
			
			for (JMenuItem menuitem : menuitems)
			
			    menuitem.setEnabled(bool);
		}
		
		
		
		private class MouseListener extends MouseAdapter
		{
			private JPopupMenu popupmenu, tabpopupmenu;
			
			private JMenuItem cutmenuitem, copymenuitem, pastemenuitem,
			
			    insertrowsmenuitem, deleterowsmenuitem;
			
			public MouseListener()
			{
				popupmenu = new JPopupMenu();
				
				tabpopupmenu = new JPopupMenu();
				
				JMenuItem menuitem;
				
				
				//  Create the tabbed pane popup menu
				
				menuitem = new JMenuItem(__.close);
				menuitem.addActionListener(new CloseListener());
				tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.saveas);
				menuitem.addActionListener(new SaveAsListener());
			//	tabpopupmenu.add(menuitem);
				
				menuitem = new JMenuItem(__.save);
				menuitem.addActionListener(new SaveListener());
			//	tabpopupmenu.add(menuitem);
				
				//  ...
			}
			
			
			public void mousePressed(MouseEvent e)
			{
				if (editorpanepanel == null) return;
				
				if (e.getButton() != MouseEvent.BUTTON1)
				{
					//  if (e.getSource() == editorpanepanel.editorpane)
					//
					//      popupmenu.show(table, e.getX(), e.getY());
					
					if (e.getSource() == tabbedpane)
					
					    tabpopupmenu.show(tabbedpane, e.getX(), e.getY());
				}
			}
			
			public void mouseReleased(MouseEvent e) {  }
			
			public void mouseClicked (MouseEvent e) {  }
		}
		
		
		
		
		private class KeyListener1 implements KeyListener
		{
		
			private boolean shift, control;
			
			public boolean getShift()
			{
				return shift;
			}
			
			public boolean getControl()
			{
				return control;
			}
			
			
			public void keyTyped(KeyEvent e)
			{
			
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				//  ...
			}
			
			
			public void keyPressed(KeyEvent e)
			{
			
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift)
				
				    shift = true;
				
				else if (keycode == vk_control)
				
				    control = true;
				
				String selectedtext = editorpanepanel
				
				    .editorpane .getSelectedText();
				
				if ((keychar == vk_backspace) || (keychar == vk_delete))
				{
				
				}
				
				if (control && (keychar == __.pluskeychar))
				{
					fontsizelistener.incrementSize();
					
					//  control = false;
				}
				
				else if (control && (keychar == __.minuskeychar))
				{
					fontsizelistener.decrementSize();
					
					//  control = false;
				}
				
				else if (control && (keycode == __.newkeycode))
				{
					newlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.openkeycode))
				{
					openlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.deletekeycode))
				{
					deletefilelistener.run();
					
					control = false;
				}
				
				else if (!shift && control && (keycode == __.savekeycode))
				{
					savelistener.run();
					
					control = false;
				}
				
				else if (shift && control && (keycode == __.saveaskeycode))
				{
					saveaslistener.run();
					
					control = false;
					
					shift = false;
				}
				
				else if (control && (keycode == __.printkeycode))
				{
					printlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.closekeycode))
				{
					closelistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.exitkeycode))
				{
					exitlistener.run();
					
					control = false;
				}
				
				else if (control && (keycode == __.findkeycode))
				{
					findlistener.setVisible(true);
					
					control = false;
				}
				
				//  else if (control && (keycode == ...))
				{
					//  ...
				}
			}
			
			
			public void keyReleased(KeyEvent e)
			{
				int keycode = e.getKeyCode();
				int keychar = e.getKeyChar();
				
				if (keycode == vk_shift)
				
				    shift = false;
				
				else if (keycode == vk_control)
				
				    control = false;
			}
			
			
			private class MouseWheelListener1 implements MouseWheelListener
			{
				//  This is the HTML Editor MouseWheelListener
				
				public void mouseWheelMoved(MouseWheelEvent e)
				{
					int rotation = e.getWheelRotation();
					
					//  ...
					
					if (control == true)
					{
						if (rotation > 0) fontsizelistener.incrementSize();
						if (rotation < 0) fontsizelistener.decrementSize();
					}
				}
			}
		}
		
		
		//  End class KeyListener1
		
		
		
		
		
		private class FocusListener extends FocusAdapter
		{
			public void focusGained(FocusEvent e)
			{
				if ((editorpanepanel != null)
				
				  && (e.getSource() == editorpanepanel.editorpane))
				{
					//  if (e.getSource() == ...
				}
				
				
				//  ...
			}
			
			public void focusLost(FocusEvent e)
			{
				if ((editorpanepanel != null)
				
				 && (e.getSource() == editorpanepanel.editorpane))
				{
					
				}
			}
		}
		
		
		
		private void setFrameTitle()
		{
			String title = (editorpanepanel != null)
			
			    && (editorpanepanel.file != null) ?
				editorpanepanel.file.getName() : "";
			
			if (!titlename.isEmpty())
			{
				if (!title.isBlank())
				
				     title += titleseparator + titlename;
				
				else title += titlename;
			}
			
			frame.setTitle(title);
		}
		
		
		
		private class NewListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Create a new html editor tab
				
				EditorPanePanel editorpanepanel;
				
				editorpanepanel = new EditorPanePanel();
				
				editorpanepanellist.add(editorpanepanel);
				
				tabbedpane.addTab(__.untitled, editorpanepanel);
				
				tabbedpane.setSelectedComponent(editorpanepanel);
				
				editorpanepanel.editorpane.requestFocusInWindow();
				
				setMenuItemsEnabled(true);
			}
		}
		
		
		
		
		private class OpenListener implements ActionListener
		{
		
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				//  Create a new editor pane panel
				
				if ((editorpanepanellist.size() == 0)
				 || (editorpanepanel == null)
				
				  || !editorpanepanel.editorpane
				
				    .getText().isEmpty())
				
					newlistener.run();
				
				
				//  Choose a file
				
				File file = chooseFile(directory);
				
				if (file == null) return;
				
				directory = file.getParent();
				
				String filename = file.getName();
				
				boolean bool = this.setPage(file.getPath());
			}
			
			
			
			private boolean setPage(String filename)
			{
			
				if (!filename.endsWith("html")
				 && !filename.endsWith("htm"))
				
				    return false;
				
				boolean encrypted = false;
				
				File file = null;
				
				String address = null;
				
				
				try
				{	file = new File(filename);
					
					if (!file.exists())
					{
						System.out.println(__.filenotfound);
						
						return false;
					}
					
					if (file.isDirectory())
					{
						System.out.println(__.directory);
						
						return false;
					}
					
					if (file.length() >= 4*1024*1024)
					{
						//  System.out.println("File length = "
						//  
						//      + file.length() / 1024 / 1024 + " MB");
						
						return false;
					}
					
					if ((editorpanepanel == null)
					
					 || (editorpanepanel.editorpane == null))
					
					    newlistener.run();
					
					editorpanepanel.editorpane
					
					    .setContentType("text/html");
					
					editorpanepanel.editorpane.getDocument()
					
					    .putProperty("IgnoreCharsetDirective", true);
					
					
					byte[] filedata = DataStream.read(file);
					
					if (Cipher.isEncrypted(file))
					{
						//  Decrypt the file
						
						encrypted = true;
						
						FileDecryptor fd;
						
						fd = new FileDecryptor(frame);
						fd.setFileKey(filekey);
						fd.setPassphrase(SP);
						fd.setFont(font.deriveFont((float) fontsize));
						
						filedata = fd.decrypt(filedata);
						
						filekey = fd.getFileKey();
						
						if (filekey == null) return false;
						
						else filekey = filekey;
					}
					
					String filetext = new String(filedata);
					
					editorpanepanel.editorpane.setText(filetext);
					
					editorpanepanel.file = file;
				}
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				
				//  Set tab title and color
				
				String tabtitle = __.untitled;
				
				if (filename != null)
				
				    tabtitle = new File(filename).getName();
				
				tabbedpane.setTitleAt(tabbedpane.getSelectedIndex(), tabtitle);
				
				if (editorpanepanel.encrypted)
				{
					//  Set the tab color to the encrypted color
					
					int index = tabbedpane.getSelectedIndex();
					
					Color foreground = editorpanepanel.editorpane.getForeground();
					Color background = editorpanepanel.editorpane.getBackground();
					
					if (background.equals(Color.white))
					
					     tabbedpane.setForegroundAt(index, foreground);
					else tabbedpane.setForegroundAt(index, background);
				}
				
				//  Set the frame title
				
				setFrameTitle();
				
				return true;
			}
			
			
			
			private File chooseFile(String directory)
			{
				File file = null;
				
				JFileChooser fc;
				
				fc = new FileChooser(directory);
				
				fc.setFont(font);
				
				int choice = fc.showOpenDialog(frame);
				
				if (choice == JFileChooser.APPROVE_OPTION)
				{
					file = fc.getSelectedFile();
					
					return file;
				}
				
				else if (choice == JFileChooser.CANCEL_OPTION)
				
				     return null;
				
				else return null;
			}
			
			
			
			private byte[] open(File file)
			{
				if (file.length() > 16*1024*1024)
				{
					String message = __.largefile;
					
					JOptionPane.showMessageDialog(frame,
					
					    message, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] input = null;
				
				try { input = DataStream.read(file); }
				
				catch (IOException ex)
				{
					String message = __.filenotfound;
					
					JOptionPane.showMessageDialog(frame,
					
					    message, "", JOptionPane.ERROR_MESSAGE);
					
					return null;
				}
				
				byte[] plaindata = input;
				
				if (!Cipher.isEncrypted(file))
				{
					//  Remember to save as unencrypted file
					
					editorpanepanel.encrypted = false;
				}
				
				else
				{	//  Remember to save as encrypted file
					
					editorpanepanel.encrypted = true;
				}
				
				
				if (editorpanepanel.encrypted)
				{
					FileDecryptor fd;
					
					fd = new FileDecryptor(frame);
					fd.setFileKey(filekey);
					fd.setPassphrase(SP);
					
					if (editorpanepanel != null)
					    fd.setFont(editorpanepanel
						.editorpane.getFont());
					
					plaindata = fd.decrypt(input);
					
					if (plaindata == null)
					{
						editorpanepanel.encrypted = false;
						
						return null;
					}
					
					filekey = fd.getFileKey();
				}
				
				return plaindata;
			}
		}
		
		
		
		
		private class SaveListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
			
			}
		}
		
		
		
		private class SaveAsListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
			
			}
		}
		
		
		
		private String getPassphrase()
		{
			return SP;
		}
		
		
		private void setPassphrase(String passphrase)
		{
			SP = passphrase;
			
			if (SP == null) return;
			
			SK = Cipher.passphraseToKey(SP);
		}
		
		
		
		private class PrintListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				try { editorpanepanel.editorpane.print(); }
				
				catch (PrinterException ex) { System.out.println(ex); }
			}
		}
		
		
		
		
		private class CloseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public int run()
			{
				if (editorpanepanellist.size() == 0) return -1;
				
				int choice = JOptionPane.NO_OPTION;
				
				if (editorpanepanellist.size() == 1)
				{
					JEditorPane editorpane =
					
					    editorpanepanel.editorpane;
					
					font = editorpane.getFont();
				}
				
				editorpanepanellist.remove(editorpanepanel);
				
				tabbedpane.remove(tabbedpane.getSelectedIndex());
				
				if (tabbedpane.getSelectedIndex() < 0)
				
				    setMenuItemsEnabled(false);
				
				setFrameTitle();
				
				return choice;
			}
		}
		
		
		
		
		private class ExitListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				if (editorpanepanellist.size() > 1)
				{
					String title = __.closealltabs;
					
					Object[] options = { __.exit, __.closetab };
					
					int choice = JOptionPane.showOptionDialog(
					
					    frame, "", title, JOptionPane.DEFAULT_OPTION,
					
						JOptionPane.QUESTION_MESSAGE,
						
						    null, options, options[1]);
					
					if ((choice < 0) || (choice > 1)) return;
					
					else if (choice == 1)
					{
						closelistener.run();
						
						return;
					}
					
					//  else (choice == 0)
				}
				
				frame.dispose();
			}
		}
		
		
		
		private class CopyListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				editorpanepanel.editorpane.copy();
			}
		}
		
		
		
		private class PasteListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				editorpanepanel.editorpane.paste();
			}
		}
		
		
		
		private class FindListener implements ActionListener
		{
			public FindListener() {  }
			
			public void actionPerformed(ActionEvent e) {  }
			
			public void setVisible(boolean bool) {  }
			
			public void setFont(Font font) {  }
		}
		
		
		
		private class TextHTMLListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String doctype1 = "text/plain";
				String doctype2 = "text/html";
				
				String contenttype = editorpanepanel.editorpane.getContentType();
				
				String html = editorpanepanel.editorpane.getText();
				
				if (contenttype == doctype1)
				
				    editorpanepanel.editorpane.setContentType(doctype2);
				
				else if (contenttype == doctype2)
				
				    editorpanepanel.editorpane.setContentType(doctype1);
				
				editorpanepanel.editorpane.getDocument()
				
				    .putProperty("IgnoreCharsetDirective", true);
				
				editorpanepanel.editorpane.setText(html);
				
				editorpanepanel.editorpane.setCaretPosition(0);
				
				if (editorpanepanel.editorpane.getContentType() == doctype1)
				{
					editorpanepanel.editorpane.setEditable(true);
					
					editorpanepanel.editorpane.requestFocusInWindow();
					
					if ((foreground != null) && (background != null))
					{
						editorpanepanel.editorpane.setForeground(foreground);
						editorpanepanel.editorpane.setBackground(background);
					}
				}
				
				else
				{	editorpanepanel.editorpane.setEditable(false);
					
					editorpanepanel.editorpane.setForeground(Color.black);
					editorpanepanel.editorpane.setBackground(Color.white);
				}
			}
		}
		
		
		
		
		private class FontSizeListener implements ActionListener
		{
		
			private JPanel panel;
			
			private JButton plusbutton;
			private JButton minusbutton;
			
			private JTextField textfield;
			
			private JCheckBox fontstylebox;
			
			private int fontstyle;
			
			
			private int k = 16;
			
			//  1/16 magnification per click
			
			
			public void actionPerformed(ActionEvent e)
			{
			
				if (editorpanepanel == null) return;
				
				plusbutton  = new JButton("+");
				minusbutton = new JButton("-");
				
				textfield = new JTextField(4);
				
				textfield.setFont(textfield
				    .getFont().deriveFont(20.0f));
				
				
				panel = new JPanel();
				
				//  panel.add(textfield);
				panel.add(minusbutton);
				panel.add(plusbutton);
				
				//  panel.add(fontstylebox);
				
				
				ActionListener actionlistener = new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						if (e.getSource() == plusbutton)
						
						    incrementSize();
						
						else if (e.getSource() == minusbutton)
						
						    decrementSize();
						
						textfield.setText(String.valueOf(
						
						    editorpanepanel.editorpane.getFont().getSize()));
					}
				};
				
				
				plusbutton .addActionListener(actionlistener);
				minusbutton.addActionListener(actionlistener);
				
				
				textfield.addKeyListener(new KeyAdapter()
				{
					public void keyReleased(KeyEvent e)
					{
						String text = textfield.getText();
						
						int fontsize = !text.isBlank() ?
						
						    Integer.parseInt(textfield.getText()) : 1;
						
						if (fontsize > 1000)
						{
							fontsize = 1000;
							
							textfield.setText(
							
							    String.valueOf(fontsize));
						}
						
						else if (fontsize == 0)
						{
							fontsize = 1;
						}
						
						font = new Font(font.getName(),
						
						    font.getStyle(), fontsize);
					}
					
					
					public void keyTyped(KeyEvent e)
					{
						if ((textfield.getText().trim().length() > 2)
						
						    || !Character.isDigit(e.getKeyChar()))
						
							e.consume();
					}
				});
				
				
				fontstyle = editorpanepanel.editorpane.getFont().getStyle();
				
				String title = __.changethefontsize;
				
				textfield.setText( String.valueOf(editorpanepanel
				
				    .editorpane.getFont().getSize()) );
				
				JOptionPane.showMessageDialog(frame,
				
				    new Object[] { panel }, title, 3);
				
				editorpanepanel.editorpane.setFont(font);
			}
			
			
			
			private void incrementSize()
			{
			
				String name = font.getName();
				int style   = font.getStyle();
				int size    = font.getSize();
				
				
				if (size > 1000) return;
				
				if (size < 30)
				
				     font = new Font(name, style, size += 1);
				else font = new Font(name, style, size += size / k);
				
				
				JEditorPane editorpane = editorpanepanel.editorpane;
				
				String text = editorpane.getText();
				
				StringBuilder sb = new StringBuilder(text);
				
				int index = 0;
				
				while ((index = sb.indexOf("font-size: ", index)) != -1)
				{
					int index1, index2;
					
					index1 = index + "font-size: ".length();
					
					String substr = sb.substring(index1, index1 + 8);
					
					index2 = substr.indexOf("px");
					
					if (index2 == -1) index2 = substr.indexOf("em");
					
					if (index2 == -1) { index += 8; continue; }
					
					index2 += index1;
					
					String sizestr = sb.substring(index1, index2);
					
					if (!Number.isNumberString(sizestr, 10))
					
					    { index += 8; continue; }
					
					double size1 = Double.valueOf(sizestr);
					
					size1 *= 1.2;  if (size1 > 40) size1 = 40;
					
					sb.delete(index1, index2);
					
					String numberstr = new Number(size1).add(0.5)
					
					    .round() .toString() .trim();
					
					sb.insert(index1, numberstr);
					
					index += 8;
				}
				
				editorpane.setText(sb.toString());
				
				
				//  Restore the screen position
				
				int cp = editorpanepanel.editorpane.getCaretPosition();
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				editorpanepanel.editorpane. setCaretPosition(cp);
				editorpanepanel.editorpane.moveCaretPosition(cp1);
				editorpanepanel.editorpane. setCaretPosition(cp);
			}
			
			
			
			private void decrementSize()
			{
			
				String name = font.getName();
				int style   = font.getStyle();
				int size    = font.getSize();
				
				if ((size < 30) && (size > 1))
				{
					font = new Font(name, style, size -= 1);
				}
				
				else
				{	size -= size / k; if (size < 1) size = 1;
					
					font = new Font(name, style, size);
				}
				
				
				JEditorPane editorpane = editorpanepanel.editorpane;
				
				String text = editorpane.getText();
				
				StringBuilder sb = new StringBuilder(text);
				
				int index = 0;
				
				while ((index = sb.indexOf("font-size: ", index)) != -1)
				{
					int index1, index2;
					
					index1 = index + "font-size: ".length();
					
					String substr = sb.substring(index1, index1 + 8);
					
					index2 = substr.indexOf("px");
					
					if (index2 == -1) index2 = substr.indexOf("em");
					
					if (index2 == -1) { index += 8; continue; }
					
					index2 += index1;
					
					String sizestr = sb.substring(index1, index2);
					
					if (!Number.isNumberString(sizestr, 10))
					
					    { index += 8; continue; }
					
					double size1 = Double.valueOf(sizestr);
					
					size1 /= 1.2;  if (size1 < 5) size1 = 5;
					
					sb.delete(index1, index2);
					
					String numberstr = new Number(size1) .subtract(0.5)
					
					    .toInteger() .toString() .trim();
					
					sb.insert(index1, numberstr);
					
					index += 8;
				}
				
				editorpane.setText(sb.toString());
				
				//  Restore the screen position
				
				int cp = editorpanepanel.editorpane.getCaretPosition();
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				editorpanepanel.editorpane. setCaretPosition(cp);
				editorpanepanel.editorpane.moveCaretPosition(cp1);
				editorpanepanel.editorpane. setCaretPosition(cp);
			}
		}
		
		
		
		
		
		private class AboutListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e)
			{
				String title = __.about;
				
				String message = program + "  " + version;
				
				Object[] options = { __.license };
				
				int choice = JOptionPane.showOptionDialog(frame,
				
				    message, title, JOptionPane.DEFAULT_OPTION,
				
					JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION))
				
					return;
				
				else new LicenseListener().run();
			}
		}
		
		
		
		private class LicenseListener implements ActionListener
		{
			public void actionPerformed(ActionEvent e) { run(); }
			
			public void run()
			{
				String title = __.softwarelicense;
				
				String document = Documents.gpl;
				
				Documents .display(frame, title,
				
				    document, font, foreground, background);
			}
		}
		
		
		
		private class WindowListener1 extends WindowAdapter
		{
			public void windowClosing(WindowEvent e)
			{
				exitmenuitem.doClick();
			}
			
			
			public void windowOpened(WindowEvent e)
			{
				readSettings();
				
				//  ...
				
				//  ...
			}
		}
		
		
		private void readSettings()
		{
			//  ...
			
			//  ...
		}
	}
	
	
	//  End class HTMLFrame
	
	
	
	
	
	
	
	
	
	
	
	public class Mail
	{
	
	
		private String version = "0.0";
		
		private String titlename = __.POPMail;
		
		private JFrame retrievemailframe;
		
		
		//  shared variables
		
		
		//  secret passphrase and key
		
		private String SP;
		
		private String SP0;
		
		private byte[] SK;
		
		private int passphraseminlength = 16;
		
		private int messagesperscreen = 50;
		
		private String maildirectory;
		
		
		private boolean testmail;
		
		private boolean mailcopytoself = true;
		
		//  these variables will be set to true if email
		//  service providers upgrade their software to
		//  allow users to send and retrieve public keys
		//  or change message states
		
		//////////////////////////////////////
		private boolean sendretrievepublickey;
		private boolean changemessagestate;
		//////////////////////////////////////
		
		//  this variable will be set to true if the
		//  user sends the public key to the server
		//  so the program doesn't keep prompting the
		//  user to send a public key to the server
		
		private boolean sentpublickey;
		
		private String  testpassphrase = "recipient's passphrase";
		private String replypassphrase = "sender's passphrase--";
		
		private KeyboardListener keyboardlistener;
		
		//  Choose a minimum size for partitioning the message
		//  and a linesize < the terminal width = 80 chars
		//
		//  The linesize should be different from the public key
		//  sizes + 16 (the size of 0123456789abcdef) so the base-16
		//  separators don't align in the encrypted text if the cipher-
		//  text is partitioned.
		
		private int linesize = 78;
		private int  minsize = 256;
		
		
		private Dimension d = Toolkit
		
		    .getDefaultToolkit().getScreenSize();
		
		//  1920 * 1080 ~ 2 M,  1366 * 768 ~ 1 M
		
		private double screenarea = d.getWidth() * d.getHeight();
		
		private int screenwidth  = (int) d.getWidth();
		private int screenheight = (int) d.getHeight();
		
		private int minfontsize =  6;
		private int maxfontsize = 20;
		
		
		{	//  Scale the font size so the font size
			//  is proportioned to the screen size
			
			float q = (float) (screenarea / (1024*1024));
			
			float q1 = q - 1; // 0 to 1
			
			// font ~ 20 to 24,25,26,...
			
			minfontsize = (int) (minfontsize + 4.0f*q1);
			maxfontsize = (int) (maxfontsize + 4.0f*q1);
		}
		
		
		
		
		//  Set the font
		
		private int defaultfontsize = maxfontsize;
		private int defaultfontstyle = Font.BOLD;
		private String defaultfontname = __.monospaced;
		
		// = new JTextArea().getFont().getName();
		
		private Font font = new Font(defaultfontname,
		
		    defaultfontstyle, defaultfontsize);
		
		private Font defaultfont = font;
		
		
		//  Define the message states 0 to 9
		
		//  The msg state numbers to send to the server
		//  and / or save in the message states file
		
		private static enum MessageState
		{
			unread,  // new envelope gold star
			read,    // opened envelope
			replied, // curved left arrow
			delete,  // trash can or an x
			important, // red exclamation point
			urgent,  // red circular clock
			spam,    // trash can
			star,    // star
			save,    // save
		}
		
		
		
		private class SendMailFrame extends JFrame
		{
		
			private static final long serialVersionUID = 1L;
			
			private JFrame frame;
			
			private boolean disposed;
			
			private JLabel[] labels;
			private JLabel[] iconlabels;
			
			private JLabel   tolabel;
			private JLabel fromlabel;
			private JLabel subjlabel;
			
			private JTextField   tofield;
			private JTextField fromfield;
			private JTextField subjfield;
			
			private JTextField[] textfields;
			
			private JLabel keyiconlabel;
			
			private JButton sendbutton;
			
			private JScrollPane scrollpane;
			private JScrollPane scrollpane2;
			
			private JTextArea textarea;
			private JTextArea textarea2;
			
			private Undo undo;
			
			
			private JPanel panel;
			
			private JComponent[] components;
			
			private String fontname = defaultfontname;
			private int fontstyle = defaultfontstyle;
			private float fontsize = defaultfontsize;
			
			private Font font = new Font(
			
			    fontname, fontstyle, (int) fontsize);
			
			
			private boolean reverse_colors;
			
			private Color foreground = Color.black;
			private Color background = Color.white;
			
			
			private int defaultkeysize = 4; // no of ciphers
			
			private int numberofciphers = defaultkeysize;
			{
			    if (numberofciphers > PublicKey.size.length)
			        numberofciphers = PublicKey.size.length;
			}
			
			private boolean usereplyaddresskey = true;
			
			
			//  Userpass is required for esmtp authorization
			
			private String userpass;
			
			//  If mail was already retrieved, then the userpass
			//  is valid and there is no need to prompt the user
			//  to re-enter or confirm the userpass
			
			private boolean authorized;
			
			
			//  An object to hold the recipients' keys
			
			private PublicKeyRing publickeyring
			
			    = new PublicKeyRing();
			
			private String recipientskey;
			private String recipientskeyaddress;
			
			private String incomingmailserver;
			private String outgoingmailserver;
			
			private int incomingmailport;
			private int outgoingmailport;
			
			private int numberofmessages;
			
			private boolean ascending;
			
			private boolean encrypted;
			
			
			
			
			//  Menu, Menu Items, ...
			
			JMenuItem[] menuitems;
			
			JMenu filemenu, editmenu;
			
			JMenuItem  attachmenuitem,
			openmenuitem, saveasmenuitem,
			closemenuitem, exitmenuitem;
			
			JMenuItem undeletemenuitem,
			selectallmenuitem, copymenuitem, findmenuitem;
			
			JMenuItem fontsizemenuitem, fonttypemenuitem,
			textboldmenuitem, colormenuitem,
			keyboardmenuitem;
			
			
			
			
			//  Listeners
			
			
			SendButtonListener sendbuttonlistener;
			
			KeyListener1 keylistener1;
			KeyListener1.MouseWheelListener1
			    mousewheellistener1;
			
			FocusListener focuslistener;
			MouseListener mouselistener;
			
			AttachListener attachlistener;
			OpenListener openlistener;
			SaveListener savelistener;
			SaveAsListener saveaslistener;
			ExitListener exitlistener;
			
			UndoListener undolistener;
			
			CutListener cutlistener;
			CopyListener copylistener;
			PasteListener pastelistener;
			
			
			
			private JPanel iconpanel;
			
			private ImageIcon[] imageicons;
			private JButton[] iconbuttons;
			
			private JButton openbutton;
			
			private JButton cutbutton;
			private JButton copybutton;
			private JButton pastebutton;
			
			private JButton undobutton;
			private JButton redobutton;
			
			
			
			public SendMailFrame()
			{
			
				frame = this;
				frame.setResizable(true);
				frame.setVisible(true);
				frame.setTitle("");
				frame.setDefaultCloseOperation(
				    DO_NOTHING_ON_CLOSE);
				
				setFrameSize();
				
				
				
				//  Listeners
				
				attachlistener = new AttachListener();
				openlistener   = new OpenListener();
				savelistener   = new SaveListener();
				saveaslistener = new SaveAsListener();
				exitlistener   = new ExitListener();
				
				
				undolistener = new UndoListener();
				
				cutlistener = new CutListener();
				copylistener = new CopyListener();
				pastelistener = new PasteListener();
				
				
				sendbuttonlistener = new SendButtonListener();
				
				mouselistener = new MouseListener();
				
				keylistener1 = new KeyListener1();
				
				mousewheellistener1 = keylistener1
				
				    .new MouseWheelListener1();
				
				ComponentListener1 componentlistener1
				
				    = new ComponentListener1();
				
				WindowListener1 windowlistener1 = new WindowListener1();
				
				if (keyboardlistener == null)
				
				    keyboardlistener = new KeyboardListener();
				
				focuslistener = new FocusListener()
				{
					public void focusLost(FocusEvent e)
					{
						if (e.getSource() == tofield)
						{
							readRecipientsKey(e);
						}
					}
					
					public void focusGained(FocusEvent e)
					{
						if (e.getSource() instanceof JTextComponent)
						{
							if ((keyboardlistener != null) &&
							    (keyboardlistener.keyboard != null))
							{
								keyboardlistener.setTextComponent(
								
								    (JTextComponent) e.getSource());
								
								keyboardlistener.setForeground(foreground);
								keyboardlistener.setBackground(background);
							}
						}
					}
				};
				
				
				panel = new JPanel();
				
				panel.setLayout(new GridBagLayout());
				
				
				int textfieldsize = 28;
				
				textfields = new JTextField[3];
				
				    labels = new JLabel[3];
				iconlabels = new JLabel[3];
				
				for (int i = 0; i < textfields.length; i++)
				
				    textfields[i] = new JTextField(textfieldsize);
				
				for (int i = 0; i < labels.length; i++)
				
				    labels[i] = new JLabel();
				
				for (int i = 0; i < iconlabels.length; i++)
				
				    iconlabels[i] = new JLabel();
				
				
				
				//  Define the order of the from, to,
				//  and subj labels and fields
				
				  tolabel = labels[0];
				fromlabel = labels[1];
				subjlabel = labels[2];
				
				keyiconlabel = iconlabels[0];
				
				  tofield = textfields[0];
				fromfield = textfields[1];
				subjfield = textfields[2];
				
				
				
				//  Set the text for the to,
				//  from, and subj labels
				
				  tolabel.setText(__.To);
				fromlabel.setText(__.From);
				subjlabel.setText(__.Subject);
				
				
				subjlabel.addMouseListener(new MouseAdapter()
				{
					boolean isreply;
					
					public void mouseClicked(MouseEvent e)
					{
						if (!subjfield.isEditable()) isreply = true;
						
						if (isreply) subjfield.setEditable(
						            !subjfield.isEditable());
					}
				});
				
				
				//  Read the public key icon
				
				ImageIcon keyicon = Icons.get(Icons.keyring);
				
				
				//  Extract the image from the icon,
				//  scale the image, then reassign the icon
				
				Image image = keyicon.getImage();
				
				//  System.out.println(keyicon.getIconWidth()
				//           + " x " + keyicon.getIconHeight());
				
				int width1 = 40, height1 = -1, hints = Image.SCALE_SMOOTH;
				
				image = image.getScaledInstance(width1, height1, hints);
				
				keyicon = new ImageIcon(image);
				
				
				//  Add the public key icon to the label
				
				keyiconlabel.setIcon(keyicon);
				
				keyiconlabel.setVisible(false);
				keyiconlabel.setToolTipText(__.click);
				
				
				for (JLabel label : labels)
				
				    label.setFont(font);
				
				sendbutton = new JButton(__.Send);
				
				sendbutton.setForeground(foreground);
				sendbutton.setBackground(background);
				sendbutton.setFont(font);
				
				
				
				//  Create the text area
				
				int rows = 15;
				
				textarea = new JTextArea(rows, textfieldsize);
				textarea.setLineWrap(true);
				textarea.setWrapStyleWord(true);
				textarea.setFont(font);
				
				undo = new Undo(textarea);
				
				scrollpane = new JScrollPane(textarea,
				
				    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
				    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				
				
				textarea2 = new JTextArea(rows, textfieldsize);
				textarea2.setLineWrap(true);
				textarea2.setWrapStyleWord(true);
				textarea2.setFont(font);
				
				textarea2.setEditable(false);
				
				scrollpane2 = new JScrollPane(textarea2,
				
				    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
				    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
				
				scrollpane2.setVisible(false);
				
				
				//  Create a textfield panel
				
				JPanel textfieldpanel = new JPanel();
				
				textfieldpanel.setLayout(new GridBagLayout());
				
				
				//  Add the labels, icon, and textfields to the panel
				
				for (int i = 0; i < textfields.length; i++)
				{
					Gbc gbc = new Gbc();
					
					//  set anchor doesn't work with set fill;
					//  set fill has to be removed for set
					//  anchor to work
					
					
					//  labels
					
					gbc.setPosition(0, i);
					gbc.setAnchor(Gbc.left);
					gbc.setFill(Gbc.both);
					gbc.setWeight(5, 100);
					gbc.setInsets(0, 2, 0, 2);
					
					textfieldpanel.add(labels[i], gbc);
					
					
					//  icons (icon labels)
					
					gbc.setPosition(1, i);
					gbc.setAnchor(Gbc.left);
					gbc.setFill(Gbc.both);
					gbc.setWeight(5, 100);
					gbc.setInsets(0, 2, 0, 2);
					
					textfieldpanel.add(iconlabels[i], gbc);
					
					
					//  text fields
					
					gbc.setPosition(2, i);
					gbc.setAnchor(Gbc.left);
					gbc.setFill(Gbc.both);
					gbc.setWeight(75, 100);
					gbc.setInsets(0, 2, 0, 2);
					
					textfieldpanel.add(textfields[i], gbc);
				}
				
				
				//  Add the send button to the panel
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(3, 0);
				gbc.setSize(1, 3);
				gbc.setAnchor(Gbc.right);
				gbc.setFill(Gbc.both);
				gbc.setWeight(5, 100);
				gbc.setInsets(0, 2, 0, 4);
				
				textfieldpanel.add(sendbutton, gbc);
				
				
				
				//  Add the textfield panel to the panel
				
				//  The width of the textfield is set to 5 and
				//  the width of the sendbutton is set to 1 so
				//  the sendbutton width is 1 / (5 + 1) == 1/6.
				
				gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				gbc.setAnchor(Gbc.left);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 10);
				
				panel.add(textfieldpanel, gbc);
				
				
				//  Create an icon panel
				
				iconpanel = createIconPanel();
				
				
				//  Add the icon panel to the frame
				
				gbc = new Gbc();
				
				gbc.setPosition(0, textfields.length + 0);
				gbc.setAnchor(Gbc.center);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 5);
				gbc.setInsets(0, 0, 0, 0);
				
				panel.add(iconpanel, gbc);
				
				
				//  Add the scrollpane to the panel (weight = 50)
				
				gbc = new Gbc();
				
				gbc.setPosition(0, textfields.length + 1);
				gbc.setAnchor(Gbc.center);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 95);
				gbc.setInsets(0, 0, 0, 0);
				
				panel.add(scrollpane, gbc);
				
				
				//  Add another textarea below the textarea
				//  (this feature is not implemented)
				
				gbc = new Gbc();
				
				gbc.setPosition(0, textfields.length + 2);
				gbc.setAnchor(Gbc.center);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 95);
				
				////  panel.add(scrollpane2, gbc);
				
				
				
				//  Add the panel to the send mail frame
				
				this.add(panel);
				
				
				components = new JComponent[]
				{
					labels[0], labels[1], labels[2], textfieldpanel,
					
					keyiconlabel, // iconlabels[0, 1, 2, ...],
					
					fromfield, tofield, subjfield, sendbutton,
					
					textarea, textarea2
				};
				
				
				
				//  MenuBar
				
				
				JMenuBar menubar = new JMenuBar();
				
				frame.setJMenuBar(menubar);
				
				
				filemenu = new JMenu(__.file);
				filemenu.setFont(menufont);
				
				//  the attachlistener is not finished
				
				ImageIcon attachicon = Icons.get(Icons.attachment);
				attachmenuitem = new JMenuItem(__.attach, attachicon);
				attachmenuitem.addActionListener(attachlistener);
				attachmenuitem.setFont(menuitemfont);
				////  filemenu.add(attachmenuitem);
				
				openmenuitem = new JMenuItem(__.open, openicon);
				openmenuitem.addActionListener(openlistener);
				openmenuitem.setFont(menuitemfont);
				filemenu.add(openmenuitem);
				
				saveasmenuitem = new JMenuItem(__.saveas, saveasicon);
				saveasmenuitem.addActionListener(saveaslistener);
				saveasmenuitem.setFont(menuitemfont);
				filemenu.add(saveasmenuitem);
				
				exitmenuitem = new JMenuItem(__.exit, exiticon);
				exitmenuitem.addActionListener(exitlistener);
				exitmenuitem.setFont(menuitemfont);
				filemenu.add(exitmenuitem);
				
				menubar.add(filemenu);
				
				
				editmenu = new JMenu(__.edit);
				editmenu.setFont(menufont);
				
				keyboardmenuitem = new JMenuItem(__.Keyboard);
				keyboardmenuitem.addActionListener(keyboardlistener);
				keyboardmenuitem.setFont(menuitemfont);
				editmenu.add(keyboardmenuitem);
				
				menubar.add(editmenu);
				
				
				
				  tofield.addFocusListener(focuslistener);
				fromfield.addFocusListener(focuslistener);
				subjfield.addFocusListener(focuslistener);
				 textarea.addFocusListener(focuslistener);
				
				
				frame.addWindowListener(windowlistener1);
				
				frame.addComponentListener(componentlistener1);
				
				
				  tofield .addKeyListener(keylistener1);
				fromfield .addKeyListener(keylistener1);
				subjfield .addKeyListener(keylistener1);
				textarea  .addKeyListener(keylistener1);
				
				keyiconlabel .addMouseListener(mouselistener);
				    textarea .addMouseListener(mouselistener);
				
				sendbutton .addActionListener(sendbuttonlistener);
				
				panel      .addMouseWheelListener(mousewheellistener1);
				scrollpane .addMouseWheelListener(mousewheellistener1);
				
				
				
				//  Change the traversal policy for the tab key
				
				this.setFocusCycleRoot(true);
				
				this.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy()
				{
					public Component getComponentAfter(
					
						Container focusCycleRoot, Component comp)
					{
					    if      (comp.equals(tofield))    return fromfield;
					    else if (comp.equals(fromfield))  return subjfield;
					    else if (comp.equals(subjfield))  return textarea;
					    else if (comp.equals(textarea))   return sendbutton;
					    else if (comp.equals(sendbutton)) return tofield;
					    
					    else return super.getComponentAfter(focusCycleRoot, comp);
					}
					
					public Component getComponentBefore(
					
						Container focusCycleRoot, Component comp)
					{
					    if      (comp.equals(tofield))    return sendbutton;
					    else if (comp.equals(fromfield))  return tofield;
					    else if (comp.equals(subjfield))  return fromfield;
					    else if (comp.equals(textarea))   return subjfield;
					    else if (comp.equals(sendbutton)) return textarea;
					    
					    else return super.getComponentBefore(focusCycleRoot, comp);
					}
				});
			}
			
			
			//  End SendMailFrame constructor
			
			
			
			
			
			
			private JPanel createIconPanel()
			{
			
				openbutton = new JButton();
				
				cutbutton = new JButton();
				copybutton = new JButton();
				pastebutton = new JButton();
				
				undobutton = new JButton();
				redobutton = new JButton();
				
				
				 openbutton.addActionListener(openlistener);
				  cutbutton.addActionListener(cutlistener);
				 copybutton.addActionListener(copylistener);
				pastebutton.addActionListener(pastelistener);
				
				undobutton.addActionListener(undolistener);
				redobutton.addActionListener(undolistener);
				
				 openbutton.setToolTipText(__.open);
				  cutbutton.setToolTipText(__.cut);
				 copybutton.setToolTipText(__.copy);
				pastebutton.setToolTipText(__.paste);
				
				undobutton.setToolTipText(__.undo);
				redobutton.setToolTipText(__.redo);
				
				
				imageicons = new ImageIcon[]
				
				    { openicon, undoicon, redoicon,
				      cuticon, copyicon, pasteicon };
				
				iconbuttons = new JButton[]
				
				    { openbutton, undobutton, redobutton,
				      cutbutton, copybutton, pastebutton };
				
				
				Box box = Box.createHorizontalBox();
				
				for (JButton button : iconbuttons)
				{
					if (button == null) continue;
					
					button.setContentAreaFilled(false);
					button.setBorderPainted(false);
					
					Component hstrut = Box
					    .createHorizontalStrut(15);
					
					box.add(button);
					box.add(hstrut);
				}
				
				
				JPanel panel = new JPanel();
				
				panel.add(box);
				
				return panel;
			}
			
			
			
			//  The component listener resizes the font
			//  if the user changes the frame size
			
			private class ComponentListener1 extends ComponentAdapter
			{
				public void componentResized(ComponentEvent e)
				{
					if (e.getSource() instanceof JFrame)
					{
						fontsize = frameSizeToFontSize(frame);
						
						font = font.deriveFont(fontsize);
						
						setFont1(font);
					}
				}
			}
			
			
			
			private boolean readRecipientsKey(Object e)
			{
			
				//  Reads the recipient's key from the clipboard and
				//  sets the public key icon to visible (or !visible)
				//  if the key name matches (or !matches) the to field
				
				String tostring = tofield.getText().trim();
				
				String[] name_key = publickeyring.readClipboardKey();
				
				if (name_key == null)
				{
					if ( (e instanceof KeyEvent) &&
					
					   (((KeyEvent) e).getSource() == tofield)
					
					      && (((KeyEvent) e).getKeyChar() == '\n') )
					{
						String message = __.noclipboardkey;
						
						JOptionPane.showMessageDialog(frame,
						
						    message, "", JOptionPane.ERROR_MESSAGE);
					}
					
					return false;
				}
				
				String emailaddress = name_key[0].trim();
				
				String publickey = name_key[1];
				
				
				//  Validate the public key
				
				if (!PublicKey.isValidKey(publickey))
				{
					JOptionPane.showMessageDialog(panel,
					
					  __.invalidpublickey, "", JOptionPane.ERROR_MESSAGE);
					
					return false;
				}
				
				//  Don't change the public key for a reply message that has a key
				
				if (!tofield.isEditable() && (recipientskey != null)) return false;
				
				
				//  If public key name does not contain an '@' sign
				
				if (!emailaddress.contains("@"))
				{
					//  Clipboard key has no email address
					
					//  Compute the recipient's public key hash
					
					String hash = PublicKey.hashPublicKey(publickey);
					
					
					if ( (e instanceof KeyEvent) && (((KeyEvent) e).getSource() == tofield)
					
					    && (((KeyEvent) e).getKeyChar() == '\n') )
					{
						if (!tofield.getText().contains("@")
						 || !tofield.getText().contains("."))
						{
							//  Clipboard key has no address. The user can
							//  enter the recipient's email address in the
							//  to field and then press enter.
							
							String message = __.clipboardkeyhasnoaddress + "\n" +
							
							   Convert.partition(hash .substring(0, 28), " ", 4);
							
							JOptionPane.showMessageDialog(panel,
							
							    message, "", JOptionPane.ERROR_MESSAGE);
							
							return false;
						}
						
						//  Use the clipboard key if the user has entered an address
						
						else if (tofield.getText().contains("@")
						      && tofield.getText().contains("."))
						{
							//  Use clipboard key 1234 5678 ....,
							
							String message1 = __.useclipboardkey;
							
							String message2 = Convert.partition(
							    hash .substring(0, 28), " ", 4);
							
							JLabel label1 = new JLabel(message1);
							JLabel label2 = new JLabel(message2);
							
							label1.setFont(labelfont);
							label2.setFont(labelfont);
							
							Box vbox = Box.createVerticalBox();
							
							vbox.add(label1); vbox.add(label2);
							
							String title = __.useclipboardkey;
							
							Object[] choices = new Object[] { __.Yes, __.No };
							
							int choice = JOptionPane.showOptionDialog(
							
							    frame, vbox, title,
							
							      JOptionPane.DEFAULT_OPTION,
							      JOptionPane.PLAIN_MESSAGE,
							
							          null, choices, choices[1]);
							
							if ((choice == JOptionPane.CANCEL_OPTION)
							 || (choice == JOptionPane.CLOSED_OPTION))
							
								return false;
							
							
							if (choice == JOptionPane.NO_OPTION)
							{
								if (recipientskey != null)
								{
									String hash0 = PublicKey
									
									    .hashPublicKey(recipientskey);
									
									if (hash0 .equals(hash))
									{
										recipientskey = null;
										
										keyiconlabel .setVisible(false);
										keyiconlabel .repaint();
									}
								}
								
								return false;
							}
							
							//  else if (choice == JOptionPane.YES_OPTION)
							
							recipientskeyaddress = tofield.getText().trim();
							
							recipientskey = publickey;
							
							keyiconlabel .setVisible(true);
							keyiconlabel .repaint();
							
							return true;
						}
					}
					
					else if ((e instanceof KeyEvent) && (((KeyEvent) e).getSource() == tofield))
					{
						//  The user can make a mistake typing in the to address or
						//  can edit the recipient's address after entering the key
						//  from the clipboard.
						//
						//  (The icon will reappear if the user corrects the address
						//  and then presses enter, or else it will say addess on
						//  clipboard key does not match address in to field.)
						
						recipientskeyaddress = tofield.getText().trim();
						
						if ( recipientskeyaddress.isEmpty()
						 || !recipientskeyaddress.contains("@")
						 || !recipientskeyaddress.contains(".") )
						{
							//  Hide the public key icon
							
							recipientskeyaddress = null;
							
							recipientskey = null;
							
							keyiconlabel .setVisible(false);
							keyiconlabel .repaint();
						}
						
						return true;
					}
					
					return false;
				}
				
				
				//  If the public key name contains an '@' sign
				//  verify that the key address matches the to field
				
				else if (emailaddress.contains("@"))
				{
					if ( tostring.isEmpty() && ( (e instanceof KeyEvent) &&
					
					  (((KeyEvent) e).getSource() == tofield) &&
					  (((KeyEvent) e).getKeyChar() == '\n'))
					
					    || tostring.equals(emailaddress) )
					
					//  If the to string is empty and the enter key is pressed
					//  or the to string equals the key name and any key is pressed
					{
						//  Use the clipboard key (a clipboard key can over-
						//  write a reply key if it has the correct address)
						
						tofield.setText(emailaddress);
						tofield.setCaretPosition(0);
						
						recipientskeyaddress = emailaddress;
						
						recipientskey = publickey;
						
						keyiconlabel .setVisible(true);
						keyiconlabel .repaint();
						
						return true;
					}
					
					
					//  If the clipboard key address does not match the to field address
					
					if (!tostring.equals(recipientskeyaddress))
					{
						//  Don't change the public key for a reply message that has a key
						
						if (!tofield.isEditable() && (recipientskey != null)) return false;
						
						recipientskeyaddress = null;
						
						recipientskey = null;
						
						keyiconlabel .setVisible(false);
						keyiconlabel .repaint();
						
						// if ((e instanceof ActionEvent) &&
						//
						//  (((ActionEvent) e).getSource() == sendbutton))
						//
						// if ((e instanceof FocusEvent) &&
						//
						//  (((FocusEvent) e).getSource() == tofield))
						
						if ( (e instanceof KeyEvent) &&
						
						  (((KeyEvent) e).getSource() == tofield)
						
						    && (((KeyEvent) e).getKeyChar() == '\n') )
						{
							JOptionPane.showMessageDialog(panel,
							
							//  Address on clipboard public key
							//  does not match address in to field
							
							  __.wrongpublickey, "", JOptionPane.ERROR_MESSAGE);
						}
						
						return false;
					}
				}
				
				return false;
			}
			
			
			
			
			private void displayPublicKeyHash(
			
				Component parent, String publickey, String title)
			{
				if (publickey == null) publickey = "";
				
				
				//  Compute the recipient's public key hash
				
				String hash = PublicKey.hashPublicKey(publickey);
				
				hash = hash .substring(0, 32);
				
				hash = Convert.partition(hash, " ", 4);
				
				
				//  Create a label and JOptionPane to display the hash
				
				JLabel label = new JLabel(hash);
				
				label.setFont(labelfont.deriveFont(20.0f)
				
				    .deriveFont(Font.PLAIN));
				
				int type = JOptionPane.PLAIN_MESSAGE;
				
				JOptionPane.showMessageDialog(
				
				    parent, label, title, type);
			}
			
			
			
			
			
			
			//  SEND EMAIL
			
			
			
			private class SendButtonListener implements ActionListener
			{
			
				public  boolean sending;
				private boolean clicked;
				
				private String plaintext;
				private String sendtext;
				
				private String clientservertext;
				
				private int   publickeymessages;
				private int replytoselfmessages;
				
				
				public void actionPerformed(ActionEvent e)
				{
				
					//  If the message has already been sent, don't re-send the message
					
					if ((clientservertext != null) && !clientservertext.isEmpty())
					{
						//  Rotate the plaintext, sendtext, and client/server
						//  text each time the send button is clicked
						
						String text = textarea.getText();
						
						if (text.equals(clientservertext))
						
						    textarea.setText(sendtext);
						
						else if (text.equals(sendtext))
						
						    textarea.setText(plaintext);
						
						else if (text.equals(plaintext))
						
						    textarea.setText(clientservertext);
						
						textarea.setCaretPosition(0);
					}
					
					
					//  The click variable doesn't get reset
					//  (unless the method throws an exception)
					//  so the message can only be sent once
					
					if (clicked) return;
					
					else clicked = true;
					
					
					String   tostring =   tofield.getText().trim();
					String fromstring = fromfield.getText().trim();
					String subjstring = subjfield.getText(); // no trim
					
					
					String sendtext = null;
					
					boolean encrypt;
					
					boolean sent1 = false;
					boolean sent2 = false;
					
					sending = true;
					
					
					//  number of encryption ciphers
					
					int encryptciphers;
					
					//  no of reply key ciphers
					
					int[] numberofciphers1 =
					
					    new int[] { numberofciphers };
					
					
					try
					{	if (textarea.getText().isEmpty())
						{
							//  Nothing to send
							
							JOptionPane.showMessageDialog(
							
							    panel, __.nothingtosend, "",
							
								JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						if (tostring.isEmpty())
						{
							//  to field is empty
							
							JOptionPane.showMessageDialog(
							
							    panel, __.tofieldisempty, "",
							
								JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						if ( !tostring.contains("@")
						   || tostring.contains(" ") )
						{
							//  to field is not an address
							
							JOptionPane.showMessageDialog(
							
							    panel, __.toaddressisinvalid, "",
							
								JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						
						if (fromstring.isEmpty())
						{
							String message = __.enterthefromaddress;
							
							JOptionPane.showMessageDialog(panel,
							
							//  "Enter the from: address so your public key \n" +
							//  "can be attached to your message.",
							
							    message, "",
							
							      JOptionPane.INFORMATION_MESSAGE);
							
							return;
						}
						
						
						if (fromstring.equals(tostring))
						{
							if (replytoselfmessages == 0)
							{
								int choice = JOptionPane.showConfirmDialog(frame,
								
								    __.replytoself + " ?", __.replytoself,
								
									JOptionPane.YES_NO_OPTION);
								
								if (choice == JOptionPane.YES_OPTION)
								{
									replytoselfmessages++;
								}
								
								if (choice == JOptionPane.NO_OPTION)
								{
									return;
								}
							}
						}
						
						
						if (subjstring.isEmpty() && subjfield.isEditable())
						{
							String message = __.subjectfieldisempty;
							
							JOptionPane.showMessageDialog(panel,
							
							    message, "", JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						
						if ((outgoingmailserver == null)
						  || outgoingmailserver.isEmpty())
						{
							String message = __.outgoingmailserverfieldisempty;
							
							JOptionPane.showMessageDialog(panel,
							
							    message, "", JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						
						
						//  Verify that the user domain
						//  matches the server domain
						
						boolean bool = false;
						
						String   userdomain = "";
						String serverdomain = "";
						
						String[] t = outgoingmailserver.split("[.]{1,}");
						
						if (t.length < 2) bool = true;
						
						else serverdomain = t[t.length -2] + "." + t[t.length -1];
						
						if (fromstring.contains("@"))
						
						    userdomain = fromstring .substring(fromstring.indexOf("@") + 1);
						
						if (userdomain.contains(" "))
						
						    userdomain = userdomain .substring(0, userdomain.indexOf(" "));
						
						if (!userdomain .equals(serverdomain)) bool = true;
						
						if (bool)
						{
							//  user domain does not match server domain
							
							String message = __.userdomaindoesnotmatchserverdomain;
							
							message += "\n" + __.userdomain + " == " + userdomain;
							message += "\n" + __.serverdomain + " == " + serverdomain;
							
							JLabel label = new JLabel(message);
							
							label.setFont(labelfont);
							
							JOptionPane.showMessageDialog(panel,
							
							   label, "", JOptionPane.ERROR_MESSAGE);
							
							//  Allow the user to open the passphrase dialog
							//  to change the outgoing mail server domain
							
							authorized = false;
							
							textarea.requestFocusInWindow();
							
							return;
						}
						
						
						
						
						//  The program should obtain the key from the recipient's mail server.
						//  If there is an error message or no response from the mail server,
						//  then the program could prompt the user to obtain a copy of the re-
						//  cipient's public key.
						//
						//  If a public key is returned, the program should compare the public
						//  key to the public key file. If the public key is different from the
						//  one stored in the file, the program should alert the user that the
						//  recipient's public key has changed. If the message is important, the
						//  sender could verify that the recipient's key has changed by calling
						//  the recipient. If the message is unimportant then it doesn't matter.
						
						
						//  Read the public key ring for this user address
						
						String useraddr = fromstring;
						
						if (useraddr.contains(" ")) useraddr =
						
						    useraddr.substring(0, useraddr.indexOf(" "));
						
						//  Use the passphrase and from address to read the public key file
						
						PublicKeyRing keyring = readPublicKeys(useraddr);
						
						if (keyring == null) keyring = new PublicKeyRing();
						
						
						
						//  Only read from the clipboard if there is no reply key
						//
						//  (The user can override the reply key by clicking
						//  in the to: field and then pressing the enter key)
						
						if ((recipientskey == null) || recipientskey.isEmpty())
						{
							readRecipientsKey(e);
						}
						
						
						if ((recipientskey == null) || recipientskey.isEmpty())
						{
						
							//  Use the recipient's POP mail server to retrieve the recipient's
							//  public key if email service providers upgrade their POP mail
							//  servers to store and retrieve users' public keys.
							//
							//  Retrieving the recipient's public key would not require authen-
							//  tication but saving or storing the public key would require au-
							//  thentication, because anyone can request a public key but only
							//  the user/client/recipient can set/store/save the public key.
							//
							//  Since saving or changing the public key is done infrequently,
							//  and usually only once, it could be done via the web browser and
							//  could be stored along with the user / client's password and other
							//  email settings.
							
							
							//  Connect to the recipient's pop mail server
							//  (such as pop.example.com 995) and issue the command
							//
							//  RETR recipientsaddr@example.com
							//
							//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
							//  xxxxxxxxxxxxxxxx0123456789abcdefxxxxxxxxx
							//  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
							//  xxxxxxxxx0123456789abcdefxxxxxxxxxxxxxxxx
							//  xxxxxxxxxxxxxxxxxxxxxxxxx................
							//  . (end of message char)
							
							
							
							if (sendretrievepublickey)
							{
								//  This code will be implemented if the email server
								//  programs are upgraded to store and retrieve keys
								
								int portno = 995;
								
								PopMail popmail = new PopMail(tostring, portno);
								
								String publickey = popmail.retrieve(tostring);
								
								//  xxxxxxxxxx0123456789abcdefxxxxxxxxxx ...  or
								//  xxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx ...
								
								if ((publickey != null) && !publickey.isEmpty()
								
								  && PublicKey.isValidKey(publickey))
								
									recipientskey = publickey;
							}
						}
						
						
						
						if ((recipientskey == null) || recipientskey.isEmpty())
						{
						
							//  If the public key is not in the recipient's public key direc-
							//  tory search the public key ring for the recipient's public key
							
							for (int i = 0; i < keyring.size(); i++)
							{
								String[] name_key = keyring.get(i);
								
								if (name_key == null) continue;
								
								String name = name_key[0], key = name_key[1];
								
								if (name.equals(tostring) && (publickeymessages == 0))
								{
									//  System.out.println("Reading recipient's"
									//     + " public key from public key ring");
									
									//  Use key ring key as recipient's key
									//  address@example.com
									//  0123 4567 89ab cdef
									
									String keyhash = PublicKey
									
									    .hashPublicKey(key) .substring(0, 32);
									
									keyhash = Convert.partition(keyhash, " ", 4);
									
									JLabel label1 = new JLabel(__.usekeyringkey);
									JLabel label2 = new JLabel(name);
									JLabel label3 = new JLabel(keyhash);
									
									label1.setFont(labelfont);
									label2.setFont(labelfont);
									label3.setFont(labelfont);
									
									Box vbox = Box.createVerticalBox();
									
									vbox.add(label1);
									vbox.add(Box.createVerticalStrut(6));
									vbox.add(label2);
									vbox.add(Box.createVerticalStrut(6));
									vbox.add(label3);
									
									String title = __.usekeyringkey;
									
									Object[] choices = new Object[] { __.Yes, __.No };
									
									int choice = JOptionPane.showOptionDialog(
									
									    frame, vbox, title,
									
									      JOptionPane.DEFAULT_OPTION,
									      JOptionPane.PLAIN_MESSAGE,
									
									          null, choices, choices[1]);
									
									if ((choice == JOptionPane.CANCEL_OPTION)
									 || (choice == JOptionPane.CLOSED_OPTION)
									 || (choice == JOptionPane.    NO_OPTION))
									
										break;
									
									//  else if (choice == JOptionPane.YES_OPTION)
									
									recipientskeyaddress = name;
									recipientskey = key;
									
									//  Show the public key icon
									
									keyiconlabel .setVisible(true);
									keyiconlabel .repaint();
									
									break;
								}
							}
						}
						
						
						
						//  If the recipient's key cannot be found in the directory
						//  or in the public key file, warn the user that there is no key
						
						
						if ((recipientskey == null) || recipientskey.isEmpty()
						
						   || (recipientskeyaddress == null) ||
						
						      !recipientskeyaddress.equals(tostring))
						{
							//  A public key is required to encrypt an email message
							//
							//  Prompt the user to enter the recipient's public key but
							//  don't keep asking for a key if the user doesn't have one
							
							encryptciphers = 0;
							
							if (publickeymessages == 0)
							{
								//  "A public key is required to encrypt a message. \n" +
								//  "Find the mail recipient's public key and copy it \n" +
								//  "to the clipboard, click in the To: box and press \n" +
								//  "enter, then click the Send button.",
								
								JTextArea textarea = new JTextArea(1, 24);
								
								textarea.setBorder(null);
								textarea.setEditable(false);
								textarea.setText(__.publickeyerror);
								textarea.setFont(labelfont);
								textarea.setBackground(new JPanel().getBackground());
								
								JOptionPane.showMessageDialog(frame,
								
								    textarea, "", JOptionPane.ERROR_MESSAGE);
								
								publickeymessages++;
								
								return;
							}
							
							else publickeymessages = 0;
						}
						
						
						else // if ((recipientskey != null) && !recipientskey.isEmpty())
						{
							String name   = recipientskeyaddress;
							String newkey = recipientskey;
							
							//  Read the old public key from the key ring
							
							String oldkey = null;
							
							if (keyring.hasKey(recipientskey))
							
							    oldkey = keyring.retrieve(recipientskeyaddress);
							
							if (oldkey != null)
							{
								//  Compare the new public key to the old public key
								//  stored in the public key file if there is one
								//  and alert the user if the public key has changed
								
								String[] oldkeys = PublicKey.splitKeys(oldkey);
								String[] newkeys = PublicKey.splitKeys(newkey);
								
								int numberofoldciphers = 0;
								
								for (int i = 0; i < oldkeys.length; i++)
								for (int j = 0; j < newkeys.length; j++)
								
								    if (oldkeys[i].equals(newkeys[j])) numberofoldciphers++;
								
								int numberofnewciphers = newkeys.length - numberofoldciphers;
								
								//  Alert the user if the new public key is different
								//  or a subset of the old public key
								
								//  ...
							}
							
							//  Read the number of encrypt ciphers
							
							encryptciphers = PublicKey.countNumberOfCiphers(recipientskey);
							
							//  Add the new public key to the key ring
							
							String[] name_key = new String[] { name, newkey };
							
							keyring.add(name_key);
						}
						
						//  Save the new key ring or update
						//  the existing public key ring
						
						savePublicKeys(useraddr, keyring);
						
						
						//  If there is a public key to encrypt to then
						//  set encrypt = true or else encrypt = false
						
						if ((recipientskey != null) && !recipientskey.isEmpty()
						
						   && (recipientskeyaddress != null)
						   &&  recipientskeyaddress.equals(tostring))
						
						      encrypt = true;
						 else encrypt = false;
						
						
						//  This line was used to test that the encryption works
						//  with either delimiter ('-' or 0123456789abcdef) be-
						//  cause public keys may use hyphens or base-16 chars
						//
						//  if (recipientskey != null) recipientskey
						//    .replaceAll(Convert.base16Separator, "-");
						
						
						
						
						
						//  Create a file data list, a file desc list, and a file
						//  name list to hold the attached files
						
						ArrayList<byte[]> filedatalist = new ArrayList<byte[]>();
						ArrayList<String> filedesclist = new ArrayList<String>();
						ArrayList<String> filenamelist = new ArrayList<String>();
						
						//  The file name list is only used to make sure that the
						//  same file is not attached twice. The file name is not
						//  sent to the recipient; only the file description is
						//  sent to the recipient.
						
						//  Create an openlistener object
						
						OpenListener openlistener = new OpenListener(
						
						    __.attachfilesordirectory);
						
						
						//  Use a while loop so that if the user clicks the
						//  Attach File button more than once the JOptionPane
						//  dialog will re-display until the user clicks the
						//  Yes button
						
						while (true)
						{
							int numberoffiles = filedatalist.size();
							
							String attachedfilemessage =
							
							    __.AttachedFiles + " " + numberoffiles;
							
							String[] filenames = new String[numberoffiles];
							
							for (int i = 0; i < numberoffiles; i++)
							{
								String filedesc = filedesclist.get(i);
								
								int filesize = filedatalist.get(i).length;
								
								String sizestr = String.valueOf(filesize / 1024);
								
								int maxstrlen = 24;
								
								if (filedesc.length() > maxstrlen)
								
								    filedesc = filedesc.substring(0, maxstrlen) + "..";
								
								filenames[i] = filedesc;
							}
							
							int maxnumber = PublicKey.size.length;
							
							if (numberofciphers1[0] < 0)
							    numberofciphers1[0] = defaultkeysize;
							
							if (numberofciphers1[0] > maxnumber)
							    numberofciphers1[0] = maxnumber;
							
							
							
							JLabel filelabel = new JLabel(attachedfilemessage);
							
							filelabel .setBackground(new JPanel().getBackground());
							
							String encryptcipherstr = String.valueOf(encryptciphers);
							String   replycipherstr = String.valueOf(numberofciphers1[0]);
							
							JLabel encryptlabel1 = new JLabel(__.encryptkeysize + " ");
							JLabel   replylabel1 = new JLabel(__.myreplykeysize + " ");
							
							JLabel encryptlabel2 = new JLabel(encryptcipherstr);
							JLabel   replylabel2 = new JLabel(  replycipherstr);
							
							encryptlabel1.setToolTipText(__.click);
							  replylabel1.setToolTipText(__.click);
							
							JLabel[] labels = new JLabel[]
							{
							    encryptlabel1, encryptlabel2,
							
							      replylabel1, replylabel2, filelabel,
							};
							
							for (JLabel label : labels)
							
							    label.setFont(labelfont);
							
							if (encrypt == false)
							{
								encryptlabel1.setEnabled(false);
								encryptlabel2.setEnabled(false);
								  replylabel1.setEnabled(false);
								  replylabel2.setEnabled(false);
							}
							
							if (encrypt) encryptlabel1.addMouseListener(new MouseAdapter()
							{
								public void mouseClicked(MouseEvent e)
								{
									//  Display the recipient's 40-digit public key hash
									
									String title = __.recipientspublickeyhash;
									
									displayPublicKeyHash(frame, recipientskey, title);
								}
							});
							
							if (encrypt) replylabel1.addMouseListener(new MouseAdapter()
							{
								public void mouseClicked(MouseEvent e)
								{
									//  Display the reply key size dialog
									
									int replykeysize = getReplyKeySize(frame,
									
									    Math.min(8, PublicKey.numberofciphers));
									
									if (replykeysize >= 0) numberofciphers1[0] = replykeysize;
									
									String s = String.valueOf(numberofciphers1[0]);
									
									replylabel2.setText(s);
								}
							});
							
							
							//   ______________________________________________
							//  |____ Send Message ____________________________|
							//  |                                              |
							//  |    Attached files 2  |   Encrypt Key Size 2  |
							//  |    file name1        |  -------------------  |
							//  |    file name2        |  My Reply Key Size 2  |
							//  |                                              |
							//  | mail                                         |
							//  | copy [ / Yes ] [ Attach Files ] [ X Cancel ] |
							//  |______________________________________________|
							
							
							
							//  mail copy to self checkbox (replaced by copylabel)
							//
							//  JCheckBox checkbox = new JCheckBox();
							//
							//  checkbox.setToolTipText(__.mailcopytoself);
							//  checkbox.setSelected(mailcopytoself);
							//  checkbox.setEnabled(!tostring.equals(fromstring));
							//  checkbox.addActionListener(new ActionListener()
							//  { public void actionPerformed(ActionEvent e)
							//      { mailcopytoself = checkbox.isSelected(); } });
							
							
							
							//  Enlarge the copy icon
							
							//  Extract the image from the icon, scale /
							//  magnify the image, then reassign the icon
							
							Image image = copyicon.getImage();
							
							//  System.out.println(keyicon.getIconWidth()
							//           + " x " + keyicon.getIconHeight());
							
							int width1 = 24, height1 = -1, hints = Image.SCALE_SMOOTH;
							
							image = image.getScaledInstance(width1, height1, hints);
							
							ImageIcon copyicon1 = new ImageIcon(image);
							
							
							
							//  mail copy to self icon label
							
							//  the copy icon looks better than a checkbox
							
							JLabel copylabel = new JLabel();
							
							copylabel.setToolTipText(__.mailcopytoself);
							copylabel.setIcon(mailcopytoself ? copyicon1 : copyicon1 );
							copylabel.setEnabled(mailcopytoself);
							if (tostring.equals(fromstring))
							    copylabel.setEnabled(false);
							
							copylabel.addMouseListener(new MouseAdapter()
							{ public void mouseClicked(MouseEvent e)
							{     mailcopytoself = ! mailcopytoself;
							      copylabel.setIcon(mailcopytoself ?
							          copyicon1 : copyicon1);
							      copylabel.setEnabled(mailcopytoself);
							      if (tostring.equals(fromstring))
								  copylabel.setEnabled(false);
							} });
							
							
							Box vbox1 = Box.createVerticalBox();
							Box vbox2 = Box.createVerticalBox();
							
							vbox1.add(filelabel);
							
							vbox1.add(Box.createVerticalStrut(5));
							
							for (int i = 0; i < numberoffiles; i++)
							{
								JLabel label = new JLabel();
								
								label.setFont(labelfont);
								
								vbox1.add(label);
								
								if (!filenames[i].isBlank())
								
								     label.setText(filenames[i]);
								else label.setText("(" + __.notitle + ")");
							}
							
							Box hbox1 = Box.createHorizontalBox();
							Box hbox2 = Box.createHorizontalBox();
							Box hbox  = Box.createHorizontalBox();
							
							hbox1.add(encryptlabel1); hbox1.add(encryptlabel2);
							hbox2.add(  replylabel1); hbox2.add(  replylabel2);
							
							vbox2.add(hbox1);
							vbox2.add(Box.createVerticalStrut(15));
							vbox2.add(hbox2);
							
							hbox .add(vbox1);
							hbox.add(Box.createHorizontalStrut(20));
							hbox .add(vbox2);
							
							
							JButton yes_button, attach_button, cancel_button;
							
							   yes_button = new JButton(__.Yes, Icons.get(Icons.dialog_ok_24x24));
							attach_button = new JButton(__.attachfiles, Icons.get(Icons.mail_attachment_24x24));
							cancel_button = new JButton(__.cancel, Icons.get(Icons.dialog_no_24x24));
							
							Box hbox3 = Box.createHorizontalBox();
							Component strut = Box.createHorizontalStrut(12);
							
							//  hbox3.add(checkbox);
							hbox3.add(copylabel);
							hbox3.add(strut);
							hbox3.add(yes_button);
							hbox3.add(attach_button);
							hbox3.add(cancel_button);
							
							
							JPanel panel = new JPanel();
							
							{	Box vbox = Box.createVerticalBox();
								
								vbox.add(hbox);
								vbox.add(Box.createVerticalStrut(20));
								vbox.add(hbox3);
								
								panel.add(vbox);
							}
							
							
							
							//  Create a JOptionPane dialog and add
							//  | Yes | Attach Files | Cancel | buttons
							
							
							String title = __.Sendmessage;
							
							Object[] options = new Object[] {  };
							
							JOptionPane pane = new JOptionPane(panel,
							
							    JOptionPane.PLAIN_MESSAGE, JOptionPane
							
								.DEFAULT_OPTION, null, options, 0);
							
							//  pane.set(...)
							
							JDialog dialog = pane.createDialog(frame, title);
							
							
							int[] choice = new int[] { -1 };
							
							yes_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice[0] = 0; dialog.dispose(); } } );
							
							attach_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice[0] = 1; dialog.dispose(); } } );
							
							cancel_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice[0] = 2; dialog.dispose(); } } );
							
							dialog.setVisible(true);
							
							
							
							if (choice[0] == 1)
							{
							
								//  Attach Files / Directory
								
								//  the encoded files are appended to the encoded text
								
								//  Choose the files to be attached and decrypt
								//  the file before encrypting to the public key
								
								//  In future versions an attached directory could
								//  be decrypted and converted to a tar file instead
								//  of adding the files individually
								
								int maxfilesize = 4*1024*1024;
								
								File selectedfile = null;
								
								do { selectedfile = openlistener
								
								    .chooseFileOrDirectory(); }
								
								        while ((selectedfile != null) &&
								               (selectedfile.length() > maxfilesize));
								
								if (selectedfile == null) continue;
								
								else directory = selectedfile.getParent();
								
								
								//  List the files
								
								File[] files = new File[] { selectedfile };
								
								if (files[0].isDirectory())
								
								    files = files[0].listFiles();
								
								//  System.out.println(files);
								
								
								int maxfileno = 10;
								
								if (files.length + filenamelist.size() > maxfileno)
								{
									String message = __.numberoffiles + " > " + maxfileno;
									
									JLabel label = new JLabel(message);
									
									label.setFont(labelfont);
									
									if (directory != null)
									
									    message = "Directory > " +
									
										maxfileno + " " + "files";
									
									System.out.println(message);
									
									JOptionPane.showMessageDialog(frame,
									
									   label, "", JOptionPane.ERROR_MESSAGE);
									
									continue;
								}
								
								int totalfilesize = 0;
								
								for (File file : files)
								
								    totalfilesize += file.length();
								
								for (int i = 0; i < filedatalist.size(); i++)
								
								    totalfilesize += filedatalist.get(i).length;
								
								
								if (totalfilesize > maxfilesize)
								{
									String message = "File or folder size > " + Convert
									
									    .partition(String.valueOf(maxfilesize), ",", -3);
									
									JOptionPane.showMessageDialog(frame,
									
									    message, "", JOptionPane.ERROR_MESSAGE);
									
									continue;
								}
								
								
								
								for (File file : files)
								{
								
									//  If the file has already been attached
									//  display an error message and continue
									
									String filename = file.getName();
									
									if (filenamelist.contains(filename))
									{
										String message = __.fileisalreadyattached;
										
										JOptionPane.showMessageDialog(frame,
										
										   message, "", JOptionPane.ERROR_MESSAGE);
										
										continue;
									}
									
									
									//  Read the file
									
									byte[] filedata;
									
									try { filedata = DataStream.read(file); }
									
									catch (IOException ex)
									{
										System.out.println("I/O error");
										
										continue;
									}
									
									
									//  If the file is encrypted
									//
									//  prompt the user to decrypt
									//  the file before attaching
									
									
									if (Cipher.isEncrypted(file))
									{
									
										//  Decrypt the file
										
										FileDecryptor fd;
										
										fd = new FileDecryptor(frame);
										fd.setFont(textarea.getFont());
										fd.setFileKey(filekey);
										fd.setPassphrase(SP);
										fd.setForeground(foreground);
										fd.setBackground(background);
										fd.setTitle(__.decryptfilebeforeattaching);
										
										byte[] input;
										
										try { input = DataStream.read(file); }
										
										catch (IOException ex)
										{
											System.out.println(ex);
											
											continue;
										}
										
										byte[] decryptedfiledata;
										
										decryptedfiledata = fd.decrypt(input);
										
										if (decryptedfiledata == null)
										{
											//  If the user doesn't enter a password or closes
											//  the dialog then skip the file because the re-
											//  cipient will be unable to read the file
											
											if (Cipher.isEncrypted(filedata))
											{
												String message1 = __.fileisnotattached1;
												String message2 = __.fileisnotattached2;
												
												JTextArea textarea1 = new JTextArea(message1 + "\n");
												JTextArea textarea2 = new JTextArea(message2);
												
												textarea1.setEditable(false);
												textarea2.setEditable(false);
												
												textarea1.setBackground(new JLabel().getBackground());
												textarea2.setBackground(new JLabel().getBackground());
												
												textarea1.setFont(labelfont);
												// textarea2.setFont(...);
												
												Box vbox = Box.createVerticalBox();
												
												vbox.add(textarea1);
												vbox.add(textarea2);
												
												Component vstrut = Box
												
												   .createVerticalStrut(20);
												
												vbox.add(vstrut);
												
												JOptionPane .showMessageDialog(frame, vbox,
												
												    "", JOptionPane.ERROR_MESSAGE);
												
												continue;
											}
											
											continue;
										}
										
										else filekey = fd.getFileKey();
										
										filedata = decryptedfiledata;
									}
									
									
									
									//  Prompt the user to enter a file description
									
									JTextField textfield = new JTextField(20);
									
									textfield.setText(file.getName());
									textfield.setForeground(foreground);
									textfield.setCaretColor(foreground);
									textfield.setBackground(background);
									textfield.setFont(font);
									
									JOptionPane .showMessageDialog(frame,
									
									    textfield, __.filedescription, JOptionPane.PLAIN_MESSAGE);
									
									String filedesc = textfield.getText().trim();
									
									
									
									//  If the file is large compress the file before attaching
									
									int minfilesize = 64*1024;
									
									if (filedata.length > minfilesize)
									{
										//  Compress the file data
										
										try
										{	byte[]   compresseddata =   compress(filedata);
											byte[] decompresseddata = decompress(compresseddata);
											
											if (!Arrays.equals(filedata, decompresseddata))
											
											    throw new DataFormatException();
											
											//  If the file is compressible then use the compressed data
											
											if (compresseddata.length < filedata.length * 3/4)
											
											    filedata = compresseddata;
										}
										
										catch (DataFormatException ex) {  }
									}
									
									
									filedatalist.add(filedata);
									filedesclist.add(filedesc);
									filenamelist.add(filename);
								}
							}
							
							
							//  If the user clicks yes, then break, else return
							
							else if (choice[0] == 0) break;
							else if (choice[0] != 0)
							
							    return;
						}
						
						
						
						
						if (encrypt == false)
						{
						
							//  Issue a warning if there is no public key to encrypt to
							
							//  (message is not encrypted)
							
							String title = "";
							
							String warning = __.Warning + "! " +
							
							    __.messageisnotencrypted + ".\n" +
							
								__.proceedanyway + "?";
							
							JTextArea textarea = new JTextArea(warning);
							
							textarea.setFont(labelfont);
							textarea.setEditable(false);
							textarea.setBackground(
							    new JLabel().getBackground());
							
							JButton yes_button, no_button; Icon icon = null;
							
							yes_button = new JButton(__.Yes, Icons.get(Icons.dialog_ok_24x24));
							 no_button = new JButton(__.No,  Icons.get(Icons.dialog_no_24x24));
							
							Object[] options = new Object[] { yes_button, no_button };
							
							JOptionPane pane = new JOptionPane(textarea, JOptionPane
							
							   .WARNING_MESSAGE, JOptionPane.DEFAULT_OPTION, icon, options, 0);
							
							//  pane.set(...)
							
							JDialog dialog = pane.createDialog(frame, title);
							
							int[] choice = new int[] { -1 };
							
							yes_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice[0] = JOptionPane.YES_OPTION; dialog.dispose(); } } );
							
							no_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice[0] = JOptionPane.NO_OPTION; dialog.dispose(); } } );
							
							dialog.setVisible(true);
							
							if (choice[0] != JOptionPane.YES_OPTION)
							
							    return;
						}
						
						
						
						//  The format used to encode, encrypt, and partition
						//  email messages. Read the format from right to left
						//  for encoding, encrypting, encoding, and partitioning,
						//  or from left to right for unpartitioning, decoding,
						//  decrypting, and decoding.
						//
						//  Encoding is used to hide newline chars that are used
						//  as delimiters and to convert the random encrypted data
						//  to text characters because random data includes control
						//  characters such as "." which is interpreted by the email
						//  server as an end of message char.
						//
						//  This method doubles the size of the email because each
						//  base-64 encoding expands the data by 1/3 which means
						//  that two encodings and the encryption encoding expands
						//  the data to 4/3 ^ 2 == 16/9 times the size or a 7/9 ==
						//  0.77 increase.
						
						
						//  partition | (encode or replace \n\n) | encrypt | >>
						//
						//       | base-16 reply key (optional)
						//
						//       | base-64 encoded message text
						//
						//       | base-64 encoded file desc1
						//
						//       | base-64 encoded file data1
						//
						//       | base-64 encoded file desc2
						//
						//       | base-64 encoded file data2
						
						
						
						//  Concatenate and encode the message and file text(s)
						
						ArrayList<String> filetextlist = new ArrayList<String>();
						
						while (filedatalist.size() != 0)
						{
							//  Encode the byte arrays and titles in base 64
							
							String filedesc = Convert   .stringToBase64(filedesclist.remove(0));
							String filetext = Convert.byteArrayToBase64(filedatalist.remove(0));
							
							if (filedesc.isBlank()) filedesc = Convert.stringToBase64("    ");
							
							if (encrypt == false) filetext = Convert
							
							    .partition(filetext, "\n", linesize);
							
							//  Concatenate the file description and the file text
							
							String filedesc_filetext = filedesc + "\n\n" + filetext;
							
							//  Add the file desc + \n\n + file text to a list
							
							filetextlist.add(filedesc_filetext);
						}
						
						
						//  Read the text area
						
						String text = textarea.getText().trim() + "\n";
						
						
						//  Prepend the subject to the message so the subject will be encrypted
						
						if (encrypt) text = __.Subject + ": " + subjstring + "\n\n" + text;
						
						
						//  Encode the subject + message
						
						text = Convert.stringToBase64(text);
						
						
						//  If the user has selected any file(s) to attach
						//
						//  splice (join) the encoded message text and
						//  the encoded (file desc + \n\n + file data)
						//
						//  (Splice can mean to join or to cut
						//  depending on the context)
						
						
						//  Initialize sendtext to the encoded typed message
						
						sendtext = text.trim();
						
						
						
						//  File Attachment
						//
						//  Append the encoded file descs + file texts
						//      to the encoded text / typed message
						
						
						while (filetextlist.size() != 0)
						{
							//  Add the encoded file text
							
							String filetext = filetextlist.remove(0);
							
							sendtext += "\n\n";
							
							sendtext += filetext;
						}
						
						
						
						if ((SP == null) || SP.isEmpty())
						{
							//  Prompt the user to enter a passphrase
							
							String title = __.passphrase;
							
							String passphrase = readPassphrase(
							
							    frame, foreground, background, font);
							
							if ((passphrase == null)
							  || passphrase.isEmpty())
							
								return;
							
							else SP = passphrase;
						}
						
						
						
						//  If the sender chooses a non-zero reply key size,
						//  prepend the sender's key so the recipient can reply
						//  to the message.
						
						
						//  System.out.println("number of ciphers == " + numberofciphers1[0]);
						
						//  Prepend the sender's static public key (reply key)
						
						if (encrypt && numberofciphers1[0] > 0)
						{
							//  Generate the sender's static reply key
							
							//  System.out.println("SP used for reply key == " + SP);
							//  System.out.println("use reply address in private key == " + usereplyaddresskey);
							//  System.out.println("number of ciphers == " + numberofciphers1[0]);
							
							String[] keys = PublicKey.generatePublicKey(SP,
							
							    usereplyaddresskey ? fromstring :
							
								"", numberofciphers1[0]);
							
							//  Concatenate the public reply keys
							
							String mypublickey = PublicKey.joinKeys(keys);
							
							//  Compute the public reply key hash
							
							String mypublickeyhash = Convert.partition(
							
							    PublicKey.hashPublicKey(mypublickey), " ", 4);
							
							//  System.out.println("reply key == " + mypublickey);
							
							System.out.println("reply key hash == \n" + mypublickeyhash);
							
							//  Prepend the sender's static public key
							
							sendtext = mypublickey + "\n\n" +
							
							    Convert.stringToBase64(sendtext);
						}
						
						
						
						//  Mail to the recipient and mail to self
						//
						//  The first message is encrypted and sent to the recipient;
						//  the second message is encrypted and self-addressed to the sender
						//  (unless the user has selected an option to disable this feature).
						//  This enables the user to retrieve the sent emails from the inbox.
						
						
						String sendtext1 = sendtext; // encrypted to recipient
						String sendtext2 = sendtext; // encrypted to self
						
						
						
						//  ENCRYPT THE MESSAGE using the recipient's public key
						//
						//  (if the recipient has a public key to encrypt to)
						
						
						//  Encryption multiplies the size of the data by up to 3/2 for
						//  the padding (to hide the size of the file) and multiplies the
						//  size by (4/3)^2 for the base-64 encoding (to hide the newlines)
						
						
						if (encrypt == true)
						{
							System.out.println("Encrypting the message");
							
							//  Generate the user's static public key to send a copy to self
							
							int numberofciphers = PublicKey.countNumberOfCiphers(recipientskey);
							
							System.out.println("number of encryption ciphers == " + numberofciphers);
							
							String[] keys = PublicKey.generatePublicKey(
							
							    SP, fromstring, numberofciphers);
							
							String mypublickey = PublicKey.joinKeys(keys);
							
							
							//  Encrypt the text (or reply key + "\n\n" + encoded text)
							//
							//  The message is encrypted to the recipient's static public key
							
							String text1 = sendtext1;
							
							
							//  It is redundant to encode in base 64 before encrypting
							//  because there is no reason to hide the newline chars
							
							if (Number.isBase64(text1)) // remove base-64
							
							    text1 = Convert.base64ToString(text1);
							
							
							if (testmail)
							{
								//  If the user pastes a public key in the to field,
								//  use the real public key instead of a test key so a
								//  user or software developer can copy the encrypted
								//  text from the send mail frame and paste it into the
								//  text editor to test the decryption using the Decrypt
								//  Message menu item.
								
								String[] testpublickey = (recipientskey != null) ?
								
								    PublicKey.splitKeys(recipientskey) :
								
									PublicKey .generatePublicKey(
								
									    testpassphrase, "", numberofciphers);
								
								sendtext1 = PublicKey.encrypt(text1, testpublickey);
								sendtext2 = PublicKey.encrypt(text1,   mypublickey);
							}
							
							else if (!testmail)
							{
								sendtext1 = PublicKey.encrypt(text1, recipientskey);
								sendtext2 = PublicKey.encrypt(text1,   mypublickey);
							}
							
							
							//  Encode the encrypted text to hide the newlines in the public key block
							//  (this encoding is redundant and can be removed by replacing the newline
							//  separators with the base-16 separator 0123456789abcdef)
							
							System.out.println("Encoding the ciphertext in base 64");
							
							//  sendtext1 = Convert.stringToBase64(sendtext1);
							//  sendtext2 = Convert.stringToBase64(sendtext2);
							
							
							//  This code can replace the stringTobase-64 conversion
							
							sendtext1 = sendtext1 .replaceAll("\n\n", Convert.base16Separator);
							sendtext2 = sendtext2 .replaceAll("\n\n", Convert.base16Separator);
						}
						
						
						else // if (encrypt == false)
						{
							//  If there is no encrypt key then remove any base-64
							//  encoding because the recipient may not have an
							//  encryption program to read the message
							
							if (filedatalist.size() == 0)
							{
								if (Number.isBase64(sendtext1.trim()))
								
								    sendtext1 = Convert.base64ToString(sendtext1.trim());
								
								if (Number.isBase64(sendtext2.trim()))
								
								    sendtext2 = Convert.base64ToString(sendtext2.trim());
							}
						}
						
						
						
						//  If the send text is in base 64, and the size
						//  is > min size, partition the base-64 text
						
						if (Number.isBase64(sendtext1.trim()) && (sendtext1.length() > minsize))
						
						    sendtext1 = Convert.partition(sendtext1.trim(), "\n", linesize);
						
						if (Number.isBase64(sendtext2.trim()) && (sendtext2.length() > minsize))
						
						    sendtext2 = Convert.partition(sendtext2.trim(), "\n", linesize);
						
						
						
						//  Create a confirmation message for the sender
						
						int maxtextlength = 256*1024;
						
						if ( encrypt) this.sendtext = __.thefollowingmessagewassentencrypted + "\n\n";
						if (!encrypt) this.sendtext = __.thefollowingmessagewassentunencrypted + "\n\n";
						
						this.sendtext += sendtext1.substring(0,
						
						    Math.min(sendtext1.length(), maxtextlength));
						
						//  Append an ellipsis if the file text is truncated
						
						if (sendtext1.length() > maxtextlength)
						
						    this.sendtext += " ... ";
						
						
						//  Request confirmation to send the message
						//  "Send plaintext" / "Send ciphertext"
						
						
						{	String unencryptedmessage = __.Sendplaintextmessage  + "?";
							String   encryptedmessage = __.Sendciphertextmessage + "?";
							
							String title1 = __.Sendmessage;
							
							//  int messagetype;
							//
							//  if (encrypt == true)
							//
							//       messagetype = JOptionPane.QUESTION_MESSAGE;
							//  else messagetype = JOptionPane. WARNING_MESSAGE;
							
							final int choice;
							
							ImageIcon   encryptedicon = Icons.get(Icons.message_48x48);
							ImageIcon unencryptedicon = Icons.get(Icons   .text_48x48);
							
							
							JButton yes_button, no_button;
							
							Icon icon = encrypt ? encryptedicon : unencryptedicon;
							
							
							yes_button = new JButton(__.Yes, Icons.get(Icons.dialog_ok_24x24));
							 no_button = new JButton(__.No,  Icons.get(Icons.dialog_no_24x24));
							
							Object[] options = new Object[] { yes_button, no_button };
							
							String message = encrypt ? encryptedmessage : unencryptedmessage;
							
							
							JLabel label = new JLabel(message);
							
							label.setFont(labelfont);
							
							Box hbox = Box.createHorizontalBox();
							
							hbox.add(label);
							
							
							JOptionPane pane = new JOptionPane(hbox, JOptionPane
							
							  .PLAIN_MESSAGE, JOptionPane.DEFAULT_OPTION, icon, options, 0);
							
							//  pane .set(...)
							
							String title = "";
							
							JDialog dialog = pane.createDialog(frame, title);
							
							int[] choice1 = new int[] { -1 };
							
							yes_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice1[0] = JOptionPane.YES_OPTION; dialog.dispose(); } } );
							
							no_button.addActionListener( new ActionListener()
							{ public void actionPerformed(ActionEvent e)
							{ choice1[0] = JOptionPane.NO_OPTION; dialog.dispose(); } } );
							
							dialog.setVisible(true);
							
							if (choice1[0] != JOptionPane.YES_OPTION)
							
							    { sendtext = null; return; }
						}
						
						
						
						//  If the user has not entered a userpass
						//  then use the hash of the passphrase + email
						//  to generate an auto password for the mail server.
						//  This makes the userpass different for each account.
						
						//  (If the user ever changes the passphrase, the user
						//  will also have to change the userpass on the email
						//  account because it equals the hash of the passphrase
						//  + the email, or the user can override the auto pass-
						//  word by entering the previous password.)
						
						if ((userpass == null) || userpass.isEmpty())
						
						    userpass = Cipher.hash2(SP + fromfield.getText())
						
						        .substring(0, 8);
						
						
						
						
						//  Save a copy of the text area so that if the user
						//  types a message and sends it, the user can still
						//  view the message and copy and paste the text into
						//  another text area.
						
						plaintext = textarea.getText();
						
						
						
						//  Send the ciphertext message
						
						//  If the user has already retrieved his or her email, then there
						//  is no need to prompt the user to enter and confirm the userpass.
						//
						//  If the user is not authorized to send email, prompt the user
						//  to confirm or replace the userpass for this username.
						
						
						//  the user will know if the userpass is incorrect because
						//  a JOptionPane will display a wrong userpass error
						
						if (false)  ////  if (!authorized)
						{
							String password = "";
							
							String title = __.enterpasswordforthisemailaddress;
							
							while ((password.length() == 0) || (password.length() >= 16))
							{
								//  Prompt the user to enter or confirm a password
								
								JTextField textfield;
								
								textfield = new JTextField(24);
								
								textfield.setFont(font);
								
								textfield.setText(userpass != null ? userpass : "");
								
								JOptionPane.showMessageDialog(frame, textfield,
								
								    title, JOptionPane.PLAIN_MESSAGE);
								
								String input = textfield.getText();
								
								password = input;
								
								if (password == null)
								{
									clicked = false;
									
									//  Hide the lower text area
									//  (not used for anything)
									
									scrollpane2.setVisible(false);
									
									return;
								}
							}
							
							userpass = password;
						}
						
						
						String username = fromstring;
						
						if (fromstring.contains(" "))
						
						    username = fromstring .substring(
						
							0, fromstring.indexOf(" "));
						
						
						//  Use the sendMail method to send the message to the recipient
						//  and then use the method to send the message to self (unless the
						//  message is addressed to self because that would be redundant)
						
						String subject1 = subjstring;
						
						if (encrypt) subject1 = null;
						
						SendMail sendmail = new SendMail(
						
						    outgoingmailserver, outgoingmailport);
						
						textarea.removeMouseListener(mouselistener);
						
						sendmail.setTextArea(textarea2);
						
						sendmail.setTestMail(testmail);
						
						//  System.out.println("Sending the ciphertext");
						
						//  to, from, password, subject, text
						
						sent1 = sendmail .send( // send to recipient
						
						    tostring, username, userpass, subject1, sendtext1);
						
						if (!sent1)
						{
							String error_message = sendmail.error_message;
							
							if (error_message.equals(__.authentication_error))
							
							    error_message += "\n" + __.userpass + " == " + userpass;
							
							JOptionPane.showMessageDialog(frame,
							
							    error_message, "", JOptionPane.ERROR_MESSAGE);
							
							return;
						}
						
						
						//  Send a self-addressed envelope
						
						if (sent1 && mailcopytoself && !tostring.equals(fromstring))
						{
							textarea2.append("\n\n\n\n");
							textarea2.append("Sending copy to self");
							textarea2.append("\n");
							
							//  Use the from string to mail to self
							
							String fromaddress = fromstring.trim();
							
							sent2 = sendmail .send(// send to self
							
							    fromaddress, username, userpass, subject1, sendtext2);
						}
						
						clientservertext = sendmail.getText();
						
						textarea.setText(clientservertext);
						
						textarea.setCaretPosition(0);
						
						if (testmail)
						{
							JLabel testlabel = new JLabel(__.testmail);
							
							testlabel.setFont(labelfont);
							
							JOptionPane.showMessageDialog(
							
							    frame, testlabel);
						}
					}
					
					catch (SocketTimeoutException ex)
					{
						clicked = false;
						
						scrollpane2.setVisible(false);
						
						JOptionPane.showMessageDialog(panel,
						
						    __.unabletoconnecttoserver + " " + outgoingmailserver,
						
							"", JOptionPane.ERROR_MESSAGE);
						
						return;
					}
					
					catch (IOException ex)
					{
						clicked = false;
						
						scrollpane2.setVisible(false);
						
						JOptionPane.showMessageDialog(panel,
						
						    __.unabletoconnecttoserver + " " + outgoingmailserver,
						
							"", JOptionPane.ERROR_MESSAGE);
						
						return;
					}
					
					catch (Exception ex)
					{
						ex.printStackTrace();
					}
					
					
					finally
					{
						//  Set sending = false so the sendmail
						//  frame can be closed by the user
						
						new Thread(() ->
						{
							try { Thread.sleep(500); }
							
							catch (InterruptedException ex) {  }
							
							sending = false;
						
						} ).start();
						
						
						if (!sent1)
						{
							sendbutton.setText(__.Send);
							
							//  scrollpane2.setVisible(false);
							
							clicked = false;
							
							return;
						}
						
						//  Disable the text field
						
						textarea.setEditable(false);
					}
				}
			}
			
			
			//  End class SendButtonListener
			
			
			
			
			
			
			
			
			private class AttachListener implements ActionListener
			{
				//  This class is not used because the sendbuttonlistener
				//  method prompts the user to attach a file or directory
				
				private String directory;
				
				public void actionPerformed(ActionEvent e)
				{
					
				}
			}
			
			
			
			private class OpenListener implements ActionListener
			{
			
				private String directory;
				
				private String title;
				
				
				public OpenListener() {  }
				
				public OpenListener(String title)
				{
					this.title = title;
				}
				
				
				public void actionPerformed(ActionEvent e) { run(); }
				
				
				public void run()
				{
				
					try
					{
					
					//  Choose a file
					
					File file = chooseFile();
					
					if (file == null) return;
					
					directory = file.getParent();
					
					
					//  Open and decrypt the file
					
					byte[] plaindata = open(file);
					
					if (plaindata == null) return;
					
					//  Prepend the file text to the reply text
					//  or text that the user has entered
					
					String text1 = new String(plaindata);
					
					String text2 = textarea.getText();
					
					
					if (text2.isEmpty())
					{
						//  Display the text
						
						textarea.setText(text1 + text2);
						
						textarea.setCaretPosition(0);
					}
					
					else // if (!text2.isEmpty())
					{
						//  | insert | | prepend | | append |
						
						int cp = textarea.getCaretPosition();
						
						String title = "";
						
						Object[] choices = { __.insert, __.prepend, __.append };
						
						int choice = JOptionPane.showOptionDialog(frame, "", title,
						
						    JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
						
						        null, choices, choices[1]);
						
						if (choice == 0) // insert
						
						    textarea.setText( text2.substring(0, cp) + 
						
							text1 + text2.substring(cp, text2.length()) );
						
						if (choice == 1) // prepend
						
						    textarea.setText( text1 + text2 );
						
						if (choice == 2) // append
						
						    textarea.setText( text2 + text1 );
						
						textarea.setCaretPosition(cp);
					}
					
					}
					
					finally
					{
						textarea.requestFocusInWindow();
					}
				}
				
				
				private File chooseFile()
				{
					File file = null;
					
					JFileChooser fc;
					
					fc = new FileChooser(directory);
					
					fc.setFont(font);
					
					fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
					
					int choice = fc.showOpenDialog(frame);
					
					if (choice == JFileChooser.APPROVE_OPTION)
					{
						file = fc.getSelectedFile();
						
						directory = file.getParent();
						
						return file;
					}
					
					else if (choice == JFileChooser.CANCEL_OPTION)
					
					     return null;
					
					else return null;
				}
				
				
				
				private File chooseFileOrDirectory()
				{
					File file = null;
					
					int mode = JFileChooser.FILES_AND_DIRECTORIES;
					
					JFileChooser fc;
					
					fc = new FileChooser(directory);
					
					fc.setFileSelectionMode(mode);
					fc.setDialogTitle(title);
					fc.setFont(font);
					
					int choice = fc.showOpenDialog(frame);
					
					if (choice == JFileChooser.APPROVE_OPTION)
					{
						file = fc.getSelectedFile();
						
						directory = file.getParent();
						
						return file;
					}
					
					else if (choice == JFileChooser.CANCEL_OPTION)
					
					     return null;
					
					else return null;
				}
				
				
				
				private byte[] open(File file)
				{
					if (file.length() > 16*1024*1024)
					{
						String message = __.largefile;
						
						JOptionPane.showMessageDialog(frame,
						
						    message, "", JOptionPane.ERROR_MESSAGE);
						
						return null;
					}
					
					byte[] input = null;
					
					try { input = DataStream.read(file); }
					
					catch (IOException ex)
					{
						String message = __.filenotfound;
						
						JOptionPane.showMessageDialog(frame,
						
						    message, "", JOptionPane.ERROR_MESSAGE);
						
						return null;
					}
					
					byte[] plaindata = input;
					
					
					if (!Cipher.isEncrypted(file))
					{
						//  Remember to save as unencrypted file
						
						//  encrypted = false
					}
					
					else
					{	//  Remember to save as encrypted file
						
						//  encrypted = true;
					}
					
					
					if (Cipher.isEncrypted(file))
					{
					
						FileDecryptor fd;
						
						fd = new FileDecryptor(frame);
						fd.setFileKey(filekey);
						fd.setPassphrase(SP);
						fd.setFont(textarea.getFont());
						
						plaindata = fd.decrypt(input);
						
						if (plaindata == null)
						{
							encrypted = false;
							
							return null;
						}
						
						filekey = fd.getFileKey();
					}
					
					return plaindata;
				}
			}
			
			
			
			private class SaveListener implements ActionListener
			{
			
				public void actionPerformed(ActionEvent e)
				{
					//  ...
					
					//  ...
				}
			}
			
			
			private class SaveAsListener implements ActionListener
			{
			
				public void actionPerformed(ActionEvent e)
				{
				
					String text = textarea.getText();
					
					byte[] filedata = text.getBytes();
					
					
					//  Prompt the user to choose a file name
					
					File file = new SaveFile(frame, __.saveas)
					
					   .setDirectory(directory) .setFont(font) .chooseFile();
					
					if (file == null) return;
					
					
					//  Save the file
					
					int result = new SaveFile(frame, __.save)
					
					    .setDirectory(directory) .setFont(font)
					
						.save(filedata, file, true);
					
					if ((result == JOptionPane.NO_OPTION)
					 || (result == JOptionPane.CANCEL_OPTION)
					 || (result == JOptionPane.CLOSED_OPTION))
					
					    return;
					
					
					//  Ask if the user wants to encrypt the file
					
					if (!Cipher.isEncrypted(file))
					{
						String question = __.encryptfile + "?";
						
						Object[] options = new Object[] { __.Yes, __.No };
						
						int choice = JOptionPane.showOptionDialog(
						
						    frame, question, null,
						
							JOptionPane.DEFAULT_OPTION,
							JOptionPane.QUESTION_MESSAGE,
							
							    null, options, options[0]);
						
						//  If yes encrypt the file
						
						if (choice == 0)
						{
							//  Display a dialog to encrypt and
							//  save the attached file to disk
							
							FileEncryptor fe;
							
							fe = new FileEncryptor(frame);
							fe.setFont(textarea.getFont());
							
							if (filekey != null) fe.setFileKey(filekey);
							
							else if ((SP != null) && !SP.isEmpty())
							
							    fe.setFileKey(Cipher.passphraseToKey(SP));
							
							fe.encrypt(file, true);
						}
					}
				}
			}
			
			
			
			private class ExitListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					//  Don't close the frame if the program is
					//  sending email (send button is clicked)
					
					if (sendbuttonlistener.sending) return;
					
					//  (Calling dispose on the send mail frame just
					//  hides the window because the retrieve mail frame
					//  created the send mail frame and therefore only
					//  the retrieve mail frame can dispose it)
					
					//  Tell the retrieve mail frame to dispose the send
					//  mail frame, and hide the send mail frame until the
					//  retrieve mail frame disposes it
					
					disposed = true;
					
					frame.dispose();
				}
			}
			
			
			
			private class WindowListener1 extends WindowAdapter
			{
				public void windowClosing(WindowEvent e)
				{
					exitlistener.run();
				}
			}
			
			
			
			
			
			//  This is the Send Mail class
			//
			//  These sendMail methods are called by the RetrieveMailFrame
			//  to initialize the SendMailFrame when the user clicks the
			//  Send Mail menu item or clicks "reply" to email in a message
			
			
			//  These methods can be declared public or private
			//
			//  (These methods should be public because they are called
			//  by another class, but they can also be declared private
			//  because the RetrieveMail and SendMail frames are both
			//  inside the Mail class.)
			
			
			public void setOutgoingMailServer(String server)
			{
				outgoingmailserver = server;
			}
			
			public void setOutgoingMailPort(int port)
			{
				outgoingmailport = port;
			}
			
			public void setToField(String to)
			{
				tofield.setText(to);
				tofield.setCaretPosition(0);
			}
			
			public void setFromField(String from)
			{
				fromfield.setText(from);
				fromfield.setCaretPosition(0);
				fromfield.setEditable(false);
			}
			
			public void setSubjectField(String subject)
			{
				subjfield.setText(subject);
				subjfield.setCaretPosition(0);
			}
			
			public void setSendersReplyKey(String to, String replykey)
			{
				if ((replykey != null) && !replykey.isBlank())
				{
					recipientskeyaddress = to;
					
					recipientskey = replykey;
					
					//    tofield .setEnabled(false);
					//  fromfield .setEnabled(false);
					//  subjfield .setEnabled(false);
					
					keyiconlabel.setVisible(true);
					
					keyiconlabel.repaint();
				}
			}
			
			
			public void setEditable(boolean bool)
			{
				  tofield.setEditable(bool);
				fromfield.setEditable(bool);
				subjfield.setEditable(bool);
				
				if (!bool) subjlabel.setToolTipText(
				    __.clicktoedit);
				
				if (bool == false)
				
				if (!fromfield.getText().isBlank()
				  &&   tofield.getText().isBlank())
				
				    // The header has no reply address.
				    // The sender may have included an
				    // address in the encrypted message.
				
				    tofield.setEditable(true);
			}
			
			
			public void setForeground1(Color color)
			{
				foreground = color;
				
				if (!reverse_colors)
				{
					textarea .setForeground(color);
					textarea2.setForeground(color);
					
					textarea .setCaretColor(color);
					textarea2.setCaretColor(color);
				}
				
				else // if (reverse_colors)
				{
					textarea .setBackground(color);
					textarea2.setBackground(color);
				}
				
				if (!color.equals(Color.white))
				{
					  tofield .setForeground(color);
					fromfield .setForeground(color);
					subjfield .setForeground(color);
					
					  tofield .setCaretColor(color);
					fromfield .setCaretColor(color);
					subjfield .setCaretColor(color);
				}
				
				if (keyboardlistener.keyboard != null)
				    keyboardlistener.keyboard.setForeground(color);
			}
			
			
			public void setBackground1(Color color)
			{
				background = color;
				
				if (!reverse_colors)
				{
					textarea .setBackground(color);
					textarea2.setBackground(color);
				}
				
				else // if (reverse_colors)
				{
					textarea .setForeground(color);
					textarea2.setForeground(color);
					
					textarea .setCaretColor(color);
					textarea2.setCaretColor(color);
				}
				
				
				//  Set the foreground (not background)
				//  because the colors may be reversed
				
				if (!color.equals(Color.white))
				{
					  tofield .setForeground(color);
					fromfield .setForeground(color);
					subjfield .setForeground(color);
					
					  tofield .setCaretColor(color);
					fromfield .setCaretColor(color);
					subjfield .setCaretColor(color);
				}
				
				if (keyboardlistener.keyboard != null)
				    keyboardlistener.keyboard.setBackground(color);
			}
			
			
			public void setReverseColors(boolean bool)
			{
				reverse_colors = bool;
			}
			
			public void setNumberOfCiphers(int numberofciphers)
			{
				this.numberofciphers = numberofciphers;
			}
			
			public void setUseReplyAddressKey(boolean usereplyaddresskey)
			{
				this.usereplyaddresskey = usereplyaddresskey;
			}
			
			
			public void setFont1(Font font)
			{
			
				//  sets the font for the SendMail frame and Keyboard
				
				//  This method is not named setFont because
				//  then it would be called twice instead of once
				//  and the font may get reset to the default font
				
				
				this.font = font;
				
				Dimension d = frame.getSize();
				
				int framearea = (int) (d.getWidth() * d.getHeight());
				
				int maxsize = maxfontsize + 2;
				
				float maxbuttonsize = maxfontsize;
				float maxboxsize = maxfontsize - 2;
				float maxtextfieldsize = maxfontsize - 2;
				float maxlabelsize = maxtextfieldsize;
				
				//  Make the keyboard font larger than the send mail frame font
				
				if (keyboardlistener.keyboard != null)
				{
					keyboardlistener.keyboard.setFont(
					
					    font.deriveFont(font.getSize() + 4.0f));
					
					keyboardlistener.keyboardframe.setSize(
					keyboardlistener.keyboardframe.getPreferredSize());
				}
				
				
				
				//  Set the max font size for the buttons,
				//  labels, boxes, and text fields
				
				
				for (Component component : components)
				{
					component.setFont(font);
					
					if (component instanceof JButton)
					{
						if (font.getSize() > maxbuttonsize)
						
						    component.setFont(font.deriveFont(maxbuttonsize));
					}
					
					else if (component instanceof JLabel)
					{
						if (font.getSize() > maxlabelsize)
						
						    component.setFont(font.deriveFont(maxlabelsize));
					}
					
					else if (component instanceof JComboBox)
					{
						if (font.getSize() > maxboxsize)
						
						    component.setFont(font.deriveFont(maxboxsize));
					}
					
					else if (component instanceof JTextField)
					{
						if (font.getSize() > maxtextfieldsize)
						
						    component.setFont(font.deriveFont(maxtextfieldsize));
					}
					
					//  else if (component instanceof ...)
					//  {
					//  	if (font.getSize() > ...)
					//	
					//  	    component.setFont(font.deriveFont(...));
					//  }
				}
				
				
				//  Change the public key icon size for the send mail frame
				
				{
					//  Read the original icon so it doesn't get distorted
					
					ImageIcon keyicon = Icons.get(Icons.keyring);
					
					Image image = keyicon.getImage();
					
					//  Scale the icon size to the frame area
					
					double m = Math.sqrt(2.0D * framearea / screenarea);
					
					int width = (int) (20 + 20 * m); // m = 0 to 1.4
					
					//  System.out.print(width + "  ");
					
					//  Set the max and min icon sizes
					
					int miniconsize =  8;
					int maxiconsize = 32;
					
					if (width > maxiconsize) width = maxiconsize;
					if (width < miniconsize) width = miniconsize;
					
					//  Scale the icon size to the font size
					
					//  (the icon size can exceed the maxicon
					//  size for the font, not the frame area)
					
					double fontsize = font.getSize();
					
					width = (int) (width * fontsize / defaultfontsize);
					
					if (width == 0) width = 1;
					
					int height = -1, hints = Image.SCALE_SMOOTH;
					
					image = image.getScaledInstance(width, height, hints);
					
					keyicon = new ImageIcon(image);
					
					keyiconlabel.setIcon(keyicon);
				}
				
				
				//  Change the icon panel sizes for the send mail frame
				
				for (int i = 0; i < iconbuttons.length; i++)
				{
					//  Read the original image so the
					//  icon doesn't get distorted
					
					if (imageicons[i] == null) continue;
					
					Image image = imageicons[i].getImage();
					
					//  Scale the icon size to the frame area
					
					double m = Math.sqrt(2.0D * framearea / screenarea);
					
					int width = (int) (10 + 20 * m); // m = 0 to 1.4
					
					//  System.out.print(width + "  ");
					
					//  Set the max and min icon sizes
					
					int miniconsize =  8;
					int maxiconsize = 28;
					
					if (width > maxiconsize) width = maxiconsize;
					if (width < miniconsize) width = miniconsize;
					
					//  Scale the icon size to the font size
					
					//  (the icon size can exceed the maxicon
					//  size for the font, not the frame area)
					
					double fontsize = font.getSize();
					
					width = (int) (width * fontsize / defaultfontsize);
					
					if (width == 0) width = 1;
					
					int height = -1, hints = Image.SCALE_SMOOTH;
					
					image = image.getScaledInstance(width, height, hints);
					
					ImageIcon scaledicon = new ImageIcon(image);
					
					iconbuttons[i].setIcon(scaledicon);
				}
			}
			
			
			
			public void setFrameSize()
			{
				//  sets the SendMail frame size
				
				int w = 440, h = 500;
				
				//  Scale the size of the frame so that the
				//  frame is proportioned to the screen size
				
				//  1920 / 1080 ~ 1.77;  440 * 1.77 ~ 770;
				//  1366 /  768 ~ 1.77;  500 * 1.77 ~ 885;
				
				float m1 = 1.0f * screenwidth / 1366;
				float m2 = 1.0f * screenheight / 768;
				
				//  System.out.println("m1 m2 == " + m1 + "  " + m2);
				
				w = (int) (w * m1);
				h = (int) (h * m2);
				
				frame.setSize(w, h);
			}
			
			
			public void setCaretPosition(int cp)
			{
				int cp1 = cp > 0 ? cp - 1 : 0;
				
				textarea. setCaretPosition(cp);
				textarea.moveCaretPosition(cp1);
				textarea. setCaretPosition(cp);
			}
			
			
			public void setText(String text)
			{
				textarea.setText(text);
				
				textarea.requestFocusInWindow();
			}
			
			
			public void requestFocusInWindow(String field)
			{
				if (field.equals("tofield"))
				
				    tofield.requestFocusInWindow();
				
				else if (field.equals("fromfield"))
				
				    fromfield.requestFocusInWindow();
				
				else if (field.equals("subjectfield"))
				
				    subjfield.requestFocusInWindow();
				
				else if (field.equals("textarea"))
				
				    textarea.requestFocusInWindow();
			}
			
			
			
			private class UndoListener implements ActionListener
			{
				//  the send mail text area undo listener
				
				public void actionPerformed(ActionEvent e)
				{
					if (textarea == null) return;
					
				////	if (e.getSource() == undomenuitem) undo();
				////	if (e.getSource() == redomenuitem) redo();
					
					if (e.getSource() == undobutton) undo();
					if (e.getSource() == redobutton) redo();
					
					textarea.requestFocusInWindow();
				}
				
				public void undo() { undo.undo(); }
				public void redo() { undo.redo(); }
			}
			
			
			private class CutListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					//  Save a copy of the send text
					
					undo.push();
					
					textarea.cut();
					
					textarea.requestFocusInWindow();
				}
			}
			
			
			private class CopyListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					textarea.copy();
					
					textarea.requestFocusInWindow();
				}
			}
			
			
			private class PasteListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					//  Save a copy of the send text
					
					undo.push();
					
					textarea.paste();
					
					textarea.requestFocusInWindow();
				}
			}
			
			
			
			//  The SendMailFrame increment and decrement size methods
			
			
			private void incrementSize(float increment)
			{
				fontsize = fontsize + increment;
				
				if (fontsize > maxfontsize)
				    fontsize = maxfontsize;
				
				Font newfont = font.deriveFont(fontsize);
				
				font = newfont;
				
				setFont1(newfont);
			}
			
			
			private void decrementSize(float decrement)
			{
				fontsize = fontsize - decrement;
				
				if (fontsize < minfontsize)
				    fontsize = minfontsize;
				
				Font newfont = font.deriveFont(fontsize);
				
				font = newfont;
				
				setFont1(newfont);
			}
			
			
			
			private class MouseListener extends MouseAdapter
			{
				//  This is the SendMail mouse listener
				
				private JPopupMenu popupmenu;
				
				public MouseListener()
				{
					popupmenu = new JPopupMenu();
					
					JMenuItem menuitem;
					
					menuitem = new JMenuItem(__.cut);
					menuitem.addActionListener(new CutListener());
					popupmenu.add(menuitem);
					
					menuitem = new JMenuItem(__.copy);
					menuitem.addActionListener(new CopyListener());
					popupmenu.add(menuitem);
					
					menuitem = new JMenuItem(__.paste);
					menuitem.addActionListener(new PasteListener());
					popupmenu.add(menuitem);
					
					//  popupmenu.addSeparator();
				}
				
				
				public void mouseEntered(MouseEvent e) {  }
				public void mouseExited (MouseEvent e) {  }
				public void mouseClicked(MouseEvent e) {  }
				
				public void mousePressed(MouseEvent e)
				{
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						popupmenu.show(textarea, e.getX(), e.getY());
					}
					
					if (e.getSource() == keyiconlabel)
					{
						if ((recipientskey != null) && !recipientskey.isEmpty())
						{
							String title = __.recipientspublickeyhash;
							
							displayPublicKeyHash(keyiconlabel, recipientskey, title);
						}
					}
				}
				
				public void mouseReleased(MouseEvent e)
				{
				
				}
			}
			
			
			
			
			
			//  This is the SendMailFrame KeyListener
			
			
			private class KeyListener1 extends KeyAdapter
			{
			
				private boolean shift, control, keypressed;
				
				public void keyPressed(KeyEvent e)
				{
					keypressed = true;
					
					int keychar = e.getKeyChar();
					int keycode = e.getKeyCode();
					
					if (keycode == vk_shift) shift = true;
					
					else if (keycode == vk_control) control = true;
					
					else if (control && (keycode == __.exitkeycode))
					{
						exitlistener.run();
						
						control = false;
					}
					
					if (control && (keychar == __.pluskeychar))
					{
						incrementSize(1);
					}
					
					else if (control && (keychar == __.minuskeychar))
					{
						decrementSize(1);
					}
					
					else if (control && (keycode == __.passphrasekeycode))
					{
						control = false;
						
						if (!authorized) // if (message is not a reply frame)
						{
							parsePassphraseServersAndDirectory(
							 readPassphraseServersAndDirectory(
							
							    frame, foreground, background, font,
							      incomingmailserver, outgoingmailserver,
							        incomingmailport, outgoingmailport,
								   maildirectory, numberofmessages,
								     ascending));
						}
					}
					
					
					if (e.getSource() == tofield)
					{
						//  Read the recipient's public key from the clipboard
						//  when the user presses the enter key in the to field
						
						//  If keyReleased were used instead of keyPressed,
						//  the JOptionPane that says "Address on clipboard key
						//  does not match address in to field" would not close
						//  by pressing the enter key because as soon as the
						//  enter key is pressed, the option pane closes which
						//  transfers the focus back to the to field, and then
						//  as the enter key is released, the option pane would
						//  be reopened because the to field has the focus.
						
						if (e.getKeyChar() == '\n')
						
						    readRecipientsKey(e);
					}
				}
				
				
				
				public void keyReleased(KeyEvent e)
				{
					keypressed = false;
					
					if (e.getKeyCode() == vk_shift)
					
					    shift = false;
					
					else if (e.getKeyCode() == vk_control)
					
					    control = false;
				}
				
				
				
				private class MouseWheelListener1 implements MouseWheelListener
				{
					//  This is the SendMail Frame MouseWheelListener
					
					private boolean resized;
					
					private int freq = 8; // 8 x per sec
					
					public void mouseWheelMoved(MouseWheelEvent e)
					{
						if (resized) return;
						
						else resized = true;
						
						new Thread(() ->
						{
							try { Thread.sleep(1000 / freq); }
							
							catch (InterruptedException ex) {  };
							
							resized = false;
						
						}).start();
						
						int rotation = e.getWheelRotation();
						
						//  ...
						
						if (control)
						{
							if (rotation > 0) incrementSize(1.00f);
							if (rotation < 0) decrementSize(1.00f);
							
						///	setFrameSize();
						}
					}
				}
			}
			
			
			
			
			private void parsePassphraseServersAndDirectory(String[] input)
			{
			
				//  This is a SendMailFrame method
				//
				//  The SendMailFrame class does not allow multiple tabs
				//  which is why there is only one instance of the incom-
				//  ing and outgoing servers and port numbers.
				//
				//  (The incoming server field might not be required
				//  because it is used only for retrieving mail.)
				
				
				if (input == null) return;
				
				if ((input[0] != null) && !input[0].isEmpty())
				{
					SP = input[0] + input[1];
					
					SP0 = input[0];
				}
				
				if ((input[2] != null) && !input[2].isEmpty())
				{
					//  Store incoming mail server and port
					
					String[] tokens = input[2].split(" {1,}");
					
					if (tokens.length == 1)  //  error
					{
						incomingmailserver = tokens[0];
					}
					
					else if (tokens.length == 2)
					{
						incomingmailserver = tokens[0];
						
						if (Number.isDigitString(tokens[1], 10))
						
						    incomingmailport = Integer.parseInt(tokens[1]);
					}
					
					else if (tokens.length > 2)  //  error
					{
						incomingmailserver = null;
					}
				}
				
				
				if ((input[3] != null) && !input[3].isEmpty())
				{
					//  Store outgoing mail server and port
					
					String[] tokens = input[3].split(" {1,}");
					
					if (tokens.length == 1)  //  error
					{
						outgoingmailserver = tokens[0];
					}
					
					else if (tokens.length == 2)
					{
						outgoingmailserver = tokens[0];
						
						if (Number.isDigitString(tokens[1], 10))
						
						    outgoingmailport = Integer.parseInt(tokens[1]);
					}
					
					else if (tokens.length > 2)  //  error
					{
						outgoingmailserver = null;
					}
				}
				
				
				if ((input[4] != null) && !input[4].isEmpty())
				{
					maildirectory = input[4];
				}
				
				if ((input[5] != null) && !input[5].isEmpty())
				{
					try { messagesperscreen = Integer.parseInt(input[5]); }
					
					catch (NumberFormatException ex) {  }
				}
			}
		}
		
		
		//  End class SendMailFrame
		
		
		
		
		
		
		
		//  The SendMailFrame KeyboardListener
		
		
		private class KeyboardListener implements ActionListener
		{
		
			private Keyboard keyboard;
			
			private JFrame keyboardframe;
			
			private class WindowListener1 extends WindowAdapter
			{
				public void windowClosing(WindowEvent e)
				{
					keyboardframe.dispose();
					keyboardframe = null;
					keyboard = null;
				}
			}
			
			public void actionPerformed(ActionEvent e)
			{
				run();
			}
			
			public void run()
			{
				if (keyboardframe == null)
				{
					keyboard = new Keyboard();
					
					keyboardframe = keyboard.getFrame();
					keyboardframe.setLocationRelativeTo(null);
					keyboardframe.addWindowListener(
					    new WindowListener1());
				}
				
				if (keyboardframe != null)
				    keyboardframe.setVisible(true);
				
				setFont(font.deriveFont(font.getSize() + 4.0f));
			}
			
			public void setTextComponent(JTextComponent comp)
			{
				keyboard.setTextComponent(comp);
			}
			
			public void setForeground(Color color)
			{
				keyboard.setForeground(color);
			}
			
			public void setBackground(Color color)
			{
				keyboard.setBackground(color);
				keyboard.setKeyboardBackground(color);
			}
			
			public void setFont(Font font)
			{
				keyboard.setFont(font);
				keyboardframe.setSize(
				keyboardframe.getPreferredSize());
			}
		}
		
		
		//  End class KeyboardListener
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		public class RetrieveMailFrame extends JFrame
		{
		
			private static final long serialVersionUID = 1L;
			
			private JFrame frame;
			
			private int width, height;
			
			private JDraggableTabbedPane tabbedpane;
			
			private EmailPanel emailpanel;
			
			//  The pop3 window is used to display the
			//  the pop3 client / server communication
			
			private JWindow pop3window;
			
			private boolean readmailsettings;
			
			
			private String fontname = __.monospaced;
			private int fontstyle = Font.BOLD;
			private float fontsize = defaultfontsize;
			
			private Font font = new Font(
			
			    fontname, fontstyle, (int) fontsize);
			
			
			private boolean showsentemails = true;
			
			
			//  In Java the cursor refers to the mouse pointer 'I',
			//  and the caret refers to the blinking character '|'.
			
			private Cursor default_cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			private Cursor    wait_cursor = Cursor.getPredefinedCursor(Cursor.   WAIT_CURSOR);
			
			
			//  the popup messages
			
			private String   testmailpopupmsg = __.testmail;
			private String delebuttonpopupmsg = __.nocheckedboxes;
			private String    readallpopupmsg = __.listfirst;
			private String     deletepopupmsg = __.deleteboxischecked;
			private String      replypopupmsg = __.deleteboxischecked;
			private String       prevpopupmsg = __.firstmessage;
			private String       nextpopupmsg = __.lastmessage;
			
			
			
			//  Icons for the list screen
			
			//  A stamp icon will be displayed next to messages that are self-addressed.
			//  (The send method mails one copy to the recipient and one copy to self.)
			//
			//  A regular envelope icon will be displayed next to messages that are received.
			//  A paper clip icon will be displayed next to messages that have file attachments.
			
			
			ImageIcon plaintext_unreadicon = Icons.get(Icons.new_); // paper + gold star
			ImageIcon plaintext_readicon   = Icons.get(Icons.file); // paper - gold star
			
			ImageIcon messageicon = Icons.get(Icons.message); // closed envelope
			
			ImageIcon senticon    = Icons.get(Icons.mail_send_32x32); // postage stamp
			ImageIcon attachicon  = Icons.get(Icons.attachment);      // paper + paper clip
			
			
			//  icon popup menu (the list / decrypt thread will change the icons)
			
			ImageIcon  unreadicon = Icons.get(Icons.unread_mail_32x32);  // new envelope gold star
			ImageIcon    readicon = Icons.get(Icons.read_mail_32x32);    // opened envelope
			ImageIcon repliedicon = Icons.get(Icons.mail_replied_32x32); // curved left arrow
			
			//  ImageIcon  deleteicon = Icons.get(Icons.delete_32x32);   // red circle around (x)
			ImageIcon  deleteicon = Icons.get(Icons.trash_32x32);        // trash can
			
			ImageIcon  importicon = Icons.get(Icons.mail_important_32x32); // red exclamation point
			ImageIcon  urgenticon = Icons.get(Icons.urgent_32x32);        // red circular clock
			ImageIcon    spamicon = Icons.get(Icons.trash_32x32);        // trash can
			
			ImageIcon    staricon = Icons.get(Icons.star_32x32);         // star icon
			ImageIcon    saveicon = Icons.get(Icons.save_24x24);         // save icon
			
			
			//  these image icons correspond to the MessageState enum
			
			private ImageIcon[] imageicons2 = new ImageIcon[]
			{
				unreadicon,
				readicon,
				repliedicon,
				deleteicon,
				importicon,
				urgenticon,
				spamicon,
				staricon,
				saveicon,
			};
			
			
			
			//  Icons for the icon / button panel
			
			//   ------------ --------- ------ ----------- ----------- ------------- ---------------
			//  | Passphrase | Compose | Bold | Font size | Print key | Show emails | Reverse color |
			//   ------------ --------- ------ ----------- ----------- ------------- ---------------
			
			ImageIcon composeicon = Icons.get(Icons.mail_send_32x32);
			ImageIcon passphraseicon = Icons.get(Icons.keyring);
			ImageIcon textboldicon1 = Icons.get(Icons.text_bold_32x32);
			ImageIcon fontsizeicon = Icons.get(Icons.font_32x32);
			ImageIcon printkeyicon = Icons.get(Icons.document_print_24x24);
			ImageIcon showhideicon = Icons.get(Icons.list_remove_48x48);
			ImageIcon reversecolorsicon = Icons.get(Icons.reverse_colors_32x32);
			
			//  ...
			
			
			
			//  Menu, Menu Items, ...
			
			
			//  Mail Program
			
			
			JMenuItem[] menuitems;
			
			JMenuBar menubar;
			
			JMenu filemenu, editmenu, viewmenu, helpmenu;
			
			
			JMenuItem newmenuitem, sendmailmenuitem,
			closemenuitem, openmenuitem, exitmenuitem;
			
			JMenuItem undeletemenuitem,
			
			checkallmenuitem, copymenuitem,
			setprogramtitlemenuitem, settabtitlemenuitem,
			findmenuitem, replykeysettingsmenuitem,
			passphrasemenuitem, userpassmenuitem,
			randomtextmenuitem, privatekeymenuitem,
			newpublickeymenuitem;
			
			JMenuItem fontsizemenuitem,
			fonttypemenuitem, boldmenuitem,
			colormenuitem,
			clientservermenuitem,
			showkeyboardmenuitem,
			showsentemailsmenuitem,
			viewpublickeysmenuitem,
			viewsavedemailsmenuitem,
			keyboardmenuitem;
			
			JMenuItem aboutmenuitem;
			JMenuItem howtousepopmailmenuitem;
			JCheckBoxMenuItem testmailmenuitem;
			
			
			
			//  Listeners
			
			
			NewListener newlistener;
			SendMailListener sendmaillistener;
			CloseListener closelistener;
			ExitListener exitlistener;
			
			UndeleteListener undeletelistener;
			CheckAllListener checkalllistener;
			CopyListener copylistener;
			SetTitleListener settitlelistener;
			SetTabTitleListener settabtitlelistener;
			FindListener findlistener;
			ReplyKeySettingsListener replykeysettingslistener;
			PassphraseListener passphraselistener;
			UserPassListener userpasslistener;
			RandomTextListener randomtextlistener;
			PublicKeyListener publickeylistener;
			
			FontSizeListener fontsizelistener;
			FontTypeListener fonttypelistener;
			ColorListener colorlistener;
			ClientServerListener clientserverlistener;
			
			ShowKeyboardListener showkeyboardlistener;
			ShowHideEmailsListener showsentemailslistener;
			
			ViewPublicKeysListener viewpublickeyslistener;
			ViewSavedEmailsListener viewsavedemailslistener;
			
			ColorButtonListener colorbuttonlistener;
			ReverseColorsListener reversecolorslistener;
			
			AboutListener aboutlistener;
			TestMailListener testmaillistener;
			HowToUsePopMailListener howtousepopmaillistener;
			
			TextBoldListener textboldlistener;
			
			KeyListener1 keylistener1;
			MouseWheelListener1 mousewheellistener1;
			
			FocusListener1 focuslistener1;
			ChangeListener changelistener1;
			IconListener iconlistener;
			MouseListener mouselistener1;
			MouseMotionListener mousemotionlistener;
			
			WindowListener1 windowlistener1;
			WindowStateListener1 windowstatelistener1;
			ComponentListener1 componentlistener1;
			
			
			
			String readallheader0 = "   [   ]      " + __.reply + "   ";
			String readallheader1 = "   [ x ]      " + __.reply + "   ";
			
			
			//          10            20            30            40          50
			//          |             |             |             |
			//       delete         reply          prev          next
			//      |              |              |             |
			//   10 - 3         20 - 3         30 - 2        40 - 2
			
			
			String messageheader;
			
			{	//  Calculate the start positions for each label
				
				int pos1 = 10 - __.delete.length() / 2;
				int pos2 = 20 - __.reply.length() / 2;
				int pos3 = 30 - __.prev.length() / 2;
				int pos4 = 40 - __.next.length() / 2;
				
				
				StringBuilder sb = new StringBuilder();
				
				while (sb.length() < pos1) sb.append(" "); sb.append(__.delete);
				while (sb.length() < pos2) sb.append(" "); sb.append(__.reply);
				while (sb.length() < pos3) sb.append(" "); sb.append(__.prev);
				while (sb.length() < pos4) sb.append(" "); sb.append(__.next);
				sb.append("    ");
				
				messageheader = sb.toString();
			}
			
			
			
			
			public RetrieveMailFrame()
			{
			
				frame = this;
				frame.setResizable(true);
				frame.setVisible(true);
				frame.setTitle(titlename);
				frame.setLayout(new GridBagLayout());
				frame.setDefaultCloseOperation(
				    DO_NOTHING_ON_CLOSE);
				
				
				width  = screenwidth  * 70 / 100;
				height = screenheight * 60 / 100;
				
				frame.setSize(width, height);
				
				retrievemailframe = this;
				
				
				//  Create a POP3 window to show the POP3 com-
				//  munication between the client and server
				
				pop3window = new JWindow(frame);
				pop3window.setSize(screenwidth/6, screenheight);
				pop3window.setVisible(false);
				
				
				//  Create a draggable JTabbedPane
				
				//  int tabplacement = JTabbedPane.LEFT;
				
				int tabplacement = JTabbedPane.TOP;
				
				tabbedpane = new JDraggableTabbedPane(tabplacement);
				tabbedpane.setTabPlacement(tabplacement);
				tabbedpane.setDragEnabled(true);
				tabbedpane.setFocusTraversalPolicy();
				
				frame.add(tabbedpane);
				
				
				
				//  Add an EventListener or ChangeListener to the JTabbedPane
				//  to update the reference to the selected tab
				
				changelistener1 = new ChangeListener1();
				
				tabbedpane.addChangeListener(changelistener1);
				
				
				
				//  Add the JTabbedPane to the frame
				
				Gbc gbc = new Gbc();
				
				gbc.setPosition(0, 0);
				gbc.setSize(1, 1);
				gbc.setAnchor(Gbc.center);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				frame.add(tabbedpane, gbc);
				
				
				
				
				//  Initialize the listeners
				
				newlistener = new NewListener();
				sendmaillistener = new SendMailListener();
				closelistener = new CloseListener();
				exitlistener = new ExitListener();
				
				undeletelistener = new UndeleteListener();
				checkalllistener = new CheckAllListener();
				copylistener = new CopyListener();
				settitlelistener = new SetTitleListener();
				settabtitlelistener = new SetTabTitleListener();
				findlistener = new FindListener();
				replykeysettingslistener = new ReplyKeySettingsListener();
				passphraselistener = new PassphraseListener();
				userpasslistener = new UserPassListener();
				randomtextlistener = new RandomTextListener();
				publickeylistener = new PublicKeyListener();
				
				fontsizelistener = new FontSizeListener();
				fonttypelistener = new FontTypeListener();
				colorlistener = new ColorListener();
				clientserverlistener = new ClientServerListener();
				
				showkeyboardlistener = new ShowKeyboardListener();
				showsentemailslistener = new ShowHideEmailsListener();
				
				viewpublickeyslistener = new ViewPublicKeysListener();
				viewsavedemailslistener = new ViewSavedEmailsListener();
				
				colorbuttonlistener = new ColorButtonListener();
				reversecolorslistener = new ReverseColorsListener();
				
				aboutlistener = new AboutListener();
				testmaillistener = new TestMailListener();
				howtousepopmaillistener = new HowToUsePopMailListener();
				
				textboldlistener = new TextBoldListener();
				
				iconlistener = new IconListener();
				
				mouselistener1 = new MouseListener1();
				focuslistener1 = new FocusListener1();
				
				componentlistener1 = new ComponentListener1();
				
				keylistener1 = new KeyListener1();
				
				mousewheellistener1 = new MouseWheelListener1();
				
				windowlistener1 = new WindowListener1();
				windowstatelistener1 = new WindowStateListener1();
				
				frame.addWindowListener(windowlistener1);
				frame.addWindowStateListener(windowstatelistener1);
				
				frame.addComponentListener(componentlistener1);
				
				
				
				//  MenuBar
				
				menubar = new JMenuBar();
				
				frame.setJMenuBar(menubar);
				
				
				filemenu = new JMenu(__.file);
				filemenu.setFont(menufont);
				
				ImageIcon sendicon = Icons.get(Icons.mail_send);
				sendmailmenuitem = new JMenuItem(__.sendmail, sendicon);
				sendmailmenuitem.addActionListener(sendmaillistener);
				filemenu.add(sendmailmenuitem);
				
				filemenu.addSeparator();
				
				newmenuitem = new JMenuItem(__.newtab, newicon);
				newmenuitem.addActionListener(newlistener);
				filemenu.add(newmenuitem);
				
				closemenuitem = new JMenuItem(__.closetab, closeicon);
				closemenuitem.addActionListener(closelistener);
				filemenu.add(closemenuitem);
				
				filemenu.addSeparator();
				
				exitmenuitem = new JMenuItem(__.exit, exiticon);
				exitmenuitem.addActionListener(exitlistener);
				filemenu.add(exitmenuitem);
				
				//  ...
				
				menubar.add(filemenu);
				
				
				
				//  Edit menu
				
				editmenu = new JMenu(__.edit);
				editmenu.setFont(menufont);
				
				undeletemenuitem = new JMenuItem(__.undelete);
				undeletemenuitem.addActionListener(undeletelistener);
				
				//  editmenu.add(undeletemenuitem);
				//
				//  editmenu.addSeparator();
				
				
				ImageIcon checkallicon = Icons.get(Icons.check_filled);
				checkallmenuitem = new JMenuItem(__.checkallkey, checkallicon);
				checkallmenuitem.addActionListener(checkalllistener);
				editmenu.add(checkallmenuitem);
				
				editmenu.addSeparator();
				
				copymenuitem = new JMenuItem(__.copykey, copyicon);
				copymenuitem.addActionListener(copylistener);
				editmenu.add(copymenuitem);
				
				editmenu.addSeparator();
				
				
				setprogramtitlemenuitem = new JMenuItem(__.setprogramtitle);
				setprogramtitlemenuitem.addActionListener(settitlelistener);
				editmenu.add(setprogramtitlemenuitem);
				
				editmenu.addSeparator();
				
				
				settabtitlemenuitem = new JMenuItem(__.settabtitle);
				settabtitlemenuitem.addActionListener(settabtitlelistener);
				//  editmenu.add(settabtitlemenuitem);
				
				//  editmenu.addSeparator();
				
				
				findmenuitem = new JMenuItem(__.find);
				findmenuitem.addActionListener(findlistener);
				
				//  editmenu.add(findmenuitem);
				//
				//  editmenu.addSeparator();
				
				
				replykeysettingsmenuitem = new JMenuItem(__.replykeysettings);
				replykeysettingsmenuitem.addActionListener(
				    replykeysettingslistener);
				editmenu.add(replykeysettingsmenuitem);
				
				editmenu.addSeparator();
				
				
				
				ImageIcon settingsicon = Icons.get(Icons.settings);
				passphrasemenuitem = new JMenuItem(__.passphrasekey, settingsicon);
				passphrasemenuitem.addActionListener(passphraselistener);
				editmenu.add(passphrasemenuitem);
				
				userpassmenuitem = new JMenuItem(__.userpassword);
				userpassmenuitem.addActionListener(userpasslistener);
				editmenu.add(userpassmenuitem);
				
				editmenu.addSeparator();
				
				randomtextmenuitem = new JMenuItem(__.randomtextgenerator);
				randomtextmenuitem.addActionListener(randomtextlistener);
				editmenu.add(randomtextmenuitem);
				
				editmenu.addSeparator();
				
				
				ImageIcon newpublickeyicon = Icons.get(Icons.key);
				newpublickeymenuitem = new JMenuItem(__.newpublickey, newpublickeyicon);
				newpublickeymenuitem.addActionListener(publickeylistener);
				editmenu.add(newpublickeymenuitem);
				
				
				// ...
				
				menubar.add(editmenu);
				
				
				
				
				//  View menu
				
				viewmenu = new JMenu(__.view);
				viewmenu.setFont(menufont);
				
				fontsizemenuitem = new JMenuItem(__.fontsizekey, fonticon);
				fontsizemenuitem.addActionListener(fontsizelistener);
				viewmenu.add(fontsizemenuitem);
				
				fonttypemenuitem = new JMenuItem(__.fonttype);
				fonttypemenuitem.addActionListener(fonttypelistener);
				viewmenu.add(fonttypemenuitem);
				
				viewmenu.addSeparator();
				
				boldmenuitem = new JMenuItem(__.bold_unbold, textboldicon);
				boldmenuitem.addActionListener(textboldlistener);
				viewmenu.add(boldmenuitem);
				
				viewmenu.addSeparator();
				
				
				colormenuitem = new JMenuItem(__.textscreencolor, coloricon);
				colormenuitem.addActionListener(colorlistener);
				viewmenu.add(colormenuitem);
				
				viewmenu.addSeparator();
				
				
				ImageIcon clientservericon = Icons.get(Icons.network_transmit);
				clientservermenuitem = new JMenuItem(__.clientservercomm, clientservericon);
				clientservermenuitem.addActionListener(clientserverlistener);
				viewmenu.add(clientservermenuitem);
				
				viewmenu.addSeparator();
				
				
				showkeyboardmenuitem = new JMenuItem(__.Showkeyboard);
				showkeyboardmenuitem.addActionListener(showkeyboardlistener);
				viewmenu.add(showkeyboardmenuitem);
				
				viewmenu.addSeparator();
				
				showsentemailsmenuitem = new JMenuItem(__.showsentemails);
				showsentemailsmenuitem.addActionListener(showsentemailslistener);
				viewmenu.add(showsentemailsmenuitem);
				
				viewmenu.addSeparator();
				
				viewpublickeysmenuitem = new JMenuItem(__.viewpublickeys);
				viewpublickeysmenuitem.addActionListener(viewpublickeyslistener);
				viewmenu.add(viewpublickeysmenuitem);
				
				viewmenu.addSeparator();
				
				ImageIcon saveicon = Icons.get(Icons.save_24x24);
				viewsavedemailsmenuitem = new JMenuItem(__.viewsavedemails, saveicon);
				viewsavedemailsmenuitem.addActionListener(viewsavedemailslistener);
				viewmenu.add(viewsavedemailsmenuitem);
				
				//  viewmenu.addSeparator();
				//
				//  keyboardmenuitem = new JMenuItem(__.Keyboard);
				//  keyboardmenuitem.addActionListener(keyboardlistener);
				//  viewmenu.add(keyboardmenuitem);
				//
				//  viewmenu.addSeparator();
				
				//  ...
				
				menubar.add(viewmenu);
				
				
				
				
				//  Help menu
				
				helpmenu = new JMenu(__.help);
				helpmenu.setFont(menufont);
				
				aboutmenuitem = new JMenuItem(__.about);
				aboutmenuitem.addActionListener(aboutlistener);
				helpmenu.add(aboutmenuitem);
				
				
				howtousepopmailmenuitem = new JMenuItem(__.howtousepopmail);
				howtousepopmailmenuitem.addActionListener(howtousepopmaillistener);
				helpmenu.add(howtousepopmailmenuitem);
				
				//  ...
				
				helpmenu.addSeparator();
				
				testmailmenuitem = new JCheckBoxMenuItem(__.testmail);
				testmailmenuitem.setSelected(testmail);
				testmailmenuitem.addActionListener(testmaillistener);
				helpmenu.add(testmailmenuitem);
				
				
				menubar.add(helpmenu);
				
				
				menuitems = new JMenuItem[]
				{
					newmenuitem, sendmailmenuitem, closemenuitem, exitmenuitem,
					
					undeletemenuitem, checkallmenuitem, copymenuitem,
					
					setprogramtitlemenuitem, settabtitlemenuitem, findmenuitem,
					
					replykeysettingsmenuitem, passphrasemenuitem, userpassmenuitem,
					
					randomtextmenuitem, newpublickeymenuitem, fontsizemenuitem,
					
					fonttypemenuitem, boldmenuitem, colormenuitem,
					
					clientservermenuitem, showkeyboardmenuitem, showsentemailsmenuitem,
					
					viewpublickeysmenuitem, viewsavedemailsmenuitem, aboutmenuitem,
					
					howtousepopmailmenuitem, testmailmenuitem,
				};
				
				
				colorbuttonlistener.init();
				
				
				//  Create a new EmailPanel
				
				newlistener.run();
			}
			
			
			//  End RetrieveMailFrame constructor
			
			
			
			
			
			/********
			
			
			//  This ListPanel is not finished, tested or debugged
			
			//  This ListPanel uses a JTable instead of a Panel so
			//  that the user can change the widths of the fields
			
			
			private class ListPanel extends JPanel
			{
			
				private static final long serialVersionUID = 1L;
				
				private JCheckBox[] checkboxes;
				
				private JLabel[] msnolabels;
				private JLabel[] iconlabels1;
				private JLabel[] iconlabels2;
				private JLabel[] sizelabels;
				private JLabel[] fromlabels;
				private JLabel[] subjlabels;
				private JLabel[] textlabels;
				
				private JComponent[][] components;
				
				private ImageIcon[] imageicons1;
				private ImageIcon[] imageicons2;
				
				private JTableHeader tableheader;
				
				private JTable table, rowheader;
				
				private boolean[] isvisible;
				
				private int rows1, cols1 = 8;
				
				private int msno, numberofmessages;
				
				private Color foreground;
				private Color background;
				
				public ListPanel(int t)
				{
				
					//  [ x ]  msg no  icon1  icon2  size  subj  first line
					//
					//    0      1       2      3     4      5       6
					
					rows1 = t;
					
					numberofmessages = t;
					
					msno = -1;
					
					
					checkboxes = new JCheckBox[t];
					
					msnolabels  = new JLabel[t];
					iconlabels1 = new JLabel[t];
					iconlabels2 = new JLabel[t];
					sizelabels  = new JLabel[t];
					fromlabels  = new JLabel[t];
					subjlabels  = new JLabel[t];
					textlabels  = new JLabel[t];
					
					components = new JComponent[][]
					
					    { checkboxes, msnolabels, iconlabels1, iconlabels2,
					      sizelabels, fromlabels, subjlabels,  textlabels };
					
					imageicons1 = new ImageIcon[t];
					imageicons2 = new ImageIcon[t];
					
					isvisible = new boolean[t];
					
					
					TableModel tablemodel = new DefaultTableModel()
					{
						public int getColumnCount() { return cols1; }
						public int getRowCount() { return rows1; }
						
						public Object getValueAt(int row, int col)
						{
							Object obj = components[col][row];
							
							if (obj instanceof JLabel)
							{
								Icon icon = ((JLabel) obj) .getIcon();
								
								if (icon == null) return ((JLabel) obj).getText();
								
								if (icon != null) return icon;
							}
							
							if (obj instanceof JCheckBox)
							{
								return (JCheckBox) obj;
							}
							
							else return obj;
						}
						
						public boolean isCellEditable(
						
						    int r, int c) { return false; }
					};
					
					
					table = new JTable(tablemodel);
					
					//  table.setAutoCreateRowSorter(true);
					
					//  table.setDragEnabled(true);
					
					table.setShowGrid(false);
					
					table.setRowSelectionAllowed(false);
					table.setColumnSelectionAllowed(false);
					table.setSelectionMode(1);
					
					table.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
					
					table.setRowHeight(40);
					
					table.setRowMargin(8);
					
					table.setColumnSelectionAllowed(true);
					
					table.setForeground(Color.black);
					table.setBackground(Color.white);
					
					//  table.addMouseListener(mouselistener1);
					//  table.addKeyListener(keylistener1);
					
					
					
					//  Create a new scroll pane and
					//  add the table to the scroll pane
					
					this.setViewportView(table);
					
					
					TableModel rowheadermodel = new DefaultTableModel()
					{
						public int getColumnCount() { return 1; }
						public int getRowCount() { return table.getRowCount(); }
						public Object getValueAt(int row, int col)
						{
							String str = String.valueOf(row + 1);
							
							if      ((row + 1) <   10) str = "   " + str;
							else if ((row + 1) <  100) str =  "  " + str;
							else if ((row + 1) < 1000) str =   " " + str;
							
							return str;
						}
						
						public boolean isCellEditable(int r, int c) { return false; }
					};
					
					rowheader = new JTable(rowheadermodel);
					
					rowheader.setRowHeight(table.getRowHeight());
					rowheader.setRowMargin(8);
					
					//  Get the table header from the table
					
					tableheader = table.getTableHeader();
					
					tableheader.addMouseListener(mouselistener1);
					
					rowheader.setBackground(tableheader.getBackground());
					
					int width = 80 + (int) Math.log10(rows1) * 4;
					
					Dimension d = new Dimension(width, 0);
					
	 				rowheader.setPreferredScrollableViewportSize(d);
					
					rowheader.addMouseListener(mouselistener1);
					rowheader.addMouseMotionListener(mousemotionlistener);
					
					//  Add a row header to the scroll pane
					
					this.setRowHeaderView(rowheader);
					
					
					for (int i = 0; i < t; i++)
					{
						checkboxes[i]  = new JCheckBox();
						msnolabels[i]  = new JLabel();
						iconlabels1[i] = new JLabel();
						iconlabels2[i] = new JLabel();
						sizelabels[i]  = new JLabel();
						fromlabels[i]  = new JLabel();
						subjlabels[i]  = new JLabel();
						textlabels[i]  = new JLabel();
						
						
						checkboxes[i] .setOpaque(false);
						msnolabels[i] .setOpaque(true);
						iconlabels1[i].setOpaque(false);
						iconlabels2[i].setOpaque(false);
						sizelabels[i] .setOpaque(true);
						fromlabels[i] .setOpaque(true);
						subjlabels[i] .setOpaque(true);
						textlabels[i] .setOpaque(true);
						
						
						imageicons1[i] = new ImageIcon();
						imageicons2[i] = new ImageIcon();
						
						isvisible[i] = true;
						
						
						checkboxes[i] .addMouseListener(mouselistener1);
						msnolabels[i] .addMouseListener(mouselistener1);
						sizelabels[i] .addMouseListener(mouselistener1);
						fromlabels[i] .addMouseListener(mouselistener1);
						subjlabels[i] .addMouseListener(mouselistener1);
						textlabels[i] .addMouseListener(mouselistener1);
						iconlabels2[i].addMouseListener(mouselistener1);
						
						sizelabels[i].setToolTipText(__.sizeinKB);
						
						
						table.setValueAt( checkboxes[i], i, 0); table.editCellAt(i, 0);
						table.setValueAt( msnolabels[i], i, 1); table.editCellAt(i, 1);
						table.setValueAt(iconlabels1[i], i, 2); table.editCellAt(i, 2);
						table.setValueAt(iconlabels2[i], i, 3); table.editCellAt(i, 3);
						table.setValueAt( sizelabels[i], i, 4); table.editCellAt(i, 4);
						table.setValueAt( fromlabels[i], i, 5); table.editCellAt(i, 5);
						table.setValueAt( subjlabels[i], i, 6); table.editCellAt(i, 6);
						table.setValueAt( textlabels[i], i, 7); table.editCellAt(i, 7);
					}
				}
				
				
				public int getNumberOfMessages()
				{
					return this.numberofmessages;
				}
				
				
				public void setFont1(Font font)
				{
					table.setFont(font);
					
					int fontsize = font.getSize();
					
					int rowheadersize = Math.min(24, font.getSize()*3/4);
					
					table.setFont(font);
					
					rowheader.setFont(new Font(font.getName(),
					    Font.PLAIN, rowheadersize));
					
					int height = fontsize + 16;
					
					table.setRowHeight(height);
					rowheader.setRowHeight(height);
					
					table.setRowMargin(8);
					rowheader.setRowMargin(8);
					
					TableColumnModel cm = table.getColumnModel();
					
					for (int i = 0; i < table.getColumnCount(); i++)
					{
						TableColumn col = cm.getColumn(i);
						
						int width = 0;
						
						if (i == 0) width = 20;
						if (i == 1) width = 20;
						if (i == 2) width = 20;
						if (i == 3) width = 20;
						if (i == 4) width = 30;
						if (i == 5) width = 80;
						if (i == 6) width = 80;
						if (i == 7) width = 80;
						
						col.setPreferredWidth(4 * width);
					}
					
					
					for (int i = 0; i < numberofmessages; i++)
					{
						msnolabels[i] .setFont(font);
						sizelabels[i] .setFont(font);
						fromlabels[i] .setFont(font);
						subjlabels[i] .setFont(font);
						textlabels[i] .setFont(font);
					}
				}
				
				
				public void setBackground1(Color color)
				{
					this.background = color;
					
					this.setBackground(color);
					
					table.setBackground(color);
					
					for (int i = 0; i < numberofmessages; i++)
					
					    setBackground(color, i);
				}
				
				private void setBackground(Color color, int i)
				{
					msnolabels[i].setBackground(color);
					sizelabels[i].setBackground(color);
					fromlabels[i].setBackground(color);
					subjlabels[i].setBackground(color);
					textlabels[i].setBackground(color);
				}
				
				private void setForeground(Color color, int i)
				{
					msnolabels[i].setForeground(color);
					sizelabels[i].setForeground(color);
					fromlabels[i].setForeground(color);
					subjlabels[i].setForeground(color);
					textlabels[i].setForeground(color);
				}
				
				public void setForeground1(Color color)
				{
					this.foreground = color;
					
					table.setForeground(color);
					
					for (int i = 0; i < numberofmessages; i++)
					
					    setForeground(color, i);
				}
				
				public void setVisible(int i, boolean bool)
				{
					isvisible[i] = bool;
				}
				
				public boolean isVisible(int i)
				{
					return isvisible[i];
				}
				
				
				private void highlight(int msno)
				{
					//  Highlight the messages by swapping
					//  the foreground and background colors
					
					setForeground(background, msno);
					setBackground(foreground, msno);
					
					//  Scroll the viewport
					
					JViewport viewport = emailpanel
					
					    .scrollpane1.getViewport();
					
					//  The scrollRectToVisible only works to
					//  scroll down but not to scroll up, and
					//  the down scroll doesn't work properly.
					
					Rectangle rect = msnolabels[msno].getBounds();
					
					viewport.scrollRectToVisible(rect);
				}
				
				
				public void removeHighlight()
				{
					setForeground1(foreground);
					setBackground1(background);
				}
				
				public void increment()
				{
					msno += 1;
					
					while ((msno < numberofmessages)
					
					    && !isVisible(msno)) msno++;
					
					if (msno > numberofmessages)
					    msno = numberofmessages;
					
					removeHighlight();
					
					if ((msno >= 0) && (msno < numberofmessages))
					
					    highlight(msno);
				}
				
				public void decrement()
				{
					msno -= 1;
					
					while ((msno > 0) && !isVisible(msno)) msno--;
					
					if (msno < -1) msno = -1;
					
					removeHighlight();
					
					if ((msno >= 0) && (msno < numberofmessages))
					
					    highlight(msno);
				}
			}
			
			
			//  End class ListPanel
			
			
			********/
			
			
			
			
			
			//  This class could be replaced by another list pane
			//  class that uses a JTable so the user can change
			//  the widths of the columns or fields
			
			
			private class ListPanel extends JPanel
			{
			
				private static final long serialVersionUID = 1L;
				
				private JCheckBox[] checkboxes;
				
				private JLabel[] msnolabels;
				private JLabel[] iconlabels1;
				private JLabel[] iconlabels2;
				private JLabel[] sizelabels;
				private JLabel[] cipherlabels;
				private JLabel[] fromlabels;
				private JLabel[] subjlabels;
				private JLabel[] textlabels;
				
				private ImageIcon[] imageicons1;
				private ImageIcon[] imageicons2;
				
				private boolean[] isvisible;
				
				private int msno, numberofmessages;
				
				private Color foreground;
				private Color background;
				
				public ListPanel(int t)
				{
				
					//  [ x ]  msg no  icon1  icon2  size  subj  first line
					//
					//    0      1       2      3     4      5       6
					
					this.numberofmessages = t;
					
					this.msno = -1;
					
					
					//  msg no, icon1 (attachment/s), icon2 (msg status), msg size, subject, first line.
					//
					//  received icon2 == unread (new envelope), read (opened envelope), replied
					//
					//  to / answered (<-), urgent msg (red circular clock), spam (trash), ...
					
					
					checkboxes = new JCheckBox[t];
					
					msnolabels   = new JLabel[t];
					iconlabels1  = new JLabel[t];
					iconlabels2  = new JLabel[t];
					sizelabels   = new JLabel[t];
					cipherlabels = new JLabel[t];
					fromlabels   = new JLabel[t];
					subjlabels   = new JLabel[t];
					textlabels   = new JLabel[t];
					
					imageicons1 = new ImageIcon[t];
					imageicons2 = new ImageIcon[t];
					
					isvisible = new boolean[t];
					
					
					this.setBackground(Color.white);
					
					this.setLayout(new GridBagLayout());
					
					Gbc gbc = new Gbc();
					
					for (int i = 0; i < t; i++)
					{
						checkboxes[i]   = new JCheckBox();
						msnolabels[i]   = new JLabel();
						iconlabels1[i]  = new JLabel();
						iconlabels2[i]  = new JLabel();
						sizelabels[i]   = new JLabel();
						cipherlabels[i] = new JLabel();
						fromlabels[i]   = new JLabel();
						subjlabels[i]   = new JLabel();
						textlabels[i]   = new JLabel();
						
						
						checkboxes[i]  .setOpaque(false);
						msnolabels[i]  .setOpaque(true);
						iconlabels1[i] .setOpaque(false);
						iconlabels2[i] .setOpaque(false);
						sizelabels[i]  .setOpaque(true);
						cipherlabels[i].setOpaque(true);
						fromlabels[i]  .setOpaque(true);
						subjlabels[i]  .setOpaque(true);
						textlabels[i]  .setOpaque(true);
						
						
						imageicons1[i] = new ImageIcon();
						imageicons2[i] = new ImageIcon();
						
						isvisible[i] = true;
						
						
						checkboxes[i]  .addMouseListener(mouselistener1);
						msnolabels[i]  .addMouseListener(mouselistener1);
						sizelabels[i]  .addMouseListener(mouselistener1);
						cipherlabels[i].addMouseListener(mouselistener1);
						fromlabels[i]  .addMouseListener(mouselistener1);
						subjlabels[i]  .addMouseListener(mouselistener1);
						textlabels[i]  .addMouseListener(mouselistener1);
						iconlabels2[i] .addMouseListener(mouselistener1);
						
						sizelabels[i].setToolTipText(__.sizeinKB);
						
						
						gbc.setInsets(7,7,7,7);
						
						gbc.setPosition(0, i);  this.add(checkboxes[i], gbc);
						gbc.setPosition(1, i);  this.add(msnolabels[i], gbc);
						gbc.setPosition(2, i);  this.add(iconlabels1[i], gbc);
						gbc.setPosition(3, i);  this.add(iconlabels2[i], gbc);
						gbc.setPosition(4, i);  this.add(sizelabels[i], gbc);
						gbc.setPosition(5, i);  this.add(cipherlabels[i], gbc);
						gbc.setPosition(6, i);  this.add(fromlabels[i], gbc);
						gbc.setPosition(7, i);  this.add(subjlabels[i], gbc);
						gbc.setPosition(8, i);  this.add(textlabels[i], gbc);
					}
				}
				
				
				public int getNumberOfMessages()
				{
					return this.numberofmessages;
				}
				
				
				public void setFont1(Font font)
				{
					for (int i = 0; i < numberofmessages; i++)
					{
						msnolabels[i]  .setFont(font);
						sizelabels[i]  .setFont(font);
						cipherlabels[i].setFont(font);
						fromlabels[i]  .setFont(font);
						subjlabels[i]  .setFont(font);
						textlabels[i]  .setFont(font);
						
						//  Read the original icon so the
						//  icon doesn't get distorted
						
						if (imageicons1[i].getImage() != null)
						    iconlabels1[i].setIcon(scaleIcon(imageicons1[i]));
						
						if (imageicons2[i].getImage() != null)
						    iconlabels2[i].setIcon(scaleIcon(imageicons2[i]));
					}
				}
				
				
				private ImageIcon scaleIcon(ImageIcon originalIcon)
				{
					//  changes the icon size for the list pane
					
					Dimension d = frame.getSize();
					
					int framearea = (int) (d.getWidth() * d.getHeight());
					
					Image image = originalIcon.getImage();
					
					//  Scale the icon size to the frame area
					
					double m = Math.sqrt(1.0D * framearea / screenarea);
					
					int width = (int) (12 + 28 * m);
					
					int miniconsize =  8;
					int maxiconsize = 36;
					
					//  Set the max and min icon sizes
					
					if (width < miniconsize) width = miniconsize;
					if (width > maxiconsize) width = maxiconsize;
					
					//  Scale the icon size to the font size
					//
					//  (the icon size can exceed the maxicon
					//  size for the font, not the frame area)
					
					double fontsize = 1.0D * font.getSize();
					
					width = (int) (width * fontsize / defaultfontsize);
					
					if (width == 0) width = 1;
					
					int height = -1, hints = Image.SCALE_SMOOTH;
					
					image = image.getScaledInstance(width, height, hints);
					
					ImageIcon scaledicon = new ImageIcon(image);
					
					return scaledicon;
				}
				
				
				public void setBackground1(Color color)
				{
					this.background = color;
					
					this.setBackground(color);
					
					for (int i = 0; i < numberofmessages; i++)
					
					    setBackground(color, i);
				}
				
				public void setForeground1(Color color)
				{
					this.foreground = color;
					
					this.setForeground(color);
					
					for (int i = 0; i < numberofmessages; i++)
					
					    setForeground(color, i);
				}
				
				
				private void setBackground(Color color, int i)
				{
					msnolabels[i]  .setBackground(color);
					sizelabels[i]  .setBackground(color);
					cipherlabels[i].setBackground(color);
					fromlabels[i]  .setBackground(color);
					subjlabels[i]  .setBackground(color);
					textlabels[i]  .setBackground(color);
				}
				
				private void setForeground(Color color, int i)
				{
					msnolabels[i]  .setForeground(color);
					sizelabels[i]  .setForeground(color);
					cipherlabels[i].setForeground(color);
					fromlabels[i]  .setForeground(color);
					subjlabels[i]  .setForeground(color);
					textlabels[i]  .setForeground(color);
				}
				
				
				public void setVisible(int i, boolean bool)
				{
					checkboxes[i]  .setVisible(bool);
					msnolabels[i]  .setVisible(bool);
					iconlabels1[i] .setVisible(bool);
					iconlabels2[i] .setVisible(bool);
					sizelabels[i]  .setVisible(bool);
					cipherlabels[i].setVisible(bool);
					fromlabels[i]  .setVisible(bool);
					subjlabels[i]  .setVisible(bool);
					textlabels[i]  .setVisible(bool);
					
					isvisible[i] = bool;
				}
				
				public boolean isVisible(int i)
				{
					return isvisible[i];
				}
				
				private void highlight(int msno)
				{
					setForeground(background, msno);
					setBackground(foreground, msno);
					
					this.setBackground(background);
					
					//  Scroll the viewport
					//  (This code doesn't work correctly)
					
					JViewport viewport = emailpanel
					
					    .scrollpane1.getViewport();
					
					Rectangle rect = checkboxes[msno].getBounds();
					
					rect = new Rectangle((int) rect.getX(),
					
					    (int) rect.getY(), 1, 1);
					
					viewport.scrollRectToVisible(rect);
				}
				
				
				public void removeHighlight()
				{
					setForeground1(foreground);
					setBackground1(background);
				}
				
				public void increment()
				{
					msno += 1;
					
					//  Skip the hidden / invisible messages
					
					while ((msno < numberofmessages)
					
					    && !isVisible(msno)) msno++;
					
					//  Don't let the msno exceed the max
					
					if (msno > numberofmessages)
					    msno = numberofmessages;
					
					//  Move the highlight to the new msg
					
					removeHighlight();
					
					if ((msno >= 0) && (msno < numberofmessages))
					
					    highlight(msno);
				}
				
				public void decrement()
				{
					msno -= 1;
					
					//  Skip the hidden / invisible messages
					
					while ((msno > 0) && !isVisible(msno)) msno--;
					
					//  Don't let the msno exceed the max
					
					if (msno < -1) msno = -1;
					
					//  Move the highlight to the new msg
					
					removeHighlight();
					
					if ((msno >= 0) && (msno < numberofmessages))
					
					    highlight(msno);
				}
			}
			
			
			//  End class ListPanel
			
			
			
			
			
			
			
			
			
			private class EmailPanel extends JPanel
			{
			
				private static final long serialVersionUID = 1L;
				
				private     JLabel emaillabel;
				private JTextField emailfield;
				
				
				private String username, userdomain, userpass;
				
				//  The passphrasehash was used for testing and debugging
				
				private String passphrasehash;
				
				//  The number of ciphers variable will be passed to the
				//  sendmail frame from the retrievemail frame, but the
				//  sendmail frame also gives the user the option to
				//  change the reply key size for each message.
				
				private int numberofciphers = 8;
				private boolean usereplyaddresskey = true;
				
				private String incomingmailserver;
				private String outgoingmailserver;
				
				private int incomingmailport;
				private int outgoingmailport;
				
				private int messagesperscreen;
				
				private boolean ascending = true;
				
				private String tabtitle = "";
				
				
				//  If the user creates an anonymous public key,
				//  decryptMessage will set nokeyaddress = true
				//  so that it does not have to keep trying two
				//  public keys, hash(SP + email) and then hash(SP).
				
				private boolean nokeyaddress;
				
				
				//  The user's public key generated from hash(SP)
				//  The user's public key generated from hash(SP + email addr)
				
				private PublicKey[] publickey_sp;
				private PublicKey[] publickey_sp_email;
				private PublicKey[] publickey_testmail;
				
				
				private int msno = -1; // msg number
				
				private boolean listscreen;
				private boolean messagescreen;
				private boolean readallscreen;
				
				private int caretposition;
				
				
				//  An object to hold the email messages
				
				private ArrayList1 list1;
				
				
				//  An object to hold the connection data
				
				private PopMail popmail;
				
				
				//  An object to hold the display labels
				
				private ListPanel listpanel;
				
				
				//  An object to hold the saved emails
				
				private SavedEmails savedemails;
				
				
				private JScrollPane popscrollpane;
				
				private JTextArea poptextarea;
				
				
				//  a tree map for reading and saving the message states
				//  the hash(from + bytes) is mapped to an integer 0 to 9
				
				private TreeMap<String, Integer> msgstatestreemap
				  = new TreeMap<String, Integer>();
				
				
				
				//  If the pop mail authorization was successful, set
				//  authorized = true so that if the user clicks reply
				//  to email, then the reply method can pass the boolean
				//  value to the send mail frame and the user will not be
				//  prompted to re-enter the userpass for this username.
				
				private boolean authorized = true;
				
				
				
				//  The POP3 mail buttons and button listener
				
				private JButton listbutton, readbutton;
				private JButton delebutton, quitbutton;
				
				private JButton[] buttons;
				
				private ButtonListener buttonlistener;
				
				private JComponent[] components;
				
				private JTextArea textarea;
				
				private JPanel readallpanel;
				
				private JScrollPane scrollpane1;
				private JScrollPane scrollpane2;
				private JScrollPane scrollpane3;
				
				
				private ArrayList<SendMailFrame> sendmailframelist
				  = new ArrayList<SendMailFrame>();
				
				
				//  buttonpanel == List, Read All, Delete, Sign out
				
				private JPanel textfieldpanel;
				private JPanel buttonpanel1;
				private JPanel iconpanel;
				private JPanel panel;
				
				
				private ImageIcon listicon = Icons.get(Icons.compose_mail_32x32);
				private ImageIcon readicon = null;
				private ImageIcon deleicon = Icons.get(Icons.edit_delete_32x32);
				private ImageIcon quiticon = Icons.get(Icons.session_logout_24x24);
				//  32x32 appears too large compared to the other icons
				
				private ImageIcon[] buttonicons;
				
				private ImageIcon[] imageicons;
				private JButton[] iconbuttons;
				
				private JButton composebutton;
				private JButton passphrasebutton;
				private JButton textboldbutton;
				private JButton fontsizebutton;
				private JButton showhidebutton;
				private JButton printkeybutton;
				private JButton reversecolorsbutton;
				private JButton clientserverbutton;
				
				
				private boolean reverse_colors;
				
				private Color foreground;
				private Color background;
				private Color caretcolor;
				
				
				
				private EmailPanel()
				{
				
					int textfieldsize = 24;
					
					JTextField[] textfield;
					
					textfield = new JTextField[1];
					
					for (int i = 0; i < textfield.length; i++)
					
					    textfield[i] = new JTextField(textfieldsize);
					
					emailfield = textfield[0];
					
					
					emaillabel = new JLabel(__.Email);
					
					JLabel[] labels = new JLabel[] { emaillabel };
					
					emaillabel.setOpaque(true);
					
					
					//  Set the panel layout to gridbaglayout
					
					this.setLayout(new GridBagLayout());
					
					
					//  Create a panel to hold the textfield panel,
					//  the button panel, and the icon panel
					
					panel = new JPanel();
					
					panel.setLayout(new GridBagLayout());
					
					
					//  Create a textfield panel
					
					textfieldpanel = new JPanel();
					textfieldpanel.setOpaque(true);
					textfieldpanel.setLayout(new GridBagLayout());
					
					
					//  Add the email label and field to the textfield panel
					
					for (int i = 0; i < textfield.length; i++)
					{
						Gbc gbc = new Gbc();
						
						gbc.setPosition(0, i);
						gbc.setAnchor(Gbc.left);
						gbc.setInsets(0, 0, 0, 5);
						gbc.setWeight(0, 0);
						
						textfieldpanel.add(labels[i], gbc);
						
						gbc.setPosition(1, i);
						gbc.setAnchor(Gbc.left);
						gbc.setFill(Gbc.both);
						gbc.setInsets(0, 0, 0, 0);
						gbc.setWeight(100, 100);
						
						textfieldpanel.add(textfield[i], gbc);
					}
					
					
					
					//  Add the textfield panel to the panel
					
					Gbc gbc = new Gbc();
					
					gbc.setPosition(0, 0);
					gbc.setSize(11, 3);
					gbc.setFill(Gbc.horizontal);
					gbc.setAnchor(Gbc.left);
					gbc.setWeight(0, 0);
					
					panel.add(textfieldpanel, gbc);
					
					
					//  Create an icon panel
					
					iconpanel = createIconPanel();
					
					
					//  Create a button panel
					
					buttonpanel1 = new JPanel();
					
					buttonpanel1.setLayout(new GridBagLayout());
					
					buttonicons = new ImageIcon[]
					
					   { listicon, readicon, deleicon, quiticon };
					
					
					//  Create the buttons
					
					listbutton = new JButton(__.List, listicon);
					readbutton = new JButton(__.ReadAll, readicon);
					delebutton = new JButton(__.Delete, deleicon);
					quitbutton = new JButton(__.Signout, quiticon);
					
					listbutton.setMnemonic((int) __.mail_listkeycode);
					//  readbutton.setMnemonic((int) __.mail_readallkeycode);
					delebutton.setMnemonic((int) __.mail_deletekeycode);
					quitbutton.setMnemonic((int) __.mail_signoutkeycode);
					
					buttons = new JButton[]
					
					    { listbutton, readbutton, delebutton, quitbutton };
					
					
					buttonlistener = new ButtonListener(this);
					
					for (JButton button : buttons)
					{
						button.setFont(font);
						button.setContentAreaFilled(false);
						button.addActionListener(buttonlistener);
						button.addKeyListener(keylistener1);
					}
					
					for (JButton button : iconbuttons)
					{
						if (button == null) continue;
						
						button.addKeyListener(keylistener1);
						
						button.addActionListener(new ActionListener()
						{
							public void actionPerformed(ActionEvent e)
							{
								//  If the listpanel has the focus, then the up and down
								//  arrows scroll the pane, but if the list button has the
								//  focus, then the arrows highlight the email headers.
								
								if (emailpanel.listscreen)
								    emailpanel.listbutton.requestFocusInWindow();
								
								if (emailpanel.messagescreen)
								    emailpanel.textarea.requestFocusInWindow();
							}
						});
					}
					
					
					//  Add a mouse listener for the list button
					
					//  This is only required for the button popup messages.
					//
					//  Each button can have its own mouse listener object
					//  because it doesn't have to share mouse member variables.
					
					listbutton.addMouseListener(new MouseListener1());
					readbutton.addMouseListener(new MouseListener1());
					delebutton.addMouseListener(new MouseListener1());
					
					
					
					//  Add the buttons to the vertical button panel
					
					gbc = new Gbc();
					
					gbc.setSize(1, 1);
					gbc.setIpad(0, 2);
					gbc.setFill(Gbc.both);
					gbc.setWeight(5, 25);
					
					gbc.setPosition(0, 0);
					buttonpanel1.add(listbutton, gbc);
					
					gbc.setPosition(0, 1);
					buttonpanel1.add(readbutton, gbc);
					
					gbc.setPosition(0, 2);
					buttonpanel1.add(delebutton, gbc);
					
					gbc.setPosition(0, 3);
					buttonpanel1.add(quitbutton, gbc);
					
					
					
					//  Add the icon panel to the panel
					
					gbc = new Gbc();
					
					gbc.setPosition(0, 4);
					gbc.setInsets(8, 0, 0, 0);
					
					panel.add(iconpanel, gbc);
					
					
					
					//  Create the list pane (list screen)
					//  and the text area (message screen)
					
					int t = 0;
					
					listpanel = new ListPanel(t);
					listpanel.setFont1(font);
					
					textarea = new JTextArea();
					
					textarea.setLineWrap(true);
					textarea.setWrapStyleWord(true);
					
					readallpanel = new JPanel();
					readallpanel.setLayout(new GridBagLayout());
					
					textarea.setHighlighter(null);
					textarea.setEditable(false);
					
					
					
					//  the list pane, message pane, and read all pane
					
					//  (These scrollpanes get replaced by the list thread)
					
					scrollpane1 = new JScrollPane(listpanel,
					
					    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
					    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
					
					scrollpane2 = new JScrollPane(textarea,
					
					    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
					    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
					
					scrollpane3 = new JScrollPane(readallpanel,
					
					    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
					    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
					
					
					//  Increase the scrolling speed for the listpanel
					
					scrollpane1.getVerticalScrollBar().setUnitIncrement(5);
					
					
					
					//   0  _______5___________________________________________ 100
					//     |       |           ___________________________     |
					//     |       |    email |___________________________|    |
					//  10 |_______|___________________________________________|
					//     |       |                                           |
					//     |_______|                                           |
					//     |       |                                           |
					//     |_______|                                           |
					//     |       |                                           |
					//     |_______|                                           |
					//     |       |                                           |
					// 100 |_______|___________________________________________|
					
					
					
					//  Define the grid bag constraints for the retrieve mail frame
					//
					//  The positions, sizes, weights and fills have to be exactly
					//  correct or else the scroll pane or buttons can sometimes
					//  collapse and the buttons or scroll pane can expand to fill
					//  the entire frame even if the frame usually displays correctly.
					
					
					//  Add the icon panel to this
					
					gbc = new Gbc();
					
					gbc.setPosition(0, 0);
					gbc.setSize(100, 10);
					gbc.setFill(Gbc.both);
					gbc.setWeight(100, 10);
					
					this.add(panel, gbc);
					
					
					//  Add the vertical buttonpanel to this
					
					gbc = new Gbc();
					
					gbc.setPosition(0, 10);
					gbc.setSize(5, 90);
					gbc.setFill(Gbc.both);
					gbc.setWeight(5, 90);
					
					this.add(buttonpanel1, gbc);
					
					
					buttonpanel1.setVisible(true);
					
					
					//  Add the scroll panes to this
					
					gbc = new Gbc();
					
					gbc.setPosition(5, 10);
					gbc.setSize(95, 90);
					gbc.setFill(Gbc.both);
					gbc.setWeight(95, 90);
					
					this.add(scrollpane1, gbc);
					this.add(scrollpane2, gbc);
					this.add(scrollpane3, gbc);
					
					scrollpane1.setVisible(true);
					scrollpane2.setVisible(false);
					scrollpane3.setVisible(false);
					
					
					
					
					emailfield.addFocusListener(focuslistener1);
					
					emailfield .addKeyListener(keylistener1);
					tabbedpane .addKeyListener(keylistener1);
					
					textarea   .addKeyListener(keylistener1);
					scrollpane1.addKeyListener(keylistener1);
					scrollpane2.addKeyListener(keylistener1);
					scrollpane3.addKeyListener(keylistener1);
					
					this.addKeyListener(keylistener1);
					
					
					textarea .addMouseListener(mouselistener1);
					
					panel       .addMouseWheelListener(mousewheellistener1);
					scrollpane1 .addMouseWheelListener(mousewheellistener1);
					scrollpane2 .addMouseWheelListener(mousewheellistener1);
					scrollpane3 .addMouseWheelListener(mousewheellistener1);
					
					
					poptextarea = new JTextArea();
					
					poptextarea.setEditable(false);
					poptextarea.setLineWrap(true);
					poptextarea.setWrapStyleWord(true);
					poptextarea.setFont(font);
					
					popscrollpane = new JScrollPane(poptextarea,
					
					    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
					    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
					
					
					components = new JComponent[]
					{
						emaillabel, emailfield,
						
						textfieldpanel, iconpanel,
						
						panel, listpanel
					};
					
					for (Component component : components)
					
					    component.setFont(font);
					
					
					//  Set the textfield panel, button panel,
					//  and icon panel background color
					
					Color color = Color.white;
					
					    emaillabel.setBackground(color);
					textfieldpanel.setBackground(color);
					     iconpanel.setBackground(color);
					         panel.setBackground(color);
					
					
					//  Set the initial color
					
					reverse_colors = false;
					
					int rgb = Colors.getRGB(__.darkaqua);
					
					foreground = new Color(rgb);
					background = Color.white;
					caretcolor = foreground;
					
					if (reverse_colors)
					{
						listpanel.setForeground1(background);
						listpanel.setBackground1(foreground);
						
						textarea.setForeground(background);
						textarea.setCaretColor(background);
						textarea.setBackground(foreground);
					}
					
					else // if (!reverse)
					{
						listpanel.setForeground1(foreground);
						listpanel.setBackground1(background);
						
						textarea.setForeground(foreground);
						textarea.setCaretColor(foreground);
						textarea.setBackground(background);
					}
				}
				
				
				
				
				private JPanel createIconPanel()
				{
				
					//   ------------ --------- ------ ----------- ----------- ------------- ----------------
					//  | Passphrase | Compose | Bold | Font size | Print key | Show emails | reverse colors |
					//   ------------ --------- ------ ----------- ----------- ------------- ----------------
					
					
					   composebutton = new JButton();
					passphrasebutton = new JButton();
					  textboldbutton = new JButton();
					  fontsizebutton = new JButton();
					  printkeybutton = new JButton();
					  showhidebutton = new JButton();
					reversecolorsbutton = new JButton();
					clientserverbutton = new JButton();
					
					   composebutton.addMouseListener(sendmaillistener);
					passphrasebutton.addMouseListener(passphraselistener);
					  textboldbutton.addMouseListener(textboldlistener);
					  fontsizebutton.addMouseListener(fontsizelistener);
					  printkeybutton.addMouseListener(publickeylistener);
					  showhidebutton.addMouseListener(showsentemailslistener);
					reversecolorsbutton.addMouseListener(reversecolorslistener);
					
					   composebutton.setToolTipText(__.compose_mail);
					passphrasebutton.setToolTipText(__.passphrasesettings);
					  textboldbutton.setToolTipText(__.text_bold);
					  printkeybutton.setToolTipText(__.printpublickey);
					  showhidebutton.setToolTipText(__.showsentemails);
					  fontsizebutton.setToolTipText(__.font);
					reversecolorsbutton.setToolTipText(__.reverse_colors);
					
					
					imageicons = new ImageIcon[]
					{
						passphraseicon, composeicon, textboldicon1,
						fontsizeicon, printkeyicon, showhideicon,
						reversecolorsicon
					};
					
					iconbuttons = new JButton[]
					{
						passphrasebutton, composebutton, textboldbutton,
						fontsizebutton, printkeybutton, showhidebutton,
						reversecolorsbutton
					};
					
					Box box = Box.createHorizontalBox();
					
					for (JButton button : iconbuttons)
					{
						if (button == null) continue;
						
						button.setContentAreaFilled(false);
						button.setBorderPainted(false);
						
						Component hstrut = Box
						    .createHorizontalStrut(15);
						
						box.add(button);
						box.add(hstrut);
					}
					
					JPanel panel = new JPanel();
					
					panel.add(box);
					
					return panel;
				}
			}
			
			
			//  End class EmailPanel
			
			
			
			
			
			
			
			
			private class ChangeListener1 implements ChangeListener
			{
			
				public void stateChanged(ChangeEvent e)
				{
				
					//  Set control = false because using ctrl + tab to change the
					//  email tab causes the control button to not get released
					//  and then the mouse wheel changes the font size instead
					//  of scrolling the email text area.
					
					keylistener1.setControl(false);
					
					emailpanel = (EmailPanel) tabbedpane.getSelectedComponent();
					
					if (emailpanel == null) return;
					
					int index = tabbedpane.getSelectedIndex();
					
					//  The tab colors in the mail program are not changed to the text
					//  color because different username panels can have different colors.
					//  If the tab colors were different, the tab colors would clash with
					//  each other because the tabs are all visible at the same time.
					//
					//  tabbedpane.setForegroundAt(index, emailpanel.foreground);
					
					
					if (emailpanel.username != null)
					{
					//	System.out.print(emailpanel.username + "  ");
					//	System.out.print(emailpanel.userpass + "  ");
					//	
					//	System.out.print(emailpanel.incomingmailserver + "  ");
					//	System.out.print(emailpanel.outgoingmailserver + "  ");
					//	System.out.print(emailpanel.messagesperscreen);
					//	System.out.println();
					}
					
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					
					    pop3window.remove(((EmailPanel)
					
						tabbedpane.getComponentAt(i)).popscrollpane);
					
					pop3window.add(emailpanel.popscrollpane);
					
					emailpanel.poptextarea  .setVisible(true);
					emailpanel.popscrollpane.setVisible(true);
					
					//  If two or more tabs are open, the pop3window has no
					//  textarea / scrollpane for the other non-selected tabs.
					//
					//  This line corrects for the bug. It sets the pop3window
					//  to visible even if the window is already visible.
					
					if (pop3window.isVisible())
					    pop3window.setVisible(true);
					
					emailpanel.poptextarea  .repaint();
					emailpanel.popscrollpane.repaint();
					
					pop3window.repaint();
					
					//  Show the send mail frames for the selected tabs and
					//  hide the send mail frames for the non-selected tabs
					
					if (emailpanel != null)
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel1 = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						if (emailpanel1 == null) continue;
						
						
						//  the view saved emails frames
						
						if (emailpanel1.savedemails != null)
						
						if (emailpanel1.equals(emailpanel))
						
						     emailpanel1.savedemails.setVisible(true);
						else emailpanel1.savedemails.setVisible(false);
						
						
						//  the reply send mail frames
						
						if (emailpanel1.list1 != null)
						
						for (int j = 0; j < emailpanel1.list1.size(); j++)
						{
							SendMailFrame sendmailframe = emailpanel1
							
							    .list1.getSendMailFrame(j);
							
							if (sendmailframe != null)
							{
								if (emailpanel1.equals(emailpanel)
								
								    && !sendmailframe.disposed)
									sendmailframe.setVisible(true);
								
								else sendmailframe.setVisible(false);
								
								//  Dispose the frames that have been disposed
								
								if (sendmailframe.disposed)
								{
									emailpanel1.list1.setSendMailFrame(j, null);
									
									sendmailframe.dispose();
								}
							}
						}
						
						
						//  the non-reply send mail frames
						
						//  Exception in thread "AWT-EventQueue-0" java.util.ConcurrentModificationException
						//  at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1013)
						//  at java.base/java.util.ArrayList$Itr.next(ArrayList.java:967)
						//
						//  for (SendMailFrame sendmailframe : emailpanel1.sendmailframelist)
						//
						//  This line throws an exception every time two email addresses (tabs) are open and
						//  the user clicks the right tab and opens a non-reply frame, clicks the left tab
						//  and opens a non-reply frame, clicks the right tab and closes the non-reply frame,
						//  clicks the left tab without closing the reply frame, and then clicks the right tab.
						
						
						//  This second line for (int j = 0; j < ... j++) does the same thing as the
						//  for-each loop for (SendMailFrame sendmailframe : emailpanel1.sendmailframelist)
						//  but it doesn't throw a ConcurrentModificationException. This problem could also
						//  be solved by using an empty try catch block.
						
						//  for (SendMailFrame sendmailframe : emailpanel1.sendmailframelist)
						
						for (int j = 0; j < emailpanel1.sendmailframelist.size(); j++)
						{
							SendMailFrame sendmailframe = emailpanel1.sendmailframelist.get(j);
							
							if (sendmailframe != null)
							{
								if (emailpanel1.equals(emailpanel)
								
								    && !sendmailframe.disposed)
									sendmailframe.setVisible(true);
								
								else sendmailframe.setVisible(false);
								
								//  Dispose the frames that have been disposed
								
								if (sendmailframe.disposed)
								{
									//  Remove the sendmailframe from
									//  the list and dispose the frame
									
									emailpanel.sendmailframelist
									   .remove(sendmailframe);
									
									sendmailframe.dispose();
								}
							}
						}
					}
					
					//  Move the retrieve mail frame to the front so
					//  the send mail frames don't cover the tabs
					//
					//  In future versions there could be an icon
					//  displayed on the retrieve mail frame if a
					//  send mail / reply frame is open because the
					//  send mail / reply frames could be hidden
					//  under the retrieve mail frame
					
					frame.toFront();
				}
			}
			
			
			
			private class ComponentListener1 extends ComponentAdapter
			{
				public void componentResized(ComponentEvent e)
				{
					if (e.getSource() instanceof JFrame)
					{
						//  This code is executed if the user resizes the window
						
						fontsize = frameSizeToFontSize(frame);
						
						font = font.deriveFont(fontsize);
						
						setFont1(font);
					}
				}
			}
			
			
			
			private void setMenuItemsEnabled(boolean bool)
			{
				JMenuItem[] menuitems = new JMenuItem[]
				{
					//  newmenuitem, exitmenuitem,
					
					sendmailmenuitem, closemenuitem, undeletemenuitem, checkallmenuitem,
					
					copymenuitem, setprogramtitlemenuitem, settabtitlemenuitem,
					
					findmenuitem, replykeysettingsmenuitem, passphrasemenuitem,
					
					userpassmenuitem, randomtextmenuitem, newpublickeymenuitem,
					
					fontsizemenuitem, fonttypemenuitem, boldmenuitem,
					
					colormenuitem, clientservermenuitem, showkeyboardmenuitem,
					
					showsentemailsmenuitem, viewpublickeysmenuitem, viewsavedemailsmenuitem,
					
					aboutmenuitem, howtousepopmailmenuitem, testmailmenuitem,
				};
				
				for (JMenuItem menuitem : menuitems)
				
				    if (menuitem != null) menuitem.setEnabled(bool);
			}
			
			
			
			
			private class NewListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					//  Create a new email panel and tab
					
					EmailPanel emailpanel = new EmailPanel();
					
					//  Set the tab title to email
					
					String title = __.email; // or __.untitled;
					
					tabbedpane.addTab(title, emailpanel);
					
					tabbedpane.setSelectedComponent(emailpanel);
					
					setFont1(font); setMenuItemsEnabled(true);
					
					setMenuItemsEnabled(true);
					
					emailpanel.emailfield.addKeyListener(new KeyAdapter()
					{
						public void keyReleased(KeyEvent e)
						{
							parseEmailField();
						}
					});
				}
			}
			
			
			
			
			private class CloseListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					if (emailpanel.emailfield.getText().isBlank())
					
					    tabbedpane.remove(tabbedpane.getSelectedComponent());
					
					else
					{	String title = __.deletetab;
						
						Object[] choices = { __.Delete, __.cancel };
						
						int choice = JOptionPane.showOptionDialog(frame, "", title,
						
						    JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE,
						
						        null, choices, choices[1]);
						
						if ((choice == 1) ||  // cancel option
						
						    (choice == JOptionPane.CLOSED_OPTION)) return;
						
						if (choice == 0) // Delete tab / remove panel from list
						{
							emailpanel = null;
							
							tabbedpane.remove(tabbedpane.getSelectedComponent());
							
							saveMailSettings();
						}
						
						else if (choice == 1) // close / remove the tab
						{
						//	System.out.println("closing tab");
						//	
						//	int index = tabbedpane.getSelectedIndex();
						//	
						//	tabbedpane.setEnabledAt(index, false);
						}
					}
					
					
					//  Change the email panel to the current selection
					
					emailpanel = (EmailPanel) tabbedpane .getSelectedComponent();
					
					
					//  Enable or disable the menu items
					
					if (emailpanel == null)
					
					     setMenuItemsEnabled(false);
					else setMenuItemsEnabled(true);
				}
			}
			
			
			
			
			
			private class SendMailListener
			
				extends MouseAdapter implements ActionListener
			{
			
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.composebutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
					//  This is the Retrieve Mail Frame
					
					//  Create a new SendMailFrame from
					//  the RetrieveMailFrame file menu
					
					
					String errormessage = null;
					
					if (emailpanel.username == null)
					{
						if (emailpanel.emailfield.getText().isBlank())
						
						     errormessage = __.emailaddressisempty;
						else errormessage = __.emailaddressisinvalid;
					}
					
					else if ((emailpanel.outgoingmailserver == null)
					       || emailpanel.outgoingmailserver.isEmpty())
					{
						errormessage = __.outgoingmailserverfieldisempty;
					}
					
					//  Display the error message and return
					
					if ((errormessage != null) && !errormessage.isEmpty())
					{
						JOptionPane.showMessageDialog(frame,
						
						    errormessage, "", JOptionPane.ERROR_MESSAGE);
						
						return;
					}
					
					for (int i = 0; i < emailpanel.sendmailframelist.size(); i++)
					{
						SendMailFrame sendmailframe = emailpanel
						
						    .sendmailframelist.get(i);
						
						if (sendmailframe.disposed)
						{
							//  remove is a structural modification, do i--;
							
							emailpanel.sendmailframelist
							   .remove(sendmailframe);
							
							sendmailframe.dispose(); i--;
						}
					}
					
					int maxframes = 4;
					
					if (emailpanel.sendmailframelist.size()
					
					    >= maxframes) return;
					
					
					String fromaddr = emailpanel.username
					          + "@" + emailpanel.userdomain;
					
					SendMailFrame sendmailframe;
					
					sendmailframe = new SendMailFrame();
					
					sendmailframe.setReverseColors(
					    emailpanel.reverse_colors);
					
					sendmailframe.setForeground1(
					    emailpanel.foreground);
					
					sendmailframe.setBackground1(
					    emailpanel.background);
					
					sendmailframe.setFont1(font);
					
					sendmailframe.setOutgoingMailServer(
					      emailpanel.outgoingmailserver);
					
					sendmailframe.setOutgoingMailPort(
					      emailpanel.outgoingmailport);
					
					
					//  Set the username and userpass
					
					sendmailframe.setFromField(fromaddr);
					sendmailframe.userpass = emailpanel.userpass;
					sendmailframe.setNumberOfCiphers(emailpanel.numberofciphers);
					sendmailframe.setUseReplyAddressKey(emailpanel.usereplyaddresskey);
					
					
					//  Display the keyboard
					
					if (showkeyboard)
					{
						keyboardlistener.run();
						
						Keyboard keyboard = keyboardlistener.keyboard;
						
						keyboard.setForeground(emailpanel.foreground);
						keyboard.setBackground(emailpanel.background);
						
						keyboardlistener.setFont(font);
						keyboardlistener.keyboardframe.setLocationRelativeTo(null);
						keyboardlistener.setTextComponent(sendmailframe.textarea);
					}
					
					//  Move the frame to the front
					
					sendmailframe.toFront();
					
					//  Add the frame to the list and remove any previous closed frames
					
					emailpanel.sendmailframelist.add(sendmailframe);
					
					for (int i = 0; i < emailpanel.sendmailframelist.size(); i++)
					
					    //  remove is a structural modification, do i--;
					
					    if ((emailpanel.sendmailframelist.get(i) == null)
					     || !emailpanel.sendmailframelist.get(i).isVisible())
						 emailpanel.sendmailframelist.remove(i--);
					
					
					//  For the reply frame move the focus to the text area
					//
					//  (If the keyboard is displayed, the caret won't be
					//  visible unless the user clicks on the send mail frame
					//  but the characters will appear in the text area as
					//  the user types on the virtual keyboard)
					
					sendmailframe.requestFocusInWindow("textarea");
				}
			}
			
			
			
			private class WindowListener1 extends WindowAdapter
			{
				public void windowClosing(WindowEvent e)
				{
					exitlistener.run();
				}
			}
			
			
			private class WindowStateListener1 extends WindowAdapter
			{
				public void windowStateChanged(WindowEvent e)
				{
				
				}
			}
			
			
			
			private class ExitListener implements ActionListener
			{
			
				public void actionPerformed(ActionEvent e) { run(); }
				
				
				public void run()
				{
				
					//  The listing, reading, and decrypting methods
					//  use a separate thread so the program should click
					//  the sign out button for the user before exiting.
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
					//	if (emailpanel.buttonlistener.   listing
					//	 || emailpanel.buttonlistener.   reading
					//	 || emailpanel.buttonlistener.  deleting
					//	 || emailpanel.buttonlistener.decrypting
					//	 || emailpanel.buttonlistener.connecting
					//	 || emailpanel.buttonlistener.  quitting)
						
						    emailpanel.quitbutton.doClick();
					}
					
					if ((SP != null) && !SP.isEmpty())
					{
						saveMailSettings();
					}
					
					//  Clear the client / server communication text
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						emailpanel.poptextarea.setText("");
					}
					
					//  Dispose the keyboard
					
					if ((keyboardlistener != null) &&
					    (keyboardlistener.keyboardframe != null))
					     keyboardlistener.keyboardframe.dispose();
					
					
					//  Show all the send mail frames before
					//  disposing the retrieve mail frame
					
					if (emailpanel != null)
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						if (emailpanel == null) return;
						
						//  the reply send mail frames
						
						if (emailpanel.list1 != null)
						
						for (int j = 0; j < emailpanel.list1.size(); j++)
						{
							SendMailFrame sendmailframe = emailpanel
							
							    .list1.getSendMailFrame(j);
							
							if (sendmailframe != null)
							{
								if (sendmailframe.disposed)
								    sendmailframe.dispose();
								
								else sendmailframe.setVisible(true);
							}
						}
						
						//  the non-reply send mail frames
						
						for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
						{
							if (sendmailframe != null)
							{
								if (sendmailframe.disposed)
								    sendmailframe.dispose();
								
								else sendmailframe.setVisible(true);
							}
						}
					}
					
					//  Dispose the frame
					
					frame.dispose();
				}
			}
			
			
			
			
			private class ReplyKeySettingsListener implements ActionListener
			{
			
				//  sets the number of reply ciphers to use when pre-
				//  pending the user's return public key to the email.
				//
				//  If the number of ciphers is set to zero, the recipient
				//  will have to obtain a copy of the sender's public key
				//  to reply to the message, or send an unencrypted message
				//  to the sender requesting the sender's public key.
				//
				//  The sender can choose zero, quad, oct, or max ciphers.
				
				
				public void actionPerformed(ActionEvent e)
				{
				
					//                    Reply key size dialog box
					//     ________________________________________________________
					//    |                   ----------------                     |
					//    |                  | Reply key size | 4                  |
					//    |                   ----------------                     |
					//    |  [x] Use my email address to generate the reply key    |
					//    |      so the reply key is different for each user name  |
					//    |                          ____                          |
					//    |                         |_OK_|                         |
					//    |________________________________________________________|
					
					
					//   Clicking on the reply key size button opens the second dialog
					//
					//   ____________________________________________________________
					//  |                                                            |
					//  | Choose the key size that you want sent with your messages. |
					//  | The recipient will use this key to reply to your messages. |
					//  |                                                            |
					//  | If you do not include a reply key, the recipient will have |
					//  | to request your public key to send an encrypted reply to   |
					//  | your email until email service providers upgrade their     |
					//  | software to allow clients or users to store public keys    |
					//  | on their servers.                                          |
					//  |                                                            |
					//  |                o zero  o quad  * oct  o max                |
					//  |                            ____                            |
					//  |                           |_OK_|                           |
					//  |____________________________________________________________|
					
					
					
					//  One reason to uncheck the email address box or not include the
					//  email address in the private key is if the user created a public
					//  key before opening an email account or before creating an email
					//  address, and then published the hash of the public key.
					//
					//  The send mail frame includes the from address in the private key
					//  to make the public key different for each username. Otherwise dif-
					//  ferent email addresses could be correlated by the same public key.
					
					
					if ( (emailpanel == null)
					  || (emailpanel.username == null)
					  ||  emailpanel.username.isEmpty())
					{
						JOptionPane.showMessageDialog(frame,
						
						    __.emailaddressisempty);
						
						return;
					}
					
					//  Reply key settings dialog box
					
					String title = "";  Icon icon = null;
					
					JCheckBox checkbox = new JCheckBox();
					
					checkbox.setSelected(emailpanel.usereplyaddresskey);
					
					JTextArea addressarea = new JTextArea();
					
					addressarea.setEditable(false);
					addressarea.setBackground(new JPanel().getBackground());
					addressarea.setText(__.usemyaddresstogeneratereplykey);
					addressarea.setFont(labelfont);
					
					int defaultkeysize = Math.min(4, PublicKey.numberofciphers);
					
					JLabel replylabel1 = new JLabel(__.replykeysize);
					JLabel replylabel2 = new JLabel(String.valueOf(
					
					    emailpanel.numberofciphers >= 0 ?
					    emailpanel.numberofciphers : defaultkeysize));
					
					int[] numberofciphers1 = new int[]
					
					    { emailpanel.numberofciphers };
					
					int maxnumber = PublicKey.size.length;
					
					if (numberofciphers1[0] < 0)
					    numberofciphers1[0] = defaultkeysize;
					
					if (numberofciphers1[0] > maxnumber)
					    numberofciphers1[0] = maxnumber;
					
					MouseListener replymouselistener = new MouseAdapter()
					{
						public void mouseClicked(MouseEvent e)
						{
							//  Display the second dialog box
							
							int replykeysize = getReplyKeySize(frame,
							
							    Math.min(8, PublicKey.numberofciphers));
							
							if (replykeysize >= 0) numberofciphers1[0] = replykeysize;
							
							String s = String.valueOf(numberofciphers1[0]);
							
							replylabel2.setText(s);
						}
					};
					
					replylabel1.addMouseListener(replymouselistener);
					replylabel2.addMouseListener(replymouselistener);
					
					addressarea.addMouseListener(new MouseAdapter()
					{ public void mouseClicked(MouseEvent e)
					{ checkbox.setSelected(!checkbox.isSelected()); } });
					
					replylabel1.setToolTipText(__.click);
					replylabel2.setToolTipText(__.click);
					addressarea.setToolTipText(__.click);
					
					Box hbox1 = Box.createHorizontalBox();
					Box hbox2 = Box.createHorizontalBox();
					
					Component hstrut1 = Box.createHorizontalStrut(7);
					Component hstrut2 = Box.createHorizontalStrut(10);
					Component vstrut  = Box.createVerticalStrut(10);
					
					//  Add the reply label and number of ciphers
					
					JButton replykeybutton = new JButton();
					//  replykeybutton.setEnabled(false);
					replykeybutton.add(replylabel1);
					
					replykeybutton.setFont(labelfont);
					replylabel1.setFont(labelfont);
					replylabel2.setFont(labelfont);
					
					hbox1.add(replykeybutton);
					hbox1.add(hstrut1);
					hbox1.add(replylabel2);
					
					//  Add the check box and address label
					
					hbox2.add(checkbox);
					hbox2.add(hstrut2);
					hbox2.add(addressarea);
					
					Box vbox = Box.createVerticalBox();
					
					vbox.add(hbox1); vbox.add(vstrut); vbox.add(hbox2);
					
					Object object = (Object) vbox;
					
					int choice = JOptionPane.showConfirmDialog(
					
					    frame, object, __.replykeysettings,
					
					      JOptionPane.DEFAULT_OPTION,
					      JOptionPane.PLAIN_MESSAGE, null);
					
					if (choice == JOptionPane.OK_OPTION)
					{
						//  Set the email panel send mail frame members
						
						emailpanel.numberofciphers = numberofciphers1[0];
						emailpanel.usereplyaddresskey = checkbox.isSelected();
						
						if ((emailpanel != null) && (emailpanel.list1 != null))
						
						for (int i = 0; i < emailpanel.list1.size(); i++)
						{
							SendMailFrame sendmailframe = emailpanel.list1.getSendMailFrame(i);
							
							if ((sendmailframe != null) && sendmailframe.isVisible())
							{
								sendmailframe.setNumberOfCiphers(numberofciphers1[0]);
								sendmailframe.setUseReplyAddressKey(checkbox.isSelected());
							}
						}
						
						if ((emailpanel != null) && (emailpanel.sendmailframelist != null))
						
						for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
						{
							if ((sendmailframe != null) && sendmailframe.isVisible())
							{
								sendmailframe.setNumberOfCiphers(numberofciphers1[0]);
								sendmailframe.setUseReplyAddressKey(checkbox.isSelected());
							}
						}
					}
				}
			}
			
			
			
			
			private class PassphraseListener
			
				extends MouseAdapter implements ActionListener
			{
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.passphrasebutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
				
					//  This is the retrieve mail passphrase listener
					
					if (emailpanel == null) return;
					
					String incomingmailserver = emailpanel.incomingmailserver;
					String outgoingmailserver = emailpanel.outgoingmailserver;
					
					int incomingmailport = emailpanel.incomingmailport;
					int outgoingmailport = emailpanel.outgoingmailport;
					
					int numberofmessages = emailpanel.messagesperscreen;
					boolean ascending    = emailpanel.ascending;
					
					Color foreground = emailpanel.foreground;
					Color background = emailpanel.background;
					
					//  Open the passphrase dialog and read
					//  the passhrase, servers, and directory
					
					parsePassphraseServersAndDirectory(
					 readPassphraseServersAndDirectory(
					
					   frame, foreground, background, font,
					    incomingmailserver, outgoingmailserver,
					      incomingmailport, outgoingmailport,
						maildirectory, numberofmessages,
						  ascending));
					
					writePassphrase0(frame);
					
					
					//  Read the mail settings once or else the user would
					//  be unable to change the settings in the dialog box
					//  because the old values would replace the new values
					
					if (!readmailsettings) readMailSettings();
					
					//  If the method was successful, set readmailsettings to true
					//  (Note that the quit button will reset readmailsettings)
					
					if (!emailpanel.emailfield.getText().isBlank())
					
					    readmailsettings = true;
					
					
					
					//  Send Mail Frames opened from the File menu
					
					for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
					{
						if ((sendmailframe != null) && sendmailframe.isVisible())
						{
							outgoingmailserver = emailpanel.outgoingmailserver;
							outgoingmailport   = emailpanel.outgoingmailport;
							
							sendmailframe.setOutgoingMailServer(outgoingmailserver);
							sendmailframe.setOutgoingMailPort  (outgoingmailport);
						}
					}
					
					
					//  Send Mail Frames opened from the reply button
					
					if (emailpanel.list1 != null)
					{
						ArrayList <SendMailFrame> sendmailframes
						
						    = emailpanel.list1.getSendMailFrames();
						
						for (SendMailFrame sendmailframe : sendmailframes)
						{
							if ((sendmailframe != null) && sendmailframe.isVisible())
							{
								outgoingmailserver = emailpanel.outgoingmailserver;
								outgoingmailport   = emailpanel.outgoingmailport;
								
								sendmailframe.setOutgoingMailServer(outgoingmailserver);
								sendmailframe.setOutgoingMailPort  (outgoingmailport);
							}
						}
					}
					
					
					
					String oldpassphrase = null, newpassphrase;
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						String username = emailpanel.username;
						
						if ((username == null) || username.isEmpty()) continue;
						
						emailpanel.savedemails = new SavedEmails(username);
						
						if (!emailpanel.savedemails.isDecryptable(SP))
						{
							//  Display a JOptionPane to warn the user that the
							//  saved emails are undecryptable and to prompt the user
							//  to enter the old passphrase so that the files can be
							//  decrypted and re-encrypted using the two passphrases.
							
							
							//  Prompt the user to enter the old passphrase
							
							//   _____________________________________________
							//  |_Enter your previous passphrase______________|
							//  |                   ________________________  |
							//  | prev passphrase0 |________________________| |
							//  | prev passphrase1 |________________________| |
							//  |                   xxxx xxxx xxxx xxxx       |
							//  |_____________________________________________|
							
							String message = __.passphrasehaschanged;
							
							JTextField textfield1 = new JTextField(24);
							JTextArea  textarea1  = new JTextArea(2, 24);
							
							textfield1.setFont(font);
							textarea1 .setFont(font);
							
							textfield1.setForeground(emailpanel.foreground);
							textarea1 .setForeground(emailpanel.foreground);
							
							textfield1.setCaretColor(emailpanel.foreground);
							textarea1 .setCaretColor(emailpanel.foreground);
							
							textfield1.setBackground(emailpanel.background);
							textarea1 .setBackground(emailpanel.background);
							
							Box vbox = Box.createVerticalBox();
							
							JTextArea messagearea = new JTextArea(message);
							
							messagearea.setEditable(false);
							messagearea.setFont(messagearea
							    .getFont().deriveFont(18.0f));
							
							vbox.add(messagearea);
							
							vbox.add(Box.createVerticalStrut(5));
							
							vbox.add(textfield1); vbox.add(Box.createVerticalStrut(5));
							vbox.add(textarea1 ); vbox.add(Box.createVerticalStrut(5));
							
							Object[] options = new Object[] { __.OK };
							
							int choice = 0;
							
							if (oldpassphrase == null)
							
							   choice = JOptionPane.showOptionDialog(frame, vbox, null,
							
							      JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
							
							         null, options, options[0]);
							
							if ((choice != 0) || (choice == -1)) return;
							
							System.out.println("New passphrase == " + SP);
							
							oldpassphrase = textfield1.getText() + textarea1 .getText();
							
							newpassphrase = SP;
							
							if (!oldpassphrase.isEmpty() && emailpanel
							
							    .savedemails.isDecryptable(oldpassphrase))
							{
								//  Re-encrypt the saved messages
								
								emailpanel.savedemails.reencryptFiles(
								
								    oldpassphrase, newpassphrase);
								
								//  Delete or rename the usernames file
								
								String filepath = passphraseToFilePath(
								
								    __.usernames, oldpassphrase);
								
								File file = new File(filepath);
								
								if (file.exists()) file.delete();
								
								saveMailSettings();
								readMailSettings();
							}
							
							else
							{	oldpassphrase = null;
								
								JOptionPane.showMessageDialog(
								
								    frame, __.Error);
							}
						}
					}
				}
			}
			
			
			
			
			private class UserPassListener implements ActionListener
			{
			
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
				
					if ( (emailpanel == null)
					  || (emailpanel.username == null)
					  ||  emailpanel.username.isEmpty())
					{
						JOptionPane.showMessageDialog(frame,
						
						    __.emailaddressisempty);
						
						return;
					}
					
					String userpass = null, hash = "";
					
					
					//  Compute the hash of the passphrase + username
					
					if ((emailpanel.username   != null) && !emailpanel.username  .isEmpty()
					 && (emailpanel.userdomain != null) && !emailpanel.userdomain.isEmpty())
					
					    hash = Cipher.hash2(SP + emailpanel.username) .substring(0, 8);
					
					
					if ((emailpanel.userpass != null) &&
					    !emailpanel.userpass.isEmpty())
					
					    userpass = emailpanel.userpass;
					
					else userpass = hash;
					
					
					System.out.println("hash(passphrase + username) == " + hash);
					System.out.println("userpass == " + userpass);
					
					
					//  Display the userpass
					
					String useremailaddress = emailpanel
					
					    .username + "@" + emailpanel.userdomain;
					
					final int maxlen = 24;
					
					useremailaddress = useremailaddress.substring(
					
					    0, Math.min(maxlen, useremailaddress.length()));
					
					if (useremailaddress.length() > maxlen) useremailaddress += "..";
					
					JLabel useremailaddresslabel = new JLabel(useremailaddress);
					
					JTextField userpassfield = new JTextField(12);
					
					
					JLabel hashlabel = new JLabel(hash);
					
					hashlabel.setFont(font.deriveFont(
					
					    font.getSize() - 4.0f));
					
					
					Box vbox = Box.createVerticalBox();
					
					vbox.add(useremailaddresslabel);
					vbox.add(Box.createVerticalStrut(10));
					vbox.add(hashlabel);
					vbox.add(Box.createVerticalStrut(10));
					vbox.add(userpassfield);
					
					
					String title = __.popmailuserpass;
					
					userpassfield.setText(userpass);
					
					useremailaddresslabel .setFont(font);
					userpassfield .setFont(font);
					
					useremailaddresslabel.setForeground(emailpanel.foreground);
					useremailaddresslabel.setBackground(emailpanel.background);
					
					userpassfield.setForeground(emailpanel.foreground);
					userpassfield.setCaretColor(emailpanel.foreground);
					userpassfield.setBackground(emailpanel.background);
					
					userpassfield .requestFocus();
					
					String newuserpass;
					
					int warnings = 0;
					
					while (true)
					{
						JOptionPane.showMessageDialog(frame, vbox,
						
						    title, JOptionPane.PLAIN_MESSAGE);
						
						//  Read the userpass field because the
						//  user may have edited the userpass
						
						newuserpass = userpassfield.getText().trim();
						
						//  Don't allow the user to enter a
						//  passphrase instead of a userpass
						
						if (newuserpass.length() > 12)
						{
							JOptionPane.showMessageDialog(
							  frame, __.userpasswarning, "",
							    JOptionPane.WARNING_MESSAGE);
							
							warnings++;
							
							if (warnings < 3) continue;
							
							else break;
						}
						
						else break;
					}
					
					//  Save the userpass
					
					if (newuserpass.equals(userpass)) return;
					
					if ((newuserpass != null) && !newuserpass.isEmpty())
					
					     emailpanel.userpass = newuserpass;
					else emailpanel.userpass = hash;
					
					
					//  Change the email userpass in the send mail frames
					
					for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
					
					    if (sendmailframe != null)
					
						sendmailframe.userpass =
						   emailpanel.userpass;
				}
			}
			
			
			
			
			private class RandomTextListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					int t = 128, rows = 8, cols = 24;
					
					String randchars = generateRandomText(t);
					
					JTextArea textarea = new JTextArea(rows, cols);
					
					textarea.setLineWrap(true);
					
					textarea.setFont(font);
					
					textarea.setText(randchars);
					
					String title = __.randomtextanddate;
					
					JButton button = new JButton(__.newtextanddate);
					
					button.addActionListener( new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ String text = generateRandomText(t);
					  textarea.setText(text); } } );
					
					Object[] objarray = new Object[] { textarea, button };
					
					JOptionPane.showMessageDialog(frame, objarray,
					
					    title, JOptionPane.PLAIN_MESSAGE);
				}
				
				
				private String generateRandomText(int t)
				{
					ArrayList<Character> charlist;
					
					charlist = new ArrayList<Character>();
					
					Math.initRng(System.nanoTime());
					
					for (int i = 0; i < t; i++)
					
					    charlist.add((char) Math.random(26));
					
					for (int i = 0; i < t; i++)
					
					    charlist.set(i, (char) (charlist.get(i) + 'a'));
					
					
					for (int i = charlist.size() -1; i >= 0; i--)
					{
						char c = charlist.get(i);
						
						//  Remove the vowels and use the consonants
						
						if ((c == 'a') || (c == 'e') || (c == 'i')
						 || (c == 'o') || (c == 'u') || (c == 'y'))
						
						    charlist.remove(i);
					}
					
					//  Add space chars to the random text
					
					for (int i = 0; i < charlist.size(); i++)
					{
						int randsize = 5 + Math.random(4);
						
						int index = (i += randsize+1);
						
						if (index < charlist.size())
						
						    charlist.add(index, ' ');
					}
					
					//  Create a random date for websites
					//  that require a fake birthdate
					
					int digits = 16, radix = 16;
					
					Number randnumber = Number.random(digits, radix);
					
					int month = randnumber .mod(12) .add(1) .intValue();
					int   day = randnumber .mod(31) .add(1) .intValue();
					int  year = randnumber .mod(50) .add(1950) .intValue();
					
					if ((month == 2) && (day > 29)) day = 29;
					if ((month == 2) && (day == 29) && ((year % 4) != 0)) day = 28;
					
					String randstr = String.valueOf(month) + " / "
					               + String.valueOf(day)   + " / "
					               + String.valueOf(year);
					
					char[] charray = new char[charlist.size()];
					
					for (int i = 0; i < charray.length; i++)
					
					    charray[i] = charlist.get(i);
					
					return new String(charray) + "\n" + randstr;
				}
			}
			
			
			
			
			private class PublicKeyListener extends MouseAdapter implements ActionListener
			{
			
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.printkeybutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
					if (emailpanel == null) return;
					
					if ((emailpanel.username == null)
					  || emailpanel.username.isEmpty()) return;
					
					String address = new String();
					
					if ((emailpanel.username   != null) && !emailpanel.username  .isEmpty()
					 && (emailpanel.userdomain != null) && !emailpanel.userdomain.isEmpty())
					
					    address = emailpanel.username + "@" + emailpanel.userdomain;
					
					
					String SP1 = "";
					
					if ((SP != null) && (SP0 != null) && !SP0.isEmpty())
					
					    SP1 = SP.substring(SP0.length());
					
					PublicKeyDialog pkd = new PublicKeyDialog(frame);
					
					pkd.setFont(font);
					pkd.setForeground(emailpanel.foreground);
					pkd.setBackground(emailpanel.background);
					pkd.setEmailAddress(address);
					pkd.setPassphrase0(SP0);
					pkd.setPassphrase1(SP1);
					
					String[] array = pkd.generatePublicKey();
					
					if (array == null) return;
					
					String passphrase0 = array[0];
					String passphrase1 = array[1];
					String publickeystr = array[2];
					
					if ((publickeystr == null) ||
					     publickeystr.isEmpty()) return;
					
					SP = passphrase0 + passphrase1;
					
					SP0 = passphrase0;
					
					//  Compute the public key hash and partition the hash string
					
					String publickeyhash = PublicKey.hashPublicKey(publickeystr);
					
					publickeyhash = publickeyhash .substring(0, 32);
					publickeyhash = Convert.partition(publickeyhash, " ", 4);
					
					
					//  Display the user's public key and a
					//  a copy to clipboard and cancel button
					
					String document = publickeystr;
					
					String title = __.mypublickeyhash;
					
					title += "  " + publickeyhash;
					
					
					JButton copy_button, cancel_button;
					
					  copy_button = new JButton(__.copytoclipboard);
					cancel_button = new JButton(__.cancel);
					
					int rows = 24, cols = 56;
					
					JTextArea textarea = new JTextArea(rows, cols);
					JScrollPane scrollpane = new JScrollPane(textarea);
					
					textarea.setText(document);
					textarea.setEditable(false);
					textarea.setFont(font);
					
					Box vbox = Box.createVerticalBox();
					Box hbox = Box.createHorizontalBox();
					
					hbox.add(copy_button);
					hbox.add(cancel_button);
					
					vbox.add(scrollpane);
					vbox.add(hbox);
					
					
					//  options has to equal the empty array instead of
					//  null or else the JOptionPane will add an OK button
					
					Object[] options = new Object[] {  };
					
					JOptionPane pane = new JOptionPane(vbox,
					
					    JOptionPane.PLAIN_MESSAGE, JOptionPane
					
						.DEFAULT_OPTION, null, options, 0);
					
					//  pane.set(...)
					
					
					JDialog dialog = pane.createDialog(frame, title);
					
					int[] choice = new int[] { -1 };
					
					copy_button.addActionListener( new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ choice[0] = 0; dialog.dispose(); } } );
					
					cancel_button.addActionListener( new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ choice[0] = 1; dialog.dispose(); } } );
					
					dialog.setVisible(true);
					
					
					if (choice[0] == 0)
					{
						//  Copy the key string to clipboard
						
						cb.setContents(new StringSelection(publickeystr), null);
						
						System.out.println("Public key copied to clipboard");
					}
					
					else if (choice[0] == 1)
					{
						
					}
				}
			}
			
			
			
			
			private class TextBoldListener extends MouseAdapter implements ActionListener
			{
			
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.textboldbutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
					String fontname = font.getName();
					int fontstyle = font.getStyle();
					int fontsize = font.getSize();
					
					if (fontstyle == Font.PLAIN)
					
					    font = new Font(fontname, Font.BOLD, fontsize);
					
					if (fontstyle == Font.BOLD)
					
					    font = new Font(fontname, Font.PLAIN, fontsize);
					
					setFont1(font);
				}
			}
			
			
			
			
			
			private class FontTypeListener implements ActionListener
			{
			
				private JTextField[] textfields;
				
				private String fontname;
				
				private int style;
				
				private JCheckBox stylebox;
				
				Font font0;
				
				
				public void actionPerformed(ActionEvent e)
				{
					font0 = font;
					
					style = (font != null) ?
					
					    font.getStyle() : Font.PLAIN;
					
					JDialog dialog = getFontDialog(font);
					
					//  JDialog setVisible() blocks
					//  until the dialog is disposed
					//  only if modal is set to true
					
					dialog.setVisible(true);
				}
				
				
				private class MouseListener extends MouseAdapter
				{
					public void mouseClicked(MouseEvent e)
					{
						Object obj = e.getSource();
						
						if (obj instanceof JTextField)
						{
							fontname = ((JTextField) obj).getText();
							
							displayFont();
						}
						
						if (obj instanceof JCheckBox)
						{
							style = stylebox.isSelected() ?
							
							    Font.BOLD : Font.PLAIN;
							
							displayFont();
						}
						
						if (obj instanceof JLabel)
						{
							 stylebox.setSelected(
							!stylebox.isSelected());
							
							style = stylebox.isSelected() ?
							
							    Font.BOLD : Font.PLAIN;
							
							displayFont();
						}
					}
				}
				
				
				private JDialog getFontDialog(Font font)
				{
					//  The font dialog allows the user to select a font type
					//  and shows the user what each font type looks like as
					//  the arrow key is pressed or the mouse is clicked
					
					JLabel stylelabel, fontlabel;
					
					GraphicsEnvironment ge;
					
					ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
					
					String[] fonts = ge.getAvailableFontFamilyNames();
					
					//  for (String font1 : fonts) System.out.println(
					//
					//      Arrays.toString(font1.toCharArray()));
					
					textfields = new JTextField[fonts.length];
					
					MouseListener mouselistener = new MouseListener();
					
					for (int i = 0; i < textfields.length; i++)
					{
						textfields[i] = new JTextField(fonts[i]);
						textfields[i] .setEditable(false);
						textfields[i] .setForeground(emailpanel.foreground);
						textfields[i] .setBackground(emailpanel.background);
						textfields[i] .addMouseListener(mouselistener);
						textfields[i] .setFont(new Font(
						     fonts[i], fontstyle, font.getSize()));
					}
					
					JScrollPane scrollpane = new JScrollPane();
					
					scrollpane.setVerticalScrollBarPolicy(
					    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
					
					scrollpane.getVerticalScrollBar().setUnitIncrement(32);
					
					Box vbox = Box.createVerticalBox();
					
					for (JTextField textfield : textfields)
					
					    vbox.add(textfield);
					
					scrollpane.setViewportView(vbox);
					
					
					//   ____________________________
					//  |                            |
					//  |     [ OK ] [ Cancel ]      |
					//  |                            |
					//  |    [x] bold  font name     |
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					//  |____________________________|
					
					stylebox = new JCheckBox();
					stylelabel = new JLabel(__.bold);
					 fontlabel = new JLabel(font.getName());
					JButton okbutton = new JButton(__.OK);
					JButton cancelbutton = new JButton(__.cancel);
					
					stylebox.setSelected(style == Font.BOLD);
					
					stylebox  .addMouseListener(mouselistener);
					stylelabel.addMouseListener(mouselistener);
					
					stylelabel.setFont(font);
					 fontlabel.setFont(font);
					
					Box hbox1 = Box.createHorizontalBox();
					Box hbox2 = Box.createHorizontalBox();
					
					hbox1.add(okbutton);
					hbox1.add(Box.createHorizontalStrut(10));
					hbox1.add(cancelbutton);
					
					hbox2.add(stylebox);
					hbox2.add(stylelabel);
					hbox2.add(Box.createHorizontalStrut(20));
					hbox2.add(fontlabel);
					
					vbox = Box.createVerticalBox();
					
					vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox1);
					vbox.add(Box.createVerticalStrut(10)); vbox.add(hbox2);
					vbox.add(Box.createVerticalStrut(10)); vbox.add(scrollpane);
					
					
					boolean modal = false;
					
					String title = __.selectfonttype;
					
					JDialog dialog = new JDialog(frame, modal);
					
					dialog.setTitle(title);
					
					
					//  Clicking ok or cancel or pressing
					//  the escape key closes the dialog
					
					okbutton .addActionListener( new ActionListener()
					{
					    public void actionPerformed(ActionEvent e)
					    {
						//  Set the new font
						
						Font font1 = font0;
						
						if ((fontname != null) && !fontname.isEmpty())
						
						    font1 = new Font(fontname, style, (int) fontsize);
						
						fontname  = font1.getName();
						fontstyle = font1.getStyle();
						fontsize  = font1.getSize();
						
						setFont1(font1);
						
						dialog.dispose();
					} } );
					
					
					cancelbutton .addActionListener( new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ setFont1(font0); dialog.dispose(); } } );
					
					KeyAdapter closelistener = new KeyAdapter()
					{ public void keyPressed(KeyEvent e)
					{ if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
					  setFont1(font0); dialog.dispose(); } };
					
					
					scrollpane.addKeyListener(closelistener);
					scrollpane.requestFocusInWindow();
					scrollpane.setHorizontalScrollBarPolicy(
					    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
					
					Dimension d = new Dimension(400, 800);
					
					dialog.add(vbox);
					dialog.setResizable(false);
					dialog.setDefaultCloseOperation(
					    JDialog.DISPOSE_ON_CLOSE);
					dialog.setMinimumSize(d);
					
					return dialog;
				}
				
				
				private void displayFont()
				{
					for (JTextField textfield : textfields)
					{
						Font textfieldfont = textfield.getFont();
						
						textfield.setFont(new Font(textfieldfont.getName(),
						
						    style, textfieldfont.getSize()));
					}
					
					if ((fontname == null) || fontname.isEmpty())
					
					    fontname = font.getName();
					
					Font font1 = new Font(fontname, style, font.getSize());
					
					setFont1(font1);
				}
			}
			
			
			
			
			private class FontSizeListener extends MouseAdapter implements ActionListener
			{
			
				//  The RetrieveMail FontSizeListener allows the user to
				//  change the maxfontsize. The setFont1() method calls
				//  the frameSizeToFontSize() method which calculates the
				//  current font size using the maxfontsize, and then it
				//  uses the returned value to set the font.
				
				
				private JPanel panel;
				
				private JButton  plusbutton;
				private JButton minusbutton;
				
				private JTextField textfield;
				
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.fontsizebutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
				
					if (emailpanel == null) return;
					
					textfield = new JTextField(4);
					
					textfield.setFont(textfield.getFont()
					
					    .deriveFont(22.0f));
					
					plusbutton  = new JButton("+");
					minusbutton = new JButton("-");
					
					panel = new JPanel();
					
					panel.add(textfield);
					panel.add(minusbutton);
					panel.add(plusbutton);
					
					
					ActionListener actionlistener = new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							if (e.getSource() ==  plusbutton) incrementSize(1);
							if (e.getSource() == minusbutton) decrementSize(1);
							
							//  int fontsize = String.valueOf(
							//      emailpanel.textarea.getFont().getSize();
							
							int fontsize = maxfontsize;
							
							textfield.setText(String.valueOf(fontsize));
						}
					};
					
					
					plusbutton .addActionListener(actionlistener);
					minusbutton.addActionListener(actionlistener);
					
					
					textfield.addKeyListener(new KeyAdapter()
					{
						public void keyReleased(KeyEvent e)
						{
							String text = textfield.getText();
							
							fontsize = !text.isBlank() ?
							
							    Integer.parseInt(textfield.getText()) : 1;
							
							try { fontsize = Integer.parseInt(text); }
							
							catch (NumberFormatException ex) { return; }
							
							int maxsize = 100;
							
							if (fontsize > maxsize)
							{
								fontsize = maxsize;
								
								textfield.setText(String
								
								    .valueOf((int) fontsize));
							}
							
							else if (fontsize == 0)
							{
								fontsize = 1;
							}
							
							maxfontsize = (int) fontsize;
							
							fontsize = frameSizeToFontSize(frame);
							
							Font font = emailpanel.textarea
							
							    .getFont().deriveFont(fontsize);
							
							setFont1(font);
						}
						
						
						public void keyTyped(KeyEvent e)
						{
							if ((textfield.getText().trim().length() > 2)
							
							    || !Character.isDigit(e.getKeyChar()))
							
								e.consume();
						}
					});
					
					
					String title = __.changethefontsize;
					
					textfield.setText(String.valueOf(maxfontsize));
					
					int type = JOptionPane.PLAIN_MESSAGE;
					
					JOptionPane.showMessageDialog(frame,
					
					    new Object[] { panel }, title, type);
					
					float size;
					
					try { size = Integer.parseInt(textfield.getText()); }
					
					catch (NumberFormatException ex)
					
					    { System.out.println(ex); return; }
					
					if (size > 0)
					{
						maxfontsize = (int) size;
						
						fontsize = frameSizeToFontSize(frame);
						
						Font font = emailpanel.textarea
						
						    .getFont().deriveFont(fontsize);
						
						setFont1(font);
					}
				}
			}
			
			
			
			
			private class ColorListener implements ActionListener
			{
			
				private JColorChooser cc;
				
				private ColorListener()
				{
					cc = new JColorChooser();
				}
				
				public void actionPerformed(ActionEvent e)
				{
				
					if (emailpanel == null) return;
					
					JButton textcolorbutton, screencolorbutton, swapcolorsbutton;
					
					textcolorbutton   = new JButton(__.textcolor);
					screencolorbutton = new JButton(__.screencolor);
					swapcolorsbutton  = new JButton(__.swapcolors);
					
					
					String title = "";
					
					Object[] options = new Object[] { textcolorbutton };
					
					
					Color screencolor1 = emailpanel.background;
					Color   textcolor1 = emailpanel.foreground;
					
					textcolorbutton.addActionListener(new ActionListener()
					{
						public void actionPerformed(ActionEvent e)
						{
							Color color = cc.getColor();
							
							if (color != null)
							{
								if (!emailpanel.foreground.equals(color))
								{
									setForeground(color);
									setBackground(Color.white);
								}
								
								else
								{	setForeground(textcolor1);
									setBackground(Color.white);
								}
							}
						}
					});
					
					
					int choice = JOptionPane.showOptionDialog(frame, cc, null,
					
					    JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE,
					
						null, options, options[0]);
					
					if (choice != JOptionPane.OK_OPTION) return;
					
					else {   }
				}
				
				
				private void setForeground(Color color)
				{
					EmailPanel emailpanel1 = emailpanel;
					
					if (emailpanel1 == null) return;
					
					setForeground(emailpanel1, color);
				}
				
				
				private void setBackground(Color color)
				{
					EmailPanel emailpanel1 = emailpanel;
					
					if (emailpanel1 == null) return;
					
					setBackground(emailpanel1, color);
				}
				
				
				private void setForeground(EmailPanel emailpanel, Color color)
				{
					//  Set the emailpanel foreground
					
					if ((tabbedpane.getTabCount() > 1)
					
					 && (emailpanel.buttonlistener.listing
					  || emailpanel.buttonlistener.reading)) return;
					
					if (!color.equals(Color.white))
					{
						for (Component comp : emailpanel.components)
						
						    comp.setForeground(color);
						
						for (JButton button : emailpanel.buttons)
						
						    button.setForeground(color);
					}
					
					if (!emailpanel.reverse_colors)
					{
						if (emailpanel.textarea != null)
						{
						    emailpanel.textarea.setForeground(color);
						    emailpanel.textarea.setCaretColor(color);
						}
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setForeground1(color);
					}
					
					else
					{	if (emailpanel.textarea != null)
						    emailpanel.textarea.setBackground(color);
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setBackground1(color);
					}
					
					
					//  Set the text color for the reply send mail frames
					
					if (emailpanel.list1 != null)
					
					for (int i = 0; i < emailpanel.list1.size(); i++)
					{
						SendMailFrame sendmailframe = emailpanel
						
						    .list1.getSendMailFrame(i);
						
						if ((sendmailframe != null) && sendmailframe.isVisible())
						{
							sendmailframe.setReverseColors(
							   emailpanel.reverse_colors);
							sendmailframe.setForeground1(color);
						}
					}
					
					//  Set the text color for non-reply send mail frames
					
					for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
					{
						if ((sendmailframe != null) && sendmailframe.isVisible())
						{
							sendmailframe.setReverseColors(
							    emailpanel.reverse_colors);
							sendmailframe.setForeground1(color);
						}
					}
					
					int index = tabbedpane.getSelectedIndex();
					//  tabbedpane.setForegroundAt(index, color);
					
					emailpanel.poptextarea.setForeground(color);
					
					emailpanel.foreground = color;
					emailpanel.caretcolor = color;
					
					if (emailpanel.savedemails != null)
					
					    emailpanel.savedemails.setForeground(color);
					
					if (!emailpanel.reverse_colors)
					
					    Documents.setForeground(color);
					
					else // if (reverse_colors)
					
					    Documents.setBackground(color);
				}
				
				
				private void setBackground(EmailPanel emailpanel, Color color)
				{
					//  Set the emailpanel foreground (not background)
					//  because the colors may be reversed
					
					if ((tabbedpane.getTabCount() > 1)
					
					 && (emailpanel.buttonlistener.listing
					  || emailpanel.buttonlistener.reading)) return;
					
					if (!color.equals(Color.white))
					{
						for (Component comp : emailpanel.components)
						
						    comp.setForeground(color);
						
						for (JButton button : emailpanel.buttons)
						
						    button.setForeground(color);
					}
					
					
					if (!emailpanel.reverse_colors)
					{
						if (emailpanel.textarea != null)
						    emailpanel.textarea.setBackground(color);
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setBackground1(color);
					}
					
					else
					{	if (emailpanel.textarea != null)
						{
						    emailpanel.textarea.setForeground(color);
						    emailpanel.textarea.setCaretColor(color);
						}
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setForeground1(color);
					}
					
					
					//  Set the screen color for the reply send mail frames
					
					if (emailpanel.list1 != null)
					
					for (int i = 0; i < emailpanel.list1.size(); i++)
					{
						SendMailFrame sendmailframe = emailpanel
						
						    .list1.getSendMailFrame(i);
						
						if ((sendmailframe != null) && sendmailframe.isVisible())
						{
							sendmailframe.setReverseColors(
							   emailpanel.reverse_colors);
							sendmailframe.setBackground1(color);
						}
					}
					
					//  Set the screen color for the non-reply send mail frames
					
					for (SendMailFrame sendmailframe : emailpanel.sendmailframelist)
					{
						if ((sendmailframe != null) && sendmailframe.isVisible())
						{
							sendmailframe.setReverseColors(
							    emailpanel.reverse_colors);
							sendmailframe.setBackground1(color);
						}
					}
					
					emailpanel.poptextarea.setBackground(color);
					
					emailpanel.background = color;
					
					if (emailpanel.savedemails != null)
					
						emailpanel.savedemails.setBackground(color);
					
					if (!emailpanel.reverse_colors)
					
					    Documents.setBackground(color);
					
					else // if (reverse_colors)
					
					    Documents.setForeground(color);
				}
				
				
				//  These methods are used to set the color of an emailpanel
				
				public void setForeground(EmailPanel emailpanel)
				{
					setForeground(emailpanel, emailpanel.foreground);
				}
				
				public void setBackground(EmailPanel emailpanel)
				{
					setBackground(emailpanel, emailpanel.background);
				}
			}
			
			
			
			
			private class ColorButtonListener
			{
			
				//  The ColorButtonListener could be replaced by a Color
				//  Palette Listener that uses a Popup and a color palette
				//  that has 4 x 8 or 5 x 8 colors but there could be an
				//  option to use buttons to change the colors.
				//
				//  There should also be an option to enable the user
				//  to hide the checkbox and color buttons from the
				//  ColorListener class or Text/Screen Color menu item.
				//
				//  Clicking on the checkbox makes the buttons disappear
				//  but the checkbox | doesn't disappear.
				
				
				private void init()
				{
				
					Colors colors = new Colors();
					
					JLabel colorlabel = new JLabel();
					JLabel closelabel = new JLabel();
					
					colorlabel.setVisible(true);
					
					closelabel.setVisible(false);
					
					JCheckBox checkbox = new JCheckBox();
					
					checkbox .setEnabled(false);
					checkbox .setForeground(
					   new JPanel().getBackground() );
					
					checkbox .add(closelabel);
					
					checkbox .setToolTipText(__.click);
					
					JButton colorbutton1 = new JButton();
					JButton colorbutton2 = new JButton();
					
					colorbutton1 .setVisible(false);
					colorbutton2 .setVisible(false);
					
					colorbutton1 .setForeground(
					 new JPanel().getBackground());
					
					colorbutton2 .setForeground(
					 new JPanel().getBackground());
					
					colorbutton1.addKeyListener(keylistener1);
					colorbutton2.addKeyListener(keylistener1);
					
					
					menubar.add(checkbox);
					menubar.add(colorbutton1);
					menubar.add(colorbutton2);
					menubar.add(colorlabel);
					
					MouseListener mouselistener = new MouseAdapter()
					{
						public void mouseEntered(MouseEvent e)
						{
							colorbutton1.setVisible(true);
							colorbutton2.setVisible(true);
							colorlabel  .setVisible(true);
							
							//  Set the color buttons to the current foreground
							
							if ((emailpanel != null) && (emailpanel.foreground != null))
							
							for (int i = 0; i < Colors.rgb.length; i++)
							
							    if (emailpanel.foreground .equals(new Color(Colors.rgb[i])))
							
								{ colors.index = i; break; }
							
							if (colorbutton1.isVisible()
							 || colorbutton2.isVisible())
							{
								if (colors.index >= 0)
								{
									String message = Colors.colors[colors.index];
									
									colorlabel.setText(message);
								}
							}
						}
						
						public void mouseExited(MouseEvent e)
						{
							colorlabel.setText("");
						}
						
						public void mousePressed(MouseEvent e)
						{
							if ((tabbedpane.getTabCount() > 1)
							
							 && (emailpanel.buttonlistener.listing
							  || emailpanel.buttonlistener.reading)) return;
							
							if (e.getSource() == checkbox)
							{
								colorbutton1.setVisible(!colorbutton1.isVisible());
								colorbutton2.setVisible(!colorbutton2.isVisible());
								colorlabel.setVisible(!colorlabel.isVisible());
								
								if (colorbutton1.isVisible()
								 || colorbutton2.isVisible())
								{
									if (colors.index >= 0)
									{
										String message = Colors.colors[colors.index];
										
										colorlabel.setText(message);
									}
								}
							}
							
							if (e.getSource() == colorbutton1)
							{
								colors.index--;
								
								if (colors.index < 0) colors.index
								
								    = Colors.rgb.length -1;
							}
							
							if (e.getSource() == colorbutton2)
							{
								colors.index++;
								
								if (colors.index >= Colors.rgb.length)
								
								    colors.index = 0;
							}
							
							if ((e.getSource() == colorbutton1)
							 || (e.getSource() == colorbutton2))
							{
								Color color = new Color(Colors.rgb[colors.index]);
								
								colorlistener.setForeground(color);
								colorlistener.setBackground(Color.white);
								
								String message = Colors.colors[colors.index];
								
								colorlabel.setText(message);
							}
						}
					};
					
					checkbox     .addMouseListener(mouselistener);
					colorlabel   .addMouseListener(mouselistener);
					colorbutton1 .addMouseListener(mouselistener);
					colorbutton2 .addMouseListener(mouselistener);
				}
			}
			
			
			
			
			private class ClientServerListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					pop3window.setVisible(!pop3window.isVisible());
					
					int x = pop3window.getWidth(), y = 0;
					
					if (pop3window.isVisible())
					
					    frame.setLocation(x, y);
					
					else // if (!pop3window.isVisible())
					
					    frame.setLocation(0, 0);
				}
			}
			
			
			
			private class ShowKeyboardListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					showkeyboard = !showkeyboard;
				}
			}
			
			
			
			private class ShowHideEmailsListener
			
				extends MouseAdapter implements ActionListener
			{
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.showhidebutton) run();
				}
				
				public void actionPerformed(ActionEvent e)
				{
					run();
				}
				
				public void run()
				{
					//  Show a dialog that allows the user
					//  to check / uncheck different emails
					//
					//  [ ] sent         (hide sent emails)
					//
					//  [x] read         (show read email)
					//  [x] replied to   (show answered emails)
					//  [x] delete       (show deleted emails)
					//       ...          ...
					//
					//  This feature could be implemented if POP mail
					//  servers would allow clients to change the state
					//  of the messages. Until this changes, the only
					//  feature that can be implemented is to hide the
					//  sent emails because the program can read the
					//  from address.
					
					//  ...   ...
					
					//  ...   ...
					
					showsentemails = !showsentemails;
					
					if (emailpanel.list1 != null)
					
					for (int i = 0; i < emailpanel.list1.size(); i++)
					{
						//  Skip messages that are deleted because deleting
						//  just hides the messages until the client / user
						//  signs out; otherwise the client message numbers
						//  would not correspond to the server numbers.
						
						if (emailpanel.list1.isDeleted(i)) continue;
						
						String from = emailpanel.list1.getFrom(i);
						String user = emailpanel.username;
						
						if (from.contains("@")) from = from.substring(0, from.indexOf("@"));
						if (user.contains("@")) user = user.substring(0, user.indexOf("@"));
						
						if (from.equals(user)) emailpanel
						
						   .listpanel.setVisible(i, showsentemails);
					}
				}
			}
			
			
			
			private class ReverseColorsListener extends MouseAdapter implements ActionListener
			{
				public void mouseClicked(MouseEvent e)
				{
					if (e.getSource() instanceof JButton)
					if (e.getSource() == emailpanel.reversecolorsbutton) run();
				}
				
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					if ((tabbedpane.getTabCount() > 1)
					
					 && (emailpanel.buttonlistener.listing
					  || emailpanel.buttonlistener.reading)) return;
					
					emailpanel.reverse_colors = !emailpanel.reverse_colors;
					
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						colorlistener.setForeground(emailpanel);
						colorlistener.setBackground(emailpanel);
					}
				}
			}
			
			
			
			
			
			private class ViewPublicKeysListener implements ActionListener
			{
			
				private ArrayList<JTextField> textfieldlist;
				
				public void actionPerformed(ActionEvent e)
				{
					listPublicKeys();
				}
				
				
				private void listPublicKeys()
				{
					//  creates and displays a dialog that enables
					//  the user to view / delete public keys
					
					//  Read the public key file into a public key ring
					
					if ((emailpanel.username == null)
					 || (emailpanel.userdomain == null))
					{
						String errormessage = __.emailaddressisempty;
						
						JOptionPane.showMessageDialog(frame,
						
						    errormessage, null, JOptionPane.ERROR_MESSAGE);
						
						return;
					}
					
					String useraddr = emailpanel.username + "@" + emailpanel.userdomain;
					
					PublicKeyRing publickeyring = readPublicKeys(useraddr);
					
					//  if file not found or undecryptable return
					
					if (publickeyring == null)
					{
						String errormessage = __.publickeyringisempty;
						
						JOptionPane.showMessageDialog(frame,
						
						    errormessage, null, JOptionPane.ERROR_MESSAGE);
						
						return;
					}
					
					JList<String> list;
					JScrollPane scrollpane;
					DefaultListModel<String> emailmodel;
					//  DefaultListModel<String> publickeymodel;
					
					emailmodel = new DefaultListModel<String>();
					
					for (int i = 0; i < publickeyring.size(); i++)
					{
						String name = publickeyring.get(i)[0];
						
						if (name != null) emailmodel.addElement(name);
					}
					
					list = new JList<String>(emailmodel);
					scrollpane = new JScrollPane(list);
					list.setVisibleRowCount(4);
					
					JButton deletebutton = new JButton(__.del);
					
					Box hbox = Box.createHorizontalBox();
					
					hbox.add(scrollpane);
					hbox.add(deletebutton);
					
					
					deletebutton.addActionListener(new ActionListener()
					{  public void actionPerformed(ActionEvent e)
					{  int choice = list.getSelectedIndex();
					   if (choice == -1) return;
					      emailmodel.remove(choice);
					   publickeyring.remove(choice);
					} });
					
					
					Box vbox = Box.createVerticalBox();
					
					vbox.add(hbox);
					
					list         .setFont(font);
					scrollpane   .setFont(font);
					deletebutton .setFont(font);
					
					deletebutton .setToolTipText(__.shiftarrow);
					
					JPanel panel1 = new JPanel();
					
					panel1.add(hbox);
					
					String title = __.recipientspublickeys;
					
					int result = JOptionPane.showOptionDialog(frame,
					
					    panel1, title, 0, JOptionPane.PLAIN_MESSAGE,
					
						null, new Object[] { __.OK }, null);
					
					if (result == JOptionPane.CLOSED_OPTION) return;
					
					
					//  Update the public key ring
					
					savePublicKeys(useraddr, publickeyring);
				}
			}
			
			
			
			private class AboutListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if (emailpanel == null) return;
					
					String title = __.about;
					
					String message = titlename + "  " + version;
					
					Object[] options = { __.license };
					
					int choice = JOptionPane.showOptionDialog(frame,
					
					    message, title, JOptionPane.DEFAULT_OPTION,
					
					      JOptionPane.PLAIN_MESSAGE, null, options, options[0]);
					
					if ((choice == JOptionPane.CANCEL_OPTION)
					 || (choice == JOptionPane.CLOSED_OPTION))
					
						return;
					
					else new LicenseListener().run();
				}
			}
			
			
			
			
			private class HowToUsePopMailListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if (emailpanel == null) return;
					
					String title = __.howtousepopmail;
					
					String document = Documents
					
					    .howtousepopmail1 + Documents.howtousepopmail2;
					
					Documents .display(frame, title, document,
					
					    font, emailpanel.foreground, emailpanel.background);
				}
			}
			
			
			
			
			
			private class LicenseListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					if (emailpanel == null) return;
					
					String title = __.softwarelicense;
					
					String document = Documents.gpl;
					
					Documents .display(frame, title, document,
					
					    font, emailpanel.foreground, emailpanel.background);
				}
			}
			
			
			
			
			private class TestMailListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if (emailpanel == null) return;
					
					//  Click the quit button before changing testmail
					//  or else the decrypt method will throw NullPointer
					//  Exceptions if the program is listing the messages.
					
					//  Stop the program from listing
					
					emailpanel.quitbutton.doClick();
					
					testmail = testmailmenuitem.isSelected();
				}
			}
			
			
			
			
			private void setFont1(Font font)
			{
				//  changes the font for the retrievemailframe
				//  (and the sendmailframes that were opened
				//  from the retrievemailframe)
				
				this.font = font;
				
				Dimension d = frame.getSize();
				
				int framearea = (int) (d.getWidth() * d.getHeight());
				
				if (emailpanel != null)
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					EmailPanel emailpanel1 = (EmailPanel)
					
					    tabbedpane.getComponentAt(i);
					
					if (emailpanel1 == null) return;
					
					for (Component comp : emailpanel1.components)
					
					    comp.setFont(font);
					
					
					//  Set the textarea font
					
					emailpanel.textarea.setFont(font);
					
					
					//  Set the list pane font
					
					if (emailpanel1.listpanel != null)
					    emailpanel1.listpanel .setFont1(font);
					
					
					//  Set the pop window font for the client / server communication
					//  (The font size is smaller than the retrieve mail frame)
					
					float popfontsize = font.getSize();
					
					popfontsize = popfontsize > 4 ? font.getSize() - 3 : 1;
					
					emailpanel1.poptextarea.setFont(
					
					    font.deriveFont(popfontsize));
					
					
					//  Set the font for the reply send mail frames
					
					if (emailpanel1.list1 != null)
					
					for (int j = 0; j < emailpanel1.list1.size(); j++)
					{
						SendMailFrame sendmailframe = emailpanel1
						
						    .list1.getSendMailFrame(j);
						
						if ((sendmailframe != null) && sendmailframe.isVisible())
						
						    sendmailframe.setFont1(font);
					}
					
					//  Set the font for non-reply send mail frames
					
					for (SendMailFrame sendmailframe : emailpanel1.sendmailframelist)
					
					    if ((sendmailframe != null) && sendmailframe.isVisible())
					
						sendmailframe.setFont1(font);
					
					
					//  Scale the button icon sizes and button
					//  text sizes for the retrieve mail frame
					
					int miniconsize = 14;
					int maxiconsize = 28;
					
					for (JButton button : emailpanel1.buttons)
					
					    button.setFont(font.deriveFont((float) font.getSize()));
					
					for (int j = 0; j < emailpanel1.buttons.length; j++)
					{
						//  Read the original image so the
						//  icon doesn't get distorted
						
						ImageIcon imageicon = emailpanel1.buttonicons[j];
						
						if (imageicon == null) continue;
						
						Image image = imageicon.getImage();
						
						//  Scale the icons to the frame size
						
						double m = Math.sqrt(2.0D * framearea / screenarea);
						
						int width = (int) (24 + 24 * m); // m = 0 to 1.4
						
						//  Set the max and min icon sizes
						
						if (width > maxiconsize) width = maxiconsize;
						if (width < miniconsize) width = miniconsize;
						
						//  Scale the icon size to the font size
						
						//  (the icon size can exceed the maxicon
						//  size for the font, not the frame area)
						
						double fontsize = 1.1D * font.getSize();
						
						width = (int) (width * fontsize / defaultfontsize);
						
						if (width == 0) width = 1;
						
						int height = -1, hints = Image.SCALE_SMOOTH;
						
						image = image.getScaledInstance(width, height, hints);
						
						ImageIcon scaledicon = new ImageIcon(image);
						
						emailpanel1.buttons[j].setIcon(scaledicon);
					}
					
					
					//  Scale the icon panel sizes for the retrieve mail frame
					
					if (emailpanel != null)
					
					for (int j = 0; j < emailpanel1.iconbuttons.length; j++)
					{
						//  Read the original image so the
						//  icon doesn't get distorted
						
						if (emailpanel1.imageicons[j] == null) continue;
						
						Image image = emailpanel1.imageicons[j].getImage();
						
						//  Scale the icons to the frame size and font size
						
						double q = 1.0D * framearea / screenarea;
						
						double sqrt = Math.sqrt(q);
						
						int width = (int) (24 + 24 * sqrt);
						
						//  Set the max and min icon sizes
						
						if (width > maxiconsize) width = maxiconsize;
						if (width < miniconsize) width = miniconsize;
						
						//  Scale the icon size to the font size
						
						//  (the icon size can exceed the maxicon
						//  size for the font, not the frame area)
						
						double fontsize = 1.1D * font.getSize();
						
						width = (int) (width * fontsize / defaultfontsize);
						
						if (width == 0) width = 1;
						
						int height = -1, hints = Image.SCALE_SMOOTH;
						
						image = image.getScaledInstance(width, height, hints);
						
						ImageIcon scaledicon = new ImageIcon(image);
						
						emailpanel1.iconbuttons[j].setIcon(scaledicon);
					}
				}
				
				
				if (emailpanel.savedemails != null)
				
				    emailpanel.savedemails.setFont(font);
				
				tabbedpane.setFont(font.deriveFont(
				
				    (float) font.getSize()));
				
				for (JMenuItem menuitem : menuitems)
				
				    if (menuitem != null) menuitem
				
					.setFont(menuitemfont);
				
				Documents.setFont(font);
			}
			
			
			
			private void setFrameSize()
			{
				//  sets the RetrieveMail frame size
				
				if (fontsize < minfontsize)
				    fontsize = minfontsize;
				
				int[] w_h = fontSizeToFrameSize(fontsize);
				
				int w = w_h[0], h = w_h[1];
				
				//  Set the new frame size
				
				frame.setSize(w, h);
			}
			
			
			
			//  The RetrieveMailFrame increment and decrement size methods
			
			
			private void incrementSize(float increment)
			{
				maxfontsize = (int) (maxfontsize + increment);
				
				float fontsize = frameSizeToFontSize(frame);
				
				Font newfont = font.deriveFont(fontsize);
				
				font = newfont;
				
				setFont1(newfont);
			}
			
			
			private void decrementSize(float decrement)
			{
				maxfontsize = (int) (maxfontsize - decrement);
				
				if (maxfontsize < minfontsize)
				    maxfontsize = minfontsize;
				
				float fontsize = frameSizeToFontSize(frame);
				
				Font newfont = font.deriveFont(fontsize);
				
				font = newfont;
				
				setFont1(newfont);
			}
			
			
			private String getPassphrase()
			{
				return SP;
			}
			
			
			private void setPassphrase(String passphrase)
			{
				SP = passphrase;
			}
			
			
			
			
			private class FocusListener1 implements FocusListener
			{
				public void focusGained(FocusEvent e)
				{
					
				}
				
				public void focusLost(FocusEvent e)
				{
					if (e.getSource() instanceof JTextField)
					{
						if (e.getSource() == emailpanel.emailfield)
						
						    emailpanel.emailfield.setCaretPosition(0);
					}
				}
			}
			
			
			
			private class IconListener implements ActionListener
			{
			
				private int msno; // message number
				
				//  the mouse listener sets the indexer / msno
				//  so the icon listener knows the icon number
				
				public void setNumber(int msno) { this.msno = msno; }
				
				public void actionPerformed(ActionEvent e)
				{
					if (e.getSource() instanceof JMenuItem)
					{
						String str = ((JMenuItem) e.getSource()).getText();
						
						ImageIcon[] icons = emailpanel.listpanel.imageicons2;
						
						//  Set the message state and the message icon
						
						Enum<MessageState> msgstate = MessageState.unread;
						
						if (str.equalsIgnoreCase(__.unread))    { msgstate = MessageState.unread;    icons[msno] =  unreadicon; }
						if (str.equalsIgnoreCase(__.read))      { msgstate = MessageState.read;      icons[msno] =    readicon; }
						if (str.equalsIgnoreCase(__.repliedto)) { msgstate = MessageState.replied;   icons[msno] = repliedicon; }
						if (str.equalsIgnoreCase(__.delete))    { msgstate = MessageState.delete;    icons[msno] =  deleteicon; }
						if (str.equalsIgnoreCase(__.important)) { msgstate = MessageState.important; icons[msno] =  importicon; }
						if (str.equalsIgnoreCase(__.urgent))    { msgstate = MessageState.urgent;    icons[msno] =  urgenticon; }
						if (str.equalsIgnoreCase(__.spam))      { msgstate = MessageState.spam;      icons[msno] =    spamicon; }
						if (str.equalsIgnoreCase(__.star))      { msgstate = MessageState.star;      icons[msno] =    staricon; }
						if (str.equalsIgnoreCase(__.save))      { msgstate = MessageState.save;      icons[msno] =    saveicon; }
						
						//  Set the message state in the arraylist1
						
						emailpanel.list1.setMessageState(msno, msgstate.ordinal());
						
						setFont1(font);
						
						
						//  if the icon / str == delete check the delete box
						//  else if the icon != delete uncheck the delete box
						
						boolean delete = str.equals(__.delete);
						
						//  Check or uncheck the delete box
						
						emailpanel.list1.setDeleteBox(msno, delete);
						emailpanel.listpanel.checkboxes[msno].setSelected(delete);
						
						String from = emailpanel.list1.getFrom(msno);
						  int bytes = emailpanel.list1.getNumberOfBytes(msno);
						
						
						//  if the user likes an email or the email is important and
						//  the user sets icon / str == save, then save the message as
						//  a file in the mail directory.
						
						//  Saving the email could be the same as starring the email except
						//  that it also saves the message to disk; the next time the user
						//  logs in, the program could display a star next to the message.
						
						if (str.equalsIgnoreCase(__.save))
						{
							String message = emailpanel.list1.getMessage(msno);
							
							if ((message == null) || message.isEmpty())
							{
								//  the message may have to be downloaded
								//  from the server and decrypted
								
								readMessage(emailpanel, msno);
								
								message = emailpanel.list1.getMessage(msno);
							}
							
							if ((message != null) && !message.isEmpty())
							{
								emailpanel.savedemails = new
								
								    SavedEmails(emailpanel.username);
								
								String subj = emailpanel.list1.getSubject(msno);
								
								
								try
								{	if (numberoffiles == 0)
									
									    emailpanel.savedemails.saveMessage(
									
										message, null, from, subj);
									
									else // save the message and files (file text)
									{
										String filetext = emailpanel.list1.getFileText(msno);
										
										emailpanel.savedemails.saveMessage(
										
										    message, filetext, from, subj);
									}
								}
								
								catch (IOException ex)
								{
									JOptionPane.showMessageDialog(frame, ex);
								}
							}
						}
						
						
						if (msgstate != null)
						{
							//  Set the icon to the new message state
							
							ImageIcon imageicon = imageicons2[msgstate.ordinal()];
							
							icons[msno] = imageicon;
							
							setFont1(font);
							
							
							//  Update the msgstatestreemap
							
							String key = Cipher.hash2(from + bytes);
							
							//  System.out.println("from == " + from);
							
							if (!testmail)
							
							emailpanel.msgstatestreemap.put(
							
							    key, msgstate.ordinal());
						}
						
						
						//  Send a command to the POP mail server such as STAT m n where m
						//  is the msg no and n is a digit that represents the message state
						//  if pop mail servers are upgraded to allow users to change the
						//  state of the messages.
						
						if (changemessagestate)
						
						    try { emailpanel.popmail.stat(msno, msgstate.ordinal()); }
						
						    catch (IOException ex) { System.out.println(ex); }
					}
				}
			}
			
			
			
			private class MouseMotionListener extends MouseMotionAdapter
			{
				public void mouseMoved  (MouseEvent e) {  }
				public void mouseDragged(MouseEvent e) {  }
			}
			
			
			private class MouseListener1 extends MouseAdapter
			{
			
				private JPopupMenu popupmenu;
				private JPopupMenu iconpopupmenu;
				
				private boolean clicked;
				
				private int iconnumber;
				
				
				JLabel label = new JLabel("");
				
				PopupFactory factory =
				PopupFactory.getSharedInstance();
				
				private Popup deletepopup;
				private Popup replypopup;
				private Popup prevpopup;
				private Popup nextpopup;
				private Popup testmailpopup;
				
				
				
				public MouseListener1()
				{
				
					popupmenu = new JPopupMenu();
					
					JMenuItem menuitem = new JMenuItem(__.copy);
					
					menuitem.addActionListener(new CopyListener());
					
					popupmenu.add(menuitem);
					
					popupmenu.setFont(menuitemfont);
					
					//  popupmenu.addSeparator();
					
					//  ...
					
					
					
					//  The menu for changing the message state
					
					iconpopupmenu = new JPopupMenu();
					
					menuitem = new JMenuItem(__.unread.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					menuitem = new JMenuItem(__.read.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					menuitem = new JMenuItem(__.repliedto.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					//  The delete item will check the delete box but
					//  the user can uncheck the delete box to mark
					//  the message for deletion and delete it later.
					
					menuitem = new JMenuItem(__.delete.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					//  menuitem = new JMenuItem(__.spam.toLowerCase());
					menuitem.setFont(menuitemfont);
					//  iconpopupmenu.add(menuitem);
					//  menuitem.addActionListener(iconlistener);
					
					iconpopupmenu.addSeparator();
					
					menuitem = new JMenuItem(__.important.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					menuitem = new JMenuItem(__.urgent.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					iconpopupmenu.addSeparator();
					
					menuitem = new JMenuItem(__.star.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
					
					menuitem = new JMenuItem(__.save.toLowerCase());
					menuitem.setFont(menuitemfont);
					iconpopupmenu.add(menuitem);
					menuitem.addActionListener(iconlistener);
				}
				
				
				
				private void showPopupMessage(MouseEvent e, String message)
				{
					//  Display the popup message
					
					label.setText(message);
					
					Point point = e.getLocationOnScreen();
					
					int x = (int) point.getX(), y = (int) point.getY();
					
					testmailpopup = factory.getPopup(frame, label, x + 12, y);
					
					testmailpopup.show();
				}
				
				
				
				public void mouseReleased(MouseEvent e)
				{
					if (e.getSource() instanceof JCheckBox)
					{
						int numberofmessages = emailpanel
						
						    .listpanel.getNumberOfMessages();
						
						for (int i = 0; i < numberofmessages; i++)
						
						    if (e.getSource() == emailpanel.listpanel.checkboxes[i])
						
							//  this line would have to be negated if it gets
							//  moved to the mousePressed or mouseClicked method
							
							if (emailpanel.listpanel.checkboxes[i].isSelected())
							
							     emailpanel.list1.setDeleteBox(i, true);
							else emailpanel.list1.setDeleteBox(i, false);
					}
					
					//  Hide the popup messages
					
					if (deletepopup != null) deletepopup.hide();
					if ( replypopup != null)  replypopup.hide();
					if (  prevpopup != null)   prevpopup.hide();
					if (  nextpopup != null)   nextpopup.hide();
					
					if (testmailpopup != null) testmailpopup.hide();
					
					
					//  Re-enable the highlighter
					
					emailpanel.textarea.setHighlighter(
					    new JTextArea().getHighlighter());
					
					keylistener1.setControl(false);
				}
				
				
				
				public void mousePressed(MouseEvent e)
				{
				
					if (e.getButton() != MouseEvent.BUTTON1)
					{
						if (emailpanel.messagescreen)
						
						    popupmenu.show(emailpanel
						
							.textarea, e.getX(), e.getY());
					}
					
					
					if ((e.getSource() == emailpanel.listbutton) && testmail)
					{
						//  Display a testmail popup message
						
						showPopupMessage(e, testmailpopupmsg);
						
						return;
					}
					
					
					if (e.getSource() == emailpanel.readbutton)
					{
						if ( (!emailpanel.listscreen ||
						      (emailpanel.listpanel == null) ||
						
						       emailpanel.buttonlistener.listing )
						
						   && !emailpanel.readallscreen)
						{
							//  Display a read all popup message
							
							showPopupMessage(e, readallpopupmsg);
							
							return;
						}
					}
					
					if (e.getSource() == emailpanel.delebutton)
					{
						boolean bool = false;
						
						if ((emailpanel == null) ||
						    (emailpanel.list1 == null)) return;
						
						for (int i = 0; i < emailpanel.list1.size(); i++)
						
						    if (emailpanel.list1.getDeleteBox(i))
						
							{ bool = true; break; }
						
						if (bool == false)
						{
							//  Display a delete popup message
							
							showPopupMessage(e, delebuttonpopupmsg);
						}
						
						return;
					}
					
					
					
					
					if (emailpanel.messagescreen &&
					
					    (e.getSource() == emailpanel.textarea))
					{
					
						//    delete   reply    prev    next
						
						
						if ((emailpanel.popmail == null)
						
						 || (emailpanel.list1 == null)) return;
						
						int t = emailpanel.list1.size();
						
						int cp = emailpanel.textarea.getCaretPosition();
						
						if ((emailpanel.msno >= 0) && (emailpanel.msno < t))
						{
						
							String text = emailpanel.textarea.getText();
							
							int deletepos = text.indexOf(__.delete);
							int  replypos = text.indexOf(__.reply);
							int   prevpos = text.indexOf(__.prev);
							int   nextpos = text.indexOf(__.next);
							int    endpos = text.indexOf(__.next) + __.next.length();
							
							int   frompos = text.indexOf(__.From);
							int   subjpos = text.indexOf(__.Subject);
							
							if (cp < endpos) emailpanel.textarea.setHighlighter(null);
							
							int numberoffiles = emailpanel.list1
							
							    .getNumberOfFiles(emailpanel.msno);
							
							int[] viewpos = new int[numberoffiles];
							int[] savepos = new int[numberoffiles];
							
							if (numberoffiles > 0)
							{
								//  Find and set the caret positions of
								//  __.viewattachedfile = "[ view ]",
								//  __.saveattachedfile = "[ save ]",
								
								viewpos[0] = text.indexOf(__.viewattachedfile);
								savepos[0] = text.indexOf(__.saveattachedfile);
								
								for (int i = 1; i < numberoffiles; i++)
								{
									viewpos[i] = text.indexOf(__.viewattachedfile, viewpos[i-1] + 1);
									savepos[i] = text.indexOf(__.saveattachedfile, savepos[i-1] + 1);
								}
							}
							
							
							int deletewidth = __.delete.length();
							int  replywidth = __. reply.length();
							int   prevwidth = __.  prev.length();
							int   nextwidth = __.  next.length();
							
							int viewwidth = __.viewattachedfile.length();
							int savewidth = __.saveattachedfile.length();
							
							int fromend = text.indexOf("\n", text.indexOf(__.From) + 1);
							int subjend = text.indexOf("\n", text.indexOf(__.Subject) + 1);
							
							int fromwidth = fromend - frompos;
							int subjwidth = subjend - subjpos;
							
							
							if ( (cp >= deletepos) && (cp < deletepos + deletewidth) )
							{
							
								//  Check the delete box
								
								//  The delete check box is not visible from the message screen
								//  (only the word delete is visible), but the word functions as
								//  a button that sets the checkbox and moves the textarea to
								//  the next message
								
								
								//  Display a popup message if the delete box is checked
								
								if ( emailpanel.list1.getDeleteBox(emailpanel.msno)
								 && !emailpanel.list1.isDeleted   (emailpanel.msno))
								{
									int msno = emailpanel.msno;
									
									if (!emailpanel.popmail.ascending)
									
									    msno = emailpanel.popmail
									
										.getNumberOfMessages() -1 -msno;
									
									String message = (msno + 1) + " " + deletepopupmsg;
									
									showPopupMessage(e, message);
									
									return;
								}
								
								
								
								if (emailpanel.msno < emailpanel.popmail.getNumberOfMessages())
								
								    emailpanel.list1.setDeleteBox(emailpanel.msno, true);
								
								
								//  Retrieve and display the next message
								//
								//  after the delete box is checked
								
								
								//  Skip messages that were deleted from the server
								
								int msno = emailpanel.msno + 1;
								
								while ((msno < t) && emailpanel.list1.isDeleted(msno)) msno++;
								
								if (msno == t)
								{
									//  Display a popup message if there is no next
									
									showPopupMessage(e, nextpopupmsg);
									
									return;
								}
								
								else emailpanel.msno = msno;
								
								readAndDisplayMessage(emailpanel.msno);
							}
							
							
							
							else if ( (cp >= replypos) && (cp < replypos + replywidth) )
							{
								//  Display a popup message if the delete box is checked
								
								if ( emailpanel.list1.getDeleteBox(emailpanel.msno)
								 && !emailpanel.list1.isDeleted   (emailpanel.msno))
								{
									int msno = emailpanel.msno;
									
									if (!emailpanel.popmail.ascending)
									
									    msno = emailpanel.popmail
									
										.getNumberOfMessages() -1 -msno;
									
									String message = (msno + 1) + " " + deletepopupmsg;
									
									showPopupMessage(e, message);
									
									return;
								}
								
								//  Reply to message
								
								reply(emailpanel.msno);
							}
							
							
							
							else if ( (cp >= prevpos) && (cp < prevpos + prevwidth) )
							{
							
								//  Retrieve the previous message
								
								//  Skip messages that were deleted from the server
								
								int msno = emailpanel.msno - 1;
								
								while ((msno >= 0) && emailpanel.list1.isDeleted(msno)) msno--;
								
								if (msno < 0)
								{
									//  Display a popup message if there is no prev
									
									showPopupMessage(e, prevpopupmsg);
									
									return;
								}
								
								else emailpanel.msno = msno;
								
								readAndDisplayMessage(emailpanel.msno);
							}
							
							
							
							else if ( (cp >= nextpos) && (cp < nextpos + nextwidth) )
							{
							
								//  Retrieve the next message
								
								//  Skip messages that were deleted from the server
								
								int msno = emailpanel.msno + 1;
								
								while ((msno < t) && emailpanel.list1.isDeleted(msno)) msno++;
								
								if (msno == t)
								{
									//  Display a popup message if there is no next
									
									showPopupMessage(e, nextpopupmsg);
									
									return;
								}
								
								else emailpanel.msno = msno;
								
								readAndDisplayMessage(emailpanel.msno);
							}
							
							
							
							else if ( ( (cp >= frompos) && (cp < frompos + fromwidth) )
							       || ( (cp >= subjpos) && (cp < subjpos + subjwidth) ) )
							{
							
								//  Display the message header
								
							//	String header = emailpanel.list1.getHeader(emailpanel.msno);
							//	
							//	Documents .display(frame, __.headerinfo, header,
							//	
							//	    font, emailpanel.foreground, emailpanel.background);
							}
							
							
							
							else if (numberoffiles > 0)
							{
								for (int i = 0; i < numberoffiles; i++)
								{
									if ( (cp >= viewpos[i]) && (cp < viewpos[i] + viewwidth) )
									{
										//  View the attached file(s)
										
										viewAttachedFile(emailpanel.msno, i);
									}
									
									else if ( (cp >= savepos[i]) && (cp < savepos[i] + savewidth -1) )
									{
										//  Save the attached file(s)
										
										saveAttachedFile(emailpanel.msno, i);
								        }
								}
							}
							
							return;
						}
					}
					
					
					
					else if (emailpanel.readallscreen && (e.getSource() == emailpanel.textarea))
					{
					
						//  Read all screen    [ ]   reply
						
						
						//  delete box [x], reply,
						//
						//  [ view ] or [ save ] attached file
						
						
						//  Find the message number
						
						if ((emailpanel == null) ||
						
						    (emailpanel.list1 == null)) return;
						
						int index, t = emailpanel.list1.size();
						
						int cp = emailpanel.textarea.getCaretPosition();
						
						for (index = 0; index < t; index++)
						{
							int sp = emailpanel.list1
							
							    .getMessageStartPos(index);
							
							if (cp <= sp) break;
						}
						
						
						//  If there are deleted messages in the list
						//  skip the deleted messages
						
						if (index != 0)
						{
							int index1 = index - 1;
							
							while ((index1 >= 0) && emailpanel
							
							    .list1.isDeleted(index1)) index1--;
							
							if (index1 >= 0) index = index1;
							
							else return;
						}
						
						emailpanel.msno = index;
						
						
						//  message start position
						//  |
						//  v
						//      [ x ]        reply
						
						
						int startpos = emailpanel.list1 .getMessageStartPos(index);
						
						int checkpos = startpos + readallheader0 .indexOf("[") + 2;
						int replypos = startpos + readallheader0 .indexOf(__.reply) + __.reply.length() / 2;
						
						int   endpos = replypos + __.reply.length();
						
						int checkwidth = ( readallheader0 .indexOf("]")
							       -   readallheader0 .indexOf("[") ) + 2;
						
						int replywidth = __.reply.length() + 3;
						
						
						String text = emailpanel.textarea.getText();
						
						int viewwidth = __.viewattachedfile.length() + 3;
						int savewidth = __.saveattachedfile.length() + 3;
						
						if (cp < endpos) emailpanel.textarea.setHighlighter(null);
						
						
						int numberoffiles = emailpanel.list1
						
						    .getNumberOfFiles(emailpanel.msno);
						
						int[] viewpos = new int[numberoffiles];
						int[] savepos = new int[numberoffiles];
						
						if (numberoffiles > 0)
						{
							viewpos[0] = startpos + text.substring(startpos).indexOf(__.viewattachedfile);
							savepos[0] = startpos + text.substring(startpos).indexOf(__.saveattachedfile);
							
							for (int i = 1; i < numberoffiles; i++)
							{
								viewpos[i] = text.indexOf(__.viewattachedfile, viewpos[i-1] + 1);
								savepos[i] = text.indexOf(__.saveattachedfile, savepos[i-1] + 1);
							}
						}
						
						
						if ((index < t)
						
						   && (cp - checkpos <  checkwidth/2)
						   && (cp - checkpos > -checkwidth/2) )
						{
							//  Check / uncheck delete box [ x ]
							
							checkDelete(emailpanel.textarea.getText(), index);
							
							//  Don't do a click for a check box because
							//  it deletes the message text and redisplays
							//  the screen which can resize the components
							//  emailpanel.readbutton.doClick();
						}
						
						
						else if ( (cp - replypos <  replywidth/2)
						       && (cp - replypos > -replywidth/2) )
						{
							reply(emailpanel.msno);
						}
						
						
						else if (numberoffiles > 0)
						{
							for (int i = 0; i < numberoffiles; i++)
							{
								if ( (cp >= viewpos[i]) && (cp < viewpos[i] + viewwidth) )
								{
									//  View the attached file(s)
									
									viewAttachedFile(emailpanel.msno, i);
								}
								
								else if ( (cp >= savepos[i])
								       && (cp < savepos[i] + savewidth) )
								{
									//  Save the attached file(s)
									
									saveAttachedFile(emailpanel.msno, i);
								}
							}
						}
						
						//  Reset the message number to -1
						
						emailpanel.msno = -1;
					}
				}
				
				
				
				
				public void mouseClicked(MouseEvent e)
				{
				
					//  Find the email message number and display the message
					
					
					if ((emailpanel.list1 == null)
					 || (emailpanel.list1.size() == 0)) return;
					
					if (emailpanel.buttonlistener.listing
					 || emailpanel.buttonlistener.reading
					 || emailpanel.buttonlistener.deleting
					 || emailpanel.buttonlistener.quitting) return;
					
					if (emailpanel.listscreen && (emailpanel.listpanel == null)) return;
					
					
					int numberofmessages = emailpanel.listpanel.getNumberOfMessages();
					
					if (e.getSource() instanceof JLabel)
					{
						for (int i = 0; i < numberofmessages; i++)
						{
							if ((emailpanel.listpanel.iconlabels2[i] == e.getSource())
							 && (emailpanel.listpanel.imageicons2[i] != senticon))
							{
								//  Set the message number of the icon to be changed
								//  and then show a popup menu to change the icon
								
								iconlistener.setNumber(i);
								
								iconpopupmenu.show(emailpanel.listpanel
								
								    .iconlabels2[i], e.getX(), e.getY());
								
								break;
							}
						}
					}
					
					
					
					try
					{
					
					//  Disable the button until the
					//  finally block is executed
					
					if (clicked) return;
					
					else clicked = true;
					
					
					if (emailpanel.listscreen)
					{
					
						//  Find the message number
						
						int index;
						
						if ((emailpanel.popmail == null)
						
						 || (emailpanel.list1 == null)
						 || (emailpanel.list1.size() == 0)) return;
						
						
						for (index = 0; index < numberofmessages; index++)
						{
							if ((e.getSource() == emailpanel.listpanel.msnolabels[index])
							 || (e.getSource() == emailpanel.listpanel.sizelabels[index])
							 || (e.getSource() == emailpanel.listpanel.cipherlabels[index])
							 || (e.getSource() == emailpanel.listpanel.fromlabels[index])
							 || (e.getSource() == emailpanel.listpanel.subjlabels[index])
							 || (e.getSource() == emailpanel.listpanel.textlabels[index]))
							{
								emailpanel.msno = index;
								
								break;
							}
						}
						
						
						if (index < numberofmessages)
						{
							if (e.getSource() instanceof JLabel)
							{
								readAndDisplayMessage(emailpanel.msno);
								
								emailpanel.listpanel.removeHighlight();
							}
						}
					}
					
					}
					
					catch (Exception ex)
					{
						ex.printStackTrace();
					}
					
					finally { clicked = false; }
				}
			}
			
			
			//  End class MouseListener1
			
			
			
			
			
			
			
			//  This is the RetrieveMailFrame KeyListener
			
			
			private class KeyListener1 extends KeyAdapter
			{
			
				private boolean shift, control;
				
				public void setControl(boolean bool) { control = bool; }
				
				public void keyTyped(KeyEvent e)
				{
					int keychar = e.getKeyChar();
					int keycode = e.getKeyCode();
				}
				
				
				public void keyPressed(KeyEvent e)
				{
				
					//  The backspace key returns the user to the list screen
					//  from the message screen.
					
					int keychar = e.getKeyChar();
					int keycode = e.getKeyCode();
					
					if (keycode == vk_shift) shift = true;
					
					else if (keycode == vk_control) control = true;
					
					//  If the backspace key is pressed in the message screen
					//  and the emailfield has the focus, the key event is consumed
					//  so the bell doesn't ring. (Consuming the key event has no
					//  effect on the email field because if the list pane != null
					//  then the email field is disabled so that the user cannot
					//  change the email address without first signing out.)
					
					//  Consume the backspace key if necessary
					
					if (emailpanel.emailfield.hasFocus())
					{
						int cp = emailpanel.emailfield.getCaretPosition();
						
						if ((cp == 0) && (keycode == vk_backspace)) e.consume();
					}
					
					else if ((emailpanel != null) && (emailpanel.listpanel != null))
					{
						if (keycode == vk_backspace) { e.consume(); }
						if (keycode == vk_left) { e.consume(); }
					}
					
					//  Use the backspace key to return from
					//  the message screen to the list screen
					
					if ((emailpanel != null) && emailpanel.messagescreen)
					{
						//  backspace key == return to list screen
						
						if ((keycode == vk_backspace)
						
						    && !emailpanel.emailfield.hasFocus())
						{
							emailpanel.listbutton.doClick(10);
							
							emailpanel   .listscreen = true;
							emailpanel.messagescreen = false;
							emailpanel.readallscreen = false;
							
							//  Transfer the focus to the list button so
							//  that the user can select the messages by
							//  using the up and down arrow keys
							
							emailpanel.listbutton.requestFocusInWindow();
							
							
							//  emailpanel.textarea.setLineWrap(false);
							//  emailpanel.textarea.setWrapStyleWord(false);
						}
						
						
						//  View or save attached file 1, 2, 3, 4, ...
						//  using the number keys or keypad
						
						if (e.getSource() instanceof JTextArea)
						
						if (Character.isDigit(keychar))
						{
							int number = Integer.valueOf(keychar)
							           - Integer.valueOf('0');
							
							final int msno = emailpanel.msno;
							
							int numberoffiles = emailpanel.list1
							
							    .getNumberOfFiles(msno);
							
							if ((number > 0) && (number <= numberoffiles))
							{
								if (!control) viewAttachedFile(msno, number-1);
								else          saveAttachedFile(msno, number-1);
							}
							
							if ((number == 0) && (numberoffiles == 10))
							{
								if (!control) viewAttachedFile(msno, 10);
								else          saveAttachedFile(msno, 10);
							}
							
							control = false;
						}
					}
					
					
					//  Use the up and down arrows to highlight the
					//  messages and the enter key to read the message
					
					if (e.getSource() == emailpanel.listbutton)
					
					if ((emailpanel != null) && emailpanel.listscreen)
					{
						if (emailpanel.listpanel != null)
						{
							if (keycode == vk_down)
							
							    emailpanel.listpanel.increment();
							
							if (keycode == vk_up)
							
							    emailpanel.listpanel.decrement();
							
							if (keycode == vk_enter)
							{
								//  Read the message number
								
								int msno = emailpanel.listpanel.msno;
								
								emailpanel.msno = msno;
								
								if ((msno >= 0) && (msno < emailpanel
								
								     .listpanel.getNumberOfMessages())
								
								    && emailpanel.listpanel.isVisible(msno))
								{
									//  Read and decrypt the message
									
									readAndDisplayMessage(msno);
								}
							}
						}
					}
					
					
					
					//  the mnemonic key codes for the list,
					//  read, delete, and sign out buttons
					
					if (control && (keycode == __.mail_listkeycode))
					{
						emailpanel.listbutton.doClick();
						
						emailpanel.listbutton.requestFocusInWindow();
						
						//  The focus has to be moved to the list button
						//  or else the tabbedpane generates two key events
						//  and then the up and down arrow keys move the mes-
						//  sage number by two increments instead of one.
					}
					
					else if (control && (keycode == __.mail_readallkeycode))
					{
						// emailpanel.readbutton.doClick();
					}
					
					else if (control && (keycode == __.mail_deletekeycode))
					{
						emailpanel.delebutton.doClick();
					}
					
					else if (control && (keycode == __.mail_signoutkeycode))
					{
						emailpanel.quitbutton.doClick();
					}
					
					
					
					//  the key codes for reply, dele, prev, next
					
					else if (emailpanel.messagescreen && control
					
					    && (keycode == __.mail_replykeycode))
					{
						reply(emailpanel.msno);
					}
					
					else if (emailpanel.messagescreen && control
					
					    && (keycode == __.mail_deletekeycode))
					{
						////  delete(emailpanel.msno);
					}
					
					
					else if (emailpanel.messagescreen && control
					
					    && (keycode == __.mail_nextkeycode))
					{
						//  Retrieve the next message
						
						//  Skip messages that were deleted from the server
						
						int msno = emailpanel.msno + 1;
						
						int t = emailpanel.list1.size();
						
						while ((msno < t) && emailpanel.list1.isDeleted(msno)) msno++;
						
						if (msno == t)
						{
							//  Display a popup message if there is no next
							
							/// showPopupMessage(e, nextpopupmsg);
							
							return;
						}
						
						else emailpanel.msno = msno;
						
						readAndDisplayMessage(emailpanel.msno);
					}
					
					
					else if (emailpanel.messagescreen && control
					
					    && (keycode == __.mail_prevkeycode))
					{
						int msno = emailpanel.msno - 1;
						
						//  Skip messages that were deleted from the server
						
						while ((msno >= 0) && emailpanel.list1.isDeleted(msno)) msno--;
						
						if (msno < 0)
						{
							//  Display a popup message if there is no prev
							
							/// showPopupMessage(e, prevpopupmsg);
							
							return;
						}
						
						else emailpanel.msno = msno;
						
						readAndDisplayMessage(emailpanel.msno);
					}
					
					
					else if (control && (keycode == __.exitkeycode))
					{
						exitlistener.run();
						
						control = false;
					}
					
					else if (control && (keychar == __.pluskeychar))
					{
						if (maxfontsize < 50)
						
						    incrementSize(1);
						
					///	setFrameSize();
					}
					
					else if (control && (keychar == __.minuskeychar))
					{
						decrementSize(1);
						
					///	setFrameSize();
					}
					
					else if (control && (keycode == __.checkallkeycode))
					{
						checkalllistener.run();
						
						control = false;
					}
				}
				
				
				
				
				public void keyReleased(KeyEvent e)
				{
				
					int keycode = e.getKeyCode();
					
					if (keycode == vk_shift)     shift = false;
					if (keycode == vk_control) control = false;
					
					if ((emailpanel != null) && (e.getSource() == emailpanel.emailfield))
					{
						int maxlen = 28;
						
						String emailstr = emailpanel.emailfield.getText().trim();
						
						if (emailstr.contains("@"))
						
						    emailstr = emailstr .substring(
						
							0, emailstr.indexOf("@"));
						
						if (emailstr.length() > maxlen)
						
						    emailstr = emailstr.substring(0, maxlen) + "..";
						
						int index = tabbedpane.getSelectedIndex();
						
						tabbedpane.setTitleAt(index, emailstr);
						
						emailpanel.tabtitle = emailstr;
					}
					
					//  The passphrase code has to be in the keyReleased method
					//  because the keyPressed method would keep re-opening the
					//  dialog box every time the user presses escape or clicks
					//  on the [x] icon instead of clicking the OK button.
					
					if (control && (keycode == __.passphrasekeycode))
					{
						control = false;
						
						passphraselistener.run();
					}
				}
			}
			
			
			//  End class KeyListener1
			
			
			
			
			
			
			private class MouseWheelListener1 implements MouseWheelListener
			{
				//  This is the RetrieveMailFrame MouseWheelListener
				
				private boolean resized;
				
				private int freq = 16; // only 16 events per sec
				
				public void mouseWheelMoved(MouseWheelEvent e)
				{
					if (resized) return;
					
					else resized = true;
					
					new Thread(() ->
					{
						try { Thread.sleep(1000 / freq); }
						
						catch (InterruptedException ex) {  };
						
						resized = false;
					
					}).start();
					
					int rotation = e.getWheelRotation();
					
					//  ...
					
					if (keylistener1.control)
					{
						if (rotation > 0) incrementSize(1.00f);
						if (rotation < 0) decrementSize(1.00f);
					}
				}
			}
			
			
			
			
			private void viewAttachedFile(int msno, int fileno)
			{
				//  Displays an image, text, or html document
				
				String filedesc = emailpanel.list1.getFileDesc(msno, fileno);
				byte[] filedata = emailpanel.list1.getFileData(msno, fileno);
				
				viewAttachedFile(filedesc, filedata);
			}
			
			
			private void saveAttachedFile(int msno, int fileno)
			{
				//  Saves an image, text, or html document
				
				String filedesc = emailpanel.list1.getFileDesc(msno, fileno);
				byte[] filedata = emailpanel.list1.getFileData(msno, fileno);
				
				saveAttachedFile(filedesc, filedata);
			}
			
			
			
			
			private void viewAttachedFile(String filedesc, byte[] filedata)
			{
			
				//  Displays an image, text, table, or html document
				
				int maxdesclength = 64;
				
				if (filedesc.length() > maxdesclength)
				
				    filedesc = filedesc .substring(0, maxdesclength);
				
				
				//  Determine if the data is a text / html document
				//  or an image file (document / file type detection)
				
				
				final String filetext;
				
				filetext = new String(filedata);
				
				boolean text, table, html;
				
				
				//  Test if the file data is text, table, or html
				
				text = FileType.isText(filetext);
				
				//  Test if the data is a table
				
				table = FileType.isTable(filetext);
				
				//  Test if the file data is HTML
				
				html = FileType.isHTML(filetext);
				
				
				//  If the file data is a table, set text = false
				//  so the method displays the text as a table
				//  because table data is also text data.
				
				//  If the file data is html, set text = false
				//  so the method displays the text as html
				//  because html data is also text data.
				
				if (table) { text = false; html = false; }
				
				if (html) { text = false; table = false; }
				
				
				
				//  If the document is text open a text area
				//  If the document is html open an editor pane
				//  If the document is csv open a table editor
				
				
				if (text) // Display the text document
				{
					Window window = null; // frame
					
					if (!emailpanel.reverse_colors)
					
					    Documents .display(window, filedesc, filetext,
					
						font, emailpanel.foreground, emailpanel.background);
					
					else // if (reverse_colors)
					
					    Documents .display(window, filedesc, filetext,
					
						font, emailpanel.background, emailpanel.foreground);
				}
				
				else if (table)
				{
					//  Open a table editor to display the table
					
					TableFrame tableframe = new TableFrame();
					
					tableframe.setData(filetext);
					
					tableframe.packTable();
					
					int index = tableframe.tabbedpane.getSelectedIndex();
					
					tableframe.tabbedpane.setTitleAt(index, filedesc);
					
					tableframe.setFont1(font);
					
					if (!emailpanel.reverse_colors)
					{
						tableframe.setForeground1(emailpanel.foreground);
						tableframe.setBackground1(emailpanel.background);
					}
					
					else // if (emailpanel.reverse_colors)
					{
						tableframe.setForeground1(emailpanel.background);
						tableframe.setBackground1(emailpanel.foreground);
					}
				}
				
				else if (html) // Display the html document
				{
					Window window = null; // frame;
					
					Documents.displayHTML(window, filedesc, filetext,
					
					    font, emailpanel.foreground, emailpanel.background);
				}
				
				else // if (image)
				{
					//  Display the image
					
					//  Set the window to null so the attached files do
					//  not obstruct the user's view of the email messages
					
					Window window = null; // frame;
					
					Icons.display(null, filedesc, filedata);
				}
			}
			
			
			
			
			private void saveAttachedFile(String filedesc, byte[] filedata)
			{
			
				//  Saves an image, text, table, or html document
				
				String title = filedesc;
				
				//  Prompt the user to choose a file name
				
				File file = new SaveFile(frame, __.save + " "
				
				    + filedesc) .setFont(font) .chooseFile();
				
				if (file == null) return;
				
				directory = file.getParent();
				
				int result = new SaveFile(frame, __.save)
				
				    .setFont(font) .save(filedata, file, true);
				
				if ((result == JOptionPane.NO_OPTION)
				 || (result == JOptionPane.CANCEL_OPTION)
				 || (result == JOptionPane.CLOSED_OPTION))
				
				    return;
				
				
				//  Ask if the user wants to encrypt the file
				
				if (!Cipher.isEncrypted(file))
				{
					String question = __.encryptfile + "?";
					
					Object[] options = new Object[] { __.Yes, __.No };
					
					int choice = JOptionPane.showOptionDialog(
					
					    frame, question, null,
					
						JOptionPane.DEFAULT_OPTION,
						JOptionPane.QUESTION_MESSAGE,
						
						    null, options, options[0]);
					
					//  If yes encrypt the file
					
					if (choice == 0)
					{
						//  Display a dialog to encrypt and
						//  save the attached file to disk
						
						FileEncryptor fe;
						
						fe = new FileEncryptor(frame);
						fe.setFont(emailpanel.textarea.getFont());
						
						if (filekey != null) fe.setFileKey(filekey);
						
						else if ((SP != null) && !SP.isEmpty())
						
						    fe.setFileKey(Cipher.passphraseToKey(SP));
						
						boolean bool = fe.encrypt(file, true);
						
						//  Update the file key
						
						filekey = fe.getFileKey();
					}
				}
			}
			
			
			
			
			//  The splitBase64Encoding methods are used by the
			//  readMessage() method and by the subject thread to
			//  unpack the message, reply key, and attached files
			
			
			private String[] splitBase64Encoding(String str)
			{
				//  This method iteratively / recursively removes
				//  multiple levels of base-64 encoding; multiple
				//  encoding is not used because the code would look
				//  non-random. Base-64 is only used for perfectly
				//  random data such as cipherdata.
				
				
				//  Example of a multiply-encoded base-64 string
				//
				//        base64  \n\n  base64  \n\n  base64 ...
				//        /    \          |           /    \
				//  base64 \n\n base64,  str,   base64 \n\n base64
				//     |        /   \     |       |           |
				//    str     str   str  str     str         str
				
				
				ArrayList<String> list = new ArrayList<String>(); list.add(str);
				
				for (int i = 0; i < list.size();  )
				{
					String str1 = list.remove(i);
					
					while (Number.isBase64(str1) && !Number.isBase16(str1))
					
					    str1 = Convert.base64ToString(str1);
					
					String[] tokens = splitBase64Encoding1(str1);
					
					if (tokens.length == 1)
					
					    { list.add(i, tokens[0]); i++; continue; }
					
					for (int j = 0; j < tokens.length; j++)
					
					    list.add(i + j, tokens[j]);
				}
				
				for (String str1 : list)
				
				    if (Number.isBase64(str1.trim()) &&
				       !Number.isBase16(str1.trim()))
				
					throw new ArithmeticException();
				
				String[] tokens = new String[list.size()];
				
				return list.toArray(tokens);
			}
			
			
			
			private String[] splitBase64Encoding1(String str)
			{
				//  This method removes one level of base-64 encoding
				
				//  It skips base-16 tokens such as a reply key.
				//
				//  A base-64 token cannot randomly be a base-16 token if the
				//  length is greater than 80 chars because (16/10) ^ 80 ~ 20
				//  x 10^15 == 1 in 20 quadrillion. (Even 64 bits is impossible
				//  to be base-16 because 1.6 ^ 64 ~ 1 in 10 trillion.)
				
				String str1 = str.trim().replaceAll("\n", "").replaceAll("=", "");
				
				if ((str1.length() % 4) != 0) str1 = str1
				
				    .substring(0, str1.length() - (str1.length() % 4));
				
				if (!Number.isBase64(str1)) return new String[] { str };
				
				String[] tokens = str.split("\n{2,}");
				
				for (int i = 0; i < tokens.length; i++)
				{
					String token = tokens[i];
					
					if (!Number.isBase64(token.trim())) continue;
					
					if ((token.length() >= 80) && Number
					
					    .isBase16(token.trim())) continue;
					
					//  Remove the base-64 encoding
					
					while (Number.isBase64(token.trim())
					
					    && !Number.isBase16(token.trim()))
					
						token = Convert.base64ToString(token.trim());
					
					tokens[i] = token;
				}
				
				for (String token : tokens)
				{
					if ( Number.isBase64(token.trim()))
					if (!Number.isBase16(token.trim()))
					
					    throw new ArithmeticException();
				}
				
				return tokens;
			}
			
			
			
			
			
			private void readMessage(EmailPanel emailpanel, int msno)
			{
			
				//  This method retrieves the email from the server,
				//  decrypts and decodes the email, then stores the from,
				//  subject, message, attached files and file descriptions,
				//  the number of ciphers used to encrypt the message, and
				//  the sender's public reply key in the ArrayList1 list1.
				
				
				//  If the user retrieves a message, set the cursor to wait
				//  so the user knows that the message is being decrypted.
				//
				//  (If the user clicks the read all button, then it would be
				//  redundant to set the wait cursor for each message. Instead
				//  of rotating smoothly the wait cursor would become jittery
				//  because it would keep getting reset by the read method.)
				
				if (!emailpanel.buttonlistener.reading)
				{
					emailpanel.readbutton .setCursor(wait_cursor);
					emailpanel.textarea   .setCursor(wait_cursor);
					
					if (emailpanel.listpanel != null)
					    emailpanel.listpanel.setCursor(wait_cursor);
				}
				
				try // no indent for the
				{  // try finally block
				
				String[] header_message;
				
				try
				{	header_message = emailpanel.popmail .retrieve(
					
					    emailpanel.list1.getServerMessageNumber(msno));
				}
				
				catch (IOException ex)
				{
					//  Try to reconnect to the server
					
					try { emailpanel.popmail.connect(); }
					
					catch (IOException ex1) { return; }
					
					readMessage(emailpanel, msno);
					
					return;
				}
				
				String header  = header_message[0];
				String message = header_message[1];
				
				
				//  Parse the from and subject fields from the header
				
				EmailHeader emailheader = new EmailHeader(header);
				
				String date    = emailheader.date;
				String from    = emailheader.from;
				String subject = emailheader.subject;
				
				if (date == null) date = "";
				if (from == null) from = "";
				if (subject == null) subject = "";
				
				
				//  Save the date, from, subject, and message in the list1
				
				emailpanel.list1.setDate   (msno, date);
				emailpanel.list1.setFrom   (msno, from);
				emailpanel.list1.setSubject(msno, subject);
				
				emailpanel.list1.setHeader (msno, header);
				emailpanel.list1.setMessage(msno, message);
				
				
				
				//  The format used to encode, encrypt, and partition email mes-
				//  sages. Encoding is used to hide newline chars that are used as
				//  delimiters and to convert the random data from the encryption
				//  method to text characters. Each base-64 encoding expands the
				//  email size by 1/3. Two encodings will double the size of the
				//  email because (4/3) ^ 2 == 16 / 9 ~ 2.
				
				
				//  partition | encode or replace \n\n | encrypt | >>
				//
				//       | base-16 reply key (optional)
				//
				//       | base-64 encoded message text
				//
				//       | base-64 encoded file desc1
				//
				//       | base-64 encoded file data1
				//
				//       | base-64 encoded file desc2
				//
				//       | base-64 encoded file data2
				
				
				
				String message1 = message.trim();
				
				//  Remove any partitioning
				
				if (message1.contains("\n") && !message1.contains("\n\n"))
				
				    message1 = message1 .replaceAll("\n{1}", "") .trim();
				
				
				//  If the message uses the base-16 separator 0123456789abcdef
				//  replace the base-16 separator with the \n\n separator
				
				if (message1.contains(Convert.base16Separator))
				
				    if (PublicKey.isEncrypted(message1.replaceAll(
				
					Convert.base16Separator, "\n\n")))
				
					    message1 = message1 .replaceAll(
					
						Convert.base16Separator, "\n\n");
				
				
				//  Remove any base-64 encoding
				
				if (Number.isBase64(message1)) message1
				
				    = Convert.base64ToString(message1);
				
				
				//  Test if the message is encrypted
				//  and set the encryption variable
				
				boolean encrypted = PublicKey.isEncrypted(message1);
				
				if (encrypted) message = message1;
				
				if (!encrypted && message.contains("\n") && !message.contains("\n\n"))
				
				    message = message .replaceAll("\n{1}", "") .trim();
				
				
				//  If the message is encrypted decrypt the message block
				
				String decryptedtext = message;
				
				if (PublicKey.isEncrypted(message))
				{
					decryptedtext = decryptMessage(emailpanel, message, msno);
					
					if ((decryptedtext != null) && !decryptedtext.isEmpty())
					
					    while (Number.isBase64(decryptedtext.trim()))
					
						decryptedtext = Convert.base64ToString(
						
						    decryptedtext.trim());
					
					int numberofciphers = PublicKey.countNumberOfCiphers(message);
					
					//  System.out.println("number of ciphers == " + numberofciphers);
					
					emailpanel.list1.setNumberOfCiphers(msno, numberofciphers);
					
					//  If the message did not decrypt properly return
					
					if ((decryptedtext == null) || decryptedtext.isEmpty())
					{
						//  Decryption error: Wrong encryption key,
						//  wrong decryption key, or defective ciphertext
						
						System.out.println("Error decrypting message " + msno);
						
						//  System.out.println("message == " + message);
						
						return;
					}
				}
				
				
				else // if (!Cipher.isEncrypted(message))
				{
					//  System.out.println("Message was sent unencrypted");
				}
				
				
				decryptedtext = decryptedtext.trim();
				
				
				//  Remove any base-64 encoding from the decrypted text
				
				while (Number.isBase64(decryptedtext.trim()))
				
				    decryptedtext = Convert.base64ToString(
				
					decryptedtext.trim());
				
				
				//  Split the decrypted text into tokens delimited by \n\n
				
				//  String[] tokens = decryptedtext.split("\n{2,}");
				
				String[] tokens;
				
				if (encrypted) tokens = splitBase64Encoding(decryptedtext);
				else           tokens = decryptedtext.split("\n\n");
				
				
				//  Remove the prepended reply key if there is one
				
				String sendersreplykey = null;
				
				if ((tokens.length > 1) && PublicKey.isValidKey(tokens[0]))
				{
					sendersreplykey = tokens[0];
					
					String[] tokens1 = new String[tokens.length -1];
					
					for (int i = 1; i < tokens.length; i++)
					
					    tokens1[i-1] = tokens[i];
					
					tokens = tokens1;
				}
				
				
				//  Read the message
				
				if (encrypted) message = tokens[0];
				
				else message = decryptedtext;
				
				
				
				//  Read the attached file(s)
				
				//  file title / desc and file text
				
				ArrayList<String> filedesclist = new ArrayList<String>();
				ArrayList<String> filetextlist = new ArrayList<String>();
				
				for (int i = 1; i < tokens.length; i++)
				{
					// the max title / desc length
					
					final int maxlen = 128;
					
					String filedesc, filetext;
					
					if (encrypted)
					{
						if ((tokens[i].length() <= maxlen)
						
						  && ((i+1) < tokens.length))
						{
							// token[i+0] is the filedesc;
							// token[i+1] is the filetext
							
							filedesc = tokens[i];
							filetext = tokens[i+++1];
						}
						
						else if ((tokens[i].length() > maxlen))
						{
							// no file desc or title
							// token[i] is the filetext
							
							filedesc = "";
							filetext = tokens[i];
						}
						
						else continue;
					}
					
					else // if (!encrypted)
					{
						//  unencrypted files may be partitioned
						
						if ((tokens[i].length() <= maxlen)
						
						  && ((i+1) < tokens.length)
						
						  && Number.isBase64(tokens[i+1].replaceAll("\n", "")))
						{
							// token[i+0] is the filedesc;
							// token[i+1] is the filetext
							
							filedesc = tokens[i];
							filetext = tokens[i+1];
							
							tokens[i]   = "";
							tokens[i+1] = "";
							
							i += 1;
						}
						
						else if ((tokens[i].length() > maxlen)
						
						  && Number.isBase64(tokens[i].replaceAll("\n", "")))
						{
							// no file desc or title
							// token[i] is the filetext
							
							filedesc = "";
							filetext = tokens[i];
						}
						
						else continue;
					}
					
					
					//  Remove the partitions / new lines from unencrypted files
					
					if (!encrypted && filetext.contains("\n"))
					
					    filetext = filetext .replaceAll("\n", "");
					
					//  This line is redundant because the file
					//  text should already be encoded in base 64
					
					if (!Number.isBase64(filetext))
					
					    filetext = Convert.stringToBase64(filetext);
					
					//  Add the file desc and file text to the lists
					
					filedesclist.add(filedesc);
					filetextlist.add(filetext);
				}
				
				int numberoffiles = filetextlist.size();
				
				ArrayList<byte[]> filedatalist = new ArrayList<byte[]>();
				
				for (int i = 0; i < numberoffiles; i++)
				
				    filedatalist.add(new byte[0]);
				
				
				//  Read and decompress the file attachment(s)
				
				for (int i = 0; i < numberoffiles; i++)
				{
					String filetext = filetextlist.get(i).trim();
					
					//  Convert the file text to file data and store
					//  the data because the file might not be compressed
					
					if (Number.isBase64(filetext))
					
					    filedatalist.set(i, Convert
					
						.base64ToByteArray(filetext));
					
					else { System.out.println("Attached file error"); break; }
					
					try
					{	byte[] filedata = Convert.base64ToByteArray(filetext);
						
						byte[] decompresseddata = decompress(filedata);
						
						byte[] compresseddata = compress(decompresseddata);
						
						//  If the file was compressed then re-save the new data
						
						if (Arrays.equals(filedata, compresseddata))
						{
							filedatalist.set(i, decompresseddata);
							
							//  System.out.println("file sizes == " +
							//
							//    decompresseddata.length + " : " +
							//      compresseddata.length);
							//
							//    26769 : 26660  color circle
							//    34770 : 11656  text document
							//     5518 :  2399  table document
						}
					}
					
					//  if the file wasn't compressed or deflated then
					//  decompressing just throws a data format exception
					
					catch (DataFormatException ex) {  }
				}
				
				
				//  Store the file data in the emailpanel arraylist1
				//
				//  (If this method is called more than once for the same message,
				//  the attached files can appear multiple times unless we test the
				//  number of files == 0 before adding the files. This can happen if
				//  the user clicks on the read all button and then keeps clicking
				//  on the list and read buttons. The other member variables in the
				//  ArrayList1 class are not affected by this because they use set
				//  commands instead of add commands.)
				
				if (emailpanel.list1.getNumberOfFiles(msno) == 0)
				
				for (int i = 0; i < numberoffiles; i++)
				{
					emailpanel.list1.addFileData(msno, filedatalist.get(i));
					emailpanel.list1.addFileDesc(msno, filedesclist.get(i));
				}
				
				//  Set the list1 concatenated file text
				
				String filetext = convertFilesToText(filedesclist, filedatalist);
				
				emailpanel.list1.setFileText(msno, filetext);
				
				
				if (!encrypted)
				{
					StringBuilder sb = new StringBuilder();
					
					for (String token : tokens)
					
					    if ((token != null) && !token.isEmpty())
					
						sb .append(token + "\n\n");
					
					message = sb.toString();
				}
				
				
				String messagetext = null;
				
				if (encrypted && (message == null) && (tokens != null))
				{
					if (PublicKey.isValidKey(tokens[0]))
					{
						if (tokens.length > 1)
						
						    messagetext = tokens[1];
						sendersreplykey = tokens[0];
					}
					
					else messagetext = tokens[0];
				}
				
				
				//  Remove the base-64 encoding to show the newlines
				
				if ((messagetext != null) && Number.isBase64(messagetext))
				
				     messagetext = Convert.base64ToString(messagetext);
				
				
				if (((sendersreplykey == null)
				   || sendersreplykey.isEmpty())
				
					&& (messagetext != null))
				{
					//  Split the reply key (sender's key) and message
					
					String[] replykey_message = messagetext.split("\n{2,}");
					
					if (replykey_message.length == 2) // reply key + message
					{
						if (PublicKey.isValidKey(replykey_message[0]))
						{
							sendersreplykey = replykey_message[0];
							
							message = replykey_message[1];
						}
					}
				}
				
				
				if (message == null)
				
				    message = messagetext;
				
				
				//  If the message is in base 64 remove the encoding
				
				if ((message != null) && Number.isBase64(message.trim()))
				
				    message = Convert.base64ToString(message.trim());
				
				
				//  If the message is partitioned and encoded,
				//  remove the partitions / newlines and decode
				
				if ((message != null) && Number.isBase64(
				
				    message.trim().replaceAll("\n", "")))
				
					message = Convert.base64ToString(
					
					    message.trim().replaceAll("\n", ""));
				
				
				
				//  Read, remove, and save the subject line
				
				if (encrypted)
				{
					subject = null;
					
					String firstline = "";
					
					message = message.trim();
					
					int pos = message.indexOf("\n");
					
					if (pos > 0) firstline = message.substring(0, pos);
					
					firstline = firstline.toLowerCase();
					
					if (firstline.startsWith(  "subj")
					 || firstline.startsWith(__.Subject))
					{
						pos = firstline.indexOf(":") + 1;
						
						if (pos <= firstline.length())
						
						    subject = firstline.substring(pos).trim();
						
						if (pos <= message.length())
						
						   message = message.substring(
						
						      firstline.length() + 2).trim();
					}
					
					if (subject != null) emailpanel.list1
					
					    .setSubject(msno, subject);
				}
				
				
				//  If the message is partitioned and encoded,
				//  remove the partitions / newlines and decode
				
				while ((message != null) && Number.isBase64(
				
				    message.trim().replaceAll("\n", "")))
				
					message = Convert.base64ToString(
					
					    message.trim().replaceAll("\n", ""));
				
				
				//  Replace the encrypted message
				//  with the decrypted message
				
				header_message[1] = message;
				
				
				//  Replace the emailpanel.list1 encrypted message
				
				emailpanel.list1.setMessage(msno, message);
				
				
				//  Store the sender's reply key (if the key is valid)
				
				if ((sendersreplykey != null) && PublicKey
				
				    .isValidKey(sendersreplykey))
				{
					emailpanel.list1.setReplyKey(msno, sendersreplykey);
					
					//  Count the number of reply key ciphers
					
					String replykey = emailpanel.list1.getReplyKey(msno);
					
					int replyciphers = 0;
					
					if ((replykey != null) && !replykey.isEmpty())
					
					   if (PublicKey.isValidKey(replykey))
					
					      replyciphers = PublicKey
					
					         .countNumberOfCiphers(replykey);
					
					emailpanel.list1.setNumberOfReplyCiphers(msno, replyciphers);
				}
				
				
				}  //  end try block
				
				
				catch (Exception ex)
				{
					ex.printStackTrace();
				}
				
				finally
				{
					if (!emailpanel.buttonlistener.reading)
					{
						//  Restore the default cursor
						
						emailpanel.readbutton .setCursor(default_cursor);
						emailpanel.textarea   .setCursor(default_cursor);
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setCursor(default_cursor);
					}
				}
			}
			
			
			//  End readMessage method
			
			
			
			
			
			private synchronized String decryptMessage(
			
				EmailPanel emailpanel, String message, int msno)
			{
				//  This method tries to decrypt a message using two keys
				//
				//  private key 1 = hash(passphrase + email) and
				//  private key 2 = hash(passphrase)
				//
				//  The user's private key is usually the hash of (SP + email address)
				//  but a user might create a public key without an email address and
				//  then edit the key by typing different addresses on the key to reuse
				//  the same key for multiple addresses.
				//
				//  If the message is already unencrypted, the message is returned
				
				
				if (!PublicKey.isEncrypted(message))
				
				    throw new IllegalArgumentException();
				
				
				//  Pre-compute the public key(s) once
				
				String emailaddr = emailpanel.emailfield.getText().trim();
				
				if (!testmail)
				{
					//  System.out.println("secret passphrase == " + SP);
					
					if (emailpanel.publickey_sp == null)
					
					    emailpanel.publickey_sp = PublicKey.generatePublicKey(
					
						Cipher.passphraseToKey(SP), PublicKey.numberofciphers);
					
					if (emailpanel.publickey_sp_email == null)
					
					    emailpanel.publickey_sp_email = PublicKey.generatePublicKey(
					
						Cipher.passphraseToKey(SP + emailaddr), PublicKey.numberofciphers);
				}
				
				else if (testmail)
				{
					if (emailpanel.publickey_testmail == null)
					
					    emailpanel.publickey_testmail = PublicKey.generatePublicKey(
					
						Cipher.passphraseToKey(testpassphrase), PublicKey.numberofciphers);
				}
				
				
				//  Trim the message and remove any encoding
				
				message = message.trim();
				
				if (Number.isBase64(message))
				
				    message = Convert.base64ToString(message);
				
				String decryptedmessage = null;
				
				
				if (PublicKey.isEncrypted(message))
				{
					//  Decrypt the message
					
					byte[] messagekey = emailpanel.list1.getMessageKey(msno);
					
					if (testmail) // test mail
					{
						if ((messagekey == null) || (messagekey.length == 0))
						
						     messagekey = PublicKey.decryptMessageKey(
						
							message, emailpanel.publickey_testmail);
						
						if (messagekey != null) decryptedmessage = PublicKey
						
						    .decryptCiphertext(message, messagekey);
					}
					
					else
					{	if (emailpanel.nokeyaddress)
						{
							//  First try hash(SP), then try hash(SP + email)
							
							if ((messagekey == null) || (messagekey.length == 0))
							{
								messagekey = PublicKey.decryptMessageKey(
								
								    message, emailpanel.publickey_sp);
								
								if (messagekey != null) decryptedmessage =
								
								    PublicKey.decryptCiphertext(message, messagekey);
								
								if ((decryptedmessage == null) || decryptedmessage.isEmpty())
								{
									messagekey = PublicKey.decryptMessageKey(
									
									    message, emailpanel.publickey_sp_email);
									
									if (messagekey != null) decryptedmessage =
									
									    PublicKey.decryptCiphertext(message, messagekey);
									
									if ((decryptedmessage != null) && !decryptedmessage.isEmpty())
									
									    //  change nokeyaddress
									    emailpanel.nokeyaddress = false;
								}
							}
						}
						
						
						else
						{	//  First try SK = hash(SP + email), then try hash(SP)
							
							messagekey = PublicKey.decryptMessageKey(
							
							    message, emailpanel.publickey_sp_email);
							
							if (messagekey != null) decryptedmessage =
							
							    PublicKey.decryptCiphertext(message, messagekey);
							
							
							if ((decryptedmessage == null) || decryptedmessage.isEmpty())
							{
								messagekey = PublicKey.decryptMessageKey(
								
								    message, emailpanel.publickey_sp);
								
								if (messagekey != null) decryptedmessage =
								
								    PublicKey.decryptCiphertext(message, messagekey);
								
								if ((decryptedmessage != null)
								 && !decryptedmessage.isEmpty())
								
								    //  change nokeyaddress
								    emailpanel.nokeyaddress = true;
							}
						}
					}
					
					emailpanel.list1.setMessageKey(msno, messagekey);
					
					if (!PublicKey.isEncrypted(message))
					{
						//  the message was decrypted
						
						//  count the number of ciphers
						
						//  emailpanel.list1.setNumberOfCiphers(...)
					}
				}
				
				//  Return the (decrypted, unencrypted, or non-decryptable) message
				
				return decryptedmessage;
			}
			
			
			
			
			private void readAndDisplayMessage(int msno)
			{
				//  Read and decrypt the message
				
				if ((emailpanel.list1.getMessage(emailpanel.msno) == null)
				  || emailpanel.list1.getMessage(emailpanel.msno).isEmpty())
				
				    readMessage(emailpanel, emailpanel.msno);
				
				
				//  Display the decrypted message
				
				displayMessage(emailpanel, emailpanel.msno);
				
				
				emailpanel   .listscreen = false;
				emailpanel.messagescreen = true;
				emailpanel.readallscreen = false;
				
				emailpanel.readallpanel.setVisible(false);
				emailpanel.scrollpane3 .setVisible(false);
				emailpanel.scrollpane2 .setVisible(true);
			}
			
			
			
			
			private void parseEmailField()
			{
				//  This method parses the email field
				
				//  username@example.com
				//
				//  The userpass created by the program should be the
				//  first 8 digits of the hash ( passphrase + email ).
				
				
				//  Read and validate the email address
				
				String text = emailpanel.emailfield.getText();
				
				if ((text.indexOf("@") == -1) || text.contains(" "))
				{
					emailpanel.username = null;
					emailpanel.userpass = null;
					emailpanel.userdomain = null;
					
					return;
				}
				
				String[] username_domain = text.split("@");
				
				if (username_domain.length != 2)
				{
					emailpanel.username = null;
					emailpanel.userpass = null;
					emailpanel.userdomain = null;
					
					return;
				}
				
				String username = username_domain[0];
				String domain   = username_domain[1];
				
				username = username.replace("@", "");
				
				emailpanel.username = username;
				emailpanel.userdomain = domain;
				
				int index = tabbedpane.getSelectedIndex();
				
				//  Set the tab title for the readMailSettings
				
				tabbedpane.setTitleAt(index, username);
			}
			
			
			
			
			
			private class EmailHeader
			{
				private String date, from, subject;
				
				//  The constructor parses the header for
				//  the date, from, and subject fields
				
				public EmailHeader(String header)
				{
					Scanner sc = new Scanner(header);
					
					while (sc.hasNextLine())
					{
						String line = sc.nextLine();
						
						String line1 = line.toLowerCase();
						
						//  Read the date
						
						if ((line1.startsWith("date:")
						
						  || line1.startsWith(__.Date.toLowerCase() + ":")
						  || line1.startsWith(__.Date.toLowerCase() + "="))
						
						    && ((date == null) || date.isEmpty()))
						{
							int startpos = line1.contains(":") ?
							
							    line1.indexOf(":") + 1 :
							    line1.indexOf("=") + 1;
							
							date = line .substring(startpos);
							
							if (date.contains("+")) date = date.substring(0, date.indexOf("+"));
							if (date.contains("-")) date = date.substring(0, date.indexOf("-"));
							
							date = date .trim();
						}
						
						if ((line1.startsWith("from:")
						
						  || line1.startsWith(__.From.toLowerCase() + ":")
						  || line1.startsWith(__.From.toLowerCase() + "="))
						
						    && line1.contains("@") && ((from == null) || from.isEmpty()))
						{
							String[] tokens = line.split(" {1,}");
							
							for (String token : tokens)
							
							    if (token.contains("@"))
							{
								token = token.trim();
								
								if (token.startsWith("<"))
								
								     from = token.substring(
								
									1, token.length() -1);
								
								else from = token;
								
								from = from .trim();
							}
							
							continue;
						}
						
						if ((line1.startsWith("subject:")
						
						  || line1.startsWith(__.Subject.toLowerCase() + ":")
						  || line1.startsWith(__.Subject.toLowerCase() + "="))
						
						    && ((subject == null) || subject.isEmpty()))
						{
							int startpos = line1.contains(":") ?
							
							    line1.indexOf(":") + 1 :
							    line1.indexOf("=") + 1;
							
							subject = line .substring(startpos);
							
							subject = subject .trim();
						}
					}
				}
			}
			
			
			
			
			
			private void checkDelete(String str, int index)
			{
				//  checks or unchecks a [ x ] box for the read all screen
				
				if (emailpanel.buttonlistener.reading) return;
				
				int cp = emailpanel.textarea.getCaretPosition();
				
				StringBuilder sb = new StringBuilder(str);
				
				int startpos = emailpanel.list1.getMessageStartPos(index);
				
				int xpos = str.indexOf("[", startpos); // [ x ]
				
				if (sb.charAt(xpos + 2) == ' ')
				{
					sb.setCharAt(xpos + 2, 'x');
					
					//  Check the delete box
					
					emailpanel.list1.setDeleteBox(index, true);
					emailpanel.listpanel.checkboxes[index].setSelected(true);
				}
				
				else
				{	sb.setCharAt(xpos + 2, ' ');
					
					//  Uncheck the delete box
					
					emailpanel.list1.setDeleteBox(index, false);
					emailpanel.listpanel.checkboxes[index].setSelected(false);
				}
				
				String text = sb.toString();
				
				emailpanel.textarea.setText(text);
				emailpanel.textarea.setCaretPosition(cp);
			}
			
			
			
			
			
			
			private void displayMessage(EmailPanel emailpanel, int msno)
			{
			
				//  Constructs a file header and message string
				//  and displays the message in the text area
				//
				//  This method does not decrypt messages but it
				//  decodes files that are encoded in base 64
				
				
				String date     = emailpanel.list1.getDate(msno);
				String from     = emailpanel.list1.getFrom(msno);
				String subject  = emailpanel.list1.getSubject(msno);
				String message  = emailpanel.list1.getMessage(msno);
				String replykey = emailpanel.list1.getReplyKey(msno);
				
				int numberoffiles   = emailpanel.list1.getNumberOfFiles(msno);
				int numberofciphers = emailpanel.list1.getNumberOfCiphers(msno);
				
				
				//  If the message was undecryptable and doesn't
				//  contain any newlines, partition the string so
				//  the text doesn't become garbled by the text
				//  area if the font size is large
				
				if (message == null) return;
				
				if ((message.length() > minsize)
				
				 && !message.trim().contains("\n"))
				
				    message = Convert.partition(
				
					message.trim(), "\n", linesize);
				
				
				//  Count the number of ciphers in the reply key
				
				int replyciphers = 0;
				
				if ((replykey != null) && !replykey.isEmpty())
				
				    if (PublicKey.isValidKey(replykey))
				
					replyciphers = PublicKey.countNumberOfCiphers(replykey);
				
				
				//  Construct a message string to display the message
				
				StringBuilder sb = new StringBuilder();
				
				
				//  Append the message header " delete  reply  prev  next "
				
				sb.append("\n" + messageheader + "\n\n");
				
				
				//  Append the from, subject, and date
				
				if ((from != null) && !from.isEmpty())
				
				    sb.append(__.From + ": " + from + "\n");
				
				if ((subject != null) && !subject.isEmpty())
				
				    sb.append(__.Subject + ": " + subject + "\n");
				
				if ((date != null) && !date.isEmpty())
				
				    sb.append(__.Sent + ": " + date + "\n");
				
				
				//  Append the message size
				
				int size = emailpanel.list1.getNumberOfBytes(msno);
				
				String sizestr = String.valueOf(size / 1024);
				
				sizestr = Convert.partition(sizestr, ",", -3);
				
				//  sb.append(__.Size + " " + sizestr + " " + __.bytes + "\n\n");
				
				
				//  Append the number of encryption ciphers and reply key ciphers
				
				sb.append(__.encryptionreplykeyciphers + " = ");
				
				sb.append(numberofciphers + " / " + replyciphers + "\n");
				
				
				//  Append the view attached file == [ view ]
				//     and the save attached file == [ save ]
				//
				//  1. Attached File  [ view ]  [ save ]
				//
				//  2. Attached File  [ view ]  [ save ]
				//
				//  3. Attached File  [ view ]  [ save ]
				
				for (int i = 0; i < numberoffiles; i++)
				{
					if (i == 0) sb.append("\n");
					
					if (i < 10) sb.append(String.valueOf(
					   (i < 9) ? i + 1 : 0) + ". ");
					
					sb.append(__.AttachedFile + "  ");
					sb.append(__.viewattachedfile + "  ");
					sb.append(__.saveattachedfile);
					
					if (i < numberoffiles -1)
					
					     sb.append("\n\n");
					else sb.append("\n");
				}
				
				
				
				//  Determine whether the message was undecryptable
				//  or was sent in the clear
				//
				//  If the message is undecryptable, display the cipher-
				//  data instead of the base-64 encoded ciphertext so the
				//  user sees the cipherdata; otherwise it looks like the
				//  base-64 encoding wasn't removed and some users might
				//  copy the text and try to decode it using a text editor
				//  to see if there is an email message.
				
				String message1 = message.trim().replaceAll("\n", "");
				
				if (Number.isBase64(message1))
				
				    message = Convert.base64ToString(message1);
				
				//  (the message might not be decryptable if the
				//  ciphertext is defective or the wrong passphrase
				//  was used by the sender or recipient)
				
				//  This message is undecryptable (wrong passphrase
				//  was used to encrypt or ciphertext is defective)
				
				if (PublicKey.isEncrypted(message)
				 || PublicKey.isEncrypted(message1))
				
				    sb.append("\n" + __.thismessageisundecryptable + "\n");
				
				
				if (numberofciphers == 0) // this message was sent unencrypted
				
				    sb.append("\n" + __.thismessagewassentunencrypted + "\n");
				
				
				if (numberofciphers > 0)
				{
					//  Read the message header to see if it includes a plaintext subject
					
					String header = emailpanel.list1.getHeader(msno);
					
					EmailHeader emailheader = new EmailHeader(header);
					
					String plainsubject = emailheader.subject;
					
					//  Warn the user if the sender's program included a plaintext subject
					//  (This would be a defect in the design of the sender's program)
					
					if ((plainsubject != null) && !plainsubject.isBlank())
					{
						//  plaintext subject warning
						
						String warningmessage = __.subjectwarning + "\n\n" + plainsubject;
						
						JOptionPane.showMessageDialog(frame, warningmessage);
					}
				}
				
				sb.append("\n\n");
				
				
				//  The read message screen requires a text area
				
				emailpanel.scrollpane1.setVisible(false);
				emailpanel.scrollpane2.setVisible(true);
				emailpanel.scrollpane3.setVisible(false);
				
				
				//  Display the heading and decrypted or plaintext message
				
				String heading = sb.toString();
				
				sb = new StringBuilder(heading + message);
				
				
				emailpanel.textarea.setText(sb.toString());
				emailpanel.textarea.setEditable(false);
				emailpanel.textarea.setCaretPosition(0);
				
				emailpanel   .listscreen = false;
				emailpanel.messagescreen = true;
				emailpanel.readallscreen = false;
				
				
				//  If the message is a partitioned encoded string,
				//  then remove the partitions and decode the string
				
				message1 = message.trim().replaceAll("\n", "");
				
				if (Number.isBase64(message1))
				
				    message = Convert.base64ToString(message1);
				
				
				//  If the decrypted message is an HTML document
				//  display the html document in a popup window
				
				{	int newlinepos = message.trim() .indexOf("\n");
					
					if (newlinepos < 0) newlinepos = 0;
					
					String line1 = message.trim().substring(0, newlinepos);
					
					Window window = frame;
					
					if (line1.contains("<") && (line1.contains("html") || line1.contains("HTML")))
					
					    Documents.displayHTML(window, "", message.trim(),
					
						font, emailpanel.foreground, emailpanel.background);
				}
				
				
				//  If the decrypted message contains an HTML document encoded
				//  in base 64, display the html document in a popup window
				
				String[] tokens = message.trim().split("\n{2,}");
				
				for (String token : tokens)
				
				if (Number.isBase64(token.trim()))
				{
					token = Convert.base64ToString(token.trim());
					
					int newlinepos = token.trim() .indexOf("\n");
					
					if (newlinepos < 0) newlinepos = 0;
					
					String line1 = message.trim().substring(0, newlinepos);
					
					Window window = frame;
					
					if (line1.contains("<") && (line1.contains("html") || line1.contains("HTML")))
					{
						Documents.displayHTML(window, "", message.trim(),
						
						    font, emailpanel.foreground, emailpanel.background);
						
						break;
					}
				}
				
				
				//  Append a few newlines so that the text area does not
				//  keep bouncing up and down as the user clicks delete, next,
				//  or prev and the vertical scroll bar becomes alternately
				//  enabled and disabled based on the size of the message.
				//
				//  (Just because the scroll bar is always visible doesn't
				//  prevent this problem. The enabling and disabling of the
				//  scroll bar is what causes the problem.)
				
				
				String newlines = "\n\n\n\n\n\n";
				
				sb.append(newlines);
				
				String str = sb.toString();
				
				emailpanel.textarea.setText(str);
				
				
				//  Autowrap the text if any line width is > 80
				//
				//  Otherwise the horizontal scroll bar could become
				//  very small and difficult to scroll for some docu-
				//  ments if each paragraph is only one line.
				
				int maxlinechars = 80;
				
				boolean linewrap = false;
				
				str = sb.toString();
				
				char[] charray = str.toCharArray();
				
				int j = 0;
				
				for (int i = 0; i < charray.length; i++)
				{
					if (charray[i] == '\n')
					{
						if ((i - j) > maxlinechars)
						
						    { linewrap = true;  break; }
						
						else j = i;
					}
				}
				
				if (j == 0) linewrap = true; // no newline char
				
				emailpanel.textarea.setLineWrap(linewrap);
				emailpanel.textarea.setWrapStyleWord(linewrap);
				emailpanel.textarea.requestFocusInWindow();
				emailpanel.textarea.setCaretPosition(0);
				
				tabbedpane.repaint();
			}
			
			
			
			
			private void reply(int msno)
			{
			
				//  This method creates a new SendMail frame and initializes
				//  the to, from, and subject fields and the text area
				
				//  The SendMailListener also creates a new SendMail frame
				//  but unlike the reply method it doesn't initialize the
				//  text fields and text area.
				
				
				//  Don't reply to messages that have checked delete boxes
				
				//  if (emailpanel.list1.getDeleteBox(msno)) return;
				
				//  Display a popup message if the delete box is checked
				
				if (emailpanel.list1.getDeleteBox(msno))
				{
					int msno1 = msno;
					
					//  Reverse the msno for descending order
					
					if (!emailpanel.popmail.ascending)
					
					    msno1 = emailpanel.popmail
					
						.getNumberOfMessages() -1 -msno1;
					
					String message = (msno1 + 1) + " " + replypopupmsg;
					
					////  showPopupMessage(e, message);
					
					return;
				}
				
				//  Don't open more than one reply frame per message
				
				SendMailFrame prevframe = emailpanel
				
				    .list1.getSendMailFrame(msno);
				
				if ((prevframe != null) && prevframe.isVisible())
				{
					//  Move frame to front
					
					prevframe.toFront();
					
					return;
				}
				
				
				//  Read the header and message from the list
				
				String header  = emailpanel.list1.getHeader (msno);
				String message = emailpanel.list1.getMessage(msno);
				
				
				//  Decrypt the message
				
				if ((message != null) && !message.isEmpty()
				
				    && PublicKey.isEncrypted(message))
				
					message = decryptMessage(
					
					    emailpanel, message, msno);
				
				
				//  Read the date and from lines
				
				EmailHeader emailheader = new EmailHeader(header);
				
				String date = emailheader.date;
				String from = emailheader.from;
				
				//  The subject thread may have already decrypted the subject line
				//  (The header subject may be null unless the message was sent unencrypted)
				
				//  Don't use the emailheader subject unless the list subject is null
				
				String subject = emailpanel.list1.getSubject(msno);
				
				if (subject == null) subject = emailheader.subject;
				
				
				//  Create the reply send mail frame
				
				SendMailFrame sendmailframe = new SendMailFrame();
				
				sendmailframe.userpass   = emailpanel.userpass;
				sendmailframe.authorized = emailpanel.authorized;
				
				sendmailframe.requestFocusInWindow("textarea");
				
				
				//  Set the reply to field equal to the email from field
				
				if (from != null) sendmailframe.setToField(from); // to = from
				
				if (subject != null) sendmailframe.setSubjectField(subject);
				
				String replykey = emailpanel.list1.getReplyKey(msno);
				
				sendmailframe.setOutgoingMailServer(emailpanel.outgoingmailserver);
				sendmailframe.setOutgoingMailPort  (emailpanel.outgoingmailport);
				
				sendmailframe.setFromField(emailpanel.emailfield.getText().trim());
				
				sendmailframe.setSendersReplyKey(from, replykey); // the recipient's encrypt key, to = from
				sendmailframe.setNumberOfCiphers(emailpanel.numberofciphers); // the user's default reply key size
				sendmailframe.setUseReplyAddressKey(emailpanel.usereplyaddresskey); // include addr in private key
				
				sendmailframe.setReverseColors(emailpanel.reverse_colors);
				sendmailframe.setForeground1(emailpanel.foreground);
				sendmailframe.setBackground1(emailpanel.background);
				
				sendmailframe.setFont1(font);
				
				sendmailframe.setEditable(false);
				
				
				
				//  Initialize the send mail text area
				
				String str = new String();
				
				String separator32 = "_".repeat(32);
				
				
				str += "\n\n\n";
				str += separator32 +"\n\n";
				str += (message + "\n");
				
				final String str1 = str;
				
				sendmailframe.setText(str1);
				
				sendmailframe.setCaretPosition(0);
				
				
				//  Store the send mail frame in the reply list1
				
				emailpanel.list1.setSendMailFrame(msno, sendmailframe);
				
				//  Display the keyboard
				
				if (showkeyboard)
				{
					keyboardlistener.run();
					
					Keyboard keyboard = keyboardlistener.keyboard;
					
					keyboard.setForeground(emailpanel.foreground);
					keyboard.setBackground(emailpanel.background);
					keyboard.setFont(font);
					
					keyboardlistener.keyboardframe.setLocationRelativeTo(null);
					keyboardlistener.setTextComponent(sendmailframe.textarea);
				}
				
				//  Move frame to front
				
				sendmailframe.toFront();
			}
			
			
			
			
			
			private boolean readMailSettings()
			{
			
				System.out.println("reading mail settings");
				
				//  reads the encrypted usernames and panel settings
				
				//  Restore any closed tabs
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					EmailPanel emailpanel1 = (EmailPanel)
					
					    tabbedpane.getComponentAt(i);
					
					if (!emailpanel1.isVisible())
					
					     emailpanel1.setVisible(true);
					
					String tabtitle = emailpanel.tabtitle.trim();
					
					if (tabtitle.isEmpty()) tabtitle = __.email;
				}
				
				if ((SP == null) || SP.isEmpty() || (maildirectory == null)
				
				    || maildirectory.isEmpty()) return false;
				
				File dir = new File(maildirectory);
				
				if (!dir.exists() || !dir.isDirectory()) return false;
				
				
				
				String filepath = passphraseToFilePath(__.usernames, SP);
				
				System.out.println("file path == " + filepath);
				
				if (filepath == null) return false;
				
				File file = new File(filepath);
				
				String plaintext = null;
				
				if (file.exists())
				{
					byte[] filedata = null;
					
					try { filedata = DataStream.read(file); }
					
					catch (IOException ex)
					{
						System.out.println(ex);
						
						return false;
					}
					
					if (Cipher.isEncrypted(file))
					{
						//  Decrypt the file input
						
						filedata = Cipher.decrypt(filedata,
						
						    Cipher.passphraseToKey(SP));
						
						//  Return false if file did not decrypt
						
						if (filedata == null) return false;
						
						//  Convert the decrypted byte[] to String
						
						plaintext = new String(filedata);
					}
				}
				
				else return false;
				
				
				
				//  Read the settings
				
				int selectedindex = tabbedpane.getSelectedIndex();
				
				Scanner sc = new Scanner(plaintext);
				
				String line = null,  line1 = null;
				
				//  Skip the empty lines
				
				while (sc.hasNextLine())
				{
					String input = sc.nextLine().trim();
					
					line = input;
					
					if (!input.isEmpty()) break;
				}
				
				//  The next email address variable enables the user to change
				//  the incoming or outgoing mail server because closing the
				//  settings dialog calls the readMailSettings and then the
				//  saveMailSettings method.
				//
				//  Without the next email address, the readMailSettings method
				//  would prevent the settings from being changed because it would
				//  keep overwriting the new settings with the old file settings.
				
				boolean nextemailaddress = false;
				
				while (sc.hasNextLine())
				{
				
					if ((line1 != null) && !line1.isEmpty())
					
					    line = line1 .trim();
					
					if (line.isEmpty()) continue;
					
					
					while (sc.hasNextLine() &&
					
					    (line1 = sc.nextLine()).isBlank())
					
					    	continue;
					
					
					//  Skip to the next email address
					
					if (nextemailaddress && !line.equals(__.email)) continue;
					
					else nextemailaddress = false;
					
					
					if (line.equalsIgnoreCase(__.email) && line1.contains("@"))
					{
						//  Verify that the address has not already
						//  been added to the email panel
						
						boolean bool = false;
						
						for (int i = 0; i < tabbedpane.getTabCount(); i++)
						{
							EmailPanel emailpanel = (EmailPanel)
							
							    tabbedpane.getComponentAt(i);
							
							if (emailpanel.emailfield.getText()
							
							    .trim().equals(line1.trim()))
							
								bool = true;
						}
						
						if (bool) { nextemailaddress = true; continue; }
						
						
						//  Create a new tab
						
						newlistener.run();
						
						emailpanel.emailfield.setText(line1);
						
						emailpanel.emailfield.setCaretPosition(0);
						
						parseEmailField();
					}
					
					else if (line.equalsIgnoreCase(__.selectedindex))
					{
						boolean bool = Boolean.valueOf(line1);
						
						//  read mail settings prevents the tab from changing
						//  if the user reopens the settings dialog to change
						//  the incoming or outgoing server
						
						if (bool && !readmailsettings)
						
						    selectedindex = tabbedpane.getSelectedIndex();
					}
					
					else if (line.equalsIgnoreCase(__.username))
					{
						emailpanel.username = line1;
					}
					
					else if (line.equalsIgnoreCase(__.userpass))
					{
						emailpanel.userpass = line1;
					}
					
					else if (line.equalsIgnoreCase(__.numberofciphers))
					{
						try { emailpanel.numberofciphers = Integer.parseInt(line1); }
						
						catch (NumberFormatException ex) {  }
					}
					
					else if (line.equalsIgnoreCase(__.usereplyaddresskey))
					{
						emailpanel.usereplyaddresskey = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.textrgb))
					{
						Color color = new Color(Integer.valueOf(line1));
						
						if (color != null) emailpanel.foreground = color;
					}
					
					else if (line.equalsIgnoreCase(__.screenrgb))
					{
						Color color = new Color(Integer.valueOf(line1));
						
						if (color != null) emailpanel.background = color;
					}
					
					else if (line.equalsIgnoreCase(__.reverse_colors))
					{
						emailpanel.reverse_colors = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.font))
					{
						String str = line1;
						
						String[] tokens = str.split(",");
						
						if (tokens.length == 3)
						{
							String fontname = tokens[0].trim();
							
							int fontstyle = Integer.valueOf(tokens[1].trim());
							
							//  Test the font size
							
							int fontsize = Integer.valueOf(tokens[2].trim());
							
							if ((fontsize < 0) || (fontsize > 50))
							
							    fontsize = defaultfontsize;
							
							Font font1 = new Font(
							
							   fontname, fontstyle, fontsize);
							
							maxfontsize = font1.getSize();
							
							font = font1;
						}
					}
					
					else if (line.equalsIgnoreCase(__.titlename))
					{
						titlename = line1;
						
						frame.setTitle(line1);
						
						int maxlen = 20;
						
						aboutmenuitem.setText(__.about + " "
						
						  + ((titlename.length()   > maxlen) ?
						      titlename.substring(0, maxlen) : titlename));
					}
					
					else if (line.equalsIgnoreCase(__.framesize))
					{
						String str = line1;
						
						String[] tokens = str.split(" {1,}");
						
						if (tokens.length == 2)
						{
							int width  = Integer.valueOf(tokens[0]);
							int height = Integer.valueOf(tokens[1]);
							
							frame.setSize(width, height);
						}
					}
					
					else if (line.equalsIgnoreCase(__.incomingmailserver))
					{
						String incomingmailserver = line1;
						
						emailpanel.incomingmailserver = incomingmailserver;
					}
					
					else if (line.equalsIgnoreCase(__.outgoingmailserver))
					{
						String outgoingmailserver = line1;
						
						emailpanel.outgoingmailserver = outgoingmailserver;
					}
					
					else if (line.equalsIgnoreCase(__.incomingmailport))
					{
						if (Number.isDigitString(line1, 10))
						
						    try { emailpanel.incomingmailport = Integer.parseInt(line1); }
						
						    catch (NumberFormatException ex) {  }
					}
					
					else if (line.equalsIgnoreCase(__.outgoingmailport))
					{
						if (Number.isDigitString(line1, 10))
						
						    try { emailpanel.outgoingmailport = Integer.parseInt(line1); }
						
						    catch (NumberFormatException ex) {  }
					}
					
					else if (line.equalsIgnoreCase(__.messagesperscreen))
					{
						if (Number.isDigitString(line1, 10))
						
						    try { emailpanel.messagesperscreen = Integer.parseInt(line1); }
						
						    catch (NumberFormatException ex) {  }
					}
					
					else if (line.equalsIgnoreCase(__.ascending))
					{
						emailpanel.ascending = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.Showkeyboard))
					{
						showkeyboard = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.showsentemails))
					{
						showsentemails = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.mailcopytoself))
					{
						mailcopytoself = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.sentpublickey))
					{
						sentpublickey = Boolean.valueOf(line1);
					}
					
					else if (line.equalsIgnoreCase(__.tabtitle))
					{
						String tabtitle = line1;
						
						//  emailpanel.tabtitle = tabtitle;
						//
						//  int index = tabbedpane.getSelectedIndex();
						//
						//  tabbedpane.setTitleAt(index, tabtitle);
					}
					
					else if (line.equalsIgnoreCase(__.programtitle))
					{
						String title = line1;
						
						frame.setTitle(title);
					}
					
					else if (line.equalsIgnoreCase(__.testmail))
					{
						testmail = Boolean.valueOf(line1);
						
						testmailmenuitem.setSelected(testmail);
					}
					
					//  ...
				}
				
				
				//  Set the saved message states for each email panel
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					EmailPanel emailpanel = (EmailPanel)
					
					    tabbedpane.getComponentAt(i);
					
					try { readMessageStates(
					
					    emailpanel.username, emailpanel.msgstatestreemap); }
					
					catch (IllegalArgumentException ex)
					
					    { ex.printStackTrace(); }
				}
				
				
				//  Set the colors for each email panel
				
				for (int i = 0; i < tabbedpane.getTabCount(); i++)
				{
					EmailPanel emailpanel = (EmailPanel)
					
					    tabbedpane.getComponentAt(i);
					
					colorlistener.setForeground(emailpanel);
					colorlistener.setBackground(emailpanel);
				}
				
				
				//  Set the tabbed pane to the selected index
				
				if (readmailsettings == false)
				
				    tabbedpane.setSelectedIndex(selectedindex);
				
				
				//  Remove the zeroth panel if the email field is empty
				
				if (tabbedpane.getTabCount() > 1)
				{
					for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						EmailPanel emailpanel = (EmailPanel)
						
						    tabbedpane.getComponentAt(i);
						
						if (emailpanel.emailfield.getText().isBlank())
						{
							tabbedpane.remove(i);
							
							break;
						}
					}
				}
				
				
				readmailsettings = true;
				
				setMenuItemsEnabled(true);
				
				setFont1(font);
				
				
				//  This code corrects for a bug in the tabbedpane
				
				int index = tabbedpane.getSelectedIndex();
				
				for (int i = 0; i <= index; i++)
				
				    tabbedpane.setSelectedIndex(i);
				
				
				return true;
			}
			
			
			
			
			private boolean saveMailSettings()
			{
			
				//  This method saves the email data to a file
				//
				//  The file name is a function of the user's passphrase.
				
				//  The data is stored in pairs where the first line is
				//  the name of the field and the second line is the data.
				//  The fields are separated by one blank line or two new-
				//  line chars to make it easier to read but they could be
				//  separated by only one newline char.
				
				
				//  Example  /home/user/Mail/user12345678
				//
				//  email
				//  user1@example.com
				//
				//  user name
				//  user1
				//
				//  user pass
				//  12345678
				//
				//  numberofciphers
				//  2
				//
				//  font
				//  monospaced, plain, 16
				//
				//  text rgb
				//  123456
				//
				//  screen rgb
				//  123456
				//
				//  incoming mail server
				//  smtp.mail.com
				//
				//  outgoing mail server
				//  pop.mail.com
				//
				//  incoming mail port
				//  995
				//
				//  outgoing mail port
				//  465
				//
				//  ...
				//
				//  messages per screen
				//  50
				//
				//  ascending
				//  true
				//
				//
				//  email
				//  user2@example.com
				//
				//  user name
				//  user2
				//
				//  user pass
				//  12345678
				//
				//  ...
				
				
				System.out.println("saving mail settings");
				
				if ((SP == null) || SP.isEmpty()) return false;
				
				if (!writePassphrase0(frame)) return false;
				
				
				ArrayList<Object> list = new ArrayList<Object>();
				
				int selectedindex = tabbedpane.getSelectedIndex();
				
				try
				{	for (int i = 0; i < tabbedpane.getTabCount(); i++)
					{
						//  Save the email panels as they appear in the tabbed pane
						
						EmailPanel emailpanel = (EmailPanel) tabbedpane.getComponentAt(i);
						
						//  Save the message states treemap for each email panel
						
						saveMessageStates(emailpanel.username, emailpanel.msgstatestreemap);
						
						String email = emailpanel.emailfield.getText().trim();
						
						String username = emailpanel.username;
						String userpass = emailpanel.userpass;
						
						int numberofciphers = emailpanel.numberofciphers;
						boolean usereplyaddresskey = emailpanel.usereplyaddresskey;
						
						Font font = emailpanel.textarea.getFont();
						
						boolean reverse_colors = emailpanel.reverse_colors;
						
						int   textrgb = emailpanel.foreground.getRGB();
						int screenrgb = emailpanel.background.getRGB();
						
						String incomingmailserver = emailpanel.incomingmailserver;
						String outgoingmailserver = emailpanel.outgoingmailserver;
						
						int incomingmailport = emailpanel.incomingmailport;
						int outgoingmailport = emailpanel.outgoingmailport;
						
						int messagesperscreen = emailpanel.messagesperscreen;
						
						boolean ascending = emailpanel.ascending;
						
						String tabtitle = emailpanel.tabtitle;
						
						if (!email.isEmpty())
						{
							list.add(__.email.toLowerCase());
							list.add(email);
						}
						
						if ((username != null) && !username.isEmpty())
						{
							list.add(__.username.toLowerCase());
							list.add(username);
						}
						
						if ((userpass != null) && !userpass.isEmpty())
						{
							list.add(__.userpass.toLowerCase());
							list.add(userpass);
						}
						
						if (textrgb != 0)
						{
							list.add(__.textrgb.toLowerCase());
							list.add(textrgb);
						}
						
						if (screenrgb != 0)
						{
							list.add(__.screenrgb.toLowerCase());
							list.add(screenrgb);
						}
						
						list.add(__.reverse_colors.toLowerCase());
						list.add(reverse_colors);
						
						if (font != null)
						{
							list.add(__.font.toLowerCase());
							list.add(font.getName() + "," + font
							    .getStyle() + "," + maxfontsize);
						}
						
						if ((titlename != null) && !titlename.isEmpty())
						{
							list.add(__.titlename.toLowerCase());
							list.add(titlename);
						}
						
						if ((incomingmailserver != null)
						 && !incomingmailserver.isEmpty())
						{
							list.add(__.incomingmailserver.toLowerCase());
							list.add(incomingmailserver);
						}
						
						if ((outgoingmailserver != null)
						 && !outgoingmailserver.isEmpty())
						{
							list.add(__.outgoingmailserver.toLowerCase());
							list.add(outgoingmailserver);
						}
						
						list.add(__.framesize.toLowerCase());
						list.add(frame.getSize().width +
						  "  " + frame.getSize().height);
						
						list.add(__.numberofciphers.toLowerCase());
						list.add(numberofciphers);
						
						list.add(__.usereplyaddresskey.toLowerCase());
						list.add(usereplyaddresskey);
						
						list.add(__.incomingmailport.toLowerCase());
						list.add(incomingmailport);
						
						list.add(__.outgoingmailport.toLowerCase());
						list.add(outgoingmailport);
						
						list.add(__.messagesperscreen.toLowerCase());
						list.add(messagesperscreen);
						
						list.add(__.ascending.toLowerCase());
						list.add(ascending);
						
						list.add(__.Showkeyboard.toLowerCase());
						list.add(showkeyboard);
						
						list.add(__.showsentemails.toLowerCase());
						list.add(showsentemails);
						
						list.add(__.mailcopytoself.toLowerCase());
						list.add(mailcopytoself);
						
						if (sendretrievepublickey)
						{
							list.add(__.sentpublickey.toLowerCase());
							list.add(sentpublickey);
						}
						
						if (!tabtitle.isBlank())
						{
							//  list.add(__.tabtitle.toLowerCase());
							//  list.add(tabtitle);
						}
						
						if (selectedindex == i)
						{
							list.add(__.selectedindex.toLowerCase());
							list.add(__.true_);
						}
						
						if (testmail)
						{
							list.add(__.testmail.toLowerCase());
							list.add(testmail);
						}
					}
				}
				
				catch (Exception ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				
				if ((SP == null) || SP.isEmpty()) return false;
				
				String filepath = passphraseToFilePath(__.usernames, SP);
				
				File file = new File(filepath);
				
				if (!file.exists())
				
				try { file.createNewFile(); }
				
				catch (IOException ex)
				{
					ex.printStackTrace();
					
					return false;
				}
				
				//  Save the data as an encrypted file
				
				String str = "";
				
				for (Object object : list) str += object + "\n";
				
				byte[] plaindata = str.getBytes();
				
				byte[] cipherdata = Cipher.encrypt(plaindata,
				
				    Cipher.passphraseToKey(SP));
				
				try { DataStream.write(file, cipherdata); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				readmailsettings = false;
				
				return true;
			}
			
			
			
			
			private class ViewSavedEmailsListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if ((emailpanel == null) ||
					
					    (emailpanel.username == null)) return;
					
					if (emailpanel.savedemails == null)
					
					    emailpanel.savedemails = new SavedEmails(emailpanel.username);
					
					emailpanel.savedemails.viewSavedEmails();
					
					emailpanel.savedemails.setForeground(emailpanel.foreground);
					emailpanel.savedemails.setBackground(emailpanel.background);
					emailpanel.savedemails.setFont(font);
				}
			}
			
			
			
			
			private class SavedEmails
			{
			
				//   __________________________________________
				//  | |       ________________________       | |
				//  | |      |________________________|      | |
				//  | |______________________________________| |
				//  | |_[][__]__day month year_______________| |
				//  | |                                      | |
				//  | |           message text 1             | |
				//  | |                                      | |
				//  | |______________________________________| |
				//  | |_[][__]__day month year_______________| |
				//  | |                                      | |
				//  | |           message text 2             | |
				//  | |                                      | |
				//  | |______________________________________| |
				//  | |_[][__]__day month year_______________| |
				//  | |                                      | |
				//  | |           message text 3             | |
				//  | |                                      | |
				//  | |______________________________________| |
				//  | |_[][__]__day month year_______________| |
				//  | |                                      | |
				//  | |           message text 4             | |
				//  | |                                      | |
				//  | |______________________________________|_|
				//  |_|_____________Close button_____________|_|
				
				
				private JDialog dialog;
				private JTextField findfield;
				private JButton closebutton;
				
				private JPanel[] panels;
				private JLabel[] datelabels;
				private JLabel[] textlabels;
				private JCheckBox[] deleboxes;
				private JButton[] editbuttons;
				
				private JScrollPane[] scrollpanes;
				private JTextArea[] textareas;
				
				private String[] messages;
				private String[][] filedescs;
				private byte[][][] filedatas;
				
				private int[] numberoffiles;
				private int[][] viewpos;
				private int[][] savepos;
				private int[][] delepos;
				
				private Boolean[] edited;
				private Boolean[] encrypted;
				
				private Component[][] components;
				
				private JScrollPane scrollpane;
				
				private String dirname;
				private String username;
				
				private String[] filenames;
				
				private Calendar cal = Calendar.getInstance();
				
				private MouseListener1 mouselistener1;
				
				
				public SavedEmails(String username)
				{
					this.username = username;
					
					String userhash = Cipher.hash2(username).substring(0, 8);
					
					dirname = maildirectory + File.separator + userhash;
					
					if (!new File(maildirectory).exists())
					     new File(maildirectory).mkdir();
					
					File dir = new File(dirname);
					if (!dir.exists()) dir.mkdir();
					
					mouselistener1 = new MouseListener1();
				}
				
				
				
				private String messageToFilePath(String message)
				{
					String filehash = Cipher.hash2(message).substring(0, 12);
					
					String filepath = dirname + File.separator + filehash;
					
					return filepath;
				}
				
				
				public boolean isSavedMessage(String message, String attachedtext)
				{
					if (attachedtext == null) attachedtext = "";
					
					String filepath = messageToFilePath(message);
					
					File file = new File(filepath);
					
					if (!file.exists()) return false;
					
					String text;
					
					try { text = readAndDecrypt(file); }
					
					catch (IOException ex)
					
					    { System.out.println(ex); return false; }
					
					if (Number.isBase64(text))
					
					    text = Convert.base64ToString(text);
					
					return text.contains(message) &&
					       text.contains(attachedtext);
				}
				
				
				
				
				public void saveMessage(String message,
				
					String attachedfiletext, String from, String subj) throws IOException
				{
					//  This method saves a message to file so the user can
					//  search previous email messages if they are deleted
					//  from the email server
					//
					//  Each message can be saved as a separate file using
					//  a 12-digit file number which equals the hash of the
					//  email message. The user could save the message with
					//  or without the attached files.
					
					
					String filehash = Cipher.hash2(message).substring(0, 12);
					
					String filepath = dirname + File.separator + filehash;
					
					File file = new File(filepath);
					
					if ((attachedfiletext != null) && !attachedfiletext.isBlank())
					{
						//  Convert the message to base 64 and append the file text
						
						if (message.trim().isEmpty()) message = "    ";
						
						message += "\n\n" + attachedfiletext;
					}
					
					
					if ((subj != null) && !subj.isEmpty())
					{
						//  Prepend the subject
						
						if (subj.length() < 16)
						
						    message = subj + "  " + message;
						
						else message = subj + "\n\n" + message;
					}
					
					//  Append the sender's address to the message
					
					message += "\n\n\n" + from;
					
					
					saveMessage(message, file);
				}
				
				
				
				private void saveMessage(String message, File file) throws IOException
				{
				
					long time = 0;
					
					if (!file.exists())
					
					     file.createNewFile();
					
					else if (file.exists())
					
					    time = file.lastModified();
					
					
					//  Encrypt the message and write to file
					
					byte[] plaindata = message.getBytes();
					
					byte[] cipherdata = Cipher.encrypt(
					
					    plaindata, Cipher.passphraseToKey(SP));
					
					
					//  Write the cipherdata to file
					//  and restore the last file time
					
					DataStream.write(file, cipherdata);
					
					if (time > 0) file.setLastModified(time);
				}
				
				
				
				
				private String readAndDecrypt(File file) throws IOException
				{
					//  Read the cipherdata from file
					
					byte[] cipherdata = DataStream.read(file);
					
					//  Decrypt the cipherdata
					
					//  The user may have decrypted the mail directory using
					//  the text editor and passphrase so we have to test if
					//  the file is unencrypted before decrypting
					
					boolean encrypted = Cipher.isEncrypted(cipherdata);
					
					byte[] plaindata = cipherdata;
					
					if (encrypted)
					{
						plaindata = Cipher.decrypt(cipherdata,
						
						    Cipher.passphraseToKey(SP));
						
						if (plaindata == null)
						
						    throw new IOException();
					}
					
					return new String(plaindata);
				}
				
				
				
				public void viewSavedEmails()
				{
				
					//  Initialize the saved emails directory
					//
					//  /home/user/Mail/Messages/userhash
					
					if ((username == null) || username.isEmpty()) return;
					
					
					File dir = new File(dirname);
					
					if (!dir.exists()) return;
					
					
					//  List the saved file names
					
					filenames = dir.list();
					
					int t = filenames.length;
					
					if (t == 0) return;
					
					
					//  Sort the files by last modified time
					
					TreeMap<Long, String> treemap = new
					TreeMap<Long, String>();
					
					for (int i = 0; i < filenames.length; i++)
					{
						String filename = filenames[i];
						String path = dir + File.separator + filename;
						Long filetime = new File(path) .lastModified();
						treemap.put(filetime, filename);
					}
					
					Set<Long>          keyset = treemap.keySet();
					Collection<String> values = treemap.values();
					
					ArrayList<String> filenameslist = new ArrayList<String>();
					
					for (String v : values) filenameslist.add(v);
					
					for (int i = 0; i < filenames.length; i++)
					
					    filenames[filenames.length-1 -i] = filenameslist.get(i);
					
					
					//  Create the dialog
					
					createDialog(t);
					
					
					
					//  Read and decrypt the saved emails
					
					//  (Note that if the user changes the passphrase,
					//  the saved messages will be undecryptable unless
					//  the program re-encrypts the messages.)
					
					for (int i = 0; i < t; i++)
					{
						String path = dir + File.separator + filenames[i];
						
						File file = new File(path);
						
						long time = file.lastModified();
						
						boolean encrypted = Cipher.isEncrypted(file);
						
						
						//  Read and decrypt the file data
						
						String plaintext;
						
						try { plaintext = readAndDecrypt(file); }
						
						catch (IOException ex)
						
						    { System.out.println(ex); continue; }
						
						
						readMessage(plaintext, i);
						
						//  Set the saved email in the text area
						
						displayMessage(i);
						
						this.encrypted[i] = encrypted;
						
						if (!encrypted) textlabels[i]
						
						    .setText(__.unencrypted);
						
						
						//  Initialize the calendar time
						
						cal.setTimeInMillis(time);
						
						//  Convert the calendar to date
						//  and set the label text
						
						String date = getDate(cal);
						
						JLabel datelabel = datelabels[i];
						
						datelabel.setText(String.valueOf(date));
					}
					
					
					Dimension d0 = Toolkit.getDefaultToolkit().getScreenSize();
					
					int width  = (int) (d0.getWidth()  * 5/10);
					int height = (int) (d0.getHeight() * 9/10);
					
					dialog.setSize(width, height);
					
					//  set visible is done last so the user doesn't
					//  see a collapsed frame for a second until the
					//  dialog frame is packed or resized. (Note that
					//  set visible doesn't block for this dialog be-
					//  cause modal is false.)
					
					dialog.setVisible(true);
				}
				
				
				
				private void readMessage(String plaintext, int index)
				{
					if (Number.isBase64(plaintext))
					
					    plaintext = Convert.base64ToString(plaintext);
					
					String[] tokens = plaintext.split("\n\n");
					
					boolean attachedfiles = tokens.length > 1;
					
					for (String token : tokens)
					
					    if (!Number.isBase64(token.trim()))
					
						{ attachedfiles = false;  break; }
					
					if (!attachedfiles)
					
					    messages[index] = plaintext;
					
					else // if (attachedfiles)
					{
						String message = tokens[0];
						
						if (Number.isBase64(message))
						
						    message = Convert.base64ToString(message);
						
						messages[index] = message;
						
						ArrayList<String> filedesclist = new ArrayList<String>();
						ArrayList<byte[]> filedatalist = new ArrayList<byte[]>();
						
						for (int i = 1; i < tokens.length; i+=2)
						{
							if (i+1 == tokens.length) return;
							
							String filedesc = Convert.base64ToString(tokens[i]);
							byte[] filedata = Convert.base64ToByteArray(tokens[i+1]);
							
							filedesclist.add(filedesc);
							filedatalist.add(filedata);
						}
						
						int numberoffiles = filedesclist.size();
						
						this.numberoffiles[index] = numberoffiles;
						
						filedescs[index] = new String[numberoffiles];
						filedatas[index] = new   byte[numberoffiles][];
						
						for (int i = 0; i < numberoffiles; i++)
						{
							filedescs[index][i] = filedesclist.get(i);
							filedatas[index][i] = filedatalist.get(i);
						}
					}
				}
				
				
				private void displayMessage(int index)
				{
					//  Constructs a file header and message string
					//  and displays the message in the text area
					
					//  Append the view attached file == [ view ]
					//         the save attached file == [ save ]
					//         the dele attached file == [ x ]
					//
					//  1. Attached File  [ view ] [ save ] [ x ]
					//
					//  2. Attached File  [ view ] [ save ] [ x ]
					//
					//  3. Attached File  [ view ] [ save ] [ x ]
					
					int numberoffiles = this.numberoffiles[index];
					
					StringBuilder sb = new StringBuilder();
					
					for (int i = 0; i < numberoffiles; i++)
					{
						if (i == 0) sb.append("\n");
						
						if (i < 10) sb.append(String.valueOf(
						   (i < 9) ? i + 1 : 0) + ". ");
						
						sb.append(__.AttachedFile + "  ");
						sb.append(__.viewattachedfile + "  ");
						sb.append(__.saveattachedfile + "  ");
						sb.append(__.deleattachedfile);
						
						if (i < numberoffiles -1)
						
						     sb.append("\n\n");
						else sb.append("\n");
					}
					
					if (!sb.toString().isBlank()) sb.append("\n\n");
					
					//  Display the heading and message
					
					sb.append(messages[index]);
					
					String text = sb.toString();
					
					JTextArea textarea = textareas[index];
					textarea.setText(text);
					textarea.setCaretPosition(0);
					
					
					//  Find and set the caret positions of
					//  __.viewattachedfile = "[ view ]",
					//  __.saveattachedfile = "[ save ]",
					//  __.deleattachedfile = "[ x ]",
					
					if (numberoffiles > 0)
					{
						viewpos[index] = new int[numberoffiles];
						savepos[index] = new int[numberoffiles];
						delepos[index] = new int[numberoffiles];
						
						viewpos[index][0] = text.indexOf(__.viewattachedfile);
						savepos[index][0] = text.indexOf(__.saveattachedfile);
						delepos[index][0] = text.indexOf(__.deleattachedfile);
						
						for (int i = 1; i < numberoffiles; i++)
						{
							viewpos[index][i] = text.indexOf(__.viewattachedfile, viewpos[index][i-1] + 1);
							savepos[index][i] = text.indexOf(__.saveattachedfile, savepos[index][i-1] + 1);
							delepos[index][i] = text.indexOf(__.deleattachedfile, delepos[index][i-1] + 1);
						}
					}
				}
				
				
				
				public boolean isDecryptable(String SP)
				{
					//  Each time the user enters a passphrase, the passphrase
					//  listener can test if the passphrase has changed by try-
					//  ing to decrypt the emails for the different usernames /
					//  emailpanels and can prompt the user to enter the old
					//  passphrase in a JOptionPane so that the saved emails
					//  or files can be re-encrypted; otherwise the previous
					//  saved emails and the new saved emails would only be
					//  decryptable using different passphrases.
					
					//  returns true if there are no files or
					//  at least a few files are decryptable
					
					
					File dir = new File(dirname);
					
					if (!dir.exists()) return true;
					
					
					//  List the saved file names
					
					String[] filenames = dir.list();
					
					int t = filenames.length;
					
					if (t == 0) return true;
					
					//  Only a few files have to be tested
					
					for (int i = 0; (i < t) && (i < 10); i++)
					{
						String path = dir + File.separator + filenames[i];
						
						File file = new File(path);
						
						byte[] cipherdata;
						
						try { cipherdata = DataStream.read(file); }
						
						catch (IOException ex)
						{
							System.out.println(ex);
							
							continue;
						}
						
						//  The user may have decrypted the mail directory using
						//  the text editor and passphrase so we have to test if
						//  the file is unencrypted before decrypting
						
						if (!Cipher.isEncrypted(cipherdata))
						
						    return true;
						
						byte[] plaindata = Cipher.decrypt(
						
						    cipherdata, Cipher.passphraseToKey(SP));
						
						if (plaindata == null)
						
						    return false;
					}
					
					return true;
				}
				
				
				
				public void reencryptFiles(
				
					String oldpassphrase, String newpassphrase)
				{
					File dir = new File(dirname);
					
					if (!dir.exists()) return;
					
					String[] filenames = dir.list();
					
					int t = filenames.length;
					
					if (t == 0) return;
					
					System.out.println("re-encrypting saved emails");
					
					for (int i = 0; i < t; i++)
					{
						String path = dir + File.separator + filenames[i];
						
						File file = new File(path);
						
						long time = file.lastModified();
						
						
						//  Read the cipherdata from file and decrypt
						
						byte[] cipherdata;
						
						try { cipherdata = DataStream.read(file); }
						
						catch (IOException ex)
						{
							System.out.println(ex);
							
							continue;
						}
						
						byte[] plaindata = Cipher.decrypt(cipherdata,
						
						    Cipher.passphraseToKey(oldpassphrase));
						
						if (plaindata == null)  continue;
						
						
						//  Encrypt the plaindata
						
						cipherdata = Cipher.encrypt(plaindata,
						
						    Cipher.passphraseToKey(newpassphrase));
						
						//  Write the data to file and restore the file time
						
						try
						{	DataStream.write(file, cipherdata);
							
							file.setLastModified(time);
						}
						
						catch (IOException ex)
						{
							System.out.println(ex);
							
							continue;
						}
					}
				}
				
				
				private String getDate(Calendar cal)
				{
					DateFormatSymbols dfs = new DateFormatSymbols();
					
					String[] months = dfs.getMonths();
					String[]   days = dfs.getWeekdays();
					
					String dayofweek = days[cal.get(Calendar.DAY_OF_WEEK) -1];
					String    month = months[cal.get(Calendar.MONTH)];
					
					String day = String.valueOf(
					
					   cal.get(Calendar.DAY_OF_MONTH) );
					
					int year = cal.get(Calendar.YEAR);
					
					String str = day + " " + month + " " + year;
					
					return str;
				}
				
				
				
				public void setVisible(boolean bool)
				{
					if (dialog != null)
					
					    dialog.setVisible(bool);
				}
				
				
				
				private void createDialog(int t)
				{
					if (dialog != null)
					{
						dialog.dispose();
						
						dialog = null;
					}
					
					JPanel panel = createPanel(t);
					
				 	dialog = new JDialog(frame);
					
					dialog.add(panel);
					dialog.setLocationRelativeTo(frame);
					dialog.setResizable(true);
					
					dialog.addWindowListener(new WindowListener1());
				}
				
				
				
				
				private class WindowListener1 extends WindowAdapter
				{
					public void windowClosing(WindowEvent e)
					{
						closebutton.doClick(100);
					}
				}
				
				
				private void deleteCheckedMessages()
				{
					for (int i = 0; i < deleboxes.length; i++)
					
					    if (deleboxes[i].isSelected()) new File(
					
						dirname + File.separator + filenames[i]) .delete();
				}
				
				
				private void saveEditedMessages()
				{
					for (int i = 0; i < textareas.length; i++)
					
					if (edited[i] || !encrypted[i])
					{
						if (textareas[i].isEditable())
						
						  editbuttons[i].doClick();
						
						String filename = dirname +
						
						    File.separator + filenames[i];
						
						File file = new File(filename);
						
						String text = messages[i];
						
						int numberoffiles = this.numberoffiles[i];
						
						if (numberoffiles > 0)
						{
							text = Convert.stringToBase64(text);
							
							text = text + "\n\n";
							
							for (int j = 0; j < numberoffiles; j++)
							
							    text += Convert.   stringToBase64(filedescs[i][j])
							 + "\n\n" + Convert.byteArrayToBase64(filedatas[i][j]) + "\n\n";
							
							text = text .trim();
						}
						
						try { saveMessage(text, file); }
						
						catch (IOException ex) { System.out.println(ex); }
					}
				}
				
				
				private JPanel createPanel(int t)
				{
					int rows = 16, cols = 52;
					
					int l_inset, r_inset;
					
					l_inset = r_inset = 100;
					
					Box vbox = Box.createVerticalBox();
					
					findfield = new JTextField(20);
					
					findfield.setFont(font);
					
					findfield.addKeyListener( new KeyAdapter()
					{
						private int index, cp1, cp2;
						
						public void keyTyped(KeyEvent e)
						{
							String text = findfield.getText();
							
							if (!text.isEmpty() && e.getKeyChar() == '\n')
							{
								boolean match = false;
								
								for (int i = index; i < t; i++)
								{
									String text1 = textareas[i].getText();
									
									cp1 = cp1 + 1;
									
									if (cp1 > text1.length())
									    cp1 = text1.length();
									
									cp1 = text1.indexOf(text, cp1);
									
									if (cp1 == -1) continue;
									
									cp2 = cp1 + text.length();
									
									index = i; match = true; break;
								}
								
								textareas[index].select(cp1, cp2);
								
								textareas[index].requestFocusInWindow();
								
								findfield.requestFocusInWindow();
								
								if ((index >= textareas.length -1) && !match) index = 0;
								
								for (int i = 0; i < t; i++)
								
								    panels[i].setVisible(
								
									(i == index) || !match);
							}
							
							else for (int i = 0; i < t; i++)
							
							    panels[i].setVisible(true);
						}
					} );
					
					
					     panels = new JPanel[t];
					 datelabels = new JLabel[t];
					  deleboxes = new JCheckBox[t];
					editbuttons = new JButton[t];
					scrollpanes = new JScrollPane[t];
					  textareas = new JTextArea[t];
					
					     edited = new Boolean[t];
					  encrypted = new Boolean[t];
					 textlabels = new JLabel[t];
					
					   messages = new String[t];
					
					viewpos = new int[t][];
					savepos = new int[t][];
					delepos = new int[t][];
					
					numberoffiles = new int[t];
					filedescs = new String[t][];
					filedatas = new   byte[t][][];
					
					components = new Component[t][];
					
					for (int i = 0; i < t; i++)
					{
						     panels[i] = new JPanel();
						 datelabels[i] = new JLabel();
						  deleboxes[i] = new JCheckBox();
						editbuttons[i] = new JButton();
						  textareas[i] = new JTextArea(rows, cols);
						
						   edited[i] = Boolean.valueOf(false);
						 encrypted[i] = Boolean.valueOf(false);
						textlabels[i] = new JLabel();
						
						datelabels[i].setFont(labelfont);
						textlabels[i].setFont(labelfont);
						
						
						JTextArea textarea = textareas[i];
						
						textarea.setEditable(false);
						textarea.setLineWrap(true);
						textarea.setWrapStyleWord(true);
						textarea.setFont(font);
						
						textarea.addMouseListener(mouselistener1);
						
						JScrollPane scrollpane = new JScrollPane(textarea);
						
						scrollpane.setHorizontalScrollBarPolicy(
						    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
						
						scrollpane.setVerticalScrollBarPolicy(
						    JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
						
						scrollpanes[i] = scrollpane;
						
						
						JPanel panel = panels[i];
						
						panel.setLayout(new GridBagLayout());
						
						//  [x]  day month year
						
						JCheckBox delebox = deleboxes[i];
						
						delebox.setToolTipText(__.delete);
						
						delebox.addActionListener(new ActionListener()
						{ public void actionPerformed(ActionEvent e)
						{ textarea.setEnabled(!delebox.isSelected()); } });
						
						
						JButton editbutton = editbuttons[i];
						editbutton.setIcon(editicon);
						editbutton.setToolTipText(__.edit);
						
						editbutton.addActionListener(new ActionListener()
						{   public void actionPerformed(ActionEvent e)
						    {   for (int i = 0; i < editbuttons.length; i++)
							{   if (e.getSource() == editbuttons[i])
							    {   edited[i] = Boolean.valueOf(true);
								JTextArea textarea = textareas[i];
								textarea.setEditable(!textarea.isEditable());
								if (textarea.isEditable() && (numberoffiles[i] > 0))
								{   textarea.setText(messages[i]);
								    textarea.setCaretPosition(0);
								}
								else if (!textarea.isEditable())
								{   messages[i] = textarea.getText();
								    displayMessage(i);
								}
								break;
							    }
							}
						    }
						});
						
						
						
						//  Add the delete box, edit button,
						//
						//  date label, and text label
						
						
						JLabel datelabel = datelabels[i];
						JLabel textlabel = textlabels[i];
						
						components[i] = new Component[]
						{
							delebox, editbutton,
							datelabel, textlabel,
						};
						
						Box hbox = Box.createHorizontalBox();
						
						hbox.add(delebox);
						hbox.add(Box.createHorizontalStrut(20));
						
						hbox.add(editbutton);
						hbox.add(Box.createHorizontalStrut(20));
						
						hbox.add(datelabel);
						hbox.add(Box.createHorizontalStrut(20));
						
						hbox.add(textlabel);
						hbox.add(Box.createHorizontalStrut(20));
						
						
						
						//  Add a large inset to the left and right margin of
						//  each text area's scrollpane so the user can scroll
						//  through all the messages using the mouse without
						//  widening the window.
						//
						//  Also, set the x weight to 100 so the user can widen
						//  and narrow the text areas by widening and narrowing
						//  the window frame;
						//
						//  and set the y size so the user notices that the mes-
						//  sage buttons and labels expand if the user types and
						//  enters a search string and then contract as the user
						//  deletes the search string; otherwise the user might
						//  not notice or realize that the message panes disap-
						//  pear whenever a search string is entered and then
						//  reappear when the search string is deleted.
						
						
						int y_size = 20;
						
						Gbc gbc = new Gbc();
						
						gbc.setPosition(0, 0);
						gbc.setSize(100, y_size);
						gbc.setAnchor(Gbc.center);
						gbc.setFill(Gbc.horizontal);
						gbc.setWeight(100, y_size);
						gbc.setInsets(0, l_inset, 0, r_inset);
						
						panel.add(hbox, gbc);
						
						
						gbc = new Gbc();
						
						gbc.setPosition(0, y_size);
						gbc.setSize(100, 100 - y_size);
						gbc.setAnchor(Gbc.center);
						gbc.setFill(Gbc.both);
						gbc.setWeight(100, 100 - y_size);
						gbc.setInsets(0, l_inset, 0, r_inset);
						
						panel.add(scrollpane, gbc);
						
						
						vbox.add(panel);
					}
					
					
					//  Create a close button / panel
					
					String closebuttontext = __.close;
					
					closebutton = new JButton(closebuttontext);
					
					closebutton.setFont(labelfont);
					
					closebutton.addActionListener(new ActionListener()
					{ public void actionPerformed(ActionEvent e)
					{ deleteCheckedMessages();
					  saveEditedMessages();
					  dialog.setVisible(false);
					  dialog = null;
					} });
					
					
					//  Add the vertical box to the scrollpane
					
					scrollpane = new JScrollPane(vbox);
					
					scrollpane.setHorizontalScrollBarPolicy(
					    JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
					
					scrollpane.setVerticalScrollBarPolicy(
					    JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
					
					JScrollBar scrollbar = scrollpane.getVerticalScrollBar();
					
					scrollbar.setUnitIncrement(32);
					
					
					//  Create a panel to hold the find field,
					//  the scrollpane, and the close button
					
					JPanel panel = new JPanel();
					
					panel.setLayout(new GridBagLayout());
					
					JPanel findpanel = new JPanel();
					
					findpanel.add(findfield);
					
					
					Gbc gbc;
					
					gbc = new Gbc();
					gbc.setPosition(0, 0);
					gbc.setSize(100, 5);
					gbc.setFill(Gbc.horizontal);
					gbc.setWeight(100, 5);
					
					panel.add(findpanel, gbc);
					
					gbc = new Gbc();
					gbc.setPosition(0, 5);
					gbc.setSize(100, 90);
					gbc.setFill(Gbc.both);
					gbc.setWeight(100, 90);
					
					panel.add(scrollpane, gbc);
					
					gbc = new Gbc();
					gbc.setPosition(0, 95);
					gbc.setSize(100, 5);
					gbc.setFill(Gbc.horizontal);
					gbc.setWeight(100, 5);
					gbc.setInsets(5, l_inset, 5, r_inset);
					
					panel.add(closebutton, gbc);
					
					return panel;
				}
				
				
				
				private class MouseListener1 extends MouseAdapter
				{
					int viewwidth = __.viewattachedfile.length();
					int savewidth = __.saveattachedfile.length();
					int delewidth = __.deleattachedfile.length();
					
					public void mouseClicked(MouseEvent e)
					{
						if (e.getSource() instanceof JTextArea)
						{
							int index = 0;
							
							for (int i = 0; i < textareas.length; i++)
							
							    if (e.getSource() == textareas[i]) index = i;
							
							int cp = ((JTextArea) e.getSource()) .getCaretPosition();
							
							
							JTextArea textarea = textareas[index];
							
							int numberoffiles1 = numberoffiles[index];
							
							if  (!textarea.isEditable() && (numberoffiles1 > 0))
							
							for (int i = 0; i < numberoffiles1; i++)
							{
								if ( (cp >= viewpos[index][i]) && (cp < viewpos[index][i] + viewwidth) )
								{
									//  View the attached file(s)
									
									viewAttachedFile(filedescs[index][i], filedatas[index][i]);
								}
								
								else if ( (cp >= savepos[index][i]) && (cp < savepos[index][i] + savewidth -1) )
								{
									//  Save the attached file(s)
									
									saveAttachedFile(filedescs[index][i], filedatas[index][i]);
							        }
								
								else if ( (cp >= delepos[index][i]) && (cp < delepos[index][i] + delewidth -1) )
								{
									//  Delete the attached file(s)
									
									String str = __.deletefile + " ?";
									
									String filedesc = filedescs[index][i];
									
									int maxfilename = 36;
									
									if (filedesc.length() > maxfilename) filedesc
									
									    = filedesc.substring(0, maxfilename) + "..";
									
									str += "\n" + filedesc;
									
									int choice = JOptionPane.showConfirmDialog(
									
									    dialog, str, "", JOptionPane.YES_NO_CANCEL_OPTION,
									
										JOptionPane.WARNING_MESSAGE, null);
									
									if (choice == JOptionPane.YES_OPTION)
									{
										//  Delete the file desc and file data
										
										filedescs[index][i] = null;
										filedatas[index][i] = null;
										
										int t = numberoffiles[index];
										
										String[] filedescs1 = new String[t-1];
										byte[][] filedatas1 = new   byte[t-1][];
										
										int[] viewpos1 = new int[t-1];
										int[] savepos1 = new int[t-1];
										int[] delepos1 = new int[t-1];
										
										for (int j = 0, k = 0; j < t; j++)
										
										if ((filedescs[index][j] != null)
										 && (filedatas[index][j] != null))
										{
											filedescs1[k] = filedescs[index][j];
											filedatas1[k] = filedatas[index][j];
											
											viewpos1[k] = viewpos[index][j];
											savepos1[k] = savepos[index][j];
											delepos1[k] = delepos[index][j]; k++;
										}
										
										filedescs[index] = filedescs1;
										filedatas[index] = filedatas1;
										
										viewpos[index] = viewpos1;
										savepos[index] = savepos1;
										delepos[index] = delepos1;
										
										numberoffiles[index]--;
										
										edited[index] = true;
										
										displayMessage(index);
										
										break;
									}
								}
							}
						}
					}
				}
				
				
				public void setFont(Font font)
				{
				
					if ((dialog == null) || (textareas == null)) return;
					
					if (textareas != null)
					
					   for (JTextArea textarea : textareas)
					
					      textarea.setFont(font);
					
					float labelfontsize = font.getSize() - 4.0f;
					
					
					for (Component[] comparray : components)
					
					    for (Component comp : comparray)
					
						if (comp instanceof JLabel)
						
						    ((JLabel) comp).setFont(font
						
							.deriveFont(labelfontsize));
					
					
					findfield.setFont(font);
					
					
					//  Set the font for the Documents dialogs
					
					Documents.setFont(font);
				}
				
				
				
				public void setForeground(Color color)
				{
					if ((dialog == null) || (textareas == null)) return;
					
					for (JTextArea textarea : textareas)
					{
						if (!emailpanel.reverse_colors)
						{
						     textarea.setForeground(color);
						     textarea.setCaretColor(color);
						}
						
						else textarea.setBackground(color);
					}
				}
				
				public void setBackground(Color color)
				{
					if ((dialog == null) || (textareas == null)) return;
					
					for (JTextArea textarea : textareas)
					{
						if (!emailpanel.reverse_colors)
						
							textarea.setBackground(color);
						
						else
						{	textarea.setForeground(color);
							textarea.setCaretColor(color);
						}
					}
				}
			}
			
			
			//  End class SavedEmails
			
			
			
			
			
			
			
			
			private class UndeleteListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					if (emailpanel.popmail != null)
					{
						int choice = JOptionPane.showConfirmDialog(
						
						    frame, __.resetmailserver + " ?");
						
						if (choice != JOptionPane.YES_OPTION) return;
						
						System.out.println("Resetting server");
						
						try { emailpanel.popmail.reset(); }
						
						catch (IOException ex)
						
						    { System.out.println(ex); }
					}
				}
			}
			
			
			
			
			private class CheckAllListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e) { run(); }
				
				public void run()
				{
					//  Check or uncheck the boxes
					
					//  If less than half the boxes are checked, check all
					//  If more than half the boxes are checked, uncheck all
					
					if (!emailpanel.listscreen || (emailpanel.listpanel == null)) return;
					
					int numberofmessages = emailpanel.listpanel.getNumberOfMessages();
					
					int numberofvisiblechecks = 0;
					
					for (int i = 0; i < numberofmessages; i++)
					{
						if (!emailpanel.listpanel.isVisible(i)) continue;
						if  (emailpanel.listpanel.checkboxes[i].isSelected())
						
						    numberofvisiblechecks++;
					}
					
					int numbervisible = 0;
					
					for (int i = 0; i < numberofmessages; i++)
					
					    if (emailpanel.listpanel.isVisible(i))
					
					    numbervisible++;
					
					boolean check_uncheck =
					
					    (numbervisible / (numberofvisiblechecks + 1)) > 2;
					
					for (int i = 0; i < numberofmessages; i++)
					{
						//  Skip the hidden messages
						
						if (!emailpanel.listpanel.isVisible(i)) continue;
						
						emailpanel.list1.setDeleteBox(i, check_uncheck);
						
						emailpanel.listpanel.checkboxes[i].setSelected(check_uncheck);
					}
				}
			}
			
			
			
			private class CopyListener implements ActionListener
			{
				public void actionPerformed(ActionEvent e)
				{
					emailpanel.textarea.copy();
				}
			}
			
			
			
			private class SetTitleListener implements ActionListener
			{
				private int maxfontsize = 24;
				
				public void actionPerformed(ActionEvent e)
				{
					JTextField textfield = new JTextField(16);
					
					float fontsize = font.getSize();
					
					if (fontsize > maxfontsize) fontsize = maxfontsize;
					
					textfield.setFont(font.deriveFont(fontsize));
					
					textfield.setForeground(emailpanel.foreground);
					textfield.setCaretColor(emailpanel.foreground);
					textfield.setBackground(emailpanel.background);
					
					String title = __.setprogramtitle;
					
					textfield.addKeyListener(new KeyAdapter()
					{
						public void keyReleased(KeyEvent e)
						{
							titlename = textfield.getText().trim();
							
							frame.setTitle(titlename);
							
							int maxlen = 20;
							
							aboutmenuitem.setText(__.about + " "
							
							  + ((titlename.length()   > maxlen) ?
							      titlename.substring(0, maxlen) : titlename));
						}
					});
					
					int messagetype = JOptionPane.PLAIN_MESSAGE;
					
					textfield.requestFocusInWindow();
					
					JOptionPane.showMessageDialog(frame,
					
					    new Object[] { textfield }, title, messagetype);
				}
			}
			
			
			
			
			private class SetTabTitleListener implements ActionListener
			{
				private int maxfontsize = 24;
				
				public void actionPerformed(ActionEvent e)
				{
					JTextField textfield = new JTextField(16);
					
					float fontsize = font.getSize();
					
					if (fontsize > maxfontsize) fontsize = maxfontsize;
					
					textfield.setFont(font.deriveFont(fontsize));
					
					textfield.setForeground(emailpanel.foreground);
					textfield.setCaretColor(emailpanel.foreground);
					textfield.setBackground(emailpanel.background);
					
					String title = __.settabtitle;
					
					textfield.addKeyListener(new KeyAdapter()
					{
						public void keyReleased(KeyEvent e)
						{
							String tabtitle = textfield.getText().trim();
							
							int index = tabbedpane.getSelectedIndex();
							
							tabbedpane.setTitleAt(index, tabtitle);
							
							emailpanel.tabtitle = tabtitle;
						}
					});
					
					int messagetype = JOptionPane.PLAIN_MESSAGE;
					
					textfield.requestFocusInWindow();
					
					JOptionPane.showMessageDialog(frame,
					
					    new Object[] { textfield }, title, messagetype);
				}
			}
			
			
			
			private class FindListener implements ActionListener
			{
				public FindListener() {  }
				
				public void actionPerformed(ActionEvent e) {  }
			}
			
			
			
			private class ButtonListener extends MouseAdapter implements ActionListener
			{
			
				private boolean clicked;
				
				private boolean connecting;
				private boolean decrypting;
				private boolean    listing;
				private boolean    reading;
				private boolean   deleting;
				private boolean   quitting;
				
				
				//  the threads that are created for listing, reading, and
				//  deleting; the subject thread is inside the list thread
				//  for decrypting and displaying the tops of the messages;
				//
				//  these references are not used because the Java Thread
				//  class doesn't provide a method for terminating, dispos-
				//  ing, or getting rid of threads that are blocked.
				
				
				private Thread listthread;
				private Thread readthread;
				private Thread delethread;
				
				private EmailPanel emailpanel;
				
				public ButtonListener(EmailPanel emailpanel)
				{
					this.emailpanel = emailpanel;
				}
				
				
				public void actionPerformed(ActionEvent e)
				{
				
					//  Each time the actionPerformed method returns and the
					//  finally block is executed, a thread is started that
					//  waits one second and then resets the click variable.
					//
					//  This allows multiple button clicks that may have ac-
					//  cumulated while executing the actionPerformed method
					//  to be consumed if the user keeps clicking on the
					//  clicked button;
					//
					//  and it "disables" the button for a second after the
					//  method has completed so the user doesn't accidentally
					//  perform the action twice by clicking on an unclicked
					//  button.
					
					
					
					//  This line consumes the button clicks that accumulated
					//  while the button was clicked until the finally thread
					//  resets the click variable.
					//
					//  This is used only for the List, Read All, and Sign out buttons.
					//
					//  For the Delete button, the click variable would prevent the
					//  method from functioning properly because the Delete button
					//  clicks the List or Read All button after deleting the checked
					//  messages to update the message or read all screen.
					
					if ((e.getSource() == emailpanel.listbutton)
					 || (e.getSource() == emailpanel.readbutton))
				     //  || (e.getSource() == emailpanel.quitbutton)
					
					
					    if (clicked) return;
					
					    else clicked = true;
					
					
					
					try
					{    //  The try block just disables and re-enables
					    //  the  list / read / delete / quit buttons
					   //  in the finally clause because these buttons
					  //  could accumulate multiple clicks if the user
					 //  keeps clicking the buttons.
					
					
					
					//  The list button uses the POP mail TOP command to read the message headers
					//  so that it can parse the headers for the senders' addresses and subjects.
					//
					//  This is more efficient than the RETR command to retrieve the messages
					//  because the size of a header is less than a few thousand bytes.
					//
					//  If the number of messages is set to 20, then the total data required is
					//  only around 50 kilobytes.
					//
					//  The POP mail LIST command is used to get the size of each message so
					//  the list screen can display the sizes without retrieving the messages.
					//  Then the user can decide which messages to retrieve based on the from
					//  address, the subject, and the message / file size.
					
					
					if (e.getSource() == emailpanel.listbutton)
					{
					
						if ((SP == null) || SP.isEmpty())
						{
							passphraselistener.run();
							
							return;
						}
						
						
						int fromlen = 24, subjlen = 44, textlen = 48;
						
						boolean[] newpopmail = new boolean[1];
						
						if (reading) return;
						
						if (listing) return;
						
						//  listing = true has to be outside of the thread so
						//  that it gets set immediately; otherwise it could
						//  take a couple of seconds and then methods that test
						//  this variable such as the setForeground and set-
						//  Background methods could get listing == false.
						
						listing = true;
						
						
						
						//  Create the list thread
						
						listthread = new Thread(() ->
						{
							//  System.out.print("\nlisting");
							
							try
							{	//  Disable the email field until the user
								//  clicks the sign out (log out) button
								
								emailpanel.emailfield.setEditable(false);
								
								
								if (emailpanel.popmail == null)
								{
								
									//  Make sure the user has entered a passphrase,
									//  a valid email address, an incoming mail server
									//  and an incoming mail port
									
									String errormsg = validateInput();
									
									if ((errormsg != null) && !errormsg.isEmpty())
									{
										//  Use a text area because some
										//  messages have newlines chars
										
										JTextArea messagearea = new JTextArea(errormsg);
										
										messagearea.setFont(labelfont);
										messagearea.setEditable(false);
										messagearea.setBackground(
										    new JLabel().getBackground());
										
										JOptionPane.showMessageDialog(frame,
										
										   messagearea, "", JOptionPane.ERROR_MESSAGE);
										
										emailpanel.emailfield.setEditable(true);
										
										return;
									}
									
									
									//  Create a new PopMail object for
									//  the current / selected email panel
									
									emailpanel.popmail = new PopMail(
									
									    emailpanel.incomingmailserver,
									    emailpanel.incomingmailport,
									    
									    emailpanel.username,
									    emailpanel.userpass,
									    emailpanel.ascending);
									
									//  Set newpopmail = true for the subject thread
									
									newpopmail[0] = true;
									
									
									//  Set the textarea for communication
									//  between the client and server
									
									emailpanel.popmail.setTextArea(emailpanel.poptextarea);
									
									
									//  Set the popmail testmail variables
									//
									//  the send test mail will use the recipient's encryption key
									//  that is pasted into the to field in the send mail frame
									//
									//  the receive test mail will use the number of ciphers set
									//  by the user in the reply key settings menu item
									
									if (testmail)
									{
										int numberofciphers = emailpanel.numberofciphers;
										
										emailpanel.popmail.setTestMail(testmail);
										emailpanel.popmail.setTestPassphrase(testpassphrase);
										emailpanel.popmail.setReplyPassphrase(replypassphrase);
										emailpanel.popmail.setNumberOfCiphers(numberofciphers);
									}
									
									
									//  Change the cursor from default to wait
									
									emailpanel.listbutton .setCursor(wait_cursor);
									emailpanel.quitbutton .setCursor(wait_cursor);
									emailpanel.textarea   .setCursor(wait_cursor);
									
									if (emailpanel.listpanel != null)
									    emailpanel.listpanel.setCursor(wait_cursor);
									
									
									//  Try to connect to the mail server for the first time
									
									int error = 0;
									
									try { error = emailpanel.popmail.connect(); }
									
									catch (IOException ex)
									{
										//  connection error
										
										emailpanel.listbutton .setCursor(default_cursor);
										emailpanel.textarea   .setCursor(default_cursor);
										
										if (emailpanel.listpanel != null)
										    emailpanel.listpanel.setCursor(default_cursor);
										
										JOptionPane.showMessageDialog(
										
										    frame, __.unabletoconnecttoserver, "",
										
											JOptionPane.ERROR_MESSAGE);
										
										emailpanel.popmail = null;
										
										emailpanel.emailfield.setEditable(true);
										
										return;
									}
									
									
									if (error != 0)
									{
										//  authentication error / wrong userpass
										
										emailpanel.listbutton .setCursor(default_cursor);
										emailpanel.textarea   .setCursor(default_cursor);
										
										if (emailpanel.listpanel != null)
										    emailpanel.listpanel.setCursor(default_cursor);
										
										
										String title = "";
										
										String message = __.wronguserpassorpop3maildisabled;
										
										Object[] options = { __.userpass }; // userpass button
										
										int choice = JOptionPane.showOptionDialog(frame,
										
										    message, title, JOptionPane.DEFAULT_OPTION,
										
										      JOptionPane.ERROR_MESSAGE, null, options, options[0]);
										
										if ((choice == JOptionPane.CANCEL_OPTION)
										 || (choice == JOptionPane.CLOSED_OPTION))
										
										    return;
										
										else userpasslistener.run();
										
										emailpanel.popmail = null;
										
										emailpanel.emailfield.setEditable(true);
										
										return;
									}
									
									
									//  Authorization was successful
									//
									//  set authorized = true so the
									//  user can reply to emails
									
									emailpanel.authorized = emailpanel.popmail.authorized;
									
									
									try
									{
									
									if (sendretrievepublickey && !sentpublickey)
									{
										//  Check if the email server has a copy of the public key
										
										String publickey = emailpanel.popmail.retrieve("");
										//  or publickey = emailpanel.popmail.retrieve(username);
										
										//  xxxxxxxxxx0123456789abcdefxxxxxxxxxx ...  or
										//  xxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxx ...
										
										System.out.println("my public server key == \n" + publickey);
										
										if ((publickey == null) || publickey.isEmpty()
										
										 || !PublicKey.isValidKey(publickey))
										{
											//  Prompt the user to send the user's key to the pop
											//  mail server so the user can receive encrypted messages
											
											String message = __.sendkeytoemailserver;
											
											int choice = JOptionPane.showConfirmDialog(frame,
											
											    message, "", JOptionPane.YES_NO_OPTION,
											
												JOptionPane.QUESTION_MESSAGE);
											
											if (choice == JOptionPane.YES_OPTION)
											{
												boolean bool = emailpanel.popmail.send(publickey);
												
												String error1 = __.errorsendingpublickey;
												
												boolean dontshowmessageagain = false;
												
												////  bool = false; // used for testing
												
												if (!bool) dontshowmessageagain =
												
												    showCheckBoxMessageDialog(frame,
												
													error1, __.dontshowthismessageagain);
												
												sentpublickey = dontshowmessageagain;
												
												System.out.println("don't show message again == " + sentpublickey);
											}
											
											else if (choice == JOptionPane.NO_OPTION)
											
											//  Don't keep prompting the user to send a public key
											//  if the key has already been sent or cannot be sent
											//  (The Send Public Key menu item will reset the sent-
											//  publickey variable if the key doesn't get sent.)
											
											    sentpublickey = true;
										}
									}
									
									
									//  STAT the number of messages and bytes
									
									int[] number_totalbytes;
									
									number_totalbytes = emailpanel.popmail.stat();
									
									
									int numberofmessages = number_totalbytes[0];
									
									//  Change the listbutton to inbox and no of msgs
									
									emailpanel.listbutton.setText(
									
									    __.Inbox + " " + numberofmessages);
									
									
									//  The number of messages on the server may
									//  be less than the messages per screen
									
									int t = Math.min(numberofmessages,
									
									    emailpanel.messagesperscreen);
									
									
									//  LIST the message numbers and bytes
									
									String[] listarray = emailpanel.popmail.list();
									
									
									
									//  Create a list1 object to store the headers and messages
									
									emailpanel.list1 = new ArrayList1();
									emailpanel.list1 .setSize(t);
									
									
									
									//  Read the message headers for the t newest messages
									//  to display the from and subject strings for each message
									
									
									//  Download the headers using the TOP (msno, lines) command
									//
									//  The program downloads the first ~ 256 lines x (approx)
									//  80 chars / line == 10 K chars == 20 K bytes to read the
									//  one-time public keys and the one-time encryption key.
									
									
									//  Set the no of top lines to read
									
									final int toplines  = 256;
									final int toplines1 = 512;
									
									for (int i = 0; i < t; i++)
									{
										if (quitting || (emailpanel.popmail == null)) return;
										
										//  Use the POP TOP command to read
										//  the email headers and message tops
										
										String poptop, header, top;
										
										poptop = emailpanel.popmail.top(i, toplines);
										
										
										//  Separate the header and message top
										
										int pos = poptop.indexOf("\n\n");
										
										if (pos == -1) continue; // error
										
										
										//  Read the header and top
										
										header = poptop.substring(0, pos);
										top    = poptop.substring(pos).trim();
										
										
										//  Test if the top includes some ciphertext so the
										//  the message can be partially decrypted to display
										//  the subject and the first lines of the message.
										//  If the public key is large, then the top will
										//  contain only the one-time public keys and the
										//  isEncrypted(str) method will return false.
										
										if (!PublicKey.isEncrypted(top))
										
										if (Number.isBase16(top.replaceAll("[ \t\n]", "")))
										{
											//  Re-read the header using more lines
											
											poptop = emailpanel.popmail.top(i, toplines1);
											
											pos = poptop.indexOf("\n\n");
											
											if (pos == -1) continue; // error
											
											header = poptop.substring(0, pos);
											top    = poptop.substring(pos).trim();
										}
										
										
										//  Remove any partitioning
										
										if (top.contains("\n") && !top.contains("\n\n"))
										
										    top = top .replaceAll("\n{1}", "") .trim();
										
										
										//  If the message uses the base-16 separator 0123456789abcdef
										//  replace the base-16 separator with the \n\n separator
										
										if (top.contains(Convert.base16Separator))
										
										    top = top.replaceAll(Convert.base16Separator, "\n\n");
										
										
										//  Remove any base-64 encoding
										
										if (Number.isBase64(top))
										
										    top = Convert.base64ToString(top);
										
										//  System.out.println("top == " + top.substring(0, 256));
										
										
										//  Save the header and message top
										
										emailpanel.list1.setHeader(i, header);
										emailpanel.list1.setTop(i, top);
										
										
										emailpanel.poptextarea.repaint();
										emailpanel.popscrollpane.repaint();
										pop3window.repaint();
									}
									
									
									//  Parse the headers array
									
									for (int i = 0; i < t; i++)
									{
										int size = 0;
										
										String header = emailpanel.list1.getHeader(i);
										
										if (header == null) continue;
										
										String firstline = header.trim();
										
										if (header.contains("\n")) firstline = firstline
										
										    .substring(0, header.trim() .indexOf("\n"));
										
										String[] tokens = firstline.split(" {1,}");
										
										for (String token : tokens)
										
										    if (Number.isDigitString(token.trim(), 10))
										
											try { size = Integer.parseInt(token.trim()); break; }
											
											catch (NumberFormatException ex) {  }
										
										EmailHeader emailheader = new EmailHeader(header);
										
										String date = emailheader.date;
										String from = emailheader.from;
										String subj = emailheader.subject;
										
										if (date == null) date = "";
										if (from == null) from = "";
										if (subj == null) subj = "";
										
										emailpanel.list1 .setDate(i, date);
										emailpanel.list1 .setFrom(i, from);
										emailpanel.list1 .setSubject(i, subj);
										
										//  Store the server number and size
										
										tokens = listarray[i].split(" {1,}");
										
										String numberstr, bytestr;
										String msgstatestr = "0";
										
										numberstr = tokens[0];
										bytestr   = tokens[1];
										
										if (tokens.length > 2)
										
										    msgstatestr = tokens[2];
										
										int number, bytes, msgstate;
										
										try
										{	number = Integer.parseInt(numberstr);
											bytes  = Integer.parseInt(bytestr);
											
											if (tokens.length > 2)
											{
												msgstate = Integer.parseInt(msgstatestr);
												emailpanel.list1.setMessageState(i, msgstate);
											}
										}
										
										catch (NumberFormatException ex)
										    { ex.printStackTrace(); continue; }
										
										
										
										//  Store the server message number and number of bytes
										//
										//  (The Popmail class has the responsibility of implementing
										//  the ascending / descending message order and translating the
										//  index number to the server message number. The other classes
										//  don't know anything about ascending / descending message
										//  order or server message numbers, except for the list panel
										//  code below that shows the user the server msno.)
										
										//  Set the server message number
										
										emailpanel.list1.setServerMessageNumber(i, i);
										emailpanel.list1.setNumberOfBytes(i, bytes);
									}
									
									}
									
									
									catch (Exception ex)
									{
										ex.printStackTrace();
										
										listing = false;
										
										//  listing has to equal false or else
										//  the program will deadlock if the
										//  quit button is clicked
										
										emailpanel.quitbutton.doClick();
										
										return;
									}
									
									
									
									//  Create a new list pane and message panel
									
									ListPanel listpanel = new ListPanel(emailpanel.list1.size());
									
									listpanel.setFont1(font);
									
									if (!emailpanel.reverse_colors)
									{
										listpanel.setForeground1(emailpanel.foreground);
										listpanel.setBackground1(emailpanel.background);
									}
									
									else // if (emailpanel.reverse_colors)
									{
										listpanel.setForeground1(emailpanel.background);
										listpanel.setBackground1(emailpanel.foreground);
									}
									
									JViewport viewport = emailpanel
									
									    .scrollpane1.getViewport();
									
									viewport.setView(listpanel);
									
									emailpanel.listpanel = listpanel;
								}
								
								
								
								else // if (emailpanel.popmail != null)
								{
									newpopmail[0] = false;
									
									int[] number_totalbytes;
									
									try { number_totalbytes = emailpanel.popmail.stat(); }
									
									//  This exception should never occur because if
									//  popmail != null then stat reads from local memory
									
									catch (IOException ex)
									{
										if (!emailpanel.buttonlistener.quitting)
										
										    System.out.println(ex);
										
										return;
									}
									
									catch (Exception ex)
									{
										emailpanel.popmail = null;
										
										emailpanel.emailfield.setEditable(true);
										
										return;
									}
								}
								
								
								//  Display a list of messages
								
								
								//  [ ]  1  Icon1  Icon2   Size   From..  Subject..  First line..
								//
								//  [ ]  2  Icon1  Icon2   Size   From..  Subject..  First line..
								//
								//  [ ]  3  Icon1  Icon2   Size   From..  Subject..  First line..
								//
								//  ...    ...     ...    ...    ...     ...      ...
								
								//  Long email addresses and subjects are truncated, shortened or
								//  abbreviated so that one message that has a long email address
								//  cannot widen the from column and push the subject column or
								//  message column to the right
								
								
								
								//  List screen requires the message panel
								
								emailpanel.scrollpane1.setVisible(true);
								emailpanel.scrollpane2.setVisible(false);
								emailpanel.scrollpane3.setVisible(false);
								
								
								
								//  Set the Msno, Icon1, Icon2, Size, From, Subject for each message
								
								String useraddress = emailpanel.username + "@" + emailpanel.userdomain;
								
								for (int i = 0; i < emailpanel.list1.size(); i++)
								{
									//  Skip the messages deleted from the server
									
									if (emailpanel.list1.isDeleted(i))
									
									    emailpanel.listpanel.setVisible(i, false);
									
									
									//  Read the from and subject from the list
									
									String from = emailpanel.list1.getFrom(i);
									String subj = emailpanel.list1.getSubject(i);
									
									if (from == null) from = "";
									if (subj == null) subj = "";
									
									
									//  Skip the self-addressed email messages (if the user hides them)
									
									if (!showsentemails && from.equals(useraddress))
									
									    emailpanel.listpanel.setVisible(i, false);
									
									
									//  Truncate the from and subject if the strings are too long
									
									if (from.length() > fromlen) from = from.substring(0, fromlen) + "..";
									if (subj.length() > subjlen) subj = subj.substring(0, subjlen) + "..";
									
									
									int msno = emailpanel.list1 .getServerMessageNumber(i);
									int size = emailpanel.list1 .getNumberOfBytes(i) / 1000;
									int ciphers = emailpanel.list1.getNumberOfCiphers(i);
									int replyciphers = emailpanel.list1.getNumberOfReplyCiphers(i);
									
									
									//  If the messages are in descending order then
									//  the msno = the number of messages -1 - msno
									
									if (!emailpanel.popmail.ascending)
									
									    msno = emailpanel.popmail.getNumberOfMessages() -1 - msno;
									
									//  Convert the size int to string and partition in groups of 3 digits
									
									String numberstr = String.valueOf(msno + 1);
									String   sizestr = String.valueOf(size);
									String cipherstr = String.valueOf(ciphers);
									
									    // + "/" + String.valueOf(replyciphers);
									
									//  if ((ciphers == 0) && (replyciphers == 0))
									
									if (true) cipherstr = "";
									
									sizestr = Convert.partition(sizestr, ",", -3);
									
									//  Pad with zeros so the size string is at least 4 chars
									
									while (sizestr.length() < 4)  sizestr = " " + sizestr;
									
									
									//  Set the check boxes for messages to be deleted
									
									emailpanel.listpanel.checkboxes[i].setSelected(
									
									    emailpanel.list1.getDeleteBox(i));
									
									
									//  Set the msg no, size, from, subj
									
									emailpanel.listpanel.msnolabels[i]  .setText(numberstr);
									emailpanel.listpanel.sizelabels[i]  .setText(sizestr);
									emailpanel.listpanel.cipherlabels[i].setText(cipherstr);
									emailpanel.listpanel.fromlabels[i]  .setText(from);
									emailpanel.listpanel.subjlabels[i]  .setText(subj);
									
									
									//  Set the icon 1 label
									
									if (emailpanel.list1.getNumberOfFiles(i) > 0)
									{
										emailpanel.listpanel.iconlabels1[i].setIcon(attachicon);
										emailpanel.listpanel.imageicons1[i] = attachicon;
									}
									
									
									//  Set the icon 2 label
									
									Integer messagestate = emailpanel.list1.getMessageState(i);
									
									if (messagestate == null) messagestate = Integer.valueOf(0);
									
									ImageIcon imageicon = imageicons2[messagestate];
									
									emailpanel.listpanel.iconlabels2[i].setIcon(imageicon);
									emailpanel.listpanel.imageicons2[i] = imageicon;
									
									
									//  Use the hash of (the from address + bytes) as a key
									//  and search a treemap for the message state value.
									//  If a value exists for the message state then set
									//  the image icon to show the saved message state.
									
									int bytes = emailpanel.list1.getNumberOfBytes(i);
									
									String key = Cipher.hash2(from + bytes);
									
									Integer stateno = null;
									
									if (emailpanel.msgstatestreemap != null)
									if (emailpanel.msgstatestreemap.containsKey(key))
									
									    stateno = emailpanel.msgstatestreemap.get(key);
									
									if (stateno != null)
									{
										//  Set the list1 message state variable and the
										//  icon to the previously saved message state
										
										//  Set the icon 2 label
										
										imageicon = imageicons2[stateno];
										
										emailpanel.listpanel.iconlabels2[i].setIcon(imageicon);
										emailpanel.listpanel.imageicons2[i] = imageicon;
									}
									
									//  Set the sent icon for self-addresses messages
									
									if (from.equals(useraddress))
									
									 // if (emailpanel.listpanel.iconlabels2[i].getIcon() == null)
									{
										emailpanel.listpanel.iconlabels2[i].setIcon(senticon);
										emailpanel.listpanel.imageicons2[i] = senticon;
									}
								}
								
								
								//  Display the list screen
								
								emailpanel   .listscreen = true;
								emailpanel.messagescreen = false;
								emailpanel.readallscreen = false;
								
								setFont1(font);
								
								tabbedpane.repaint();
							}
							
							
							finally
							{
								emailpanel.listbutton .setCursor(default_cursor);
								emailpanel.quitbutton .setCursor(default_cursor);
								emailpanel.textarea   .setCursor(default_cursor);
								
								if (emailpanel.listpanel != null)
								    emailpanel.listpanel.setCursor(default_cursor);
								
								listing = false;
								
								clicked = false;
							}
							
							
							
							
							
							//  The subject / message key decrypt thread for the list screen
							
							//  The following code starts a new thread to decrypt the partial
							//  ciphertexts to read the encrypted prepended subject lines until
							//  all the message keys have been decrypted (or popmail == null).
							
							
							//  The subject thread and the quit button method communicate
							//  with each other using the decrypting and quitting variables.
							//  The subject thread sets and resets the decrypting variable
							//  which the quit button can read and wait until !decrypting,
							//  and the quit button method sets the quitting variable which
							//  the subject thread can read and return if (quitting == true).
							
							
							
							//  In future versions, the subject thread could also read the sender's
							//  prepended from address if the program supports private email addresses.
							//
							//  A private address could be a name that has one or more space characters
							//  in it because an email address is not allowed to have spaces. It could
							//  also have other illegal characters such as '/' and ',' chars, or it
							//  could start with a '.' character.
							//
							//  To generate a private address, the program would compute a hash of the
							//  descriptive email name. For example, money launderer @ example.com would
							//  become 1a93781b@example.com. (The email address can start with a digit
							//  because nearly all email service providers allow email addresses to start
							//  with a digit.)
							//
							//  The subject thread would decrypt the prepended from address and then
							//  change the from label from the 8-digit public email address to the private
							//  descriptive email name so that the recipient would know who is writing to
							//  him or her. If the public address ends with digits, the digits could be
							//  replaced with the ellipsis ...
							//
							//  If the user replies to an email, the send mail frame would display the
							//  private email address in the to box and the public address above the box.
							//  If the user types a recipient's address, then if there is a space or other
							//  illegal character in the address field the frame would alert the user that
							//  the address is private and would display the public address / private
							//  email hash in a label above the to field.
							//
							//  The benefit of a private email address is that users could give out their
							//  descriptive email address and the 8-digit hash of the address (for example
							//  on a business card or by encrypted email if the user initiates an email
							//  communication), but only the hash of the private email would be sent over
							//  the internet.
							//
							//  A private email address would also allow people to use illegal or special
							//  characters to write their addresses any way they want to.
							
							
							
							
							
							
							//  The subject thread / message key decrypt thread
							
							if (newpopmail[0]) new Thread(() ->
							{
								try
								{
								// no indent for the try finally block
								
								//  Set decrypting to true so the quit button
								//  knows to wait until decrypting == false
								
								decrypting = true;
								
								for (int i = 0; i < emailpanel.list1.size(); i++)
								{
									if (quitting) return;
									
									String top = emailpanel.list1.getTop(i) .trim();
									
									if ((top != null) && !top.isEmpty())
									{
										boolean encrypted = false;
										
										if (PublicKey.isEncrypted(top))
										{
											//  Decrypt the partial ciphertext
											
											//  Note that the program has to read all the one-time
											//  public keys (and the composite secret key) of the
											//  message block to read the first line of the message.
											
											top = decryptMessage(emailpanel, top, i);
											
											if (top != null) top = top.trim(); else continue;
											
											//  Replace the encrypted top with the decrypted top
											
											emailpanel.list1.setTop(i, top);
											
											encrypted = true;
										}
										
										
										//  Read the prepended reply key, subject, and first
										//  line of text from the decrypted message top
										
										String[] tokens = splitBase64Encoding(top);
										
										String from1 = null, subj = null, text = null;
										
										for (int j = 0; j < tokens.length; j++)
										{
											String token = tokens[j].trim();
											
											//  Skip the reply key (if there is one)
											
											if (Number.isBase16(token)) continue;
											
											final int lines = 2; // number of prepended lines to remove
											
											//  lines could equal 1 if the lines are prepended in the correct
											//  order but the sender may not be using the same program
											
											if (encrypted) for (int k = 0; k < lines; k++)
											{
												//  Read, remove, and save the subject line
												//  (if there is a prepended subject line)
												
												if (subj == null)
												{
													int pos = token.indexOf("\n");
													
													if (pos < 0) pos = 0;
													
													String firstline = token.substring(0, pos);
													
													firstline = firstline.toLowerCase();
													
													if (firstline.startsWith("subject")
													 || firstline.startsWith(__.Subject))
													{
														int pos1 = firstline.indexOf(":") + 1;
														
														if (pos1 <= firstline.length())
														
														    subj = firstline.substring(pos1).trim();
													}
													
													
													if (subj != null)
													
													if ((emailpanel.list1.getSubject(i) == null)
													  || emailpanel.list1.getSubject(i).isEmpty())
													{
														//  Truncate, shorten or abbreviate the subject line
														
														if (subj.length() > subjlen)
														
														    subj = subj.substring(0, subjlen) + "..";
														
														
														//  Save and display the subject
														
														emailpanel.list1.setSubject(i, subj);
														
														emailpanel.listpanel.subjlabels[i].setText(subj);
														
														
														//  Remove the prepended subject line
														
														token = token.substring(pos) .trim();
														
														
														//  Read the first few words of text
														
														text = token.trim().replaceAll("\n", " ");
														
														if (text.length() > textlen)
														
														    text = text.substring(0, textlen);
														
														text = text + "...";
													}
												}
												
												
												//////////////////////////////////////////////////////////
												
												
												//  Read, remove, and save the prepended from line
												//  (if there is a prepended private address)
												
												//  This feature is not implemented
												
												if (from1 == null)
												{
													int pos = token.indexOf("\n");
													
													if (pos < 0) pos = 0;
													
													String firstline = token.substring(0, pos);
													
													firstline = firstline.toLowerCase();
													
													if (firstline.startsWith("from")
													 || firstline.startsWith(__.From))
													{
														int pos1 = firstline.indexOf(":") + 1;
														
														if (pos1 <= firstline.length())
														
														    from1 = firstline.substring(pos1).trim();
													}
													
													if ((from1 != null) && from1.contains("@"))
													
													if ((emailpanel.list1.getFrom1(i) == null)
													  || emailpanel.list1.getFrom1(i).isEmpty())
													{
														//  Remove the "@" sign and domain
														
														int pos1 = from1.indexOf("@");
														
														from1 = from1.substring(0, pos1);
														
														
														//  Verify that the sender's public email address
														//  equals the hash of the sender's private email address
														//
														//  (All email service providers except for yandex allow
														//  email addresses to begin with a digit or number.)
														
														boolean bool = false;
														
														String from = emailpanel.list1.getFrom(i);
														
														String hash2 = Cipher.hash2(from1).substring(0, 8);
														
														if (from.equals(hash2)) bool = true;
														
														//  Try other tests if other hashes or algorithms are used
														
														//  ...     ...
														
														if (bool == true)
														{
															//  Save the sender's private email address
															
															emailpanel.list1.setFrom1(i, from1);
															
															//  Truncate, shorten or abbreviate the from line
															//  and replace the last digits with the ellipsis ...
															
															if (from1.length() > fromlen)
															
															    from1 = from1.substring(0, fromlen);
															
															int pos2 = from1.lastIndexOf(" ");
															
															if (pos2 > 0)
															{
																String str1 = from1.substring(0, pos2);
																String str2 = from1.substring(pos2 + 1).trim();
																
																if (Number.isBase16(str2))
																
																    from1 = str1 + "...";
															}
															
															
															//  Display the sender's private address
															
															emailpanel.listpanel.fromlabels[i].setText(from1);
															
															
															//  Remove the prepended from line
															
															token = token.substring(pos).trim();
															
															
															//  Read the first few words of text
															
															text = token.trim().replaceAll("\n", " ");
															
															if (text.length() > textlen)
															
															    text = text.substring(0, textlen);
														}
													}
												}
												
												
												//////////////////////////////////////////////////////////
												
												
												if (text != null) emailpanel.listpanel
												
												    .textlabels[i].setText(text);
											}
											
											
											else // if (!encrypted) // no secret prepended subject
											{
												text = "";
												
												//  if (emailpanel.listpanel.textlabels[i].getText().isEmpty())
												//      emailpanel.listpanel.textlabels[i].setText(text);
												
												break;
											}
										}
									}
								}
								
								}
								
								
								finally
								{
									decrypting = false;
									
									clicked = false;
								}
							
							} ) .start();
							
							//  end decrypt thread
						
						}); //  end list thread
						
						listthread.start();
					
					}  //  end listbutton
					
					
					
					
					
					
					else if (e.getSource() == emailpanel.readbutton)
					{
					
						if (listing) return;
						
						//  The list button has to be clicked first
						
						if (emailpanel.popmail == null) return;
						
						if (decrypting) { return; }
						
						
						//  Read all screen requires a textarea
						
						emailpanel.scrollpane1.setVisible(false);
						emailpanel.scrollpane2.setVisible(true);
						emailpanel.scrollpane3.setVisible(false);
						
						tabbedpane.repaint();
						
						
						//  listing = true has to be outside of the thread so
						//  that it gets set immediately; otherwise it could
						//  take a couple of seconds and then methods that test
						//  this variable could get reading == false.
						
						reading = true;
						
						readthread = new Thread(() ->
						{
							int cp = 0;
							
							try // no indent for the
							{  // try finally block
							
							//  Change the cursor from default to wait
							
							emailpanel.readbutton .setCursor(wait_cursor);
							emailpanel.textarea   .setCursor(wait_cursor);
							
							if (emailpanel.listpanel != null)
							    emailpanel.listpanel.setCursor(wait_cursor);
							
							
							//  Read all the messagesperscreen messages
							
							int numberofmessages = emailpanel.popmail.getNumberOfMessages();
							
							//  System.out.println("number of messages == " + numberofmessages);
							
							int t = Math.min(numberofmessages, emailpanel.messagesperscreen);
							
							if (emailpanel.list1 == null)
							{
								emailpanel.list1 = new ArrayList1();
								emailpanel.list1 .setSize(t);
							}
							
							else t = emailpanel.list1.size();
							
							
							//  Limit the number of messages to a max number
							
							final int maxnumber = 20;
							
							if (t > maxnumber) t = maxnumber;
							
							
							//  If the read all screen is already displayed
							//  and the user clicks on a message delete box,
							//  save the caret position so the user doesn't
							//  have to re-scroll to the deleted message.
							
							if (emailpanel.readallscreen)
							
							   cp = emailpanel.textarea.getCaretPosition();
							
							emailpanel.textarea.setLineWrap(true);
							emailpanel.textarea.setWrapStyleWord(true);
							
							emailpanel.textarea.setVisible(true);
							emailpanel.scrollpane2.setVisible(true);
							emailpanel.scrollpane3.setVisible(false);
							
							emailpanel.listscreen = false;
							emailpanel.messagescreen = false;
							emailpanel.readallscreen = true;
							
							
							//  Retrieve and display all the messages
							
							StringBuilder sb = new StringBuilder("\n");
							
							for (int index = 0; index < t; index++)
							{
								//  Test for quitting and popmail == null
								
								if (quitting || (emailpanel.popmail == null)) return;
								
								
								//  Skip the hidden and deleted messages but not the checked messages
								//
								//  (Don't skip the checked messages because then the read all check-
								//  boxes would not correspond to the same list screen checkboxes
								//  and the user would delete the wrong messages.
								//
								//  If the user checks the delete box in the read all screen, then
								//  the message text will disappear if the user re-clicks the Read
								//  All button, and the checked messages only show the date, from,
								//  and subject.
								
								
								//  Store the message start position for each message index
								
								int startpos = sb.length();
								
								emailpanel.list1.setMessageStartPos(index, startpos);
								
								
								//  If the message is not visible (such
								//  as the sent emails) then continue
								
								if (!emailpanel.listpanel.isVisible(index)) continue;
								
								if (emailpanel.list1.isDeleted(index)) continue;
								
								
								
								//  Append the delete box [  ] or [ x ] and reply label for each message
								
								if (!emailpanel.list1.getDeleteBox(index)) sb.append(readallheader0);
								if ( emailpanel.list1.getDeleteBox(index)) sb.append(readallheader1);
								
								sb.append("\n\n\n");
								
								
								
								String date, from, subj;
								
								date = emailpanel.list1.getDate   (index);
								from = emailpanel.list1.getFrom   (index);
								subj = emailpanel.list1.getSubject(index);
								
								
								
								//  If the emailpanel arraylist does not have the message
								//  then read the message from the server and store it
								//  in the array list
								
								if ((emailpanel.list1.getMessage(index) == null)
								  || emailpanel.list1.getMessage(index).isEmpty())
								
								    readMessage(emailpanel, index);
								
								
								//  Append the from, subject, date
								
								if ((from != null) && !from.isEmpty())
								
								    sb.append(__.From + ": " + from + "\n");
								
								if ((subj != null) && !subj.isEmpty())
								
								    sb.append(__.Subject + ": " + subj + "\n");
								
								if ((date != null) && !date.isEmpty())
								
								    sb.append(__.Sent + ": " + date + "\n");
								
								
								
								//  If a message has been checked for deletion, then just
								//  display the from, subject, and date on the read all screen
								//  (The text to be deleted is not displayed in the Read All
								//  screen if the checkbox is selected.)
								
								if (emailpanel.list1.getDeleteBox(index))
								{
									sb.append("\n\n\n");
									
									sb.append("-".repeat(48));
									
									sb.append("\n\n\n");
									
									emailpanel.textarea.setText(sb.toString());
									
									continue;
								}
								
								
								//  Read the number of encryption ciphers
								
								int numberofciphers = emailpanel.list1
								
								    .getNumberOfCiphers(index);
								
								
								int replyciphers = emailpanel.list1
								
								    .getNumberOfReplyCiphers(index);
								
								String ciphstr = numberofciphers + " / " + replyciphers;
								
								sb.append(__.encryptionreplykeyciphers + " = ");
								
								sb.append(numberofciphers + " / " + replyciphers + "\n");
								
								
								//  Append the number of bytes
								
								int size = emailpanel.list1.getNumberOfBytes(index);
								
								String sizestr = String.valueOf(size);
								
								sizestr = Convert.partition(sizestr, ",", -3);
								
								sb.append(__.Size + " " + sizestr + " " + __.bytes + "\n\n");
								
								
								//  Append the view attached file == [ view ]
								//     and the save attached file == [ save ]
								
								int numberoffiles = emailpanel.list1.getNumberOfFiles(index);
								
								String attachedfilestr = __.AttachedFile + "  " +
								
								    __.viewattachedfile + "  " + __.saveattachedfile;
								
								for (int i = 0; i < numberoffiles; i++)
								{
									if (i == 0) sb.append("\n");
									
									sb.append(attachedfilestr + "\n\n");
								}
								
								sb.append("\n");
								
								
								//  Retrieve or decrypt the message from the array list
								
								String message = emailpanel.list1.getMessage(index);
								
								
								//  Decrypt the message if the message is encrypted
								
								//  (If the message is unencrypted the decryptMessage
								//  method will return the plaintext, but if the message
								//  is undecryptable it will return null.)
								
								String decryptedmessage = message;
								
								if ((message != null) && !message.isEmpty()
								
								    && PublicKey.isEncrypted(message))
								
									decryptedmessage = decryptMessage(
									
									    emailpanel, message, index);
								
								if (decryptedmessage == null)
								
								    decryptedmessage = message;
								
								
								//  Truncate the message if the message is long
								//  (This is only done for the read all screen)
								
								int maxlength = 4096;
								
								if (decryptedmessage.length() > maxlength)
								
								    decryptedmessage = decryptedmessage
								
									.substring(0, maxlength) + " ........";
								
								
								if ((decryptedmessage == null) || decryptedmessage.isEmpty())
								{
									//  Decryption error: Wrong encryption key,
									//  wrong decryption key, or defective ciphertext
									
									sb.append(__.decryptionerror + ": ");
									sb.append(__.wrongencryptionordecryptionkey);
								}
								
								
								//  Append the decrypted (or non-encrypted) message
								
								sb.append(decryptedmessage);
								
								if (index < t-1)
								{
									sb.append("\n\n\n\n");
									
									sb.append("-".repeat(48));
									
									sb.append("\n\n\n\n");
								}
								
								String text = sb.toString();
								
								emailpanel.textarea.setText(text);
								
								
								
								//  Create a panel and/or text area for
								//  each message in the read all screen
								
								//  This feature is not implemented
								
								
								JPanel panel = new JPanel();
								
								panel.setLayout(new GridBagLayout());
								
								JTextArea textarea = new JTextArea(20, 80);
								
								textarea.setText(sb.toString());
								
								textarea.setEditable(false);
								textarea.setLineWrap(true);
								textarea.setWrapStyleWord(true);
								
								textarea.setForeground(emailpanel.foreground);
								textarea.setCaretColor(emailpanel.caretcolor);
								textarea.setBackground(emailpanel.background);
								
								textarea.setFont(font);
								textarea.setHighlighter(null);
								textarea.setSelectionColor(
								    emailpanel.background);
								
								panel.add(textarea);
							}
							
							
							//  Reset the message number to -1
							
							emailpanel.msno = -1;
							
							}
							
							finally
							{
								emailpanel.readbutton .setCursor(default_cursor);
								emailpanel.textarea   .setCursor(default_cursor);
								
								if (emailpanel.listpanel != null)
								    emailpanel.listpanel.setCursor(default_cursor);
								
								emailpanel.textarea.setCaretPosition(Math.min(
								
								    cp, emailpanel.textarea.getText().length()));
								
								emailpanel.textarea.requestFocusInWindow();
								
								reading = false;
								
								clicked = false;
							};
						});
						
						readthread.start();
					}
					
					
					
					
					else if (e.getSource() == emailpanel.delebutton)
					{
					
						if (clicked || listing) return;
						
						//  The list button has to be clicked first
						//  before the delete button will work
						
						if (emailpanel.popmail == null) return;
						
						
						//  If nothing to delete, return
						
						boolean bool = false;
						
						for (int i = 0; i < emailpanel.list1.size(); i++)
						
						    if (emailpanel.list1.getDeleteBox(i))
						
							{ bool = true; break; }
						
						if (bool == false) return;
						
						
						delethread = new Thread(() ->
						{
						
						try // no indent for the
						{  // try finally block
						
						//  Change the cursor from default to wait
						
						emailpanel.delebutton .setCursor(wait_cursor);
						emailpanel.textarea   .setCursor(wait_cursor);
						
						if (emailpanel.listpanel != null)
						    emailpanel.listpanel.setCursor(wait_cursor);
						
						
						deleting = true;
						
						for (int i = 0; i < emailpanel.list1.size(); i++)
						{
							if (emailpanel.list1.getDeleteBox(i)
							&& !emailpanel.list1.isDeleted(i))
							{
								//  Delete the message from the server and
								//  then remove the message from the list
								
								try
								{	//  Delete the message from the server
									
									boolean bool1 = emailpanel.popmail .delete( emailpanel
									
									    .list1 .getServerMessageNumber(i) );
									
									//  Delete the local copy of the message and uncheck the list box
									
									if (bool1)
									{
										emailpanel.list1 .setDeleted  (i, true);
										emailpanel.list1 .setDeleteBox(i, false);
									}
								}
								
								catch (IOException ex)
								{
									//  Try to reconnect to the server
									
									try { emailpanel.popmail.connect(); }
									
									catch (IOException ex1)
									{
										emailpanel.delebutton .setCursor(default_cursor);
										emailpanel.textarea   .setCursor(default_cursor);
										
										if (emailpanel.listpanel != null)
										    emailpanel.listpanel.setCursor(default_cursor);
										
										JOptionPane.showMessageDialog(
										
										    frame, __.unabletoconnecttoserver, "",
										
											JOptionPane.ERROR_MESSAGE);
										
										return;
									}
									
									emailpanel.delebutton.doClick();
									
									return;
								}
							}
						}
						
						//  The delete command will not take effect on the server
						//  message numbers until the user logs out and logs in again.
						//
						//  For this reason, the messages cannot be removed from the
						//  list array because it would change the message numbers
						//  and then the wrong messages would be retrieved or deleted
						//  because the numbers on the list would not correspond to
						//  the numbers on the server.
						
						
						//  Update the (list or read all) screen
						//  to hide the deleted messages
						
						if (emailpanel.listscreen)
						    emailpanel.listbutton.doClick();
						
						else if (emailpanel.readallscreen)
						         emailpanel.readbutton.doClick();
						}
						
						finally
						{
							deleting = false;
							
							emailpanel.delebutton .setCursor(default_cursor);
							emailpanel.textarea   .setCursor(default_cursor);
							
							if (emailpanel.listpanel != null)
							    emailpanel.listpanel.setCursor(default_cursor);
						}
						
						});
						
						delethread.start();
					}
					
					
					
					
					//  The user clicks the sign out
					//  log out button to disconnect
					
					
					else if (e.getSource() == emailpanel.quitbutton)
					{
					
						//  Reset the readmailsettings
						//
						//  The readmailsettings variable is used so that the
						//  passphrase / settings dialog only reads the settings
						//  once or else the user would be unable to change any
						//  of the email settings
						
						readmailsettings = false;
						
						
						//  If the list button has not been clicked, return
						
						if (emailpanel.popmail == null) return;
						
						
						try
						{   //  Notify the other threads that the user has
						   //  clicked the quit button by setting quitting
						
						quitting = true;
						
						
						//  Wait for the other threads to terminate
						
						int timer = 0, unit = 500;
						
						//  System.out.print("\nstopping");
						
						while (listing || decrypting || reading || deleting)
						{
							//  System.out.print(".");
							
							//  Set the time unit increment
							
							try { Thread.sleep(unit); }
							
							catch (InterruptedException ex) {  }
							
							timer += unit;
							
							if (timer > 12*seconds)
							
							//  If the program is unresponsive, exit the
							//  program because there is no Thread method
							//  to terminate or dispose of the threads.
							
							    System.exit(0);
						}
						
						System.out.println();
						
						//  If (testmail) tell the popmail class to stop
						
						if (testmail) emailpanel.popmail.testmailstop = true;
						
						
						//  Re-enable the email field until
						//  the user clicks the List button
						
						emailpanel.emailfield.setEditable(true);
						
						
						//  Disconnect from the mail server
						
						if (emailpanel.popmail != null)
						
						    try { emailpanel.popmail.quit(); }
						
						    catch (IOException ex)
						    {
							emailpanel.poptextarea.append(
							
							    __.sockettimedout + "\n");
						    }
						
						
						if (emailpanel.listpanel != null)
						
						    emailpanel.remove(emailpanel.listpanel);
						
						emailpanel.listpanel = null;
						
						
						//  Append one or more newlines to the poptextarea
						
						if (emailpanel.popmail != null)
						
						    emailpanel.poptextarea.append("\n\n");
						
						
						//  Remove the array list, the list pane, and
						//  the popmail object, and clear the text area
						
						emailpanel.list1 = null;
						emailpanel.listpanel = null;
						emailpanel.popmail = null;
						
						emailpanel.textarea.setText("");
						
						
						//  Reset the list button from inbox to list
						
						emailpanel.listbutton.setText(__.List);
						
						
						//  Hide the list pane and show the empty text area
						
						emailpanel.scrollpane1.setVisible(false);
						emailpanel.scrollpane2.setVisible(true);
						emailpanel.scrollpane3.setVisible(false);
						
						}
						
						finally
						{
							if (emailpanel.listpanel != null)
							    emailpanel.listpanel.setCursor(default_cursor);
							
							quitting = false;
						}
					}
					
					}
					
					
					finally
					{
						if (listing || decrypting
						 || reading || quitting) return;
						
						clicked = false;
					}
				}
				
				//  End actionPerformed
				
				
				
				
				
				
				private String validateInput()
				{
				
					String errormessage = null;
					
					parseEmailField();
					
					if ((SP == null) || SP.isEmpty())
					{
						errormessage = __.passphrasefieldisempty;
					}
					
					else if (SP.length() < passphraseminlength)
					{
						errormessage = __.passphraseislessthan16chars;
					}
					
					else if (emailpanel.emailfield.getText().isEmpty())
					{
						errormessage =  __.emailaddressisempty + "\n";
						errormessage += __.ifyoualreadyhaveanemailaddr;
					}
					
					else if ((emailpanel.username   == null) || emailpanel.username  .isEmpty()
					      || (emailpanel.userdomain == null) || emailpanel.userdomain.isEmpty())
					{
						errormessage = __.emailaddressisinvalid;
					}
					
					else if ((emailpanel.incomingmailserver == null)
					       || emailpanel.incomingmailserver.isEmpty())
					{
						errormessage = __.incomingmailserverfieldisempty;
					}
					
					else if (emailpanel.incomingmailport == 0)
					{
						errormessage = __.typetheincomingmailport;
					}
					
					else
					{	//  server = pop.domain.com
						//  domain =     domain.com
						
						String serverdomain = "";
						
						String[] t = emailpanel.incomingmailserver.split("[.]{1,}");
						
						if (t.length < 2) errormessage = __.typetheincomingmailport;
						
						else serverdomain = t[t.length -2] + "." + t[t.length -1];
						
						//  If user domain does not match server domain
						
						String userdomain = emailpanel.userdomain;
						
						if (!userdomain .equals(serverdomain))
						{
							errormessage = __.userdomaindoesnotmatchserverdomain;
							
							errormessage += "\n" + __.  userdomain + " == " +   userdomain;
							errormessage += "\n" + __.serverdomain + " == " + serverdomain;
						}
					}
					
					return errormessage;
				}
			}
			
			
			//  End class ButtonListener
			
			
			
			
			
			
			
			private void parsePassphraseServersAndDirectory(String[] input)
			{
			
				//  This is a RetrieveMailFrame method
				
				if (input == null) return;
				
				if ((input[0] != null) && !input[0].isEmpty())
				{
					SP = input[0] + input[1];
					
					SP0 = input[0];
				}
				
				try
				{
				
				if ((input[2] != null) && !input[2].isEmpty())
				{
					//  Store incoming mail server and port
					
					String[] tokens = input[2].split(" {1,}");
					
					if (tokens.length == 1) // error
					{
						emailpanel.incomingmailserver = tokens[0];
					}
					
					else if (tokens.length == 2)
					{
						emailpanel.incomingmailserver = tokens[0];
						
						if (Number.isDigitString(tokens[1], 10))
						
						    emailpanel.incomingmailport
						
							= Integer.parseInt(tokens[1]);
					}
					
					else if (tokens.length > 2) // error
					{
						emailpanel.incomingmailserver = null;
					}
				}
				
				
				if ((input[3] != null) && !input[3].isEmpty())
				{
					//  Store outgoing mail server and port
					
					String[] tokens = input[3].split(" {1,}");
					
					if (tokens.length == 1)
					{
						emailpanel.outgoingmailserver = tokens[0];
					}
					
					else if (tokens.length == 2)
					{
						emailpanel.outgoingmailserver = tokens[0];
						
						if (Number.isDigitString(tokens[1], 10))
						
						    emailpanel.outgoingmailport =
						
							Integer.parseInt(tokens[1]);
					}
					
					else if (tokens.length > 2)
					{
						emailpanel.outgoingmailserver = null;
					}
				}
				
				
				if ((input[4] != null) && !input[4].isEmpty())
				{
					maildirectory = input[4];
				}
				
				if ((input[5] != null) && !input[5].isEmpty())
				
				    emailpanel.messagesperscreen = Integer.parseInt(input[5]);
				
				
				if ((input[6] != null) && !input[6].isEmpty())
				{
					String str = input[6];
					
					emailpanel.ascending =
					
					   str.equals(__.ascending);
				}
				
				}
				
				catch (NumberFormatException ex)
				{
					ex.printStackTrace();
				}
			}
		}
		
		
		//  End class RetrieveMailFrame
		
		
		
		
		
		
		
		
		//  The ArrayList1 class was moved outside the retrieve mail frame
		//  class since it doesn't use any of the frame's members or methods
		
		
		
		private class ArrayList1
		{
		
			//  This class creates a super array list or an array list
			//  of array lists to store the retrieved email messages,
			//  subjects, attached files, attached reply keys, number
			//  of encryption ciphers, the reply sendmail frames, ...
			
			
			//  Declare the ArrayLists
			
			private ArrayList<Integer> servermsno;
			private ArrayList<Integer> numberofbytes;
			
			//  deletebox could be renamed delete;
			//  checked messages to be deleted from the server are displayed;
			//  messages that have been deleted from the server are hidden;
			
			private ArrayList<Boolean> deletebox;
			private ArrayList<Boolean> deleted;
			
			private ArrayList<String> tops;
			private ArrayList<String> headers;
			private ArrayList<String> messages;
			
			private ArrayList<Integer> states;
			
			//  message start and end positions
			//  are used by the read all thread
			
			private ArrayList<Integer> messagestartpos;
			private ArrayList<Integer> messageendpos;
			
			private ArrayList<String> date;
			private ArrayList<String> from;
			//  private email address
			private ArrayList<String> from1;
			
			private ArrayList<String> subject;
			private ArrayList<String> replykey;
			
			//  reply key refers to the sender's prepended reply key
			//  (because the user can generate his/her own public key)
			
			//  message key is the secret encryption key that
			//  was used by the sender to encrypt the message
			
			private ArrayList<byte[]> messagekey;
			
			//  no member variable for storing the sender's public key
			//
			//  (the sender's public key is unimportant for email
			//  because the sender uses a one-time public key;
			//  for telephony the public key would be important be-
			//  cause the caller would use a static public key so
			//  that the caller and recipient could verify the pub-
			//  lic key agreement or secret key.)
			
			//  an ArrayList of ArrayList of type byte[] and string
			//  for the attached files and file descriptions or titles
			
			//  a double iterator is required for the msno and file no
			private ArrayList<ArrayList<String>> filedesc;
			private ArrayList<ArrayList<byte[]>> filedata;
			
			//  a single iterator is required for the msno because
			//  the files are concatenated into a single filetext
			private ArrayList<String> filetext;
			
			private ArrayList<Integer> numberoffiles;
			private ArrayList<Integer> numberofciphers;
			private ArrayList<Integer> numberofreplyciphers;
			
			private ArrayList<SendMailFrame> sendmailframes;
			
			
			
			public ArrayList1()
			{
			
				//  Initialize the ArrayLists
				
				deletebox = new ArrayList<Boolean>();
				deleted   = new ArrayList<Boolean>();
				
				servermsno    = new ArrayList<Integer>();
				numberofbytes = new ArrayList<Integer>();
				
				messagestartpos = new ArrayList<Integer>();
				messageendpos   = new ArrayList<Integer>();
				
				tops     = new ArrayList<String>();
				headers  = new ArrayList<String>();
				messages = new ArrayList<String>();
				states   = new ArrayList<Integer>();
				
				date     = new ArrayList<String>();
				from     = new ArrayList<String>();
				from1    = new ArrayList<String>();
				subject  = new ArrayList<String>();
				replykey = new ArrayList<String>();
				
				messagekey = new ArrayList<byte[]>();
				
				
				//  arraylist of arraylist of byte[] and string
				
				filedesc = new ArrayList<ArrayList<String>>();
				filedata = new ArrayList<ArrayList<byte[]>>();
				filetext = new ArrayList<String>();
				
				numberoffiles = new ArrayList<Integer>();
				numberofciphers = new ArrayList<Integer>();
				numberofreplyciphers = new ArrayList<Integer>();
				
				sendmailframes = new ArrayList<SendMailFrame>();
			}
			
			
			
			private void setSize(int elements)
			{
			
				for (int i = 0; i < elements; i++)
				{
					deletebox.add(false);
					deleted  .add(false);
					
					servermsno   .add(0);
					numberofbytes.add(0);
					
					messagestartpos .add(0);
					messageendpos   .add(0);
					
					tops    .add(new String());
					headers .add(new String());
					messages.add(new String());
					states  .add(null);
					
					date     .add(new String());
					from     .add(new String());
					from1    .add(new String());
					subject  .add(new String());
					replykey .add(new String());
					
					messagekey .add(new byte[0]);
					
					filedesc.add(new ArrayList<String>());
					filedata.add(new ArrayList<byte[]>());
					filetext.add("");
					
					numberoffiles.add(0);
					numberofciphers.add(0);
					numberofreplyciphers.add(0);
					
					sendmailframes.add(null);
				}
			}
			
			
			
			private boolean remove(int index)
			{
			
				deletebox.remove(index);
				deleted  .remove(index);
				
				servermsno.remove(index);
				numberofbytes.remove(index);
				
				messagestartpos .remove(index);
				messageendpos   .remove(index);
				
				tops     .remove(index);
				headers  .remove(index);
				messages .remove(index);
				states   .remove(index);
				
				numberoffiles.remove(index);
				numberofciphers.remove(index);
				numberofreplyciphers.remove(index);
				
				sendmailframes.remove(index);
				
				date     .remove(index);
				from     .remove(index);
				from1    .remove(index);
				subject  .remove(index);
				replykey .remove(index);
				
				messagekey .remove(index);
				
				filedesc .remove(index);
				filedata .remove(index);
				filetext .remove(index);
				
				return true;
			}
			
			
			
			private int size()
			{
				return deletebox.size();
			}
			
			private boolean getDeleteBox(int index)
			{
				return deletebox.get(index);
			}
			
			private boolean isDeleted(int index)
			{
				return deleted.get(index);
			}
			
			private int getMessageStartPos(int index)
			{
				return messagestartpos.get(index);
			}
			
			private int getMessageEndPos(int index)
			{
				return messageendpos.get(index);
			}
			
			private String getTop(int index)
			{
				return tops.get(index);
			}
			
			private String getHeader(int index)
			{
				return headers.get(index);
			}
			
			private String getMessage(int index)
			{
				return messages.get(index);
			}
			
			private Integer getMessageState(int index)
			{
				return states.get(index);
			}
			
			private int getServerMessageNumber(int index)
			{
				return servermsno.get(index);
			}
			
			private int getNumberOfBytes(int index)
			{
				return numberofbytes.get(index);
			}
			
			
			
			private String getDate(int index)
			{
				return date.get(index);
			}
			
			private String getFrom(int index)
			{
				return from.get(index);
			}
			
			private String getFrom1(int index)
			{
				return from1.get(index);
			}
			
			private String getSubject(int index)
			{
				return subject.get(index);
			}
			
			private String getReplyKey(int index)
			{
				return replykey.get(index);
			}
			
			private byte[] getMessageKey(int index)
			{
				return messagekey.get(index);
			}
			
			private byte[] getFileData(int index1, int index2)
			{
				return filedata .get(index1) .get(index2);
			}
			
			private String getFileDesc(int index1, int index2)
			{
				return filedesc .get(index1) .get(index2);
			}
			
			private String getFileText(int index)
			{
				return filetext .get(index);
			}
			
			private int getNumberOfCiphers(int index)
			{
				return numberofciphers.get(index);
			}
			
			private int getNumberOfReplyCiphers(int index)
			{
				return numberofreplyciphers.get(index);
			}
			
			private SendMailFrame getSendMailFrame(int index)
			{
				return sendmailframes.get(index);
			}
			
			private ArrayList<SendMailFrame> getSendMailFrames()
			{
				ArrayList<SendMailFrame> sendmailframes
				
				    = new ArrayList<SendMailFrame>();
				
				for (SendMailFrame sendmailframe : this.sendmailframes)
				
				    sendmailframes.add(sendmailframe);
				
				return sendmailframes;
			}
			
			private int getNumberOfFiles(int index)
			{
				return numberoffiles.get(index);
			}
			
			private String removeFileDesc(int index1, int index2)
			{
				if (index2 >= filedesc.get(index1).size())
				
				    return null;
				
				return filedesc.get(index1).remove(index2);
			}
			
			private byte[] removeFileData(int index1, int index2)
			{
				if (index2 >= filedata.get(index1).size())
				
				    return null;
				
				this.numberoffiles.set(index1,
				this.numberoffiles.get(index1) - 1);
				
				return filedata.get(index1).remove(index2);
			}
			
			private String removeFileText(int index)
			{
				return filetext.remove(index);
			}
			
			
			
			private void addFileDesc(int index, String description)
			{
				this.filedesc .get(index) .add(description);
			}
			
			private void addFileData(int index, byte[] filedata)
			{
				this.filedata .get(index) .add(filedata);
				
				//  increment the number of files
				
				this.numberoffiles .set(index,
				this.numberoffiles .get(index) + 1);
			}
			
			private void addFileText(int index, String filetext)
			{
				this.filetext .add(filetext);
				
				//  increment the number of files
				
				this.numberoffiles .set(index,
				this.numberoffiles .get(index) + 1);
			}
			
			private void setDeleteBox(int index, Boolean bool)
			{
				this.deletebox.set(index, bool);
			}
			
			private void setDeleted(int index, Boolean bool)
			{
				this.deleted.set(index, bool);
			}
			
			private void setMessageStartPos(int index, Integer startpos)
			{
				this.messagestartpos.set(index, startpos);
			}
			
			private void setMessageEndPos(int index, Integer endpos)
			{
				this.messageendpos.set(index, endpos);
			}
			
			private void setTop(int index, String top)
			{
				this.tops.set(index, top);
			}
			
			private void setHeader(int index, String header)
			{
				this.headers.set(index, header);
			}
			
			private void setMessage(int index, String message)
			{
				this.messages.set(index, message);
			}
			
			private void setMessageState(int index, Integer state)
			{
				this.states.set(index, state);
			}
			
			private void setServerMessageNumber(int index, Integer msno)
			{
				this.servermsno.set(index, msno);
			}
			
			private void setNumberOfBytes(int index, Integer msno)
			{
				this.numberofbytes.set(index, msno);
			}
			
			private void setNumberOfCiphers(int index, Integer numberofciphers)
			{
				this.numberofciphers.set(index, numberofciphers);
			}
			
			private void setNumberOfReplyCiphers(int index, Integer numberofciphers)
			{
				this.numberofreplyciphers.set(index, numberofciphers);
			}
			
			private void setSendMailFrame(int index, SendMailFrame sendmailframe)
			{
				this.sendmailframes.set(index, sendmailframe);
			}
			
			
			
			
			private void setDate(int index, String date)
			{
				this.date.set(index, date);
			}
			
			private void setFrom(int index, String from)
			{
				this.from.set(index, from);
			}
			
			private void setFrom1(int index, String from1)
			{
				this.from1.set(index, from1);
			}
			
			private void setSubject(int index, String subject)
			{
				this.subject.set(index, subject);
			}
			
			private void setReplyKey(int index, String replykey)
			{
				this.replykey.set(index, replykey);
			}
			
			private void setMessageKey(int index, byte[] messagekey)
			{
				this.messagekey.set(index, messagekey);
			}
			
			private void setFileDesc(int index1, int index2, String filedesc)
			{
				this.filedesc.get(index1).set(index2, filedesc);
			}
			
			private void setFileData(int index1, int index2, byte[] filedata)
			{
				this.filedata.get(index1).set(index2, filedata);
			}
			
			private void setFileText(int index, String filetext)
			{
				this.filetext.set(index, filetext);
			}
		}
		
		
		//  End class ArrayList1
		
		
		
		
		
		
		
		
		private String convertFilesToText(String[] filedescs, byte[][] filedatas)
		{
			ArrayList<String> filedesclist = new ArrayList<String>();
			ArrayList<byte[]> filedatalist = new ArrayList<byte[]>();
			
			for (int i = 0; i < filedatas.length; i++)
			{
				filedesclist.add(filedescs[i]);
				filedatalist.add(filedatas[i]);
			}
			
			return convertFilesToText(
			
			    filedesclist, filedatalist);
		}
		
		
		private String convertFilesToText(
		
			ArrayList<String> filedesclist, ArrayList<byte[]> filedatalist)
		{
			if (filedatalist.size() != filedesclist.size())
			
			    throw new IllegalArgumentException();
			
			StringBuilder sb = new StringBuilder();
			
			int numberoffiles = filedatalist.size();
			
			//  a single iterator is used for the file no.
			//  (there is no message number)
			
			for (int i = 0; i < numberoffiles; i++)
			{
				String filedesc1 = filedesclist.get(i);
				byte[] filedata1 = filedatalist.get(i);
				
				//  Encode the byte arrays and titles in base 64
				
				String filedesc = Convert   .stringToBase64(filedesc1);
				String filetext = Convert.byteArrayToBase64(filedata1);
				
				if (filedesc.isBlank()) filedesc = Convert.stringToBase64("    ");
				
				//  Concatenate the file description and the file text
				
				String filedesc_filetext = filedesc + "\n\n" + filetext;
				
				//  Add the file desc + \n\n + file text to string
				
				sb.append(filedesc_filetext);
				
				if (i < numberoffiles - 1) sb.append("\n\n");
			}
			
			return sb.toString();
		}
		
		
		private Object[] convertTextToFiles(String text)
		{
			String[] tokens = text.split("\n\n");
			
			if ((tokens.length % 2) != 0)
			
			    throw new IllegalArgumentException();
			
			for (int i = 0; i < tokens.length; i++)
			
			    if (!Number.isBase64(tokens[i].trim()))
			
			        throw new IllegalArgumentException();
			
			ArrayList<String> filedesclist = new ArrayList<String>();
			ArrayList<byte[]> filedatalist = new ArrayList<byte[]>();
			
			//  a single iterator is used for the file number
			//  (there is no message number)
			
			for (int i = 0; i < tokens.length; i++)
			{
				//  Read the file title and text
				//  and remove the base-64 encoding
				
				String filedesc = Convert.base64ToString(tokens[0]);
				byte[] filedata = Convert.base64ToByteArray(tokens[1]);
				
				filedesclist.add(filedesc);
				filedatalist.add(filedata);
			}
			
			return new Object[]
			
			    { filedesclist, filedatalist };
		}
		
		
		
		
		
		//  Methods and inner classes of the Mail class that are
		//  shared by the SendMailFrame and RetrieveMailFrame classes
		//  to avoid replication of code
		
		
		
		
		public static byte[] compress(byte[] input)
		{
			//  compresses a byte array
			
			byte[] output = new byte[input.length];
			
			Deflater compressor = new Deflater();
			
			compressor.setInput(input);
			
			compressor.finish();
			
			int compressedlength =
			
			    compressor.deflate(output);
			
			compressor.end();
			
			output = Arrays.copyOfRange(
			
			    output, 0, compressedlength);
			
			return output;
		}
		
		
		
		
		public static byte[] decompress(byte[] compresseddata)
		
			throws DataFormatException
		{
			//  decompresses a byte array
			
			byte[] input = compresseddata;
			
			byte[] imagedata = null;
			
			//  Decompress the image
			
			Inflater decompressor = new Inflater();
			
			decompressor.setInput(input);
			
			imagedata = new byte[8*input.length];
			
			int datalength = decompressor
			
			    .inflate(imagedata);
			
			decompressor.end();
			
			imagedata = Arrays.copyOfRange(
			
			    imagedata, 0, datalength);
			
			return imagedata;
		}
		
		
		
		
		private int[] fontSizeToFrameSize(float fontsize)
		{
			//  scales the font size to the frame size
			
			//  (this method returns a rectangular size for
			//  the retrieve mail frame, but the send mail
			//  class can square the frame by setting w = h)
			
			//  Read the screen size
			
			Toolkit tk = Toolkit.getDefaultToolkit();
			
			Dimension d = tk.getScreenSize();
			
			//  Compute the dimension of the frame for the font size
			
			double q = 1.0 * (fontsize - 3) / maxfontsize;
			
			double w = 1.5 * d.width  * q * Math.sqrt(q) * 7/10;
			double h = 1.5 * d.height * q * Math.sqrt(q) * 5/8;
			
			//  The frame size should not exceed the screen size
			
			if (w > d.width)  w = d.width;
			if (h > d.height) h = d.height;
			
			return new int[] { (int) w, (int) h };
		}
		
		
		
		private float frameSizeToFontSize(int[] width_height)
		{
			//  scales the frame size to the font size
			
			int x = width_height[0];
			int y = width_height[1];
			
			int z = Math.min(x, y);
			
			int avg = (d.width + d.height) / 2;
			
			//  q = ~ 0 to 1 so the font size
			//     goes from 0 to maxfontsize
			
			double q = 1.0 * z / avg;
			
			//  Use the sqrt of q instead of q
			
			double sqrt = Math.sqrt(q);
			
			double fontsize = 1.3 * maxfontsize * sqrt;
			
			return (float) fontsize;
		}
		
		
		
		private float frameSizeToFontSize(JFrame frame)
		{
			//  scales the frame size to the font size
			
			//  Read the screen size
			
			Toolkit tk = Toolkit.getDefaultToolkit();
			
			Dimension d = tk.getScreenSize();
			
			int x = frame.getSize().width;
			int y = frame.getSize().height;
			
			return frameSizeToFontSize(new int[] { x, y });
		}
		
		
		
		
		private String readPassphrase(
		
			JFrame frame, Color foreground, Color background, Font font)
		{
			PassphraseDialog pd = new PassphraseDialog(
			
			    frame, PassphraseDialog.passphrase_only);
			
			pd.showKeyboard(showkeyboard);
			pd.setForeground1(foreground);
			pd.setBackground1(background);
			pd.setFont1(font);
			
			String passphrase = pd.readPassphrase();
			
			return passphrase;
		}
		
		
		
		private String[] readPassphraseServersAndDirectory(
		
			JFrame frame, Color foreground, Color background, Font font,
			
				String incomingmailserver, String outgoingmailserver,
				int incomingmailport, int outgoingmailport,
				String maildirectory, int messagesperscreen,
				boolean ascending)
		{
		
			//  Initialize the passphrase dialog
			
			//  Read the saved passphrase for this mail directory
			
			SP0 = readPassphrase0();
			
			String SP1 = "";
			
			if ((SP0 != null) && (SP != null) && !SP.isEmpty()
			  && (SP.length() >= SP0.length()) && SP.startsWith(SP0))
			
			    SP1 = SP.substring(SP0.length());
			
			PassphraseDialog pd = new PassphraseDialog(
			
			    frame, PassphraseDialog.passphrase_mailserver);
			
			pd.showKeyboard(showkeyboard);
			pd.setForeground1(foreground);
			pd.setBackground1(background);
			pd.setFont1(font);
			
			pd.setPassphrase0(SP0);
			pd.setPassphrase1(SP1);
			
			pd.setMailServers(
			
			    ( ((incomingmailserver != null)
			    && !incomingmailserver.isEmpty()) ?
			
				(incomingmailserver + "  " +
				
				  String.valueOf(incomingmailport)) : null),
			
			    ( ((outgoingmailserver != null)
			    && !outgoingmailserver.isEmpty()) ?
			
				(outgoingmailserver + "  " +
				
				  String.valueOf(outgoingmailport)) : null) );
			
			String homedir = System.getProperty("user.home");
			
			if (maildirectory == null) maildirectory =
			
			    homedir + File.separator + __.Mail;
			
			pd.setMessagesPerScreen(messagesperscreen);
			pd.setMailDirectory(maildirectory);
			pd.setMailPassphraseFileName(__.mailpassphrase);
			pd.setAscension(ascending);
			
			
			//  Read passphrase, servers, and directory
			
			String[] input = pd.readDialogInput();
			
			return input;
		}
		
		
		
		
		private boolean writePassphrase0(JFrame frame)
		{
			if (SP0 == null) return false;
			
			String filename = maildirectory + File.separator
			
			    + __.mailpassphrase;
			
			File dir = new File(maildirectory);
			
			File file = new File(filename);
			
			if (!dir.exists())
			{
				String message = "";
				
				message += __.createnewmaildir;
				
				message += "\n" + maildirectory;
				
				//  Display the JOptionPane
				
				//  Create a new mail folder ?
				
				int choice = JOptionPane
				
				   .showConfirmDialog(frame, message);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
					return false;
				
				dir.mkdir();
			}
			
			try
			{	if (!file.exists()) file.createNewFile();
				
				DataStream.write(file, SP0.getBytes());
			}
			
			catch (IOException ex)
			
			    { System.out.println(ex); return false; }
			
			System.out.println("saving passphrase " + SP0);
			
			return true;
		}
		
		
		
		private String readPassphrase0()
		{
			String homedir = System.getProperty("user.home");
			
			if (maildirectory == null) maildirectory
			
			    = homedir + File.separator + __.Mail;
			
			String filename = maildirectory + File.separator
			
			    + __.mailpassphrase;
			
			File file = new File(filename);
			
			if (file.exists())
			{
				byte[] input;
				
				try { input = DataStream.read(file); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return null;
				}
				
				String SP0 = new String(input);
				
				return SP0;
			}
			
			return null;
		}
		
		
		
		
		
		//  All username and public key files are encrypted by the same passphrase
		
		private String passphraseToFilePath(String desc, String passphrase)
		{
			//  creates a unique file name from the passphrase and username
			
			//  The RetrieveMailFrame uses only the passphrase so that one file
			//  contains all the user's email addresses and panel settings.
			//
			//  The SendMail frame uses the passphrase + username which changes
			//  the suffix for the public key file so that the public keys for
			//  each email address are in different files.
			
			//  /home/user/Mail/file desc 12345678
			//
			//  /home/user/Mail/user names 12345678
			//  /home/user/Mail/public keys 12345678
			//  /home/user/Mail/message states 12345678
			
			
			if ((SP == null) || SP.isEmpty() || (maildirectory == null)
			
			    || maildirectory.isEmpty()) return null;
			
			//  If the directory does not exist, make a new directory
			
			File dir = new File(maildirectory);
			
			if (!dir.exists() || !dir.isDirectory()) dir.mkdir();
			
			String fileno = Cipher.hash2(passphrase) .substring(0, 8);
			
			String path = maildirectory + File.separator + desc + " " + fileno;
			
			return path;
		}
		
		
		
		private boolean readMessageStates(
		
			String user, TreeMap<String, Integer> treemap)
		{
			//  Reads the message states from file and
			//  stores the key value pairs in the tree map
			
			//  Read the file of hashes and msg states
			//  and then for each key value pair use the
			//  put method to save the message state
			//
			//  msgstatestreeamp.put(key, value);
			
			
			String filepath = passphraseToFilePath(
			
			    __.messagestates.toLowerCase(), SP + user);
			
			if (filepath == null)  return false;
			
			File file = new File(filepath);
			
			byte[] filedata = null;
			
			if (file.exists())
			{
				try { filedata = DataStream.read(file); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				if (Cipher.isEncrypted(file))
				{
					//  Decrypt the file input
					
					filedata = Cipher.decrypt(filedata,
					
					    Cipher.passphraseToKey(SP));
					
					//  Return if file did not decrypt
					
					if (filedata == null) return false;
				}
			}
			
			else return false;
			
			
			//  Convert the decrypted byte array to string
			
			String plaintext = new String(filedata);
			
			//  Read the key value pairs or the hashes
			//  and message states into the tree map
			
			Scanner sc = new Scanner(plaintext);
			
			String line = null,  line1 = null;
			
			//  Skip the empty lines
			
			while (sc.hasNextLine())
			{
				line = sc.nextLine();
				
				if (line.isEmpty()) continue;
				
				String[] tokens = line.split(" {1,}");
				
				if (tokens.length != 2) continue;
				
				String key = tokens[0];
				String val = tokens[1];
				
				//  Add the key value pair to the tree map
				
				Integer stateno;
				
				try { stateno = Integer.valueOf(val); }
				
				catch (NumberFormatException ex) { continue; }
				
				treemap.put(key, stateno);
			}
			
			return true;
		}
		
		
		
		private boolean saveMessageStates(
		
			String user, TreeMap<String, Integer> treemap)
		{
			//  The message states file name suffix equals the hash of
			//  (the passphrase + user address) so that there is one
			//  message states file for each user name.
			
			//  Each message state can be saved as the hash of (the
			//  from address + the number of bytes) followed by a double
			//  space and then the message state 0 to 9 and a newline
			//  char \n. (The ordinal numbers are saved instead of the
			//  enum strings because the message state names could change
			//  in future versions of the program, and the email servers
			//  will also save the message states as integers.)
			
			//  Extract the keyset and values
			
			Set<String>         keyset = treemap.keySet();
			Collection<Integer> values = treemap.values();
			
			ArrayList<String>    keylist = new ArrayList<String>();
			ArrayList<Integer> valuelist = new ArrayList<Integer>();
			
			for (String  k : keyset)   keylist.add(k);
			for (Integer v : values) valuelist.add(v);
			
			
			//  Add the message states to an array list
			
			ArrayList<String> list = new ArrayList<String>();
			
			for (int i = 0; i < keylist.size(); i++)
			{
				String  key =   keylist.get(i);
				Integer val = valuelist.get(i);
				
				list.add(key + "  " + String.valueOf(val));
			}
			
			
			//  Define the file path
			
			if ((SP == null) || SP.isEmpty()) return false;
			
			String filepath = passphraseToFilePath(
			
			    __.messagestates.toLowerCase(), SP + user);
			
			
			File file = new File(filepath);
			
			if (!file.exists())
			{
				try { file.createNewFile(); }
				
				catch (IOException ex)
				
				    { System.out.println(ex); }
			}
			
			
			if (file.exists())
			{
				//  Save the list to file
				
				StringBuilder sb = new StringBuilder();
				
				for (String str : list)
				
				    { sb.append(str); sb.append("\n"); }
				
				String str = sb.toString();
				
				byte[] plaindata = str.getBytes();
				
				byte[] cipherdata = Cipher.encrypt(plaindata,
				
				    Cipher.passphraseToKey(SP));
				
				try { DataStream.write(file, cipherdata); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				return true;
			}
			
			return false;
		}
		
		
		
		
		private PublicKeyRing readPublicKeys(String user)
		{
		
			//  The RetrieveMailFrame does not read or write individual public keys.
			//  The SendMailFrame reads and writes one public key for each username
			//  or from address each time the user clicks the Send button.
			//
			//  But the RetrieveMailFrame can read and display the file so the
			//  user can view the list of public keys and delete them individually.
			
			
			String filepath = passphraseToFilePath(
			
			    __.publickeys.toLowerCase(), SP + user);
			
			if (filepath == null)  return null;
			
			File file = new File(filepath);
			
			byte[] filedata = null;
			
			if (file.exists())
			{
				try { filedata = DataStream.read(file); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return null;
				}
				
				if (Cipher.isEncrypted(file))
				{
					//  Decrypt the file input
					
					filedata = Cipher.decrypt(filedata,
					
					    Cipher.passphraseToKey(SP));
					
					//  Return if file did not decrypt
					
					if (filedata == null) return null;
				}
			}
			
			else return null;
			
			
			//  Convert the decrypted byte array to string
			
			String plaintext = new String(filedata);
			
			
			//  Read the public keys into a key ring
			
			PublicKeyRing publickeyring = new PublicKeyRing();
			
			Scanner sc = new Scanner(plaintext);
			
			String line = null,  line1 = null;
			
			//  Skip the empty lines
			
			while (sc.hasNextLine())
			{
				String input = sc.nextLine().trim();
				
				line = input;
				
				if (!input.isEmpty()) break;
			}
			
			while (sc.hasNextLine())
			{
				if ((line1 != null) && !line1.isEmpty())
				
				    line = line1 .trim();
				
				if (line.isEmpty()) continue;
				
				while (sc.hasNextLine() &&
				
				    (line1 = sc.nextLine()).isBlank())
				
				        continue;
				
				//  Add the public key to the key ring
				
				if (line.contains("@") && !line1.contains("@"))
				{
					String address   = line;
					String publickey = line1;
					
					String[] name_key = new String[]
					
					    { address, publickey };
					
					if (PublicKey.isValidKey(publickey))
					
					    publickeyring.add(name_key);
				}
			}
			
			return publickeyring;
		}
		
		
		
		private boolean savePublicKeys(String user, PublicKeyRing keyring)
		{
			//  The public key file name suffix equals the hash of the
			//  (passphrase + user address) so that there is one public
			//  key file for each user name.
			
			//  Add the public keys to an array list
			
			ArrayList<String> list = new ArrayList<String>();
			
			try
			{	for (int i = 0; i < keyring.size(); i++)
				{
					String[] name_key = keyring.get(i);
					
					String name = name_key[0];
					String  key = name_key[1];
					
					if (!name.isEmpty()) { list.add("\n"); list.add(name); }
					if (! key.isEmpty()) { list.add("\n"); list.add(key); list.add("\n"); }
				}
			}
			
			catch (Exception ex)
			{
				System.out.println(ex);
				
				return false;
			}
			
			
			//  Define the file path
			
			if ((SP == null) || SP.isEmpty()) return false;
			
			String filepath = passphraseToFilePath(
			
			    __.publickeys.toLowerCase(), SP + user);
			
			
			File file = new File(filepath);
			
			if (!file.exists())
			{
				try { file.createNewFile(); }
				
				catch (IOException ex)
				
				    { System.out.println(ex); }
			}
			
			
			if (file.exists())
			{
				//  Save the list to file
				
				String str = "";
				
				for (String str1 : list) str += str1 + "\n";
				
				byte[] plaindata = str.getBytes();
				
				byte[] cipherdata = Cipher.encrypt(plaindata,
				
				    Cipher.passphraseToKey(SP));
				
				try { DataStream.write(file, cipherdata); }
				
				catch (IOException ex)
				{
					System.out.println(ex);
					
					return false;
				}
				
				return true;
			}
			
			else return false;
		}
		
		
		
		
		
		private int getReplyKeySize(Component parent, int size)
		{
		
			//     ______________________________________________
			//    |                                              |
			//    |    Choose the key size that you want sent    |
			//    |    with your messages. The recipient will    |
			//    |    use this key to reply to your messages.   |
			//    |                                              |
			//    |         o zero  o quad  * oct  o max         |
			//    |                                              |
			//    |                    [ OK ]                    |
			//    |______________________________________________|
			
			
			
			//  Number of ciphers to be used for a public key
			
			
			JRadioButton zerobutton, singlebutton;
			JRadioButton doublebutton, quadbutton;
			JRadioButton octbutton, maxbutton;
			
			zerobutton   = new JRadioButton(__.zero);
			singlebutton = new JRadioButton(__.single);
			doublebutton = new JRadioButton(__.double1);
			quadbutton   = new JRadioButton(__.quad);
			octbutton    = new JRadioButton(__.oct);
			maxbutton    = new JRadioButton(__.max);
			
			JRadioButton[] radiobuttons = new JRadioButton[]
			{
				zerobutton, singlebutton, doublebutton,
				quadbutton, octbutton, maxbutton
			};
			
			for (JRadioButton button : radiobuttons)
			
			    button.setFont(labelfont);
			
			ButtonGroup group = new ButtonGroup();
			
			group.add(zerobutton);
			group.add(singlebutton);
			group.add(doublebutton);
			group.add(quadbutton);
			group.add(octbutton);
			group.add(maxbutton);
			
			JCheckBox maxcheckbox = new JCheckBox();
			
			maxcheckbox.setSelected(false);
			maxcheckbox.setEnabled(false);
			maxcheckbox.setVisible(false);
			maxcheckbox.setVisible(false);
			
			maxcheckbox.setToolTipText(
			    __.includelargeciphers);
			
			
			JPanel panel = new JPanel();
			
			panel.add(zerobutton);
			panel.add(singlebutton);
			panel.add(doublebutton);
			panel.add(quadbutton);
			panel.add(octbutton);
			panel.add(maxbutton);
			panel.add(maxcheckbox);
			
			
			//  Count the number of ciphers
			//
			//  >= 256 chars / 1 K bits
			
			int largesize = (4+1)*1024;
			
			int n = PublicKey.numberofciphers;
			
			int numberoflargekeys = 0;
			
			for (int size1 : PublicKey.size)
			
			    if (size1 > largesize) numberoflargekeys++;
			
			int n1 = numberoflargekeys;
			
			
			if (n > 1) singlebutton.setVisible(false);
			if (n > 2) doublebutton.setVisible(false);
			if (n < 4)   quadbutton.setVisible(false);
			if (n < 8)    octbutton.setVisible(false);
			
			JLabel cipherlabel = new JLabel(__.cipher);
			
			
			Box vbox = Box.createVerticalBox();
			
			//  "Choose the key size that you want sent\n" +
			//  "with your message(s). The recipient will\n" +
			//  "use this key to reply to your message(s).",
			
			String message1 = __.choosethereplykeysize1;
			String message2 = __.choosethereplykeysize2;
			
			JTextArea textarea1 = new JTextArea(message1 + "\n");
			JTextArea textarea2 = new JTextArea(message2);
			
			textarea1.setEditable(false);
			textarea2.setEditable(false);
			
			textarea1.setBackground(new JLabel().getBackground());
			textarea2.setBackground(new JLabel().getBackground());
			
			textarea1.setFont(labelfont);
			// textarea2.setFont(...);
			
			vbox.add(textarea1);
			vbox.add(textarea2);
			
			Component vstrut = Box
			
			   .createVerticalStrut(20);
			
			vbox.add(vstrut);
			
			vbox.add(panel);
			
			
			if      (size == 0)     zerobutton .setSelected(true);
			else if (size == 1)   singlebutton .setSelected(true);
			else if (size == 2)   doublebutton .setSelected(true);
			else if (size == 4)     quadbutton .setSelected(true);
			else if (size == 8)      octbutton .setSelected(true);
			else if (size >= n)      maxbutton .setSelected(true);
			
			
			maxcheckbox.setVisible(n1 > 0);
			maxcheckbox.setEnabled(maxbutton.isSelected());
			
			for (JRadioButton radiobutton : radiobuttons)
			
			    radiobutton.addActionListener(
			
				new ActionListener()
				{
					public void actionPerformed(ActionEvent e)
					{
						maxcheckbox.setEnabled((n1 > 0)
						
						    && maxbutton.isSelected());
						
						if (!maxcheckbox.isEnabled())
						
						     maxcheckbox.setSelected(false);
					}
				}
			);
			
			
			String title = "";
			
			int choice = JOptionPane.showConfirmDialog(parent,
			
		            vbox, title, JOptionPane.DEFAULT_OPTION);
			
			if (choice == JOptionPane.CLOSED_OPTION) return -1;
			
			int m = 0;
			
			if      (zerobutton   .isSelected())  m = 0;
			else if (singlebutton .isSelected())  m = 1;
			else if (doublebutton .isSelected())  m = 2;
			else if (quadbutton   .isSelected())  m = 4;
			else if (octbutton    .isSelected())  m = 8;
			else if (maxbutton    .isSelected()
			      && maxcheckbox  .isSelected())  m = n;
			else if (maxbutton    .isSelected()
			     && !maxcheckbox  .isSelected())  m = n - n1;
			else                                  m = -1;
			
			return Math.min(m, n);
		}
		
		
		
		public static boolean showCheckBoxMessageDialog(
		
			Component parent, String message, String checkboxmessage)
		{
			//  Displays a JOptionPane message dialog
			//  that includes a check box option
			
			JTextArea textarea = new JTextArea(message);
			textarea.setEditable(false);
			textarea.setFont(labelfont);
			textarea.setBackground(new
			    JPanel().getBackground());
			
			JLabel label = new JLabel(checkboxmessage);
			label.setFont(labelfont);
			Box hbox = Box.createHorizontalBox();
			Component hstrut = Box.createHorizontalStrut(4);
			Component vstrut = Box.createVerticalStrut(8);
			JCheckBox checkbox = new JCheckBox();
			hbox.add(checkbox); hbox.add(hstrut); hbox.add(label);
			Box vbox = Box.createVerticalBox();
			vbox.add(textarea);
			vbox.add(hbox);
			
			label.addMouseListener(new MouseAdapter()
			{ public void mouseClicked(MouseEvent e)
			{ checkbox.setSelected(!checkbox.isSelected()); } });
			
			JOptionPane.showMessageDialog(parent, vbox);
			
			return checkbox.isSelected();
		}
	}
	
	
	//  End class Mail
	
	
	
	
	
	
	
	//  Methods and inner classes of the Programs class that are shared
	//  by the TextFrame and TableFrame classes could be placed here or
	//  outside the Programs class to avoid replication of code. Some
	//  classes such as the FontSize and FontType classes would have to
	//  be rewritten so the variables could be passed by reference (such
	//  as inside an array) instead of by value which just creates a copy
	//  instead of a reference or pointer to a variable.
	
	
}


//  End class Programs


















//  These classes are shared by all the editor programs
//  including the text editor, table editor, image editor
//  / viewer, html editor / viewer, and email editor.
//
//  The PopMail and SendMail classes are used only by the
//  Mail class but they are outside the Mail class because
//  they don't use any of the Mail class members or methods.







class Undo
{

	//  This method undoes changes that were made up to the last back-
	//  space key, delete key, or enter key event. The first time that
	//  a delete / backspace / enter key is pressed, the text is pushed
	//  onto the stack, and then for multiple key events the keylistener
	//  keeps popping and pushing the text onto the stack until a non-
	//  delete / backspace / enter key is pressed. It would be wasteful
	//  of memory and inconvenient for the user to undo changes if the
	//  program pushed every key event onto the stack without first pop-
	//  ping the previous change off the stack for multiple key events.
	
	
	
	private JTextArea textarea;
	
	private int stacksize = 128;
	
	private int indexer = 0;
	
	private ArrayList<Object[]> stack;
	
	private boolean undo;
	private boolean redo;
	
	private boolean enter;
	private boolean delete;
	
	
	public Undo(JTextArea textarea)
	{
		stack = new ArrayList<Object[]>();
		
		this.textarea = textarea;
		
		textarea.addKeyListener(
		
		    new KeyListener1());
	}
	
	public void clear()
	{
		stack.clear();
		
		indexer = 0;
	}
	
	public void undo()
	{
		if (stack.size() == 0) return;
		
		if (indexer >= stack.size()) return;
		
		if (indexer < 0) indexer++;
		
		
		//  Replace the current text with the previous text
		
		Object[] text_cp = stack.get(indexer++);
		
		String prev = (String) text_cp[0];
		int cp =     (Integer) text_cp[1];
		
		textarea.setText(prev);
		textarea.setCaretPosition(cp);
		
		
		//  Set delete and enter to false so the key listener
		//  will push the next string onto the stack instead
		//  of popping and then pushing onto the stack which
		//  happens if the user keeps typing or clicking the
		//  backspace or enter key.
		
		enter  = false;
		delete = false;
		
		if (redo) { redo = false; undo(); }
		
		undo = true;
	}
	
	
	public void redo()
	{
	
		if (stack.size() == 0) return;
		
		if (indexer == stack.size()) indexer--;
		
		if (indexer <= 0) indexer++;
		
		
		//  Replace the current text with the previous text
		
		Object[] text_cp = stack.get(indexer---1);
		
		String next = (String) text_cp[0];
		
		int cp = (Integer) text_cp[1];
		
		textarea.setText(next);
		textarea.setCaretPosition(cp);
		
		//  Set delete and enter to false so the key listener
		//  will push the next string onto the stack instead
		//  of popping and then pushing onto the stack which
		//  happens if the user keeps typing or clicking the
		//  backspace or enter key.
		
		enter  = false;
		delete = false;
		
		if (undo) { undo = false; redo(); }
		
		redo = true;
	}
	
	
	public void push()
	{
		String str = textarea.getText();
		
		int cp = textarea.getCaretPosition();
		
		if (indexer != 0)
		{
			//  Delete the elements from 0 to i
			
			for (int i = 0; i < indexer; i++)
			
			    stack.remove(0);
			
			//  Reset the indexer
			
			indexer = 0;
		}
		
		stack.add(0, new Object[] { str, cp });
		
		if (stack.size() > stacksize)
		
		    stack.remove(stack.size()-1);
	}
	
	
	public Object[] pop()
	{
		if (indexer != 0)
		{
			//  Delete the elements from 0 to i
			
			for (int i = 0; i < indexer; i++)
			
			    stack.remove(0);
			
			//  Reset the indexer
			
			indexer = 0;
		}
		
		Object[] text_cp = stack.remove(0);
		
		return text_cp;
	}
	
	
	private class KeyListener1 implements KeyListener
	{
	
		private int vk_enter     = KeyEvent.VK_ENTER;
		private int vk_backspace = KeyEvent.VK_BACK_SPACE;
		private int vk_delete    = KeyEvent.VK_DELETE;
		
		public void keyReleased(KeyEvent e) {  }
		
		public void keyTyped(KeyEvent e) {  }
		
		public void keyPressed(KeyEvent e)
		{
			//  If the user types the backspace or delete key the
			//  delete variable is set to true until the user clicks
			//  a different key so that the program doesn't keep
			//  pushing text onto the stack for each backspace or
			//  delete key event.
			
			int keycode = e.getKeyCode();
			int keychar = e.getKeyChar();
			
			if ((keychar == vk_backspace)
			 || (keychar == vk_delete))
			{
				// the first delete key event
				
				if (!delete) push();
				
				else // multiple backspaces or delete key events
				{
					//  Keep replacing the previous text
					//  until the user types a non-delete key
					
					pop(); push();
				}
				
				delete = true;
			}
			
			else // if ((keychar != vk_backspace)
			     //  && (keychar != vk_delete))
			
			    delete = false;
			
			
			if (keychar == vk_enter)
			{
				// the first enter key event
				
				if (!enter) push();
				
				else  //  multiple enter key events
				{
					//  Keep replacing the previous text
					//  until the user types a non-enter key
					
					pop(); push();
				}
				
				enter = true;
			}
			
			else enter = false;
		}
	}
}


//  End class Undo











class FileType
{

	//  This class detects if a file is text, table, or html
	//
	//  For text files such as source code documents the chars are all
	//  less than 256; for image files many chars are greater than 256.
	//  Testing the int values of the chars works for detecting the file
	//  types of attached files for documents that use the Latin alphabet.
	//  (This method might not work for other character sets. Also it won't
	//  work for files that have special chars such as the copyright symbol
	//  or the minus char 8722 unless the code is modified to test for
	//  these chars.)
	//
	//  If a file is not text, table or html then the file is image or audio.
	//  The program would have to use other tests to distinguish between
	//  image and audio files.
	
	
	public static boolean isText(String str)
	{
		//  tests if a string contains text
		
		char[] charray = str.toCharArray();
		
		for (int c : charray)
		
		    if (c >= 256) return false;
		
		return true;
	}
	
	
	public static boolean isTable(String str)
	{
		//  tests if a string contains character separated values
		//
		//  (tabs, commas, or semicolons)
		
		String delimiter;
		
		if (str.contains("\t")) delimiter = "\t";
		
		else if (str.contains(",")) delimiter = ",";
		
		else delimiter = ";";
		
		str = str .replaceAll(delimiter,
		
		    " " + delimiter + " ");
		
		String[] rows = str.split("\n");
		
		//  Count the number of elements in the first row
		
		String[] cols = rows[0].split(delimiter);
		
		if (cols.length == 1) return false;
		
		int prevcount = cols.length;
		
		//  Test if all rows have the
		//  same number of elements
		
		for (String row : rows)
		{
			cols = row.split(delimiter);
			
			if (cols.length != prevcount)
			
			    return false;
			
			prevcount = cols.length;
		}
		
		return true;
	}
	
	
	
	public static boolean isHTML(String str)
	{
	
		//  Test if the text starts with <! and contains the word html or htm
		
		if (str.startsWith("<") || str.startsWith("<!"))
		{
			int index = str.indexOf("\n");
			
			if (index != 0)
			{
				String s = str.substring(0, index).toLowerCase();
				
				if (s.contains("html") || s.contains("doctype"))
				
				    return true;
			}
		}
		
		return false;
	}
}


//  End class FileType








class Colors
{

	//  The Colors class uses bright, bold, vivid, or intense
	//  colors so that users can read the text.
	//
	//  Some colors such as yellow are not included in this list
	//  because there is not enough contrast to read the letters
	//  unless the background color is changed.
	
	//  The Colors class includes reds, greens, blues, oranges,
	//  purples, pinks, magentas, cyans and aquas but users can
	//  select any color they want using the Color menu item.
	
	//  The visible / ocular / color / solar spectrum has the three
	//  primary colors red, green, and blue, and the combinations
	//  of red and green (yellow, orange) and green and blue (cyan,
	//  aqua) which are all monochromatic colors; but it doesn't have
	//  the combinations of red and blue (magenta, pink, purple) be-
	//  cause they are at opposite ends of the spectrum. Of course
	//  the three primary colors can produce any polychromatic or
	//  composite color by filtering out one of the three colors.
	
	
	public int index = -1;
	
	
	private static Object[][] colors_names = new Object[][]
	{
	
		{ 0x000000, __.black },
		{ 0x202020, __.darkgray },
		
		//  reds
		
		{ 0xd00000, __.brightred },
		{ 0xa00000, __.red },
		{ 0x600000, __.darkred },
		
		{ 0xf05000, __.orange },
		
		//  greens
		
		{ 0x009000, __.brightgreen },
		{ 0x006800, __.green },
		{ 0x003800, __.darkgreen },
		
		//  greenish blues
		
		{ 0x006060, __.cyan },
		{ 0x004040, __.darkcyan },
		
		{ 0x003870, __.aqua },
		{ 0x002850, __.darkaqua },
		{ 0x00359f, __.cobaltblue },
		
		//  blues
		
		{ 0x4040a0, __.paleblue },
		{ 0x0000e0, __.brightblue },
		{ 0x0000b0, __.blue },
		{ 0x000070, __.mediumblue },
		{ 0x000040, __.darkblue },
		
		//  bluish reds
		
		{ 0xdf38a6, __.brightpink },
		{ 0xcf339b, __.pink },
		{ 0xcf1967, __.redpink },
		{ 0xa800e0, __.reddishblue },
		
		//  red + blue
		
		{ 0xa800a8, __.magenta },
		{ 0x780078, __.darkmagenta },
		{ 0x800055, __.crimson },
		
		//  reddish blues
		
		{ 0x6038c0,  __.palepurple },
		{ 0x7000e0,  __.brightpurple },
		{ 0x5000a0,  __.purple },
		{ 0x380070,  __.darkpurple },
		
		{ 0x2000A0, __.purplishblue },
		{ 0x170080, __.violet },
		
		//  ...
		
		//  ...
	};
	
	public static String[] colors = new String[colors_names.length];
	
	public static int[] rgb = new int[colors_names.length];
	
	static
	{
		for (int i = 0; i < colors.length; i++)
		{
			rgb[i] = (int) colors_names[i][0];
			
			colors[i] = (String) colors_names[i][1];
		}
	}
	
	public static int getRGB(String name)
	{
		for (int i = 0; i < colors_names.length; i++)
		
		    if (colors_names[i][1].equals(name))
		
			return (int) colors_names[i][0];
		
		return Color.black.getRGB();
	}
}


//  End class Colors










class SaveFile
{

	private Component parent;
	
	private String directory;
	
	private String title;
	
	private Font font = new JPanel()
	
	    .getFont() .deriveFont(16.0f);
	
	
	public SaveFile(Component parent, String title)
	{
		this.parent = parent;
		
		this.title = title;
	}
	
	public SaveFile setDirectory(String directory)
	{
		this.directory = directory;
		
		return this;
	}
	
	public SaveFile setFont(Font font)
	{
		int size = font.getSize();
		
		this.font = font;
		
		return this;
	}
	
	public int save(byte[] data, File file, boolean confirm)
	{
	
		//  Choose a file
		//
		//  Save the data to the file
		
		if (file == null)
		
		    file = chooseFile();
		
		if (file == null) return -1;
		
		
		//  Confirm if the user wants to replace an exis-
		//  ting file, or create a new file if the file
		//  does not exist, and write the data to file
		
		if (file.exists())
		{
			String message = __.Replace + " "
			
			    + file.getName() + " ?";
			
			if (file == null)  return -1;
			
			if (file.exists() && confirm)
			{
				JLabel label = new JLabel(message);
				
				label.setFont(new JLabel().getFont().deriveFont(16.0f));
				
				int choice = JOptionPane.showConfirmDialog(parent, label);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
				    return choice;
			}
		}
		
		else // if (!file.exists())
		{
			try { file.createNewFile(); }
			
			catch (IOException ex)
			{
				System.out.println(ex);
				
				String title = "";
				
				int msgtype = JOptionPane.ERROR_MESSAGE;
				
				JOptionPane.showMessageDialog(
				
				    parent, ex, title, msgtype);
				
				return -1;
			}
		}
		
		//  Save the file
		
		try { DataStream.write(file, data); }
		
		catch (IOException ex)
		{
			System.out.println(ex);
			
			String title = "";
			
			int msgtype = JOptionPane.ERROR_MESSAGE;
			
			JOptionPane.showMessageDialog(
			
			    parent, ex, title, msgtype);
			
			return -1;
		}
		
		return JOptionPane.YES_OPTION;
	}
	
	
	
	public File chooseFile()
	{
		File selectedfile = null;
		
		JFileChooser fc;
		
		fc = new FileChooser(directory);
		
		fc.setFont(font);
		
		fc.setDialogTitle(title);
		
		int choice = fc.showSaveDialog(parent);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		{
			selectedfile = fc.getSelectedFile();
			
			return selectedfile;
		}
		
		else return null;
	}
}


//  End class SaveFile










class FileChooser extends JFileChooser
{

	//  A static font type is used because some font
	//  types can change the size of the dialog
	
	private static final long serialVersionUID = 1L;
	
	private Font font = new Font("Dialog", Font.PLAIN, 18);
	
	public FileChooser() { super(); }
	
	private float minsize =  8;
	private float maxsize = 21;
	
	public FileChooser(String directory)
	{
		super(directory);
	}
	
	public void setFont(Font font1)
	{
		//  sets the font size
		
		if (font1 == null) return;
		
		int size = font1.getSize();
		
		if (size < minsize) font1 = font.deriveFont(minsize);
		if (size > maxsize) font1 = font.deriveFont(maxsize);
		
		String name = font .getName();
		  int style = font .getStyle();
		  int size1 = font1.getSize();
		
		//  < size 17 == bold font, >= 17 == plain font
		
		style = (size1 >= 17) ? Font.PLAIN : Font.BOLD;
		
		font = new Font(name, style, size1);
		
		this.font = font;
		
		setFont(this.getComponents());
		
		Dimension d = super.getPreferredSize();
		
		double x = d.getWidth(), y = d.getHeight();
		
		d = new Dimension((int) (0.8*x), (int) (1.2*y));
		
		super.setPreferredSize(d);
	}
	
	
	private void setFont(Component[] comps)
	{
		for (Component comp : comps)
		{
			if (comp instanceof Container) // use recursion
			
			    setFont(((Container) comp).getComponents());
			
			if (comp instanceof JList
			 || comp instanceof JTable
			 || comp instanceof JTextField)
			
			    comp.setFont(font);
			
			float buttonfontsize = font.getSize();
			float comboboxfontsize = font.getSize();
			
			if (buttonfontsize < minsize) buttonfontsize = minsize;
			if (comboboxfontsize < minsize) comboboxfontsize = minsize;
			
			Font buttonfont = font.deriveFont(buttonfontsize);
			Font comboboxfont = font.deriveFont(comboboxfontsize);
			
			if (comp instanceof JComboBox) comp.setFont(comboboxfont);
			if (comp instanceof JButton) comp.setFont(buttonfont);
		}
	}
}








class Print
{

	public static void print(JTextArea textarea)
	{
	
		JTextArea textarea1 = new JTextArea();
		
		String selectedtext = textarea.getSelectedText();
		
		String text = textarea.getText();
		
		//  Create a new text area to copy the text to
		
		if ((selectedtext == null) || selectedtext.isEmpty())
		
		     textarea1.setText(text);
		else textarea1.setText(selectedtext);
		
		textarea1.setLineWrap(textarea.getLineWrap());
		textarea1.setWrapStyleWord(textarea.getWrapStyleWord());
		
		//  printed pages should be line wrapped
		textarea1.setLineWrap(true);
		
		textarea1.setForeground(textarea.getForeground());
		// textarea1.setBackground(textarea.getBackground());
		
		Font font = textarea.getFont();
		
		//  Make the print font size smaller
		//  than the text font size
		
		font = font.deriveFont(
		
		    font.getSize() - 6.0f);
		
		textarea1.setFont(font);
		
		//  Print the text area
		
		try { textarea1.print(); }
		
		catch (PrinterException ex)
		{
			System.out.println(ex);
		}
	}
}





class DeleteFileListener implements ActionListener
{

	//  Ctrl + D  opens the Delete (file) dialog
	
	
	private String directory;
	
	private JFrame frame;
	
	private Font font = new JPanel()
	
	    .getFont() .deriveFont(18.0f);
	
	
	public DeleteFileListener(JFrame frame)
	{
		this.frame = frame;
	}
	
	public void actionPerformed(ActionEvent e) { run(); }
	
	
	public void run()
	{
		int warnings = 0;
		
		while (true)
		{
			//  Choose a file
			
			File file = chooseFile(directory);
			
			if (file == null) return;
			
			directory = file.getParent();
			
			String filename = file.getName();
			
			
			//  Confirm delete operation
			
			//  String message = __.deletefileorfolder + " ?";
			
			String title = __.Warning + " !" + "  " + __.deletefile;
			
			String warning = __.Delete + " " + filename + " ?" + "\n\n";
			
			if (file.isFile())      warning += __.  filewillbedeleted + "!\n";
			if (file.isDirectory()) warning += __.folderwillbedeleted + "!\n";
			
			JTextArea textarea = new JTextArea(warning);
			
			textarea.setFont(new JLabel().getFont().deriveFont(16.0f));
			textarea.setBackground(new JLabel().getBackground());
			textarea.setEditable(false);
			
			if ((warnings < 2) || file.isDirectory())
			{
				//  Show the warning twice
				
				int choice = JOptionPane.showConfirmDialog(frame,
				    textarea, title, JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.WARNING_MESSAGE);
				
				if ((choice == JOptionPane.YES_OPTION)
				
				    && (file.isDirectory() || (warnings < 2)))
				
				    choice = JOptionPane.showConfirmDialog(frame,
				        textarea, title, JOptionPane.YES_NO_CANCEL_OPTION,
					    JOptionPane.WARNING_MESSAGE);
				
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)) return;
				
				else if (choice == JOptionPane.NO_OPTION) return;
				 
				else if (choice == JOptionPane.YES_OPTION) { }
			}
			
			//  Delete the file
			
			
			if (file.isFile()) { file.delete(); warnings++; }
			
			else if (file.isDirectory())
			{
				//  Delete the contents of the directory
				
				File[] files = ListFiles.listFiles(file);
				
				//  Only the files or empty directories will get
				//  deleted by the first for each loop unless the
				//  sub-directories are moved to the end of the array
				//  by the ListFiles listFiles method.
				
				for (File file1 : files)
				{
				    try { file1.delete(); }
				
				    catch (SecurityException ex)
				    {
					System.out.println(ex);
					
					JOptionPane.showMessageDialog(frame, ex);
					
					return;
				    }
				}
				
				//  Use a second loop to delete the remaining empty
				//  sub-directories that were not deleted by the
				//  first for each loop
				
				for (File file1 : files)
				
				    if (file1.exists()) file1.delete();
				
				//  Delete the empty top directory
				
				if (file.exists()) file.delete();
				
				warnings = 0;
			}
		}
	}
	
	
	
	
	private File chooseFile(String directory)
	{
	
		File file = null;
		
		FileChooser fc;
		
		fc = new FileChooser(directory);
		
		fc.setFont(font);
		
		String title = __.deletefileorfolder;
		
		fc.setDialogTitle(title);
		
		fc.setApproveButtonText(title);
		
		fc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
		
		int choice = fc.showDialog(frame, null);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		{
			file = fc.getSelectedFile();
			
			return file;
		}
		
		else if (choice == JFileChooser.CANCEL_OPTION)
		
		     return null;
		
		else return null;
	}
}


//  End class DeleteFileListener









class RenameFileListener implements ActionListener
{

	//  This class is not required because the user can rename
	//  a file by clicking File -> Open / Save and then clicking
	//  once on a selected file name.
	
	//  A user can also rename / move a file using Save As and
	//  then delete (ctrl + d) to remove the original file but
	//  that takes two operations.
	
	//  The difference between move and rename is that move
	//  can change the path, directory, or folder of the file.
	//  Rename just changes the name of the file.
	
	
	
	private String directory;
	
	private JFrame frame;
	
	String title = __.renamefileorfolder;
	
	private Font font = new JPanel()
	
	    .getFont() .deriveFont(18.0f);
	
	
	public RenameFileListener(JFrame frame)
	{
		this.frame = frame;
	}
	
	
	public void actionPerformed(ActionEvent e) { run(); }
	
	
	public void run()
	{
	
		while (true)
		{
			//  Choose a file
			
			File file1 = chooseFile(directory);
			
			if (file1 == null) return;
			
			directory = file1.getParent();
			
			String filename = file1.getName();
			String filepath = file1.getPath();
			
			
			//  Enter new file name
			
			String newfilename = null;
			
			while (true)
			{
				String title = __.newfilename;
				
				JTextField textfield;
				
				textfield = new JTextField(24);
				
				textfield.setFont(font);
				
				textfield.setText(filename);
				
				JOptionPane.showMessageDialog(frame, textfield,
				
				    title, JOptionPane.PLAIN_MESSAGE);
				
				String input = textfield.getText();
				
				newfilename = input;
				
				if ((newfilename == null)
				  || newfilename.isBlank())
				
				    return;
				
				if (newfilename.trim().equals(filename))
				
				    continue;
				
				else break;
			}
			
			File dest = new File(file1.getParent()
			
			    + File.separator + newfilename.trim());
			
			if (dest.exists())
			{
				//  Confirm file replacement
				
				String message = __.Replace + " " + newfilename + " ?";
				
				JLabel label = new JLabel(message);
				
				label.setFont(new JLabel().getFont().deriveFont(16.0f));
				
				int choice = JOptionPane.showConfirmDialog(frame, label);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
					break;
			}
			
			file1 .renameTo(dest);
		}
	}
	
	
	
	private File chooseFile(String directory)
	{
	
		File file = null;
		
		JFileChooser fc;
		
		fc = new FileChooser(directory);
		
		fc.setDialogTitle(title);
		
		fc.setApproveButtonText(title);
		
		int choice = fc.showDialog(frame, null);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		{
			file = fc.getSelectedFile();
			
			return file;
		}
		
		else if (choice == JFileChooser.CANCEL_OPTION)
		
		     return null;
		
		else return null;
	}
}


//  End class RenameFileListener











//	//  This code was used to create a file folder to
//	//  test the encrypt / decrypt directory menu items
//	
//	int filesize = 1024*1024, numberoffiles = 1024;
//	
//	String homedir = System.getProperty("user.home");
//	
//	String filename1 = homedir + File.separator +
//	
//	    "Desktop" + File.separator + "folder";
//	
//	File file1 = new File(filename1);
//	
//	System.out.println(!file1.exists());
//	
//	if (!file1.exists()) file1.mkdir();
//	
//	for (int i = 0; i < numberoffiles; i++)
//	{
//		String s = File.separator;
//		
//		String filename = homedir + s + "Desktop"
//		
//		 + s + "folder" + s + String.valueOf(i);
//		
//		File file = new File(filename);
//		
//		byte[] array = new byte[filesize + i];
//		
//		for (int j = 0; j < array.length; j++)
//		
//		//  ... !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNO
//		//
//		//  PQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ...
//		
//		    array[j] = (byte) j;
//		
//		DataStream.write(file, array);
//	}





class EncryptDirectory
{


	//  The user could have the option to convert a directory to a
	//  tar file, but if this option is used to encrypt and decrypt
	//  the directory, then the encryption is not parallelizable, and
	//  the entire directory has to be decrypted just to read one file.
	//
	//  If the user opens an encrypted file, the program sets the title
	//  of the frame to the decrypted file name but does not rename the
	//  file unless the user decrypts the file using the decrypt file or
	//  directory menu item.
	//
	//  If the user's operating system encrypts the home directory, the
	//  user may not want to use the editor program to encrypt the files.
	
	
	
	private File directory;
	
	private JFrame frame;
	
	private String defaultfontname
	
	    = new JTextArea().getFont().getName();
	
	private int maxfontsize = 22;
	private int defaultfontsize = 16;
	
	private Font font = new Font(
	
	  defaultfontname, Font.BOLD, defaultfontsize);
	
	private Color foreground = Color.black;
	private Color background = Color.white;
	
	private byte[] filekey;
	
	private boolean encryptfilenames;
	
	private JDialog dialog;
	
	private JTextArea filearea;
	
	private JButton    testbutton;
	private JButton encryptbutton;
	private JButton decryptbutton;
	private JButton  cancelbutton;
	
	private JButton[] buttons;
	
	private boolean canceled;
	
	private static AtomicInteger numberoffiles;
	
	private boolean running;
	
	private boolean test;
	
	
	public EncryptDirectory(JFrame frame)
	{
		this.frame = frame;
		
		numberoffiles = new AtomicInteger();
		
		   testbutton = new JButton(__.test);
		encryptbutton = new JButton(__.encrypt);
		decryptbutton = new JButton(__.decrypt);
		 cancelbutton = new JButton(__.cancel);
		
		buttons = new JButton[]
		
		    { testbutton, encryptbutton,
		   decryptbutton,  cancelbutton };
		
		for (JButton button : buttons) button.setFont(
		
		    button.getFont().deriveFont(18.0f));
		
		
		testbutton.addActionListener(new ActionListener()
		{    public void actionPerformed(ActionEvent e)
		     {  if (running) return;
			// Set test = true so the
			// encrypt/decrypt methods
			// only test the files
			test = true;
			filearea.setText("");
			canceled = false;
			new Thread(() ->
			{ running = true;
			  encrypt(directory);
			  decrypt(directory);
			  running = false;
			  test = false;
			}).start();
		} });
		
		encryptbutton.addActionListener(new ActionListener()
		{    public void actionPerformed(ActionEvent e)
		     {  if (running) return;
			filearea.setText("");
			canceled = false;
			new Thread(() ->
			{ running = true;
			  encrypt(directory);
			  running = false;
			}).start();
		} });
		
		decryptbutton.addActionListener(new ActionListener()
		{   public void actionPerformed(ActionEvent e)
		    {   if (running) return;
			filearea.setText("");
			canceled = false;
			new Thread(() ->
			{ running = true;
			  decrypt(directory);
			  running = false;
			}).start();
		} });
		
		cancelbutton.addActionListener(new ActionListener()
		   { public void actionPerformed(ActionEvent e)
		        { canceled = true; }});
	}
	
	public void setFont(Font font)
	{
		if (font.getSize() > maxfontsize)
		
		  font = font.deriveFont((float) maxfontsize);
		
		this.font = font;
	}
	
	public void setForeground(Color color)
	{
		this.foreground = color;
	}
	
	public void setBackground(Color color)
	{
		this.background = color;
	}
	
	public void setFileKey(byte[] filekey)
	{
		this.filekey = filekey;
	}
	
	public byte[] getFileKey()
	{
		return this.filekey;
	}
	
	
	public void encryptDecryptDirectory()
	{
	
		int choice = chooseDirectory();
		
		if ((choice == JOptionPane.CLOSED_OPTION)
		 || (choice == JOptionPane.NO_OPTION)) return;
		
		if (filekey == null) chooseFileKey();
		
		if (filekey == null) return;
		
		String encryptmessage  = __.encryptdirectorywithkey;
		String enterpassphrase = __.entersecretpassphrase;
		
		String filepath = directory.toString();
		
		if (filepath.length() > 32) filepath =
		
		    filepath .substring(0, 32) + "..";
		
		String str = new Number(filekey) .toString(16);
		
		while ((str.length() % 8) != 0) str = "0" + str;
		
		String keyhash = Convert.partition(
		
		    str.substring(0, 16), " ", 4);
		
		String title = directory.toString();
		
		
		//  Create the panel that contains the components
		
		JPanel panel = createPanel(filepath, keyhash);
		
		
		//  Display the panel using a JOptionPane dialog
		//
		//  JOptionPane.showConfirmDialog(frame, panel, title,
		//
		//    JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null);
		
		
		//  The JOptionPane constructor is used instead of the
		//  static factory method to get a reference to the
		//  dialog object so the frame can be re-packed if the
		//  user changes the directory name or file key.
		
		
		Icon icon = null;
		
		Object[] options = null;
		
		JOptionPane pane = new JOptionPane(panel,
		
		    JOptionPane.PLAIN_MESSAGE, JOptionPane
		
			.DEFAULT_OPTION, icon, options, 0);
		
		//  pane.set(...)
		
		dialog = pane.createDialog(frame, title);
		
		dialog.setVisible(true);
		
		
		//  Object value = pane.getValue();
		//
		//  if(value == null) return JOptionPane.CLOSED_OPTION;
		//
		//  if ((options == null) && value instanceof Integer)
		//
		//    return ((Integer) value).intValue();
		//
		//  return CLOSED_OPTION;
	}
	
	
	
	private int chooseDirectory()
	{
		//  Choose a directory to encrypt
		
		JFileChooser fc;
		
		fc = new FileChooser();
		
		fc.setFont(font);
		
		
		//  Choose a directory
		
		int mode = JFileChooser.DIRECTORIES_ONLY;
		
		fc.setFileSelectionMode(mode);
		
		String title =
		
		  __.encryptdecryptdirectory;
		
		fc.setDialogTitle(title);
		
		fc.setApproveButtonText(title);
		
		int choice = fc.showDialog(frame, null);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		
		    directory = fc.getSelectedFile();
		
		return choice;
	}
	
	
	
	private void chooseFileKey()
	{
		//  Create a passphrase dialog
		
		PassphraseDialog pd = new PassphraseDialog(
		
		    frame, PassphraseDialog.passphrase_only);
		
		pd.setMinimumLength(0);
		
		pd.setFont1(font != null ?
		
		    font : frame.getFont());
		
		pd.setForeground1(foreground);
		pd.setBackground1(background);
		
		//  Request a secret file key
		
		String passphrase = pd .readPassphrase();
		
		if ((passphrase != null) && !passphrase.isEmpty())
		
		    filekey = Cipher.passphraseToKey(passphrase);
		
		else return;
	}
	
	
	
	
	private JPanel createPanel(String filename, String keyhash)
	{
	
	
		//   _____________________________________________________
		//  |                                                     |
		//  |               [x] Encrypt file names                |
		//  |               /home/username/folder                 |
		//  |              Encrypt directory with key             |
		//  |                 0123 4567 89ab cdef                 |
		//  |      _________________________________________      |
		//  |     |  Encrypting file /home/username/file1   |     |
		//  |     |  Encrypting file /home/username/file2   |     |
		//  |     |  Encrypting file /home/username/file3   |     |
		//  |     |  Encrypting file /home/username/file4   |     |
		//  |     |_________________________________________|     |
		//  |      ______   _________   _________   ________      |
		//  |     |_Test_| |_Encrypt_| |_Decrypt_| |_Cancel_|     |
		//  |                        ____                         |
		//  |                       |_OK_|                        |
		//  |_____________________________________________________|
		
		
		//  Create the encrypt / decrypt directory panel
		
		Box vbox = Box.createVerticalBox();
		
		JCheckBox checkbox = new JCheckBox();
		
		checkbox.addActionListener(new ActionListener()
		{ public void actionPerformed(ActionEvent e)
		{ encryptfilenames = checkbox.isSelected(); }});
		
		JLabel label1, label2, label3, label4;
		
		label1 = new JLabel(__.encryptfilenames);
		label2 = new JLabel(filename);
		label3 = new JLabel(__.encryptdirectorywithkey);
		label4 = new JLabel(keyhash);
		
		label1.setFont(font);
		label2.setFont(font);
		label3.setFont(font);
		label4.setFont(font);
		
		label1.addMouseListener(new MouseAdapter()
		{ public void mouseClicked(MouseEvent e)
		{ Object obj = e.getSource();
		if (obj instanceof JLabel)
		    checkbox.setSelected(
		   !checkbox.isSelected()); }});
		
		
		JButton filebutton = new JButton();
		JButton  keybutton = new JButton();
		
		filebutton.setEnabled(false);
		 keybutton.setEnabled(false);
		
		filebutton.add(label2);
		 keybutton.add(label4);
		
		
		Box hbox1, hbox2, hbox3, hbox4;
		
		hbox1 = Box.createHorizontalBox();
		hbox2 = Box.createHorizontalBox();
		hbox3 = Box.createHorizontalBox();
		hbox4 = Box.createHorizontalBox();
		
		Component hstrut = Box
		    .createHorizontalStrut(2);
		
		hbox1.add(checkbox);
		hbox1.add(hstrut);
		hbox1.add(label1);
		hbox2.add(filebutton);
		hbox3.add(label3);
		hbox4.add(keybutton);
		
		Component strut1 = Box.createVerticalStrut(2);
		Component strut2 = Box.createVerticalStrut(2);
		Component strut3 = Box.createVerticalStrut(2);
		Component strut4 = Box.createVerticalStrut(2);
		
		vbox.add(hbox1); vbox.add(strut1);
		vbox.add(hbox2); vbox.add(strut2);
		vbox.add(hbox3); vbox.add(strut3);
		vbox.add(hbox4); vbox.add(strut4);
		
		
		//  The highlighter must be disabled or set to null or
		//  else the program can become deadlocked if the user
		//  clicks on the text area as the file names are scrolling
		
		filearea = new JTextArea(10, 64);
		filearea.setEditable(false);
		filearea.setHighlighter(null);
		filearea.setFont(font);
		filearea.setForeground(foreground);
		filearea.setBackground(background);
		if (background.equals(new JPanel().getBackground()))
		    background = Color.white;
		
		JScrollPane scrollpane;
		
		scrollpane = new JScrollPane(filearea);
		
		vbox.add(scrollpane);
		
		Box hbox = Box.createHorizontalBox();
		
		hbox.add(testbutton);
		hbox.add(encryptbutton);
		hbox.add(decryptbutton);
		hbox.add(cancelbutton);
		
		vbox.add(hbox);
		
		JPanel panel = new JPanel();
		
		panel.add(vbox);
		
		
		JLabel filelabel;
		JLabel keyhashlabel;
		
		   filelabel = label2;
		keyhashlabel = label4;
		
		
		filelabel.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent e)
			{
				if (e.getSource() == filelabel)
				{
					if (running) return;
					
					chooseDirectory();
					
					String pathname = directory.getPath();
					
					filelabel.setText(pathname);
					
					dialog.setSize(dialog
					
					    .getPreferredSize());
				}
			}
		});
		
		
		keyhashlabel.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent e)
			{
				if (e.getSource() == keyhashlabel)
				{
					if (running) return;
					
					chooseFileKey();
					
					String str = new Number(filekey).toString(16);
					
					while ((str.length() % 8) != 0) str = "0" + str;
					
					String keyhash = Convert.partition(
					
					    str.substring(0, 16), " ", 4);
					
					keyhashlabel.setText(keyhash);
					
					dialog.setSize(dialog
					
					    .getPreferredSize());
				}
			}
		});
		
		
		return panel;
	}
	
	
	
	//  The program could become deadlocked if the append
	//  method were not synchronized and then the user
	//  would have to find and terminate the process
	
	
	private synchronized void append(String message)
	{
		filearea.append(message + "\n");
		
		filearea.moveCaretPosition(
		
		   filearea.getText().length());
		
		//  System.out.println(message);
	}
	
	
	
	private void encrypt(File directory)
	{
	
		//  Verify that the directory is in the home dir
		//  (The computer could become inoperable if the
		//  user encrypts directories other than home be-
		//  cause it would encrypt the operating system
		//  files.)
		
		String parent = directory.getParent();
		
		if (parent != null)
		{
			int index = parent.indexOf(File.separator, 1);
			
			if (index != -1) parent = parent.substring(0, index);
			
			String home = System.getProperty("user.home");
			
			home = home.substring(0, home.indexOf(File.separator, 1));
			
			if (!parent.equals(home) && !directory.getPath().contains(__.media))
			{
				//  Warn the user that the file
				//  is not in the home directory
				
				String title = "";
				
				String message = __.directoryisnotinhomefolder
				        + "\n" + __.proceedanyway + " ?";
				
				int choice = JOptionPane
				
				  .showConfirmDialog(frame, message, title,
				
				    JOptionPane.YES_NO_CANCEL_OPTION,
				    JOptionPane.WARNING_MESSAGE);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
					return;
			}
		}
		
		//  Reset the number of files
		
		numberoffiles.set(0);
		
		//  Read the file names into the file list
		
		File[] files = ListFiles.listFiles(directory);
		
		long totalbytes = 0;
		
		for (File file : files)
		
		    totalbytes += file.length();
		
		
		//  Permutate the files randomly so
		//  that the file sizes are random
		
		permutate(files);
		
		
		//  Create multiple threads
		
		int t = Runtime.getRuntime()
		
		    .availableProcessors();
		
		Thread[] tarray = new Thread[t];
		
		int size = (files.length + t -1) / t;
		
		File[][] filearrays = new File[t][];
		
		for (int i = 0; i < t; i++)
		
		    filearrays[i] = new File[size];
		
		for (int i = 0; i < t; i++)
		
		   for (int j = 0; j < size; j++)
		
		      if ((size*i + j) < files.length)
		
		         filearrays[i][j] = files[size*i + j];
		
		//  Add the runnable R1 to the thread array
		
		for (int i = 0; i < tarray.length; i++)
		
		    tarray[i] = new Thread(new R1(filearrays[i]));
		
		
		long starttime = System.currentTimeMillis();
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		long endtime = System.currentTimeMillis();
		
		long seconds = (endtime - starttime) / 1000;
		
		if (canceled)
		{
			append(__.canceled + "\n");
			
			append(__.clickdecrypt);
			
			running = false;
			
			return;
		}
		
		int totalfiles = 0;
		
		for (File file : files) if (file.isFile()) totalfiles++;
		
		String message = "\n" + numberoffiles + " " + __.files
		
		   + "  " + totalbytes/1024/1024 + " " + "M" + __.bytes
		
		   + "  " + seconds + " " + __.seconds;
		
		message += "\n" + __.encrypteddirectory + " " + directory;
		
		if (!test) append(message);
	}
	
	
	
	
	
	private void decrypt(File directory)
	{
	
		//  Verify that the directory is in the home dir
		
		String parent = directory.getParent();
		
		if (parent != null)
		{
			int index = parent.indexOf(File.separator, 1);
			
			if (index != -1) parent = parent.substring(0, index);
			
			String home = System.getProperty("user.home");
			
			home = home.substring(0, home.indexOf(File.separator, 1));
			
			if (!parent.equals(home) && !directory.getPath().contains(__.media) && !test)
			{
				//  Warn the user that the file is not in the home dir
				
				String title = "";
				
				String message = __.directoryisnotinhomefolder
				        + "\n" + __.proceedanyway + " ?";
				
				int choice = JOptionPane
				
				  .showConfirmDialog(frame, message, title,
				
				    JOptionPane.YES_NO_CANCEL_OPTION,
				    JOptionPane.WARNING_MESSAGE);
				
				if ((choice == JOptionPane.CANCEL_OPTION)
				 || (choice == JOptionPane.CLOSED_OPTION)
				 || (choice == JOptionPane.NO_OPTION))
				
					return;
			}
		}
		
		//  Reset the number of files
		
		numberoffiles.set(0);
		
		
		//  Read the file names into the file list
		
		File[] files = ListFiles.listFiles(directory);
		
		long totalbytes = 0;
		
		for (File file : files)
		
		    totalbytes += file.length();
		
		
		//  Permutate the files to randomize
		//  the workload among the threads
		
		permutate(files);
		
		
		//  Create multiple threads
		
		int t = Runtime.getRuntime()
		
		    .availableProcessors();
		
		Thread[] tarray = new Thread[t];
		
		int size = (files.length + t -1) / t;
		
		File[][] filearrays = new File[t][];
		
		for (int i = 0; i < t; i++)
		
		    filearrays[i] = new File[size];
		
		for (int i = 0; i < t; i++)
		
		   for (int j = 0; j < size; j++)
		
		      if ((size*i + j) < files.length)
		
		         filearrays[i][j] = files[size*i + j];
		
		
		//  Add the runnable R2 to the thread array
		
		for (int i = 0; i < tarray.length; i++)
		
		    tarray[i] = new Thread(new R2(filearrays[i]));
		
		
		long starttime = System.currentTimeMillis();
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		long endtime = System.currentTimeMillis();
		
		long seconds = (endtime - starttime) / 1000;
		
		
		if (canceled) { append(__.canceled);
		
		    running = false; return; }
		
		
		int totalfiles = 0;
		
		for (File file : files) if (file.isFile()) totalfiles++;
		
		String message = "\n" + (test ? totalfiles : numberoffiles)
		
		   + " " + __.files + "  " + totalbytes/1024/1024 + " " + "M"
		
		   + __.bytes + "  " + seconds + " " + __.seconds;
		
		if (test) append(message);
		
		if (!test) append(message + "\n" +
		
		    __.decrypteddirectory + " " + directory);
	}
	
	
	
	
	private void permutate(File[] files)
	{
		//  Permutate the files to randomize
		//  the workload among the threads
		
		int n = files.length;
		
		Math.initRng(System.nanoTime());
		
		for (int i = 0; i < n; i++)
		{
			//  Generate a random index from 0 to n-2 -i
			
			int rand1 = Math.random(n-1 -i); // 0 to n-2 -i
			
			//  Swap or interchange a[n-1 -i] and a[rand1]
			
			File temp = files[rand1];
			
			files[rand1] = files[n-1 -i];
			
			files[n-1 -i] = temp;
		}
	}
	
	
	
	
	private class R1 implements Runnable
	{
	
		private File[] files;
		
		public R1(File[] files)
		
		    { this.files = files; }
		
		public void run()
		{
		
			for (File file : files)
			{
				if ((file == null) || file.isDirectory()) continue;
				
				if (canceled) return;
				
				
				if (test)
				{
					String message = __.encryptedfile + " " + file;
					
					if (Cipher.isEncrypted(file))
					
					    append(message);
					
					continue;
				}
				
				
				if (!file.canWrite())
				
				  { append(__.fileisnotwritable); continue; }
				
				
				
				if (!Cipher.isEncrypted(file))
				{
					String message = __.encryptingfile + " " + file;
					
					append(message);
					
					
					//  Save the last modified time
					
					long time = file.lastModified();
					
					
					//  Encrypt the file input
					
					boolean bool;
					
					try { bool = FileEncryptor.encrypt(file, filekey); }
					
					catch (IOException ex)
					{
						append(ex.toString());
						
						continue;
					}
					
					numberoffiles.getAndIncrement();
				}
				
				else
				{	String message = __.fileisalreadyencrypted
					
					     + " " + file.toString();
					
					append(message);
					
					continue;
				}
				
				
				if (encryptfilenames)
				{
					String name1 = FileNameEncryptor
					
					  .encryptFileName(file.getName(), filekey);
					
					String path1 = file.getParent() + File.separator + name1;
					
					file.renameTo(new File(path1));
				}
			}
		}
	}
	
	
	
	
	private class R2 implements Runnable
	{
	
		private File[] files;
		
		public R2(File[] files)
		
		    { this.files = files; }
		
		
		public void run()
		{
			for (File file : files)
			{
				if ((file == null) || file.isDirectory()) continue;
				
				if (canceled) return;
				
				if (test)
				{
					String message = __.unencryptedfile + " " + file;
					
					if (!Cipher.isEncrypted(file))
					{
						append(message);
						
						//  System.out.println(message);
					}
					
					continue;
				}
				
				
				if (!file.canWrite())
				
				  { append(__.fileisnotwritable); continue; }
				
				
				//  Read the last modified time
				
				long time = file.lastModified();
				
				
				if (Cipher.isEncrypted(file))
				{
					//  Try to decrypt the file
					
					String message = __.decryptingfile + " " + file;
					
					append(message);
					
					boolean bool;
					
					try
					{	bool = FileDecryptor.decrypt(file, filekey);
						
						if (bool && Cipher.isEncrypted(file))
						
						    System.out.println("Error: " + file.getName() +
						
							" was encrypted more than once, decrypt again");
						
						file.setLastModified(time);
					}
					
					catch (IOException ex)
					{
						append(ex.toString());
						
						continue;
					}
					
					numberoffiles.getAndIncrement();
					
					
					if (Number.isBase16(file.getName())
					
					    && (file.getName().length() >= 32))
					{
						//  Decrypt the file name
						
						String name1 = FileNameEncryptor
						
						  .decryptFileName(file.getName(), filekey);
						
						if ((name1 != null) && !name1.isEmpty())
						{
							String path1 = file.getParent()
							
							    + File.separator + name1;
							
							file.renameTo(new File(path1));
						}
					}
				}
				
				else
				{	String message =
					
					   __.fileisnotencrypted + " " + file;
					
					append(message);
					
					continue;
				}
			}
		}
	}
}


//  End class EncryptDirectory













class PublicKeyRing
{


	//  This class is not finished
	
	
	private ArrayList<String[]> publickeylist;
	
	
	public PublicKeyRing()
	{
		this.publickeylist = new ArrayList<String[]>();
	}
	
	
	public int add(String[] name_key)
	{
		//  stores the public key name and data
		
		if ((name_key == null) || (name_key.length != 2)
		
		 || (name_key[0] == null) || (name_key[1] == null))
		
		    throw new IllegalArgumentException();
		
		String name = name_key[0].trim();
		String  key = name_key[1].trim();
		
		key = key.replaceAll("\n", "");
		
		if (!PublicKey.isValidKey(key))
		
		    throw new IllegalArgumentException();
		
		int size = this.publickeylist.size();
		
		//  Search the public key ring for the key name
		
		for (int i = 0; i < size; i++)
		{
			if (this.publickeylist.get(i)[0].equals(name))
			
			//  email address already exists
			{
				if (this.publickeylist.get(i)[1].equals(key))
				{
					//  public key already exists
					
					return 1;
				}
				
				else    //  public key has changed
				{
					this.publickeylist.set(i,
					
					    new String[] { name, key });
					
					return -1;
				}
			}
		}
		
		//  Add a new public key name to the ring
		
		this.publickeylist.add(new String[] { name, key });
		
		return 0;
	}
	
	
	public String[] get(int index)
	{
		//  returns a public key by index
		
		return this.publickeylist.get(index);
	}
	
	public boolean hasKey(String name)
	{
		//  tests if the public key ring
		//  contains a public key
		
		String key = retrieve(name);
		
		if ((key != null) && !key.isEmpty())
		
		     return true;
		
		else return false;
	}
	
	public String[] remove(int index)
	{
		//  removes a public key
		
		return this.publickeylist.remove(index);
	}
	
	
	public String[] readClipboardKey()
	{
		//  reads the clipboard text and uses the static Public-
		//  Key.parseKey(String) method to parse the key into a
		//  string array of email address and public key data
		
		//  email address and public key
		
		String[] name_key = null;
		
		String clipboardtext = "";
		
		Clipboard cb = Toolkit.getDefaultToolkit().getSystemClipboard();
		
		DataFlavor flavor = DataFlavor.stringFlavor;
		
		try { clipboardtext = (String) cb.getData(flavor); }
		
		catch (UnsupportedFlavorException ex) {  }
		
		catch (IOException ex) { return null; }
		
		//  Read the name / address and public key
		
		if ((clipboardtext != null) && !clipboardtext.isEmpty()
		
		    && PublicKey.isPublicKeyDocument(clipboardtext))
		
			name_key = PublicKey.parseKey(clipboardtext);
		
		if (name_key == null) return null;
		
		//  Partition the key hash to make it easier to read
		
		if (Number.isBase16(name_key[0]))
		
		    name_key[0] = Convert.partition(name_key[0], " ", 4);
		
		if (name_key.length == 2)
		
		    return name_key;
		
		else return null;
	}
	
	
	public int size()
	{
		//  returns the number of public keys
		
		return this.publickeylist.size();
	}
	
	
	public String retrieve(String name)
	{
		//  returns a public key by name
		
		for (int i = 0; i < this.publickeylist.size(); i++)
		
		    if (this.publickeylist.get(i)[0].startsWith(name.trim()))
		
			return this.publickeylist.get(i)[1];
		
		return null;
	}
}


//  End class PublicKeyRing













class FileEncryptor
{

	//  The FileEncryptor class displays the JFileChooser
	//  Dialog and the select and confirm file key dialog
	
	
	private Window window;
	
	private byte[] filekey;
	
	private Font font = new JTextArea().getFont();
	
	private Color foreground = Color.black;
	private Color background = Color.white;
	
	private String title;
	
	private int minlength;
	
	private String encryptmessage =
	
	    __.encryptfilewithkey;
	
	private String SP; // file decryption
	
	
	//  FileEncryptor constructor
	
	public FileEncryptor(Window window)
	{
		this.window = window;
	}
	
	
	//  FileEncryptor methods
	
	public void setMinimumLength(int length)
	{
		this.minlength = length;
	}
	
	public byte[] getFileKey()
	{
		return this.filekey;
	}
	
	public void setFileKey(byte[] filekey)
	{
		this.filekey = filekey;
	}
	
	public void setFont(Font font)
	{
		float maxfontsize = 24;
		
		int size = font.getSize();
		
		if (size > maxfontsize)
		
		    font = font.deriveFont(maxfontsize);
		
		this.font = font;
	}
	
	public void setForeground(Color color)
	{
		this.foreground = color;
	}
	
	public void setBackground(Color color)
	{
		this.background = color;
	}
	
	public void setTitle(String title)
	{
		this.title = title;
	}
	
	public File chooseFile(String directory)
	{
	
		File file = null;
		
		JFileChooser fc;
		
		fc = new FileChooser(directory);
		
		fc.setFont(font);
		
		fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
		
		String title = __.encryptfile;
		
		if (filekey != null)
		{
			String passphrasehash = new Number(filekey).toString(40, 16);
			
			while ((passphrasehash.length() % 8) != 0)
			
			    passphrasehash = "0" + passphrasehash;
			
			passphrasehash = passphrasehash.substring(0, 16);
			
			passphrasehash = Convert.partition(passphrasehash, " ", 4);
			
			//  Encrypt file   0123 4567 89ab cdef
			
			title += "      " + passphrasehash;
		}
		
		fc.setDialogTitle(title);
		
		fc.setApproveButtonText(__.encryptfile);
		
		int choice = fc.showDialog(window, null);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		{
			file = fc.getSelectedFile();
			
			return file;
		}
		
		else if (choice == JFileChooser.CANCEL_OPTION)
		
		     return null;
		
		else return null;
	}
	
	
	
	
	public boolean encrypt(File file)
	{
		return encrypt(file, false);
	}
	
	
	public boolean encrypt(File file, boolean confirm)
	{
		boolean bool = false;
		
		if (confirm || (filekey == null))
		{
			bool = selectAndConfirmFileKey(encryptmessage);
			
			if (!bool || (filekey == null)) return false;
		}
		
		//  Encrypt the file with the file key
		
		bool = false;
		
		try { bool = encrypt(file, filekey); }
		
		catch (IOException ex) { System.out.println(ex); }
		
		
		if (!bool) return false;
		
		else return true;
	}
	
	
	
	
	public boolean selectAndConfirmFileKey(String title)
	{
	
		if (filekey == null)
		{
			//  Display the passphrase dialog
			
			PassphraseDialog pd = new PassphraseDialog(
			
			   window, PassphraseDialog.passphrase_only);
			
			pd.setMinimumLength(minlength);
			pd.setForeground1(foreground);
			pd.setBackground1(background);
			pd.setFont1(font);
			
			String passphrase = pd.readPassphrase();
			
			if ((passphrase != null) && !passphrase.isEmpty())
			
			     filekey = Cipher.passphraseToKey(passphrase);
			
			else return false;
		}
		
		
		
		//  Confirm the key
		
		
		while (true)
		{
			//  Show confirmation dialog
			
			int digits = 16, radix = 16;
			
			String passphrasehash = new Number(filekey).toString(40, 16);
			
			while ((passphrasehash.length() % 8) != 0)
			
			    passphrasehash = "0" + passphrasehash;
			
			passphrasehash = passphrasehash.substring(0, 16);
			
			passphrasehash = Convert.partition(passphrasehash, " ", 4);
			
			//  Encrypt file with key xxxx xxxx xxxx xxxx
			
			JLabel label1 = new JLabel(title);
			JLabel label2 = new JLabel(passphrasehash);
			
			Font labelfont = new JLabel()
			
			   .getFont() .deriveFont(16.0f);
			
			label1.setFont(labelfont);
			label2.setFont(labelfont);
			
			Box vbox = Box.createVerticalBox();
			
			vbox.add(label1);
			vbox.add(Box.createVerticalStrut(8));
			vbox.add(label2);
			
			int choice = JOptionPane
			
			   .showConfirmDialog(window, vbox);
			
			if ((choice == JOptionPane.CANCEL_OPTION)
			 || (choice == JOptionPane.CLOSED_OPTION))
			{
				return false;
			}
			
			else if (choice == JOptionPane.NO_OPTION)
			{
				//  Create a passphrase dialog
				
				PassphraseDialog pd = new PassphraseDialog(
				
				   window, PassphraseDialog.passphrase_only);
				
				pd.setMinimumLength(minlength);
				pd.setForeground1(foreground);
				pd.setBackground1(background);
				
				pd.setFont1(font != null ?
				    font : window.getFont());
				
				String passphrase = pd.readPassphrase();
				
				if ((passphrase == null) || passphrase.isEmpty())
				{
					return false;
				}
				
				else
				{	this.filekey = Cipher
					
					    .passphraseToKey(passphrase);
					
					continue;
				}
			}
			
			else if (choice == JOptionPane.YES_OPTION)
			{
				return true;
			}
		}
	}
	
	
	
	public static boolean encrypt(File file, byte[] encryptionkey)
	
		throws IOException, FileNotFoundException
	{
		//  encrypts a file using an encryption key
		
		//  The last modified time is not changed by this method
		//  because the file is not being modified by encryption.
		//
		//  Otherwise the time stamps would be useless because all
		//  the files would be set to the last encryption date
		//  instead of the last modified date.
		
		if ((file == null) || Cipher.isEncrypted(file)) return false;
		
		//  Save the last modified time before writing
		
		long time = file.lastModified();
		
		//  Read and encrypt the plaindata
		
		byte[] plaindata, cipherdata = null;
		
		//  Set the file size <= 256 K bytes so the code
		//  doesn't throw an exception that says java.lang.
		//  OutOfMemoryError: Java heap space
		
		int maxfilesize = 256*1024*1024;
		
		if (file.length() < maxfilesize)
		{
			plaindata = DataStream.read(file);
			
			cipherdata = Cipher.encrypt(plaindata,
			
			    encryptionkey, Cipher.encrypt_method_3);
			
			if (cipherdata == null)
			{
				System.out.println("encryption error");
				
				return false;
			}
		}
		
		else // if (file.length() >= maxfilesize)
		{
			boolean bool = Cipher.encryptLargeFile(
			
			    file, encryptionkey);
			
			file.setLastModified(time);
			
			return bool;
		}
		
		
		//  //  Erase the file plaintext by writing zeros
		//
		//  byte[] array = new byte[(int) file.length()];
		//
		//  DataStream.write(file, array); // too slow
		
		
		//  Read the file path, delete the plaindata/text file,
		//  and create a new cipherdata/text file using the path
		
		String filepath = file.getPath();
		
		if (file.canWrite())
		{
			//  Make sure the file is really writable
			//  before deleting the plaintext file
			
			try { DataStream.write(file, new byte[0]); }
			
			catch (IOException ex)
			{
				System.out.println(ex);
			}
			
			boolean bool = file.delete();
			
			if (!bool) System.out.println(
			
			    "Error deleting file");
		}
		
		//  Save the encrypted file
		
		file = new File(filepath);
		
		//  Save the cipherdata to file
		
		DataStream.write(file, cipherdata);
		
		file.setLastModified(time);
		
		return true;
	}
}


//  End class FileEncryptor














class FileDecryptor
{


	//  The FileDecryptor class displays the JFileChooser Dialog
	//  and the passphrase dialog
	//
	//  (The FileDecryptor class doesn't do passphrase confirmation
	//  because there is no need to confirm a passphrase for decryption)
	
	
	private Window window;
	
	private byte[] filekey;
	
	private Font font = new JTextArea().getFont();
	
	private Color foreground = Color.black;
	private Color background = Color.white;
	
	private String SP;
	
	private String title;
	
	private int minlength;
	
	
	
	//  FileDecryptor constructor
	
	
	public FileDecryptor(Window window)
	{
		this.window = window;
	}
	
	
	//  FileDecryptor methods
	
	
	public void setMinimumLength(int length)
	{
		this.minlength = length;
	}
	
	public byte[] getFileKey()
	{
		return this.filekey;
	}
	
	public void setFileKey(byte[] filekey)
	{
		this.filekey = filekey;
	}
	
	public void setPassphrase(String passphrase)
	{
		this.SP = passphrase;
	}
	
	public void setFont(Font font)
	{
		float maxfontsize = 24;
		
		int size = font.getSize();
		
		if (size > maxfontsize)
		
		    font = font.deriveFont(maxfontsize);
		
		this.font = font;
	}
	
	public void setForeground(Color color)
	{
		this.foreground = color;
	}
	
	public void setBackground(Color color)
	{
		this.background = color;
	}
	
	public void setTitle(String title)
	{
		this.title = title;
	}
	
	public File chooseFile(String directory)
	{
		File file = null;
		
		JFileChooser fc;
		
		fc = new FileChooser(directory);
		
		fc.setFont(font);
		
		fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
		
		String title = __.decryptfile;
		
		fc.setDialogTitle(title);
		
		fc.setApproveButtonText(title);
		
		int choice = fc.showDialog(window, null);
		
		if (choice == JFileChooser.APPROVE_OPTION)
		{
			file = fc.getSelectedFile();
			
			return file;
		}
		
		else if (choice == JFileChooser.CANCEL_OPTION)
		
		     return null;
		
		else return null;
	}
	
	
	
	public boolean decrypt(File file)
	{
	
		int maxfilesize = Cipher.maxfilesize;
		
		if (!Cipher.isEncrypted(file)) return false;
		
		if (file.length() <= maxfilesize)
		{
			byte[] input;
			
			try { input = DataStream.read(file); }
			
			catch (IOException ex)
			{
				System.out.println(ex);
				
				return false;
			}
			
			byte[] plaindata = decrypt(input);
			
			if (plaindata == null) return false;
			
			
			//  Save the last modified time before writing
			
			long time = file.lastModified();
			
			//  Save the decrypted file and restore the last modified time
			
			if (plaindata != null)
			{
				try
				{	DataStream.write(file, plaindata);
					
					file.setLastModified(time);
				}
				
				catch (IOException ex) { System.out.println(ex); }
			}
			
			
			if (Number.isBase16(file.getName())
			
			    && (file.getName().length() >= 32))
			{
				String name1 = FileNameEncryptor
				
				  .decryptFileName(file.getName(), filekey);
				
				String path1 = file.getParent() + File.separator + name1;
				
				file.renameTo(new File(path1));
			}
			
			return true;
		}
		
		
		else // if (file.length() > maxfilesize)
		{
			//  Find the decryption key
			
			//  First try the secret passphrase SP
			
			boolean bool = false;
			
			if ((SP != null) && !SP.isEmpty())
			{
				try { bool = decrypt(file, Cipher.passphraseToKey(SP)); }
				
				catch (IOException ex) { System.out.println(ex); }
			}
			
			//  If the file was decrypted by the secret passphrase
			//
			//  update the filekey and return
			
			if (bool)
			{
				if (filekey == null) this.filekey
				
				    = Cipher.passphraseToKey(SP);
				
				return true;
			}
			
			
			while (true)
			{
				if (filekey != null)
				{
					//  Try the file key and return true if the file decrypts
					
					try { bool = decrypt(file, filekey); }
					
					catch (IOException ex) { System.out.println(ex); }
					
					if (bool == true) return true;
					
					else filekey = null;
				}
				
				//  Request a passphrase from the user
				
				//  Create a passphrase dialog
				
				PassphraseDialog pd = new PassphraseDialog(
				
				   window, PassphraseDialog.passphrase_only);
				
				pd.setTitle(title);
				pd.setMinimumLength(minlength);
				pd.setForeground1(foreground);
				pd.setBackground1(background);
				pd.setFont1(font != null ?
				    font : window.getFont());
				
				String passphrase = pd.readPassphrase();
				
				if ((passphrase == null) || passphrase.isEmpty())
				
				    return false;
				
				filekey = Cipher.passphraseToKey(passphrase);
			}
		}
	}
	
	
	
	public byte[] decrypt(byte[] data)
	{
	
		//  This method is required because the editor programs
		//  have to be able to read and view encrypted files
		//  without decrypting the files on disk.
		//
		//  The method first tries the secret passphrase and file
		//  key and then it prompts the user to enter a passphrase.
		
		
		//  Verify that the data is encrypted or random
		
		if (!Cipher.isEncrypted(data)) return null;
		
		
		//  Find the decryption key
		
		byte[] cipherdata = data;
		
		byte[] plaindata = null;
		
		
		//  try the secret passphrase SP and the file key
		
		if ((SP != null) && !SP.isEmpty())
		
		    plaindata = Cipher.decrypt(cipherdata,
		
			Cipher.passphraseToKey(SP));
		
		if ((plaindata == null) && (filekey != null))
		
		     plaindata = Cipher.decrypt(cipherdata, filekey);
		
		
		//  If the file was decrypted by the secret passphrase
		//
		//  update the filekey and return
		
		if (plaindata != null)
		{
			if (filekey == null) this.filekey
			
			    = Cipher.passphraseToKey(SP);
			
			return plaindata;
		}
		
		//  Create a passphrase dialog
		
		PassphraseDialog pd = new PassphraseDialog(
		
		   window, PassphraseDialog.passphrase_only);
		
		pd.setMinimumLength(minlength);
		
		pd.setFont1(font != null ?
		
		    font : window.getFont());
		
		pd.setForeground1(foreground);
		pd.setBackground1(background);
		
		pd.setTitle(title);
		
		
		while (true)
		{
			//  Try the file key or request a passphrase from the user
			
			if (filekey == null)
			{
				String passphrase = pd.readPassphrase();
				
				if ((passphrase == null) || passphrase.isEmpty())
				
				    return null;
				
				filekey = Cipher.passphraseToKey(passphrase);
				
				if (filekey == null)  return null;
			}
			
			//  Try the file key
			
			plaindata = Cipher.decrypt(cipherdata, filekey);
			
			if (plaindata == null)  //  wrong file key
			
			    { filekey = null; continue; }
			
			else break;
		}
		
		return plaindata;
	}
	
	
	
	
	
	public static boolean decrypt(File file, byte[] decryptionkey)
	
		throws IOException, FileNotFoundException
	{
		//  decrypts a file using the decryption key
		
		if ((file == null) || !Cipher.isEncrypted(file)) return false;
		
		//  Read and decrypt the cipherdata
		
		byte[] plaindata = null, cipherdata = null;
		
		//  Save the last modified time before writing
		
		long time = file.lastModified();
		
		int maxfilesize = 256*1024*1024;
		
		boolean largefile = file.length() >= maxfilesize;
		
		if (largefile == false)
		{
			cipherdata = DataStream.read(file);
			
			plaindata = Cipher.decrypt(cipherdata, decryptionkey);
			
			if (plaindata == null)  return false;
		}
		
		else // if (largefile)
		{
			boolean bool = Cipher.decryptLargeFile(
			
			    file, decryptionkey);
			
			if (bool == false) return false;
		}
		
		
		//  Save the plaindata
		
		if (largefile == false)
		
		    DataStream.write(file, plaindata);
		
		
		file.setLastModified(time);
		
		
		//  Decrypt the file name
		
		if (Number.isBase16(file.getName())
		
		    && (file.getName().length() >= 32))
		{
			String name1 = FileNameEncryptor
			
			  .decryptFileName(file.getName(), decryptionkey);
			
			String path1 = file.getParent() + File.separator + name1;
			
			file.renameTo(new File(path1));
		}
		
		return true;
	}
}


//  End class FileDecryptor









class FileNameEncryptor
{


	public static String encryptFileName(String filename, byte[] filekey)
	{
		//  m is the hash of the plaindata
		
		//  To encrypt the file name
		//
		//  generate a random iv
		//
		//  compute the one-time pad
		//
		//  k = hash(filekey (+) iv)
		//
		//  convert the file name to byte array
		//
		//  xor k and the file name byte array
		//
		//  convert the encrypted name array to base 16
		//
		//  prepend the random iv
		
		String plaintext = filename;
		
		Math.initRng(System.nanoTime());
		
		byte[] iv = new Number(Math.random(
		
		    4L*1024*1024*1024)).toByteArray(4);
		
		byte[] k = Cipher.hash(Math.xor(filekey, iv));
		
		byte[] plaindata = plaintext.getBytes();
		
		byte[] cipherdata = Math.xor(plaindata, k);
		
		//  Convert from base-256 byte array to base-16 string
		
		return  Convert.byteArrayToBase16(iv) +
			Convert.byteArrayToBase16(cipherdata);
	}
	
	
	
	public static String decryptFileName(String filename, byte[] filekey)
	{
	
		//  To decrypt the file name
		//
		//  remove the random iv
		//
		//  convert from base 16 to byte array
		//
		//  compute the one-time secret pad
		//
		//  k = hash(filekey (+) iv)
		//
		//  xor k and the encrypted byte array
		//
		//  remove zeros from the end of the array
		
		
		String name = filename;
		
		if (!Number.isBase16(name) || (name.length() < 24))
		
		    return filename;
		
		//  Convert from base-16 string to base-256 byte array
		
		byte[] namebytes = Convert.base16ToByteArray(name);
		
		byte[] iv = Arrays.copyOfRange(namebytes, 0, 4);
		
		namebytes = Arrays.copyOfRange(namebytes, 4, namebytes.length);
		
		byte[] k = Cipher.hash(Math.xor(filekey, iv));
		
		byte[] namebytes1 = Math.xor(namebytes, k);
		
		//  Remove the zero bytes at the end of the byte array
		//  or else the string will not contain valid characters
		//  and the file will not rename to the decrypted name.
		//  (Zero bytes occur because the encryption pad is longer
		//  than the file name bytes)
		
		int zeros = 0;
		
		for (int i = 0; i < namebytes1.length; i++)
		
		    if (namebytes1[namebytes1.length -1 -i] == 0) zeros++;
		
		namebytes1 = Arrays.copyOfRange(
		
		    namebytes1, 0, namebytes1.length - zeros);
		
		return new String(namebytes1);
	}
}

//  End class FileNameEncryptor





















//  A draggable tabbed pane class


class JDraggableTabbedPane extends JTabbedPane implements

	DragGestureListener, DragSourceListener, DropTargetListener
{
	private static final long serialVersionUID = 1L;
	
	private Point startpoint, endpoint;
	
	private DragSource dragSource;
	
	private boolean dragging, enabled;
	
	
	public static void main(String[] args)
	{
		//  This method was used to test and debug the class
		
		//  Create a draggable tabbed pane
		
		JDraggableTabbedPane tabbedpane;
		
		tabbedpane = new JDraggableTabbedPane();
		
		String tabtitle1 = "tab title 1";
		String tabtitle2 = "tab title 2";
		String tabtitle3 = "tab title 3";
		String tabtitle4 = "tab title 4";
		
		JTextArea textarea1 = new JTextArea("text area 1");
		JTextArea textarea2 = new JTextArea("text area 2");
		JTextArea textarea3 = new JTextArea("text area 3");
		JTextArea textarea4 = new JTextArea("text area 4");
		
		tabbedpane.add(tabtitle1, textarea1);
		tabbedpane.add(tabtitle2, textarea2);
		tabbedpane.add(tabtitle3, textarea3);
		tabbedpane.add(tabtitle4, textarea4);
		
		tabbedpane.setVisible(true);
		
		//  Create a test frame for the tabbed pane
		
		int width = 400, height = 400;
		
		JFrame frame = new JFrame("Test Frame");
		
		frame.add(tabbedpane, BorderLayout.CENTER);
		frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
		frame.setSize(width, height);
		frame.setVisible(true);
	}
	
	
	public JDraggableTabbedPane() { super(); init(); }
	
	public JDraggableTabbedPane(int tabplace) { super(tabplace); init(); }
	
	public JDraggableTabbedPane(int tabplace, int tablayout)
	
	    { super(tabplace, tablayout); init(); }
	
	
	public void setDragEnabled(boolean enabled)
	{
		this.enabled = enabled;
	}
	
	
	private void init()
	{
		MouseListener1 mouselistener1 = new MouseListener1();
		
		this.addMouseListener(mouselistener1);
		this.addMouseMotionListener(mouselistener1);
		
		//  Create a drag source
		
		dragSource = new DragSource();
		
		//  Associate the drag source with a particular component
		
		dragSource.createDefaultDragGestureRecognizer(
		
		    this, DnDConstants.ACTION_COPY_OR_MOVE, this);
		
		new DropTarget(this, this);
	}
	
	
	private class MouseListener1 extends MouseAdapter
	{
		public void mousePressed(MouseEvent e)
		{
			startpoint = e.getPoint();
		}
		
		//  public void mouseMoved(MouseEvent e) {  }
		//  public void mouseClicked(MouseEvent e) {  }
		//  public void mouseReleased(MouseEvent e) {  }
		//  public void mouseEntered(MouseEvent e) {  }
		//  public void mouseExited(MouseEvent e) {  }
		//  public void mouseDragged(MouseEvent e) {  }
	}
	
	
	//  DragSourceListener methods
	
	public void dropActionChanged(DragSourceDragEvent e) {  }
	public void dragOver(DragSourceDragEvent e) {  }
	public void dragEnter(DragSourceDragEvent e) {  }
	public void dragExit(DragSourceEvent e) {  }
	public void dragDropEnd(DragSourceDropEvent e) {  }
	
	
	//  DragGestureListener method
	
	public void dragGestureRecognized(DragGestureEvent e)
	{
		if (!enabled || (getTabCount() <= 1)) return;
		
		Transferable transferable = new StringSelection("");
		
		dragSource.startDrag(e, DragSource.DefaultCopyDrop, transferable, this);
		
		dragging = true;
	}
	
	
	//  DropTargetListener methods
	
	public void dragEnter(DropTargetDragEvent e) {  }
	
	public void dragOver(DropTargetDragEvent e)
	{
		endpoint = e.getLocation();
		
		swapTabs();
	}
	
	public void dropActionChanged(DropTargetDragEvent e) {  }
	
	public void dragExit(DropTargetEvent e) {  }
	
	public void drop(DropTargetDropEvent e)
	{
		endpoint = e.getLocation();
		
		swapTabs();
		
		dragging = false;
	}
	
	
	private void swapTabs()
	{
		//  Don't swap if target is on another tabbed pane
		
		if (!dragging) return;
		
		//  Find the indexes of the start and end points
		
		int index1 = indexAtLocation(startpoint.x, startpoint.y);
		int index2 = indexAtLocation(  endpoint.x,   endpoint.y);
		
		//  Return if the start or end point is not on a tab
		
		if ((index1 < 0) || (index2 < 0) || (index1 == index2)
		
		    || (getTabCount() <= 1)) return;
		
		//  Verify that the end point is inside the target tab because
		//  if the point is on the border then the tabs will flicker
		
		//  Find the location, width and height of the target tab
		
		Rectangle bounds = getBoundsAt(index2);
		
		int tabplacement = getTabPlacement();
		
		if ((tabplacement == JTabbedPane.TOP)
		 || (tabplacement == JTabbedPane.BOTTOM))
		{
			int l = bounds.x;
			int r = bounds.x + bounds.width;
			int w = bounds.width;
			
			int x = endpoint.x;
			
			if (((x - l) > (w * 5/6))
			 || ((r - x) > (w * 5/6))) return;
		}
		
		else // if (tabplacement == LEFT or RIGHT)
		{
			int t = bounds.y;
			int b = bounds.y + bounds.height;
			int h = bounds.height;
			
			int y = endpoint.y;
			
			if (((y - t) > (h * 5/6))
			 || ((b - y) > (h * 5/6))) return;
		}
		
		
		String title1, title2, tip1, tip2;
		
		Icon icon1, icon2;
		
		Component comp1, comp2;
		
		Color foreground1, foreground2;
		Color background1, background2;
		
		boolean isenabled1, isenabled2;
		
		title1 = getTitleAt(index1);
		title2 = getTitleAt(index2);
		
		icon1 = getIconAt(index1);
		icon2 = getIconAt(index2);
		
		comp1 = getComponentAt(index1);
		comp2 = getComponentAt(index2);
		
		tip1 = getToolTipTextAt(index1);
		tip2 = getToolTipTextAt(index2);
		
		foreground1 = getForegroundAt(index1);
		foreground2 = getForegroundAt(index2);
		background1 = getBackgroundAt(index1);
		background2 = getBackgroundAt(index2);
		
		isenabled1 = isEnabledAt(index1);
		isenabled2 = isEnabledAt(index2);
		
		if (index1 < index2) { remove(index1); remove(index2 -1); }
		if (index1 > index2) { remove(index2); remove(index1 -1); }
		
		if (index1 < index2)
		{
			insertTab(title2, icon2, comp2, tip2, index1);
			insertTab(title1, icon1, comp1, tip1, index2);
		}
		
		else // if (index1 > index2)
		{
			insertTab(title1, icon1, comp1, tip1, index2);
			insertTab(title2, icon2, comp2, tip2, index1);
		}
		
		setEnabledAt(index1, isenabled2);
		setEnabledAt(index2, isenabled1);
		
		setForegroundAt(index1, foreground2);
		setForegroundAt(index2, foreground1);
		setBackgroundAt(index1, background2);
		setBackgroundAt(index2, background1);
		
		setSelectedIndex(index2);
		
		int x = bounds.x + bounds.width/2;
		int y = bounds.y + bounds.height/2;
		
		Point point = new Point(x, y);
		
		startpoint = point;
	}
	
	
	
	public void setFocusTraversalPolicy()
	{
		//  changes the traversal policy so that pressing
		//  Ctrl + Tab moves the focus to the next tab
		
		this.setFocusCycleRoot(true);
		
		this.setFocusTraversalPolicy(new LayoutFocusTraversalPolicy()
		{
			public Component getComponentAfter(
			
				Container focusCycleRoot, Component comp)
			{
				int tabcount = getTabCount();
				
				//  If tabcount = 0 or 1, it will cause a divide by 0 error
				//  or it will remove the focus from the textarea because the
				//  stateChanged method will not be called to request the focus
				
				if ((tabcount == 0) || (tabcount == 1)) return comp;
				
				int nextindex = (getSelectedIndex() + 1) % tabcount;
				
				Component nextcomp = getComponentAt(nextindex);
				
				if (!comp.isValid() || !comp.isVisible()) return comp;
				
				setSelectedIndex(nextindex);
				
				return nextcomp;
			}
			
			public Component getComponentBefore(
			
				Container focusCycleRoot, Component comp)
			{
				int tabcount = getTabCount();
				
				if ((tabcount == 0) || (tabcount == 1)) return comp;
				
				int previndex = (getSelectedIndex() - 1 + tabcount) % tabcount;
				
				Component prevcomp = getComponentAt(previndex);
				
				if (!comp.isValid() || !comp.isVisible()) return comp;
				
				setSelectedIndex(previndex);
				
				return prevcomp;
			}
		});
	}
}

//  End class JDraggableTabbedPane























class PopMail
{


	//	Post Office Protocol for retrieving messages
	//	
	//	
	//	Client message          Mail server response
	//	
	//	(Connect to socket)     +OK ... or  -ERR ...
	//	
	//	USER username           +OK ... or  -ERR ...
	//	
	//	PASS userpass           +OK ... or  -ERR ...
	//	
	//	STAT                    +OK 10 12345
	//	
	//	LIST                    +OK 10 12345
	//	
	//	                        1 size
	//	                        2 size
	//	                        3 size
	//	                        . ....
	//	                        n size
	//	                        .
	//	
	//	TOP msg# line           +OK 1234 octets
	//	
	//	                        header + \n\n + first n lines of msg
	//	                        .  (end of message)
	//	
	//	
	//	RETR n                  +OK size
	//	
	//	                        header_n + \n\n + message1
	//	                        .
	//	
	//	
	//	DELE n                 +OK ... or  -ERR ...
	//	
	//	NOOP                   +OK ... or  -ERR ...
	//	
	//	RSET                   +OK ... or  -ERR ...
	//	
	//	QUIT                   +OK ... or  -ERR ...
	//	
	//	
	//	All command and response lines are terminated by
	//	the carriage return and line feed characters "\r\n".
	//	
	//	The responses to LIST and RETR are terminated by the
	//	end of message '.' character.
	//	
	//	The header and message are always separated by at least
	//	one blank line (two newlines chars).
	//	
	//	RSET resets the server to undelete any deleted messages.
	//	This command may not work on some servers.
	
	
	
	
	
	
	
	final public boolean ascending;
	
	public boolean testmailstop;
	
	public boolean authorized;
	
	//  If the user logs in to the popmail account
	//  then set authorized = true so the send mail
	//  program doesn't have to prompt the user to
	//  confirm the password if the user replies to
	//  or sends an email from the same address.
	
	
	
	//  the line terminator is t = \r\n
	
	private String t = "\r\n";
	
	private SSLSocket socket;
	
	private int timeout = 20*1000;
	
	private InetAddress socketaddress;
	
	private BufferedReader in;
	private BufferedWriter out;
	
	
	private String domain;
	
	private String incomingmailserver;
	
	private int incomingmailport;
	
	private String username;
	private String userpass;
	
	
	private ArrayList<String> list;
	
	private String[] testmaillist;
	
	private int numberofmessages;
	
	private int[] stat;
	
	private String[] array;
	
	private JTextArea textarea;
	
	private int linesread;
	private int bytesread;
	
	
	
	//  member variables used only for test mail
	
	private boolean testmail;
	
	private String  testpassphrase;
	private String replypassphrase;
	
	private int numberofciphers = 6;
	
	
	
	
	//  PopMail constructor
	
	
	PopMail(String incomingmailserver, int incomingmailport,
	
		String username, String userpass, boolean ascending)
	{
		if (incomingmailserver.contains(" "))
		
		    throw new IllegalArgumentException();
		
		this.incomingmailserver = incomingmailserver;
		this.incomingmailport   = incomingmailport;
		
		String[] t = incomingmailserver.split("[.]{1,}");
		
		if (t.length == 1) throw new IllegalArgumentException();
		
		//  Read the server domain from the incoming mail server
		
		//  server = pop.example.com
		//  domain =     example.com
		
		String domain = t[t.length -2]
		        + "." + t[t.length -1];
		
		this.domain = domain;
		
		if (this.incomingmailport == 0)
		    this.incomingmailport = 995;
		
		this.username = username;
		this.userpass = userpass;
		
		this.ascending = ascending;
		
		list = new ArrayList<String>();
	}
	
	//  End constructor
	
	
	
	
	
	//  A constructor for non-users or non-clients
	//  to connect to the recipient's mail server
	//  and request the recipient's public key
	
	
	PopMail(String recipientmailserver, int portno)
	{
		//  pop.example.com  995
		
		this.incomingmailserver = recipientmailserver;
		this.incomingmailport = portno;
		
		this.domain = domain;
		
		if (this.incomingmailport == 0)
		    this.incomingmailport = 995;
		
		//  the compiler requires that final
		//  class members be initialized even
		//  if the variable is not used
		
		ascending = true;
	}
	
	
	
	
	
	private String[] createTestMailList()
	{
	
		numberofmessages = 20;
		
		int linewidth = 78; // the partition size
		
		testmaillist = new String[numberofmessages];
		
		
		//  Create recipient's test public key strings to test the mail program
		
		String[] testpublickey, replypublickey, wrongpublickey;
		
		String wrongpassphrase = testpassphrase.substring(1);
		
		 testpublickey = PublicKey.generatePublicKey( testpassphrase, "", numberofciphers);
		replypublickey = PublicKey.generatePublicKey(replypassphrase, "", numberofciphers);
		wrongpublickey = PublicKey.generatePublicKey(wrongpassphrase, "", numberofciphers);
		
		System.out.println("number of ciphers == " + numberofciphers);
		
		
		//  Create the imaginary senders' one-time test public keys for faster encryption
		//
		//  Note that the imaginary sender uses a different public key method from the recipient
		//  for public key ciphers that are asymmetric.
		//
		//  Usually the sender just uses the PublicKey.encrypt(message, recipient's key) method and
		//  the encrypt method implicitly generates a matching one-time public key. Here we use the
		//  PublicKey[] generateMatchingPublicKeys(byte[] privatekey, String[] receivedkey) method.
		
		PublicKey[] testpublickey1, wrongpublickey1;
		
		byte[]  testprivatekey1 = Cipher.passphraseToKey( testpassphrase);
		byte[] wrongprivatekey1 = Cipher.passphraseToKey(wrongpassphrase);
		
		 testpublickey1 = PublicKey.generateMatchingPublicKeys( testprivatekey1,  testpublickey);
		wrongpublickey1 = PublicKey.generateMatchingPublicKeys(wrongprivatekey1, wrongpublickey);
		
		
		//  Concatenate the reply public keys into a composite public key
		//  using the base 16 separator to join the ciphers
		
		String replykeystring = PublicKey.joinKeys(replypublickey);
		
		
		//  Verify that the reply key string is a valid key
		
		if (!PublicKey.isValidKey(replykeystring))
		
		    throw new ArithmeticException();
		
		if (!testmail) return null;
		
		//  System.out.print("\nEncrypting test messages");
		
		String myaddress = username + "@" + domain;
		
		
		//  These file examples can be changed or replaced
		//  (They are only used to test the mail program)
		
		byte[] filedata1 = Convert.base64ToByteArray(Icons.image_example1);
		byte[] filedata2 = Documents.gpl.getBytes();
		byte[] filedata3 = Documents.table_example.getBytes();
		
		filedata1 = Programs.Mail.compress(filedata1);
		filedata2 = Programs.Mail.compress(filedata2);
		filedata3 = Programs.Mail.compress(filedata3);
		
		String filetext01 = Convert.byteArrayToBase64(filedata1);
		String filetext02 = Convert.byteArrayToBase64(filedata2);
		String filetext03 = Convert.byteArrayToBase64(filedata3);
		
		
		//  The file description typed by the sender
		
		String desc1 = "This is an attached image file example";
		String desc2 = "This is an attached text file example";
		String desc3 = "This is an attached table file example";
		
		filetext01 = Convert.stringToBase64(desc1) + "\n\n" + filetext01;
		filetext02 = Convert.stringToBase64(desc2) + "\n\n" + filetext02;
		filetext03 = Convert.stringToBase64(desc3) + "\n\n" + filetext03;
		
		//  Converting to base-64 to remove the newlines between the
		//  file descriptions and encoded file texts is redundant
		
		String filetext1 = filetext01; /// Convert.stringToBase64(filetext01);
		String filetext2 = filetext02; /// Convert.stringToBase64(filetext02);
		String filetext3 = filetext03; /// Convert.stringToBase64(filetext03);
		
		
		
		//  This multi-threading may be redundant because the PublicKey
		//  encrypt method is already multi-threaded to the number of ciphers,
		//  but it could still run faster if the processor has a large number
		//  of cores or threads.
		
		Thread[] tarray = new Thread[numberofmessages];
		
		for (int i = 0; i < tarray.length; i++)
		{
			final int i1 = i;
			
			tarray[i] = new Thread(() ->
			{
				if (testmailstop || !testmail) return;
				
				boolean encrypt = (i1 % 7) != 0;
				
				String header = "";
				
				header += "TEST MAIL HEADER";
				header += "+OK 12345 octets.\n";
				header += "Date: " + new Date().toString() + "\n";
				
				if ((i1 % 5) != 0) // include a few self-addressed messages
				
				//   no spaces are allowed in email addresses
				
				     header += "From: <" + "sender" + (i1 + 1) + "@example.com>" + "\n";
				else header += "From: <" + myaddress + ">" + "\n";
				
				if (!encrypt) // Place the plaintext subject line in the header
				
				    header += "Subject: subject line " + (i1 + 1) + "\n";
				
				header += "Other-header-info:";
				
				header += "\n"; // at least one blank line separates the header and message
				
				
				//  Create a test message and add a char to make the messages
				//  different so the user can try saving different messages
				
				String text = __.testmailmessage + " " + (i1 + 1);
				
				
				//  If encrypt prepend the subject to the message (so the subject is encrypted)
				
				if (encrypt) text = __.Subject + ": " + "this subject line was encrypted" + "\n\n" + text;
				
				//  The subject is prepended last so that it is at the top of the text
				
				
				//  Convert the string to base 64
				
				text = Convert.stringToBase64(text);
				
				
				//  Some messages will have reply keys
				
				//  Prepend the reply key before encrypting and encoding
				
				if ((i1 % 3) != 0) text = replykeystring + "\n\n" + text;
				
				if ((i1 % 2) == 1) // some messages have file attachments
				{
					//  Some files will have titles or descriptions
					//  (If the sender doesn't include a file description
					//  then the file won't have a file description)
					
					//  Append the file texts to the message text
					
					text += "\n\n" + filetext1;
					text += "\n\n" + filetext2;
					text += "\n\n" + filetext3;
				}
				
				
				if (encrypt)
				{
					try
					{	if ((i1 % 11) != 0) // include a few undecryptable ciphertexts
						
						     text = PublicKey.encrypt(text,  testpublickey,  testpublickey1);
						else text = PublicKey.encrypt(text, wrongpublickey, wrongpublickey1);
					}
					
					catch (Exception ex)
					{
						System.out.println(ex);
						
						System.out.println("invalid public key");
					}
				}
				
				
				//  Encode the base-16 public keys and base-64
				//  ciphertext in base 64 to hide the newlines
				//
				//  the list and decrypt threads should be able to read
				//  and decrypt messages even if this line is commented
				//
				//  This line probably should be commented because
				//  the encoding is redundant
				
				//  text = Convert.stringToBase64(text);
				
				
				if (encrypt) text = text .replaceAll(
				
				    "\n\n", Convert.base16Separator);
				
				
				//  Partition the base-64 text
				
				if (Number.isBase64(text))
				
				    text = Convert.partition(
				
					text.trim(), "\n", linewidth);
				
				
				//  Concatenate the test header and message
				
				String str = header + "\n\n" + text;
				
				//  Add the header and message to the list
				
				testmaillist[i1] = str;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		for (int i = 0; i < numberofmessages; i++)
		
		    if (testmaillist[i] == null) return null;
		
		return testmaillist;
	}
	
	
	public void setTextArea(JTextArea textarea)
	{
		this.textarea = textarea;
	}
	
	public void setTestMail(boolean testmail)
	{
		this.testmail = testmail;
	}
	
	public void setTestPassphrase(String testpassphrase)
	{
		this.testpassphrase = testpassphrase;
	}
	
	public void setReplyPassphrase(String replypassphrase)
	{
		this.replypassphrase = replypassphrase;
	}
	
	public void setNumberOfCiphers(int numberofciphers)
	{
		this.numberofciphers = numberofciphers;
	}
	
	
	private SSLSocket createSocket(String host, int port) throws IOException
	{
		SSLSocketFactory f = (SSLSocketFactory) SSLSocketFactory.getDefault();
		SSLSocket sslsock  = (SSLSocket) f.createSocket(host, port);
		
		String[] list = sslsock.getEnabledCipherSuites();
		
		//  System.out.println("Enabled ciphers == " + Arrays.toString(list));
		
		//  sslsock.setEnabledCipherSuites(list);
		
		sslsock.setSoTimeout(timeout);
		
		sslsock.startHandshake();
		
		return sslsock;
	}
	
	
	
	
	
	//  Public PopMail methods
	
	
	
	public int connect() throws IOException
	{
	
		//  Test the RetrieveMailFrame for wrong userpass by
		//  returning an error. A JOptionOptionPane should
		//  display an error message and a button to open
		//  the userpass menu item and change the password.
		//
		//  if (true) return 1;
		
		
		String response;
		
		int error = 0;
		
		if ((stat != null) || (array != null))
		{
			textarea.append(__.sockettimedout + "\n");
			textarea.append(__.reconnectingtoserver + "\n");
		}
		
		if (testmail)
		{
			if ((stat == null) && (array == null))
			
			    textarea.append("TEST MAIL" + "\n");
			
			try { Thread.sleep(1000); }
			
			catch (InterruptedException ex) {  }
			
			authorized = true;
			
			return 0;
		}
		
		//  Connect to server
		
		socket = createSocket(incomingmailserver, incomingmailport);
		
		
		InputStreamReader inputstreamreader = new
		InputStreamReader(socket.getInputStream());
		
		OutputStreamWriter outputstreamwriter = new
		OutputStreamWriter(socket.getOutputStream());
		
		in  = new BufferedReader( inputstreamreader);
		out = new BufferedWriter(outputstreamwriter);
		
		
		response = readLine(in);
		
		if (!response.trim().startsWith("+OK") )
		{
			//  connection error
			
			error = 1;
			
			return error;
		}
		
		
		//  All pop mail servers accept USER name@domain.com
		//  but not all accept USER name (without domain.com)
		
		
		//  Send the username and password
		
		String message;
		
		message = "USER " + username + "@" + domain;
		
		writeLine(out, message);
		
		
		response = readLine(in);
		
		if (!response.trim().startsWith("+OK"))
		
		    error = 2; // username error
		
		message = "PASS " + userpass;
		
		writeLine(out, message);
		
		response = readLine(in).trim();
		
		if (!response.trim().startsWith("+OK"))
		
		    error = 3; // userpass error
		
		authorized = (error == 0);
		
		return error;
	}
	
	
	
	
	public boolean delete(int n) throws IOException
	{
		//  sends the DELE msg no. command
		
		int msno = n; // msg no.
		
		if (!ascending) msno = stat[0] -1 - n;
		
		writeLine(out, "DELE " + (msno + 1));
		
		if (testmail)  return true;
		
		String response = readLine(in);
		
		return response.trim().startsWith("+OK");
	}
	
	
	
	
	public String[] list() throws IOException, SocketTimeoutException, Exception
	{
		//  returns a list of messages
		
		
		//  Return a local copy of array until the user logs out
		
		if (this.array != null)  return array;
		
		
		String[] array;
		
		
		if (testmail)
		{
			if (testmaillist == null)
			
			    testmaillist = createTestMailList();
			
			array = new String[testmaillist.length];
			
			
			//  For debugging, test if the program can recover if
			//  the server doesn't respond or throws an exception
			
			//  This line causes the program to terminate
			//  a few seconds after the user clicks quit
			//
			//  if (true) try { Thread.sleep(1024*1024); }
			//  catch (InterruptedException ex) {  }
			
			//  This line causes the program to quit
			//  and then the user can click list again
			//
			//  if (true) throw new IOException();
			
			
			writeLine(out, "LIST");
			
			for (int i = 0; i < array.length; i++)
			{
				//  message number and number of bytes
				
				array[i] = (i + 1) + " " + testmaillist[i].length();
			}
		}
		
		
		else
		{	String response;
			
			writeLine(out, "LIST");
			
			response = readLine(in);
			
			if (!response.trim().startsWith("+OK"))
			
			    throw new Exception();
			
			
			//  Read each msno and number of bytes
			
			String line;
			
			this.list = new ArrayList<String>();
			
			while (true)
			{
				line = readLine(in);
				
				if (line.equals(".")) break;
				
				else list.add(line);
			}
			
			array = new String[list.size()];
			
			list.toArray(array);
		}
		
		
		String temp;
		
		if (!ascending) // reverse the list array
		
		for (int i = 0; i < array.length / 2; i++)
		{
			temp = array[i];
			
			array[i] = array[array.length -1 -i];
			           array[array.length -1 -i] = temp;
		}
		
		this.array = array;
		
		return Arrays.copyOf(array, array.length);
	}
	
	
	
	
	public int getNumberOfMessages() // no IOException
	{
		if (testmail)
		{
			if (testmaillist == null)
			
			    testmaillist = createTestMailList();
			
			return testmaillist.length;
		}
		
		if ((this.stat != null) && (this.stat[0] > 0))
		
		    return this.stat[0];
		
		else return -1;
	}
	
	
	
	
	public void reset() throws IOException
	{
		//  resets the mail server to undelete the messages
		//  (Some servers may not acknowledge this command)
		
		String response;
		
		writeLine(out, "RSET");
		
		if (testmail) return;
		
		response = readLine(in);
	}
	
	
	
	
	public String[] retrieve(int n) throws IOException
	{
		//  returns the header and message
		
		//  The header and message are always separated by
		//  at least one blank line (i.e. two newline chars)
		
		int msno = n; // msg no.
		
		if (!ascending) msno = stat[0] -1 -n;
		
		String document;
		
		writeLine(out, "RETR " + (msno + 1));
		
		if (!testmail)
		{
			StringBuilder sb = new StringBuilder();
			
			while (true)
			{
				String line = readLine(in);
				
				if (line.equals(".")) break;
				
				sb.append(line + "\n");
			}
			
			document = sb.toString().trim();
		}
		
		else document = testmaillist[msno];
		
		
		int pos = document.indexOf("\n\n");
		
		if (pos == -1) return new String[] { document, "" };
		
		String header  = document.substring(0, pos);
		String message = document.substring(pos + 2);
		
		return new String[] { header, message };
	}
	
	
	
	
	public String retrieve(String recipientsaddr) throws IOException
	{
		//  retrieves and returns the recipient's public key
		//  (if the address is empty or equals the user's ad-
		//  dress, then the server should return the user's key)
		
		String publickey;
		
		writeLine(out, "RETR " + recipientsaddr);
		
		if (!testmail)
		{
			StringBuilder sb = new StringBuilder();
			
			while (true)
			{
				String line = readLine(in);
				
				if (line.equals(".")) break;
				
				sb.append(line + "\n");
			}
			
			publickey = sb.toString().trim();
		}
		
		else // if (testmail)
		{
			publickey = "";
		}
		
		return publickey;
	}
	
	
	
	public boolean send(String publickey) throws IOException
	{
		//  send's the user's public key to the server
		
		writeLine(out, "SEND " + publickey);
		
		if (testmail)  return true;
		
		String response = readLine(in);
		
		return response.trim().startsWith("+OK");
	}
	
	
	
	public int[] stat() throws IOException, Exception
	{
		//  returns the total number of messages and bytes
		
		//  Return a local copy of STAT until the user logs out
		
		if (this.stat != null) return this.stat;
		
		if (testmail)
		{
			if (testmaillist == null)
			
			    testmaillist = createTestMailList();
			
			//  Test the SocketTimeoutException
			//
			//  if (true) throw new SocketTimeoutException();
			
			writeLine(out, "STAT");
			
			int number = testmaillist.length;
			
			int totalbytes = 0;
			
			for (String str : testmaillist)
			
			    if (str != null) totalbytes += str.length();
			
			this.stat = new int[] { number, totalbytes };
			return      new int[] { number, totalbytes };
		}
		
		String response;
		
		writeLine(out, "STAT");
		
		response = readLine(in);
		
		if (!response.trim().startsWith("+OK"))
		
		    throw new Exception();
		
		//  +OK 1234 123456789
		
		//  Read the number of messages and bytes
		
		String str = response.substring(3).trim();
		
		String[] number_totalbytes = str.split(" {1,}");
		
		if (number_totalbytes.length != 2) return null;
		
		if (!Number.isDigitString(number_totalbytes[0], 10)
		 || !Number.isDigitString(number_totalbytes[1], 10))
		
			throw new Exception();
		
		int number, totalbytes;
		
		try
		{	number     = Integer.parseInt(number_totalbytes[0]);
			totalbytes = Integer.parseInt(number_totalbytes[1]);
		}
		
		catch (NumberFormatException ex)
		{
			ex.printStackTrace(); return null;
		}
		
		this.stat = new int[] { number, totalbytes };
		return      new int[] { number, totalbytes };
	}
	
	
	public boolean stat(int n, int state) throws IOException
	{
		//  sends STAT msg.no. msg.state
		
		int msno = n; // msg no.
		
		writeLine(out, "STAT " + (msno + 1) + " " + state);
		
		if (testmail)  return true;
		
		String response = readLine(in);
		
		return response.trim().startsWith("+OK");
	}
	
	
	
	
	public String top(int n, int numberoflines) throws IOException, Exception
	{
		//  returns the header and first n lines of the message
		
		int msno = n; // msg no.
		
		if (!ascending) msno = stat[0] -1 -n;
		
		if (testmail)
		{
			writeLine(out, "TOP " + (msno + 1) + " " + numberoflines);
			
			String message = testmaillist[msno];
			
			ArrayList<String> list = new ArrayList<String>();
			
			Scanner sc = new Scanner(message);
			
			while (sc.hasNextLine())
			{
				String line = sc.nextLine();
				
				list.add(line);
			}
			
			StringBuilder sb = new StringBuilder();
			
			for (String str : list)
			
			    sb.append(str + "\n");
			
			return sb.toString();
		}
		
		writeLine(out, "TOP " + (msno + 1) + " " + numberoflines);
		
		String response = readLine(in);
		
		if (!response.trim().startsWith("+OK"))
		
		    throw new Exception();
		
		
		ArrayList<String> list = new ArrayList<String>();
		
		while (true)
		{
			String line = readLine(in);
			
			if (line.equals(".")) break;
			
			list.add(line);
		}
		
		StringBuilder sb = new StringBuilder();
		
		for (String str : list)
		
		    sb.append(str + "\n");
		
		return sb.toString();
	}
	
	
	
	public boolean noop() throws IOException
	{
		//  No op can be used to test the connection
		
		writeLine(out, "NOOP ");
		
		if (testmail) return true;
		
		String response = readLine(in);
		
		return response.trim().startsWith("+OK");
	}
	
	
	
	public boolean quit() throws IOException
	{
		//  sends the QUIT command and then
		//  reads and closes the socket
		
		writeLine(out, "QUIT ");
		
		if (testmail) return true;
		
		String response = readLine(in);
		
		out.close(); socket.close();
		
		out = null;  socket = null;
		
		return response.trim().startsWith("+OK");
	}
	
	
	
	private String readLine(BufferedReader in) throws IOException
	{
		String response;
		
		response = in.readLine();
		
		if (response != null) { linesread++; bytesread += response.length(); }
		
		//  if null throw an exception so the caller knows
		//  to reconnect because the connection timed out
		
		if (response == null) throw new IOException();
		
		if (response.startsWith("+OK") || response.startsWith("-ERR"))
		
		    textarea.append("S" + ": " + response + "\n");
		
		textarea.setCaretPosition(textarea.getText().length());
		
		return response;
	}
	
	
	
	private boolean writeLine(BufferedWriter out, String message) throws IOException
	{
		if (linesread > 1) textarea.append(
		
		    linesread + " lines read" + "\n");
		
		linesread = 0;
		
		if (testmail)
		{
			try { Thread.sleep(200); }
			
			catch (InterruptedException ex) {  }
		}
		
		if (!testmail) { out.write(message + t); out.flush(); }
		
		String str = "C" + ": " + message;
		
		if ((message.length() > 4) && (message.length() <= 24)
		
		    && Number.isBase64(message))
		
			str += " (" + Convert.base64ToString(message) + ")";
		
		textarea.append(str + "\n");
		
		textarea.setCaretPosition(textarea.getText().length());
		
		return true;
	}
}

//  End class Popmail













class SendMail
{


	private String outgoingmailserver;
	
	private int outgoingmailport;
	
	private boolean testmail;
	
	private JTextArea textarea = new JTextArea();
	
	public String error_message = "";
	
	
	//  The SendMail constructor
	
	public SendMail(String outgoingmailserver, int outgoingmailport)
	{
		this.outgoingmailserver = outgoingmailserver;
		
		this.outgoingmailport = outgoingmailport;
	}
	
	
	public void setTextArea(JTextArea textarea)
	{
		this.textarea = textarea;
	}
	
	public String getText()
	{
		return this.textarea.getText();
	}
	
	public void setTestMail(boolean testmail)
	{
		this.testmail = testmail;
	}
	
	
	private SSLSocket createSocket(String host, int port) throws IOException
	{
		int timeout = 12*1000;
		
		SSLSocket sslsock = null;
		
		SSLSocketFactory f = (SSLSocketFactory) SSLSocketFactory.getDefault();
		
		sslsock = (SSLSocket) f.createSocket(host, port);
		
		if (sslsock == null) throw new IOException();
		
		String[] list = sslsock.getEnabledCipherSuites();
		
		//  System.out.println("Enabled ciphers == " + Arrays.toString(list));
		
		//  sslsock.setEnabledCipherSuites(list);
		
		sslsock.setSoTimeout(timeout);
		
		sslsock.startHandshake();
		
		return sslsock;
	}
	
	
	
	
	public boolean send (
	
	    String tostring, String username, String userpass,
	
		String subject, String ciphertext )
		
		    throws IOException, SocketException
	{
		//	The extended simple mail transport protocol
		//	
		//	(All lines are terminated by a carriage return and line feed \r\n)
		//	
		//	
		//	server: 220 smtp.example.com ESMTP Server
		//	
		//	client: EHLO client.example.com
		//	
		//	server: 250-smtp.example.com, ...
		//	server: 250- ...    ...
		//	server: 250- ...    ...
		//	server: 250-AUTH LOGIN PLAIN
		//	server: 250- ...    ...
		//	server: 250- ...    ...
		//	server: 250 (no hyphen-)
		//	
		//	
		//	client: AUTH LOGIN
		//	
		//	server: 334 VXNlcm5hbWU6  (Username:)
		//	
		//	
		//	client: bXl1c2VybmFtZQ==  (myusername)
		//	
		//	server: 334 UGFzc3dvcmQ6  (Password:)
		//	
		//	
		//	client: bXl1c2VycGFzcw==  (myuserpass)
		//	
		//	server: 235 2.7.0 Authentication successful
		//	
		//	
		//	
		//	client: MAIL FROM: <sender@example.com>
		//	
		//	server: 250 ...
		//	
		//	
		//	client: RCPT TO: <recipient1@example.com>
		//	
		//	server: 250 ...
		//	
		//	
		//	client: RCPT TO: <recipient2@example.com>
		//	
		//	server: 250 ...
		//	
		//	
		//	client: DATA
		//	
		//	server: 354 ...
		//	
		//	
		//	client: From: sender@example.com
		//	
		//	client: To: recipient1@example.com
		//	
		//	client: Cc: recipient2@example.com
		//	
		//	client: Date: date
		//	
		//	client: Subject: subject line
		//	
		//	client: (blank line)
		//	
		//	client: message line 1.
		//	
		//	client: message line 2.
		//	
		//	client: message line 3.
		//	
		//	client: .
		//	
		//	server: 250 ...
		//	
		//	QUIT
		//	
		//	221 ...
		
		
		
		
		SSLSocket socket = null;
		
		BufferedReader in  = null;
		BufferedWriter out = null;
		
		
		String message;
		
		String outputstring = "";
		
		String response = "";
		
		
		
		//  The Extended Simple Mail Transport Protocol
		
		
		if (!testmail)
		{
			socket = createSocket(outgoingmailserver, outgoingmailport);
			
			InputStreamReader inputstreamreader = new
			InputStreamReader(socket.getInputStream());
			
			OutputStreamWriter outputstreamwriter = new
			OutputStreamWriter(socket.getOutputStream());
			
			in  = new BufferedReader( inputstreamreader);
			out = new BufferedWriter(outputstreamwriter);
		}
		
		
		//  There are proprietary transport protocols so we specify that
		//  we are using the extended simple mail transport protocol
		
		if (textarea != null)
		{
			textarea.append("Mail Transport Protocol" + "\n"); // ==
			textarea.append("Extended Simple Mail Transport Protocol" + "\n\n");
			
			textarea.append(__.openedsocket + " (" + outgoingmailserver
			
			    + " " + "port" + " " + outgoingmailport + ")" + "\n");
		}
		
		InetAddress localaddress = null;
		
		String localIP;
		
		if (!testmail)
		{
			localaddress = socket .getLocalAddress();
			
			localIP = localaddress .getHostAddress();
		}
		
		else { localIP = InetAddress .getLocalHost() .getHostAddress(); }
		
		if (textarea != null)
		
		    textarea.append(__.localipaddress + " == " + localIP + "\n");
		
		
		response = readLine(in);
		
		
		
		//  Use EHLO instead of the older and deprecated HELO
		//
		//  EHLO probably stands for Extended HelLO
		
		message = "EHLO" + " " + localIP;
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		response = readLine(in);
		
		if (!response.startsWith("250") && !testmail)
		{
			error_message = __.connection_error;
			
			return false;
		}
		
		while (response.startsWith("250-") && !testmail)
		
		    response = readLine(in);
		
		
		message = "AUTH LOGIN";
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		
		response = readLine(in);
		
		if (!response.startsWith("334") && !testmail)
		{
			error_message = __.login_error;
			
			return false;
		}
		
		
		//  Send the username
		
		message = Convert.stringToBase64(username);
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		response = readLine(in);
		
		if (!response.startsWith("334") && !testmail)
		{
			error_message = __.username_error;
			
			return false;
		}
		
		
		//  Send the userpass
		
		message = Convert.stringToBase64(userpass);
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		response = readLine(in);
		
		if (!response.startsWith("235") && !testmail)
		{
			error_message = __.authentication_error;
			
			return false;
		}
		
		
		message = "MAIL FROM: " + "<" + username + ">";
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		response = readLine(in);
		
		if (!response.startsWith("2") && !testmail)
		{
			error_message = __.mailtransport_error;
			
			return false;
		}
		
		
		message = "RCPT TO: " + "<" + tostring + ">";
		
		writeLine(out, message);
		
		outputstring += message;
		
		
		response = readLine(in);
		
		if (!response.startsWith("2") && !testmail)
		{
			error_message = __.mailtransport_error;
			
			return false;
		}
		
		
		//  Send DATA
		
		
		message = "DATA";
		
		writeLine(out, message);
		
		
		response = readLine(in);
		
		if (!response.startsWith("3") && !testmail)
		{
			error_message = __.mailtransport_error;
			
			return false;
		}
		
		
		////  Send header data
		
		String ccstring   = null;
		String datestring = null;
		
		message = "From: " + username;
		
		writeLine(out, message);
		
		
		message = "To: " + tostring;
		
		writeLine(out, message);
		
		
		if ((ccstring != null) && !ccstring.isEmpty())
		{
			message = "Cc: " + ccstring;
			
			writeLine(out, message);
		}
		
		if ((datestring != null) && !datestring.isEmpty())
		{
			message = "Date: " + datestring;
			
			writeLine(out, message);
		}
		
		if ((subject != null) && !subject.isEmpty())
		{
			message = "Subject: " + subject;
			
			writeLine(out, message);
		}
		
		//  Write a blank line
		
		writeLine(out, "");
		
		
		//  Send the ciphertext (or plaintext)
		
		message = ciphertext;
		
		writeLine(out, message);
		
		
		//  Send the end of message character "."
		
		message = ".";
		
		writeLine(out, message);
		
		
		response = readLine(in);
		
		if (!response.startsWith("2") && !testmail)
		{
			error_message = __.mailtransport_error;
			
			return false;
		}
		
		if (!testmail)
		{
			in.close();
			
			out.close();
			
			if (socket != null) socket.close();
			
			if (textarea != null) textarea.append(
			
			    "\n\n" + __.closedsocket + "\n");
		}
		
		else if (testmail)
		{
			if (textarea != null)
			{
				textarea.append("\n\n" + __.closedsocket + "\n");
				
				textarea.append("\n" + __.testmail + "\n");
			}
		}
		
		if (textarea != null)
		{
			int length = textarea.getText().length();
			
			textarea.setCaretPosition(length);
		}
		
		return true;
	}
	
	
	
	
	
	private String readLine(BufferedReader in)
	{
		String response = "";
		
		try { if (!testmail) response = in.readLine(); }
		
		catch (IOException ex)
		{
			System.out.println(ex);
			
			return "";
		}
		
		String str = __.Received + ": " + response;
		
		//  Received: base-64 message (decoded base-64 message)
		
		if ((response.length() <= 24) && Number.isBase64(response))
		
		    str += " (" + Convert.base64ToString(response) + ")";
		
		if (textarea != null) textarea.append("\n" + str);
		
		//  System.out.println(str);
		
		return response;
	}
	
	
	
	
	private boolean writeLine(BufferedWriter out, String message)
	{
	
		//  Read the first 1024 chars of the message
		//  to append to the text area
		
		final int maxsize = 1024;
		
		String substr = message;
		
		//  Truncate the message and append an ellipsis
		
		if (substr.length() > maxsize)
		{
			substr = message.substring(0, maxsize);
			
			substr += " ........";
		}
		
		if (testmail)
		{
			//  Use a delay instead of a write line
			
			try { Thread.sleep(100); }
			
			catch (InterruptedException ex) {  }
		}
		
		
		if (!testmail)
		
		try
		{	out.write(message + "\r\n");
			
			out.flush();
		}
		
		catch (IOException ex)
		{
			System.out.println(ex);
			
			return false;
		}
		
		
		String str = __.Sent + ": " + substr;
		
		//  Sent: base-64 message (decoded base-64 message)
		
		if ((substr.length() <= 24) && Number.isBase64(substr)
		
		    && !substr.equals("DATA"))
		
			str += " (" + Convert.base64ToString(substr) + ")";
		
		if (textarea != null) textarea.append("\n" + str);
		
		
		//  Verify if the message was sent encrypted by removing newlines,
		//  removing base-64 encoding, and then using the isEncrypted method
		
		if (message.length() > 64)
		{
			message = message.trim().replaceAll("\n", "");
			
			if (Number.isBase64(message))
			
			    message = Convert.base64ToString(message);
			
			if (textarea != null)
			{
				if (PublicKey.isEncrypted(message))
				
				     textarea.append("\n(" + __.encryptedmessage + ")");
				else textarea.append("\n(" + __.plaintextmessage + ")");
			}
		}
		
		if (textarea != null)
		{
			int length = textarea.getText().length();
			
			textarea.setCaretPosition(length);
		}
		
		//  System.out.println(str);
		
		return true;
	}
}

//  End Class SendMail




























//  The Hyperactive class is excerpted from the
//  Java source code jdk/jdk-xx/lib/src.zip

class Hyperactive implements HyperlinkListener
{
	public void hyperlinkUpdate(HyperlinkEvent e)
	{
		if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
		{
			JEditorPane pane = (JEditorPane) e.getSource();
			
			if (e instanceof HTMLFrameHyperlinkEvent)
			{
				HTMLFrameHyperlinkEvent  evt = (HTMLFrameHyperlinkEvent) e;
				
				HTMLDocument doc = (HTMLDocument) pane.getDocument();
				
				doc.processHTMLFrameHyperlinkEvent(evt);
			}
			
			else
			{	URL url = e.getURL();
				
				if (url != null)
				{
					System.out.println("url == " + url.toString());
					
					Clipboard cb = Toolkit.getDefaultToolkit() .getSystemClipboard();
					
					cb.setContents(new StringSelection(url.toString()), null);
					
					if (false) // if hyperlinks are enabled by the user
					{
						//  Open an html viewer if the
						//  url starts with https://...
						//
						//  ...    ...
					}
					
					//  try { pane.setPage(url); }
					//
					//  catch (IOException ex)
					//  {
					// 	ex.printStackTrace();
					//  }
				}
			}
		}
	}
}









class Documents
{

	//  To add a document to the class, use Edit -> Convert Text / Document -> String;
	//  append a semicolon to the string; use Edit -> Select All or Ctrl A to select
	//  the text and use the right arrow key to indent the document; type "static
	//  String document name = " and then copy and paste the document.
	
	
	static String gpl =
	
	"This program is free software; you can redistribute it and/or modify it under th" +
	"e terms of the GNU General Public License as published by the Free Software Foun" +
	"dation, either version 3 of the License, or, at your option, any later version.\n" +
	"\n\nGNU General Public License version 3 (GPLv3)\n\nGNU GENERAL PUBLIC LICENSE\n" +
	"\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc. <" +
	"http://fsf.org/>\n\nEveryone is permitted to copy and distribute verbatim copies" +
	" of this license document, but changing it is not allowed.\n\n\nPreamble\n\nThe " +
	"GNU General Public License is a free, copyleft license for software and other ki" +
	"nds of works.\n\nThe licenses for most software and other practical works are de" +
	"signed to take away your freedom to share and change the works. By contrast, the" +
	" GNU General Public License is intended to guarantee your freedom to share and c" +
	"hange all versions of a program--to make sure it remains free software for all i" +
	"ts users. We, the Free Software Foundation, use the GNU General Public License f" +
	"or most of our software; it applies also to any other work released this way by " +
	"its authors. You can apply it to your programs, too.\n\nWhen we speak of free so" +
	"ftware, we are referring to freedom, not price. Our General Public Licenses are " +
	"designed to make sure that you have the freedom to distribute copies of free sof" +
	"tware (and charge for them if you wish), that you receive source code or can get" +
	" it if you want it, that you can change the software or use pieces of it in new " +
	"free programs, and that you know you can do these things.\n\nTo protect your rig" +
	"hts, we need to prevent others from denying you these rights or asking you to su" +
	"rrender the rights. Therefore, you have certain responsibilities if you distribu" +
	"te copies of the software, or if you modify it: responsibilities to respect the " +
	"freedom of others.\n\nFor example, if you distribute copies of such a program, w" +
	"hether gratis or for a fee, you must pass on to the recipients the same freedoms" +
	" that you received. You must make sure that they, too, receive or can get the so" +
	"urce code. And you must show them these terms so they know their rights.\n\nDeve" +
	"lopers that use the GNU GPL protect your rights with two steps: (1) assert copyr" +
	"ight on the software, and (2) offer you this License giving you legal permission" +
	" to copy, distribute, and/or modify it.\n\nFor the developers' and authors' prot" +
	"ection, the GPL clearly explains that there is no warranty for this free softwar" +
	"e. For both users' and authors' sake, the GPL requires that modified versions be" +
	" marked as changed, so that their problems will not be attributed erroneously to" +
	" authors of previous versions.\n\nSome devices are designed to deny users access" +
	" to install or run modified versions of the software inside them, although the m" +
	"anufacturer can do so. This is fundamentally incompatible with the aim of protec" +
	"ting users' freedom to change the software. The systematic pattern of such abuse" +
	" occurs in the area of products for individuals to use, which is precisely where" +
	" it is most unacceptable. Therefore, we have designed this version of the GPL to" +
	" prohibit the practice for those products. If such problems arise substantially " +
	"in other domains, we stand ready to extend this provision to those domains in fu" +
	"ture versions of the GPL, as needed to protect the freedom of users.\n\nFinally," +
	" every program is threatened constantly by software patents. States should not a" +
	"llow patents to restrict development and use of software on general-purpose comp" +
	"uters, but in those that do, we wish to avoid the special danger that patents ap" +
	"plied to a free program could make it effectively proprietary. To prevent this, " +
	"the GPL assures that patents cannot be used to render the program non-free.\n\nT" +
	"he precise terms and conditions for copying, distribution and modification follo" +
	"w.\n\n\n\nTERMS AND CONDITIONS\n\n\n0. Definitions.\n\n\"This License\" refers t" +
	"o version 3 of the GNU General Public License.\n\n\"Copyright\" also means copyr" +
	"ight-like laws that apply to other kinds of works, such as semiconductor masks.\n" +
	"\n\"The Program\" refers to any copyrightable work licensed under this License. " +
	"Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be i" +
	"ndividuals or organizations.\n\nTo \"modify\" a work means to copy from or adapt" +
	" all or part of the work in a fashion requiring copyright permission, other than" +
	" the making of an exact copy. The resulting work is called a \"modified version\"" +
	" of the earlier work or a work \"based on\" the earlier work.\n\nA \"covered wor" +
	"k\" means either the unmodified Program or a work based on the Program.\n\nTo \"" +
	"propagate\" a work means to do anything with it that, without permission, would " +
	"make you directly or secondarily liable for infringement under applicable copyri" +
	"ght law, except executing it on a computer or modifying a private copy. Propagat" +
	"ion includes copying, distribution (with or without modification), making availa" +
	"ble to the public, and in some countries other activities as well.\n\nTo \"conve" +
	"y\" a work means any kind of propagation that enables other parties to make or r" +
	"eceive copies. Mere interaction with a user through a computer network, with no " +
	"transfer of a copy, is not conveying.\n\nAn interactive user interface displays " +
	"\"Appropriate Legal Notices\" to the extent that it includes a convenient and pr" +
	"ominently visible feature that (1) displays an appropriate copyright notice, and" +
	" (2) tells the user that there is no warranty for the work (except to the extent" +
	" that warranties are provided), that licensees may convey the work under this Li" +
	"cense, and how to view a copy of this License. If the interface presents a list " +
	"of user commands or options, such as a menu, a prominent item in the list meets " +
	"this criterion.\n\n1. Source Code.\n\nThe \"source code\" for a work means the p" +
	"referred form of the work for making modifications to it. \"Object code\" means " +
	"any non-source form of a work.\n\nA \"Standard Interface\" means an interface th" +
	"at either is an official standard defined by a recognized standards body, or, in" +
	" the case of interfaces specified for a particular programming language, one tha" +
	"t is widely used among developers working in that language.\n\nThe \"System Libr" +
	"aries\" of an executable work include anything, other than the work as a whole, " +
	"that (a) is included in the normal form of packaging a Major Component, but whic" +
	"h is not part of that Major Component, and (b) serves only to enable use of the " +
	"work with that Major Component, or to implement a Standard Interface for which a" +
	"n implementation is available to the public in source code form. A \"Major Compo" +
	"nent\", in this context, means a major essential component (kernel, window syste" +
	"m, and so on) of the specific operating system (if any) on which the executable " +
	"work runs, or a compiler used to produce the work, or an object code interpreter" +
	" used to run it.\n\nThe \"Corresponding Source\" for a work in object code form " +
	"means all the source code needed to generate, install, and (for an executable wo" +
	"rk) run the object code and to modify the work, including scripts to control tho" +
	"se activities. However, it does not include the work's System Libraries, or gene" +
	"ral-purpose tools or generally available free programs which are used unmodified" +
	" in performing those activities but which are not part of the work. For example," +
	" Corresponding Source includes interface definition files associated with source" +
	" files for the work, and the source code for shared libraries and dynamically li" +
	"nked subprograms that the work is specifically designed to require, such as by i" +
	"ntimate data communication or control flow between those subprograms and other p" +
	"arts of the work.\n\nThe Corresponding Source need not include anything that use" +
	"rs can regenerate automatically from other parts of the Corresponding Source.\n\n" +
	"The Corresponding Source for a work in source code form is that same work.\n\n2." +
	" Basic Permissions.\n\nAll rights granted under this License are granted for the" +
	" term of copyright on the Program, and are irrevocable provided the stated condi" +
	"tions are met. This License explicitly affirms your unlimited permission to run " +
	"the unmodified Program. The output from running a covered work is covered by thi" +
	"s License only if the output, given its content, constitutes a covered work. Thi" +
	"s License acknowledges your rights of fair use or other equivalent, as provided " +
	"by copyright law.\n\nYou may make, run and propagate covered works that you do n" +
	"ot convey, without conditions so long as your license otherwise remains in force" +
	". You may convey covered works to others for the sole purpose of having them mak" +
	"e modifications exclusively for you, or provide you with facilities for running " +
	"those works, provided that you comply with the terms of this License in conveyin" +
	"g all material for which you do not control copyright. Those thus making or runn" +
	"ing the covered works for you must do so exclusively on your behalf, under your " +
	"direction and control, on terms that prohibit them from making any copies of you" +
	"r copyrighted material outside their relationship with you.\n\nConveying under a" +
	"ny other circumstances is permitted solely under the conditions stated below. Su" +
	"blicensing is not allowed; section 10 makes it unnecessary.\n\n3. Protecting Use" +
	"rs' Legal Rights From Anti-Circumvention Law.\n\nNo covered work shall be deemed" +
	" part of an effective technological measure under any applicable law fulfilling " +
	"obligations under article 11 of the WIPO copyright treaty adopted on 20 December" +
	" 1996, or similar laws prohibiting or restricting circumvention of such measures" +
	".\n\nWhen you convey a covered work, you waive any legal power to forbid circumv" +
	"ention of technological measures to the extent such circumvention is effected by" +
	" exercising rights under this License with respect to the covered work, and you " +
	"disclaim any intention to limit operation or modification of the work as a means" +
	" of enforcing, against the work's users, your or third parties' legal rights to " +
	"forbid circumvention of technological measures.\n\n4. Conveying Verbatim Copies." +
	"\n\nYou may convey verbatim copies of the Program's source code as you receive i" +
	"t, in any medium, provided that you conspicuously and appropriately publish on e" +
	"ach copy an appropriate copyright notice; keep intact all notices stating that t" +
	"his License and any non-permissive terms added in accord with section 7 apply to" +
	" the code; keep intact all notices of the absence of any warranty; and give all " +
	"recipients a copy of this License along with the Program.\n\nYou may charge any " +
	"price or no price for each copy that you convey, and you may offer support or wa" +
	"rranty protection for a fee.\n\n5. Conveying Modified Source Versions.\n\nYou ma" +
	"y convey a work based on the Program, or the modifications to produce it from th" +
	"e Program, in the form of source code under the terms of section 4, provided tha" +
	"t you also meet all of these conditions:\n\na) The work must carry prominent not" +
	"ices stating that you modified it, and giving a relevant date.\n\nb) The work mu" +
	"st carry prominent notices stating that it is released under this License and an" +
	"y conditions added under section 7. This requirement modifies the requirement in" +
	" section 4 to \"keep intact all notices\".\n\nc) You must license the entire wor" +
	"k, as a whole, under this License to anyone who comes into possession of a copy." +
	" This License will therefore apply, along with any applicable section 7 addition" +
	"al terms, to the whole of the work, and all its parts, regardless of how they ar" +
	"e packaged. This License gives no permission to license the work in any other wa" +
	"y, but it does not invalidate such permission if you have separately received it" +
	".\n\nd) If the work has interactive user interfaces, each must display Appropria" +
	"te Legal Notices; however, if the Program has interactive interfaces that do not" +
	" display Appropriate Legal Notices, your work need not make them do so.\n\nA com" +
	"pilation of a covered work with other separate and independent works, which are " +
	"not by their nature extensions of the covered work, and which are not combined w" +
	"ith it such as to form a larger program, in or on a volume of a storage or distr" +
	"ibution medium, is called an \"aggregate\" if the compilation and its resulting " +
	"copyright are not used to limit the access or legal rights of the compilation's " +
	"users beyond what the individual works permit. Inclusion of a covered work in an" +
	" aggregate does not cause this License to apply to the other parts of the aggreg" +
	"ate.\n\n6. Conveying Non-Source Forms.\n\nYou may convey a covered work in objec" +
	"t code form under the terms of sections 4 and 5, provided that you also convey t" +
	"he machine-readable Corresponding Source under the terms of this License, in one" +
	" of these ways:\n\na) Convey the object code in, or embodied in, a physical prod" +
	"uct (including a physical distribution medium), accompanied by the Corresponding" +
	" Source fixed on a durable physical medium customarily used for software interch" +
	"ange.\n\nb) Convey the object code in, or embodied in, a physical product (inclu" +
	"ding a physical distribution medium), accompanied by a written offer, valid for " +
	"at least three years and valid for as long as you offer spare parts or customer " +
	"support for that product model, to give anyone who possesses the object code eit" +
	"her (1) a copy of the Corresponding Source for all the software in the product t" +
	"hat is covered by this License, on a durable physical medium customarily used fo" +
	"r software interchange, for a price no more than your reasonable cost of physica" +
	"lly performing this conveying of source, or (2) access to copy the Corresponding" +
	" Source from a network server at no charge.\n\nc) Convey individual copies of th" +
	"e object code with a copy of the written offer to provide the Corresponding Sour" +
	"ce. This alternative is allowed only occasionally and noncommercially, and only " +
	"if you received the object code with such an offer, in accord with subsection 6b" +
	".\n\nd) Convey the object code by offering access from a designated place (grati" +
	"s or for a charge), and offer equivalent access to the Corresponding Source in t" +
	"he same way through the same place at no further charge. You need not require re" +
	"cipients to copy the Corresponding Source along with the object code. If the pla" +
	"ce to copy the object code is a network server, the Corresponding Source may be " +
	"on a different server (operated by you or a third party) that supports equivalen" +
	"t copying facilities, provided you maintain clear directions next to the object " +
	"code saying where to find the Corresponding Source. Regardless of what server ho" +
	"sts the Corresponding Source, you remain obligated to ensure that it is availabl" +
	"e for as long as needed to satisfy these requirements.\n\ne) Convey the object c" +
	"ode using peer-to-peer transmission, provided you inform other peers where the o" +
	"bject code and Corresponding Source of the work are being offered to the general" +
	" public at no charge under subsection 6d.\n\nA separable portion of the object c" +
	"ode, whose source code is excluded from the Corresponding Source as a System Lib" +
	"rary, need not be included in conveying the object code work.\n\nA \"User Produc" +
	"t\" is either (1) a \"consumer product\", which means any tangible personal prop" +
	"erty which is normally used for personal, family, or household purposes, or (2) " +
	"anything designed or sold for incorporation into a dwelling. In determining whet" +
	"her a product is a consumer product, doubtful cases shall be resolved in favor o" +
	"f coverage. For a particular product received by a particular user, \"normally u" +
	"sed\" refers to a typical or common use of that class of product, regardless of " +
	"the status of the particular user or of the way in which the particular user act" +
	"ually uses, or expects or is expected to use, the product. A product is a consum" +
	"er product regardless of whether the product has substantial commercial, industr" +
	"ial or non-consumer uses, unless such uses represent the only significant mode o" +
	"f use of the product.\n\n\"Installation Information\" for a User Product means a" +
	"ny methods, procedures, authorization keys, or other information required to ins" +
	"tall and execute modified versions of a covered work in that User Product from a" +
	" modified version of its Corresponding Source. The information must suffice to e" +
	"nsure that the continued functioning of the modified object code is in no case p" +
	"revented or interfered with solely because modification has been made.\n\nIf you" +
	" convey an object code work under this section in, or with, or specifically for " +
	"use in, a User Product, and the conveying occurs as part of a transaction in whi" +
	"ch the right of possession and use of the User Product is transferred to the rec" +
	"ipient in perpetuity or for a fixed term (regardless of how the transaction is c" +
	"haracterized), the Corresponding Source conveyed under this section must be acco" +
	"mpanied by the Installation Information. But this requirement does not apply if " +
	"neither you nor any third party retains the ability to install modified object c" +
	"ode on the User Product (for example, the work has been installed in ROM).\n\nTh" +
	"e requirement to provide Installation Information does not include a requirement" +
	" to continue to provide support service, warranty, or updates for a work that ha" +
	"s been modified or installed by the recipient, or for the User Product in which " +
	"it has been modified or installed. Access to a network may be denied when the mo" +
	"dification itself materially and adversely affects the operation of the network " +
	"or violates the rules and protocols for communication across the network.\n\nCor" +
	"responding Source conveyed, and Installation Information provided, in accord wit" +
	"h this section must be in a format that is publicly documented (and with an impl" +
	"ementation available to the public in source code form), and must require no spe" +
	"cial password or key for unpacking, reading or copying.\n\n7. Additional Terms.\n" +
	"\n\"Additional permissions\" are terms that supplement the terms of this License" +
	" by making exceptions from one or more of its conditions. Additional permissions" +
	" that are applicable to the entire Program shall be treated as though they were " +
	"included in this License, to the extent that they are valid under applicable law" +
	". If additional permissions apply only to part of the Program, that part may be " +
	"used separately under those permissions, but the entire Program remains governed" +
	" by this License without regard to the additional permissions.\n\nWhen you conve" +
	"y a copy of a covered work, you may at your option remove any additional permiss" +
	"ions from that copy, or from any part of it. (Additional permissions may be writ" +
	"ten to require their own removal in certain cases when you modify the work.) You" +
	" may place additional permissions on material, added by you to a covered work, f" +
	"or which you have or can give appropriate copyright permission.\n\nNotwithstandi" +
	"ng any other provision of this License, for material you add to a covered work, " +
	"you may (if authorized by the copyright holders of that material) supplement the" +
	" terms of this License with terms:\n\na) Disclaiming warranty or limiting liabil" +
	"ity differently from the terms of sections 15 and 16 of this License; or \n\nb) " +
	"Requiring preservation of specified reasonable legal notices or author attributi" +
	"ons in that material or in the Appropriate Legal Notices displayed by works cont" +
	"aining it; or \n\nc) Prohibiting misrepresentation of the origin of that materia" +
	"l, or requiring that modified versions of such material be marked in reasonable " +
	"ways as different from the original version; or \n\nd) Limiting the use for publ" +
	"icity purposes of names of licensors or authors of the material; or \n\ne) Decli" +
	"ning to grant rights under trademark law for use of some trade names, trademarks" +
	", or service marks; or \n\nf) Requiring indemnification of licensors and authors" +
	" of that material by anyone who conveys the material (or modified versions of it" +
	") with contractual assumptions of liability to the recipient, for any liability " +
	"that these contractual assumptions directly impose on those licensors and author" +
	"s. All other non-permissive additional terms are considered \"further restrictio" +
	"ns\" within the meaning of section 10. If the Program as you received it, or any" +
	" part of it, contains a notice stating that it is governed by this License along" +
	" with a term that is a further restriction, you may remove that term. If a licen" +
	"se document contains a further restriction but permits relicensing or conveying " +
	"under this License, you may add to a covered work material governed by the terms" +
	" of that license document, provided that the further restriction does not surviv" +
	"e such relicensing or conveying.\n\nIf you add terms to a covered work in accord" +
	" with this section, you must place, in the relevant source files, a statement of" +
	" the additional terms that apply to those files, or a notice indicating where to" +
	" find the applicable terms.\n\nAdditional terms, permissive or non-permissive, m" +
	"ay be stated in the form of a separately written license, or stated as exception" +
	"s; the above requirements apply either way.\n\n8. Termination.\n\nYou may not pr" +
	"opagate or modify a covered work except as expressly provided under this License" +
	". Any attempt otherwise to propagate or modify it is void, and will automaticall" +
	"y terminate your rights under this License (including any patent licenses grante" +
	"d under the third paragraph of section 11).\n\nHowever, if you cease all violati" +
	"on of this License, then your license from a particular copyright holder is rein" +
	"stated (a) provisionally, unless and until the copyright holder explicitly and f" +
	"inally terminates your license, and (b) permanently, if the copyright holder fai" +
	"ls to notify you of the violation by some reasonable means prior to 60 days afte" +
	"r the cessation.\n\nMoreover, your license from a particular copyright holder is" +
	" reinstated permanently if the copyright holder notifies you of the violation by" +
	" some reasonable means, this is the first time you have received notice of viola" +
	"tion of this License (for any work) from that copyright holder, and you cure the" +
	" violation prior to 30 days after your receipt of the notice.\n\nTermination of " +
	"your rights under this section does not terminate the licenses of parties who ha" +
	"ve received copies or rights from you under this License. If your rights have be" +
	"en terminated and not permanently reinstated, you do not qualify to receive new " +
	"licenses for the same material under section 10.\n\n9. Acceptance Not Required f" +
	"or Having Copies.\n\nYou are not required to accept this License in order to rec" +
	"eive or run a copy of the Program. Ancillary propagation of a covered work occur" +
	"ring solely as a consequence of using peer-to-peer transmission to receive a cop" +
	"y likewise does not require acceptance. However, nothing other than this License" +
	" grants you permission to propagate or modify any covered work. These actions in" +
	"fringe copyright if you do not accept this License. Therefore, by modifying or p" +
	"ropagating a covered work, you indicate your acceptance of this License to do so" +
	".\n\n10. Automatic Licensing of Downstream Recipients.\n\nEach time you convey a" +
	" covered work, the recipient automatically receives a license from the original " +
	"licensors, to run, modify and propagate that work, subject to this License. You " +
	"are not responsible for enforcing compliance by third parties with this License." +
	"\n\nAn \"entity transaction\" is a transaction transferring control of an organi" +
	"zation, or substantially all assets of one, or subdividing an organization, or m" +
	"erging organizations. If propagation of a covered work results from an entity tr" +
	"ansaction, each party to that transaction who receives a copy of the work also r" +
	"eceives whatever licenses to the work the party's predecessor in interest had or" +
	" could give under the previous paragraph, plus a right to possession of the Corr" +
	"esponding Source of the work from the predecessor in interest, if the predecesso" +
	"r has it or can get it with reasonable efforts.\n\nYou may not impose any furthe" +
	"r restrictions on the exercise of the rights granted or affirmed under this Lice" +
	"nse. For example, you may not impose a license fee, royalty, or other charge for" +
	" exercise of rights granted under this License, and you may not initiate litigat" +
	"ion (including a cross-claim or counterclaim in a lawsuit) alleging that any pat" +
	"ent claim is infringed by making, using, selling, offering for sale, or importin" +
	"g the Program or any portion of it.\n\n11. Patents.\n\nA \"contributor\" is a co" +
	"pyright holder who authorizes use under this License of the Program or a work on" +
	" which the Program is based. The work thus licensed is called the contributor's " +
	"\"contributor version\".\n\nA contributor's \"essential patent claims\" are all " +
	"patent claims owned or controlled by the contributor, whether already acquired o" +
	"r hereafter acquired, that would be infringed by some manner, permitted by this " +
	"License, of making, using, or selling its contributor version, but do not includ" +
	"e claims that would be infringed only as a consequence of further modification o" +
	"f the contributor version. For purposes of this definition, \"control\" includes" +
	" the right to grant patent sublicenses in a manner consistent with the requireme" +
	"nts of this License.\n\nEach contributor grants you a non-exclusive, worldwide, " +
	"royalty-free patent license under the contributor's essential patent claims, to " +
	"make, use, sell, offer for sale, import and otherwise run, modify and propagate " +
	"the contents of its contributor version.\n\nIn the following three paragraphs, a" +
	" \"patent license\" is any express agreement or commitment, however denominated," +
	" not to enforce a patent (such as an express permission to practice a patent or " +
	"covenant not to sue for patent infringement). To \"grant\" such a patent license" +
	" to a party means to make such an agreement or commitment not to enforce a paten" +
	"t against the party.\n\nIf you convey a covered work, knowingly relying on a pat" +
	"ent license, and the Corresponding Source of the work is not available for anyon" +
	"e to copy, free of charge and under the terms of this License, through a publicl" +
	"y available network server or other readily accessible means, then you must eith" +
	"er (1) cause the Corresponding Source to be so available, or (2) arrange to depr" +
	"ive yourself of the benefit of the patent license for this particular work, or (" +
	"3) arrange, in a manner consistent with the requirements of this License, to ext" +
	"end the patent license to downstream recipients. \"Knowingly relying\" means you" +
	" have actual knowledge that, but for the patent license, your conveying the cove" +
	"red work in a country, or your recipient's use of the covered work in a country," +
	" would infringe one or more identifiable patents in that country that you have r" +
	"eason to believe are valid.\n\nIf, pursuant to or in connection with a single tr" +
	"ansaction or arrangement, you convey, or propagate by procuring conveyance of, a" +
	" covered work, and grant a patent license to some of the parties receiving the c" +
	"overed work authorizing them to use, propagate, modify or convey a specific copy" +
	" of the covered work, then the patent license you grant is automatically extende" +
	"d to all recipients of the covered work and works based on it.\n\nA patent licen" +
	"se is \"discriminatory\" if it does not include within the scope of its coverage" +
	", prohibits the exercise of, or is conditioned on the non-exercise of one or mor" +
	"e of the rights that are specifically granted under this License. You may not co" +
	"nvey a covered work if you are a party to an arrangement with a third party that" +
	" is in the business of distributing software, under which you make payment to th" +
	"e third party based on the extent of your activity of conveying the work, and un" +
	"der which the third party grants, to any of the parties who would receive the co" +
	"vered work from you, a discriminatory patent license (a) in connection with copi" +
	"es of the covered work conveyed by you (or copies made from those copies), or (b" +
	") primarily for and in connection with specific products or compilations that co" +
	"ntain the covered work, unless you entered into that arrangement, or that patent" +
	" license was granted, prior to 28 March 2007.\n\nNothing in this License shall b" +
	"e construed as excluding or limiting any implied license or other defenses to in" +
	"fringement that may otherwise be available to you under applicable patent law.\n" +
	"\n12. No Surrender of Others' Freedom.\n\nIf conditions are imposed on you (whet" +
	"her by court order, agreement or otherwise) that contradict the conditions of th" +
	"is License, they do not excuse you from the conditions of this License. If you c" +
	"annot convey a covered work so as to satisfy simultaneously your obligations und" +
	"er this License and any other pertinent obligations, then as a consequence you m" +
	"ay not convey it at all. For example, if you agree to terms that obligate you to" +
	" collect a royalty for further conveying from those to whom you convey the Progr" +
	"am, the only way you could satisfy both those terms and this License would be to" +
	" refrain entirely from conveying the Program.\n\n13. Use with the GNU Affero Gen" +
	"eral Public License.\n\nNotwithstanding any other provision of this License, you" +
	" have permission to link or combine any covered work with a work licensed under " +
	"version 3 of the GNU Affero General Public License into a single combined work, " +
	"and to convey the resulting work. The terms of this License will continue to app" +
	"ly to the part which is the covered work, but the special requirements of the GN" +
	"U Affero General Public License, section 13, concerning interaction through a ne" +
	"twork will apply to the combination as such.\n\n14. Revised Versions of this Lic" +
	"ense.\n\nThe Free Software Foundation may publish revised and/or new versions of" +
	" the GNU General Public License from time to time. Such new versions will be sim" +
	"ilar in spirit to the present version, but may differ in detail to address new p" +
	"roblems or concerns.\n\nEach version is given a distinguishing version number. I" +
	"f the Program specifies that a certain numbered version of the GNU General Publi" +
	"c License \"or any later version\" applies to it, you have the option of followi" +
	"ng the terms and conditions either of that numbered version or of any later vers" +
	"ion published by the Free Software Foundation. If the Program does not specify a" +
	" version number of the GNU General Public License, you may choose any version ev" +
	"er published by the Free Software Foundation.\n\nIf the Program specifies that a" +
	" proxy can decide which future versions of the GNU General Public License can be" +
	" used, that proxy's public statement of acceptance of a version permanently auth" +
	"orizes you to choose that version for the Program.\n\nLater license versions may" +
	" give you additional or different permissions. However, no additional obligation" +
	"s are imposed on any author or copyright holder as a result of your choosing to " +
	"follow a later version.\n\n15. Disclaimer of Warranty.\n\nTHERE IS NO WARRANTY F" +
	"OR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE" +
	" STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRA" +
	"M \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING" +
	", BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR " +
	"A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE P" +
	"ROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF A" +
	"LL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n16. Limitation of Liability.\n\n" +
	"IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY C" +
	"OPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS P" +
	"ERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, IN" +
	"CIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE" +
	" PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACC" +
	"URATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO" +
	" OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN A" +
	"DVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n\n17. Interpretation of Sections 15 " +
	"and 16.\n\nIf the disclaimer of warranty and limitation of liability provided ab" +
	"ove cannot be given local legal effect according to their terms, reviewing court" +
	"s shall apply local law that most closely approximates an absolute waiver of all" +
	" civil liability in connection with the Program, unless a warranty or assumption" +
	" of liability accompanies a copy of the Program in return for a fee.\n\n\nEND OF" +
	" TERMS AND CONDITIONS\n\n\n\n\nHow to Apply These Terms to Your New Programs\n\n" +
	"If you develop a new program, and you want it to be of the greatest possible use" +
	" to the public, the best way to achieve this is to make it free software which e" +
	"veryone can redistribute and change under these terms.\n\nTo do so, attach the f" +
	"ollowing notices to the program. It is safest to attach them to the start of eac" +
	"h source file to most effectively state the exclusion of warranty; and each file" +
	" should have at least the \"copyright\" line and a pointer to where the full not" +
	"ice is found.\n\n    {one line to give the program's name and a brief idea of wh" +
	"at it does.}\n    Copyright (C) {year}  {name of author}\n\nThis program is free" +
	" software; you can redistribute it and/or modify it under the terms of the GNU G" +
	"eneral Public License as published by the Free Software Foundation, either versi" +
	"on 3 of the License, or (at your option) any later version.\n\nThis program is d" +
	"istributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without" +
	" even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOS" +
	"E. See the GNU General Public License for more details.\n\nYou should have recei" +
	"ved a copy of the GNU General Public License along with this program. If not, se" +
	"e <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you " +
	"by electronic and paper mail.\n\nIf the program does terminal interaction, make " +
	"it output a short notice like this when it starts in an interactive mode:\n\n   " +
	" {project}  Copyright (C) {year}  {fullname}\n    This program comes with ABSOLU" +
	"TELY NO WARRANTY; for details type `show w'.\n    This is free software, and you" +
	" are welcome to redistribute it\n    under certain conditions; type `show c' for" +
	" details.\n\nThe hypothetical commands `show w' and `show c' should show the app" +
	"ropriate parts of the General Public License. Of course, your program's commands" +
	" might be different; for a GUI interface, you would use an \"about box\".\n\nYou" +
	" should also get your employer (if you work as a programmer) or school, if any, " +
	"to sign a \"copyright disclaimer\" for the program, if necessary.\n\nFor more in" +
	"formation on this, and how to apply and follow the GNU GPL, see <http://www.gnu." +
	"org/licenses/>.\n\nThe GNU General Public License does not permit incorporating " +
	"your program into proprietary programs. If your program is a subroutine library," +
	" you may consider it more useful to permit linking proprietary applications with" +
	" the library. If this is what you want to do, use the GNU Lesser General Public " +
	"License instead of this License. But first, please read <http://www.gnu.org/phil" +
	"osophy/why-not-lgpl.html>.\n\n\n94d4 d7bf 3a9e c83c 1efe bd56 f9d9 3bd4\n";
	
	
	
	
	
	static String howtousepopmail1 =
	
	"\n0. Open an email account that supports POP3 (Post Office Protocol) mail. Once " +
	"you open an email account, you may also have to enable POP mail if it is not ena" +
	"bled by default. Click on the settings or email client label on the email websit" +
	"e, click on the check box that says enable POP mail, and then click Save to conf" +
	"irm the changes.\n\nThis program includes free email service providers such as g" +
	"mx and mail.com but you are not limited to the names listed in the drop-down / c" +
	"ombo box because the box is editable. If your company has its own private POP ma" +
	"il provider (such as pop.mycompany.com), then type in your company's POP server " +
	"name followed by the port number. (The program was tested using yandex.com.)\n\n" +
	"Some email providers such as gmail and yahoo require a name, a date of birth, an" +
	"d an answer to a security question. The Java mail program provides a menu item t" +
	"hat generates random text and birth dates for these email providers. Just double" +
	"-click on one of the random words and use control C to copy the word, then click" +
	" in the email text field on the sign-up page and use control V to paste random g" +
	"arbage into the email website. Web browsers such as Firefox could also provide t" +
	"his feature because the browsers already have a random password generator.\n\n\n" +
	"\n\n1. Choose one passphrase for all your email accounts.\n\nClick Edit -> Passp" +
	"hrase / Settings to open the settings dialog box or hold down the Ctrl button an" +
	"d press the letter P on the keyboard.\n\nYou can use the random number generator" +
	" button next to the passphrase to choose a random number for you. You could also" +
	" add some additional digits to the passphrase. (If the random number generator b" +
	"utton is not visible, you can delete the passphrase and then the random number g" +
	"enerator button will become visible.)\n\nThe passphrase should contain informati" +
	"on from different sources, or it should contain several random digits or words. " +
	"Make sure that the passphrase has enough randomness or entropy so that nobody ca" +
	"n try all the possible combinations. The number of combinations can be calculate" +
	"d from the number of digits or words.\n\nFor example, if 24 decimal digits are c" +
	"hosen randomly, the number of combinations is 10^24 or one septillion. If 20 bas" +
	"e-16 digits are chosen, the number of combinations is 16^20 which is also approx" +
	"imately 10^24. If 16 characters are chosen randomly using the 36 alphanumeric ch" +
	"aracters, the number of combinations is 36 ^ 16 or 10 septillion. If 14 characte" +
	"rs are chosen using the 36 alphanumeric and ~ 20 special characters !@#$%^&*-_+=" +
	"|:;,./?, the number of combinations is 56 ^ 14 or approximately one septillion.\n" +
	"\nIncreasing the size of the character set from 36 alphanumeric characters to 56" +
	" characters only reduces the size of the passphrase by two characters for the sa" +
	"me amount of entropy. Even with a set of 56 characters, the password still requi" +
	"res at least 14 to 15 random characters.\n\nIf the minimum number of operations " +
	"required to generate one public key is on the order of a million, then the numbe" +
	"r of operations required to try a septillion public keys or combinations is arou" +
	"nd one nonillion or 10^30. This number of operations is impossible for any super" +
	"computer to perform. Even if a computer could be built using a billion processor" +
	"s that can do a hundred billion operations per second per processor, or 10^20 op" +
	"erations per second, it would take 10^10 or 10 billion seconds to do 10^30 opera" +
	"tions.\n\nNote that your computer login password may only require a few characte" +
	"rs because the files are protected by your computer, and the server password or " +
	"userpass only requires a few characters because the email account is protected b" +
	"y the server and the encryption used to send the password, but your public key r" +
	"equires at least 15 random characters.\n\nMake sure to write down the passphrase" +
	" that you use and store it in a safe location. If you lose your encryption passp" +
	"hrase, you will not be able to read your emails.\n\nJust because the program use" +
	"s only one passphrase doesn't mean that different email addresses can be correla" +
	"ted. The public key and the userpass generated for each email account will be di" +
	"fferent because the private key uses the hash of the passphrase and email addres" +
	"s. (You can view and edit the userpass for each email name or tab by clicking on" +
	" Edit -> User password and then use this password when you open or register your" +
	" email account.)\n\nYou can type your passphrase on the first line or second lin" +
	"e of the passphrase dialog. If you include a passphrase on the second line, you " +
	"have to retype it each time the mail or text editor program is closed and then r" +
	"eopened.\n\n\n\n2. Choose an incoming mail server and port number.\n\nClick Edit" +
	" -> Passphrase / Settings to open the settings dialog box, or hold down the Ctrl" +
	" button and press the letter P once on the keyboard.\n\nThen click the down arro" +
	"w on the incoming mail server combo box. A drop-down list appears showing differ" +
	"ent mail servers such as pop.mail.com. You can choose one of these servers by cl" +
	"icking on the server name. You could also type in a different server that is not" +
	" shown on this list followed by the port number by erasing one of the server nam" +
	"es.\n\nNote that all email servers listen on port 995 for clients that use POP m" +
	"ail (Post Office Protocol). If you type a different port number, the server will" +
	" not respond to the email program because email servers do not listen for POP ma" +
	"il clients on any ports other than 995.\n\n\n\n3. Enter your email username such" +
	" as myaddress@example.com.\n\nThe domain name of the email address has to match " +
	"the domain name of the incoming mail server or else the program will issue a war" +
	"ning that the two do not match. If you checked the menu item Help -> [x] Test Ma" +
	"il and are testing the program, you can either change your domain to example.com" +
	" and then select pop.example.com 995, or erase one of the incoming server fields" +
	" and type in pop.mydomain.com where mydomain is the domain after the @ sign in t" +
	"he email field.\n\nThe program will generate a password suggestion using the fir" +
	"st eight digits of the hash of the passphrase + username. You can view and edit " +
	"the password that the program is using for the email account by clicking Edit ->" +
	" User Password. If you delete the password in the userpass field, the program wi" +
	"ll fill in the password using the hash of the passphrase and username.\n\nIf you" +
	" enter more than 16 digits for the user password, the program will complain abou" +
	"t the password length because it assumes that the user is mistakenly entering th" +
	"e passphrase instead of the userpass or password. Unlike the user password which" +
	" is used to login, the secret passphrase is never shared with anyone else, inclu" +
	"ding an email server.\n\n\n\n\n4. Click Help -> [x] Test Mail to enable / disabl" +
	"e test mail.\n\nUse the test mail feature to learn how the POP mail program work" +
	"s. You can list, read, view, delete, send, and save emails using the test mail f" +
	"eature. Each time you sign out, the current setting of test mail is saved to dis" +
	"k along with all the other settings so that the next time you enter your passphr" +
	"ase the settings will be restored.\n\nYou can view the communication between the" +
	" client and server by clicking the View -> Client/Server Communication menu item" +
	" to open a window. The client or mail program sends the commands STAT, LIST, TOP" +
	", RETR, DELE, and QUIT to read the status (number of messages and bytes), list t" +
	"he message numbers and bytes for each message, read the tops or headers of the e" +
	"mails, retrieve or delete messages, and log out of the server.\n\nIf you click t" +
	"he Sign Out button while the program is listing or retrieving the messages, you " +
	"will see that the program stops retrieving messages and sends the quit command t" +
	"o the server. Because the window has no frame, you have to click the menu item a" +
	" second time to close / hide the window.\n\n\n\n5. Click the List button to list" +
	" the messages.\n\nThe list screen displays the message number, the number of kil" +
	"obytes, the sender, the subject, and the first few words of each message.\n\nIf " +
	"you are using the test mail feature, the list may take several seconds to appear" +
	" if you are using only a single- or dual-core processor because the program has " +
	"to encrypt several messages for the test.\n\nMany users leave hundreds of messag" +
	"es on the server by not deleting them (except for spam) and then just download t" +
	"he newest 10, 20, 50, or 100 messages by choosing the number of messages in the " +
	"settings dialog box. You can choose the number of messages from the drop-down / " +
	"combo box, or you can choose your own number such as 15 or 25 by erasing one of " +
	"the numbers and then typing in a new number. If the server is slow, choosing a s" +
	"maller number allows the List button to display the tops of the messages faster." +
	"\n\nIf you want to update the list screen because you are expecting a new messag" +
	"e to arrive, then you have to click the Sign Out button and then click the List " +
	"button. Otherwise the List button will keep re-displaying the same list stored o" +
	"n your computer. If the program is closed and then reopened, the memory cache wi" +
	"ll disappear and the program will have to retrieve the messages from the server," +
	" just as if the user had clicked the Sign Out button. (Closing the window may no" +
	"t close the program if there is also a text editor window opened. If a text edit" +
	"or window is open, closing the Mail program just hides the window from view.)\n\n" +
	"Depending on the service provider and the number of messages on the server, you " +
	"may have to change the order of the messages to ascending or descending. Some em" +
	"ail service providers enumerate the messages in ascending order (newest messages" +
	" first, oldest messages last), but other providers enumerate them in descending " +
	"order (oldest messages first, newest messages last). If you have a lot of new me" +
	"ssages to read and delete, you can choose which order to read them, and you can " +
	"change back and forth to read and/or delete the oldest or newest by changing the" +
	" settings box to ascending or descending, and then clicking the Sign Out and Lis" +
	"t buttons to reload the messages.\n\n\n\n6. Choose the message that you want to " +
	"retrieve, view or read by clicking on the sender's address or the subject line. " +
	"You can return to the list screen by clicking the List button or by pressing the" +
	" Backspace <-- button on the keyboard.\n\nOnce a message has been retrieved, the" +
	" program will store a temporary copy in volatile memory so the program does not " +
	"have to download the same message more than once (unless you click Sign Out).\n\n" +
	"You can change the font size to make your messages easier to read by holding dow" +
	"n the control (Ctrl) key and pressing the + or - key, or by holding down Ctrl an" +
	"d using the scroll wheel on the mouse. You can also change the font type by clic" +
	"king the View -> Font Type menu item and then using the down arrow key until you" +
	" find a font that you like. Clicking OK changes the display to the new font, but" +
	" closing the font dialog box without clicking OK (by clicking Cancel, clicking t" +
	"he 'x', or pressing the escape button) restores the original font.\n\nThe icons " +
	"on the list screen can be changed from unread to read, replied to / answered, im" +
	"portant, urgent, etc. The message states will be stored in the mail directory on" +
	" the client computer but not on the server because POP3 does not allow the user " +
	"to change the state of a message.\n\n\n\n7. Reply to a message by clicking on th" +
	"e reply label at the top of the message (where it says \" delete  reply  prev  n" +
	"ext \").\n\nA reply window appears that has the to, from, and subject fields, an" +
	"d the sender's message filled in. You can type your message and then click the S" +
	"end button.\n\nIf a message box appears that says \"user domain does not match s" +
	"erver domain\", you will have to click on Edit -> Password / Settings or use Ctr" +
	"l + P to open the settings dialog box; click inside the outgoing mail server com" +
	"bo box; erase the existing outgoing server and type your server domain name and " +
	"port number (such as mydomain.com 465, or mail.mydomain.com 465, or whatever the" +
	" server name is) where mydomain is the name after the '@' sign in the from addre" +
	"ss. If you use the email address myname@example.com to test the program, then yo" +
	"u can choose mail.example.com 465 as the server domain.\n\nIf no reply key was i" +
	"ncluded in the message, a dialog box will prompt you to find the recipient's pub" +
	"lic key and copy it to the clipboard. You can ignore this message and click agai" +
	"n on the Send button if you want to send a plaintext message that is not encrypt" +
	"ed.\n\nIf a reply key was included in the message, an icon showing two public ke" +
	"ys on a key ring will appear next to the To: field. If you click on the public k" +
	"ey icon, a message box will appear displaying the recipient's 32-digit public ke" +
	"y hash. (If you have a document such as a business card that has the recipient's" +
	" public key hash, you can verify that the recipient's public key is correct by c" +
	"omparing the two numbers.)\n\nIf you click the Send button, a confirmation dialo" +
	"g box appears that says \"Yes\", \"Attach File / Dir\", and \"Cancel\". You can " +
	"click the Attach File / Directory button to attach up to 10 files to your email." +
	" If you click the Attach File / Dir button, a file chooser dialog box appears. C" +
	"hoose the file or folder that you want to attach, and then click Yes to send the" +
	" message.\n\n(Note that you if you want to attach a file or folder that is insid" +
	"e another folder or directory, you have to select the top folder and then use th" +
	"e enter button or double-click on the folder name to navigate to the subdirector" +
	"y or file. If you just select a folder and click the button on the dialog box in" +
	"stead of pressing the enter key, it will assume that you want to attach the enti" +
	"re folder or directory.)\n\nYou can close the send mail frame and try replying t" +
	"o another message. If a test message does not include a reply key, you can creat" +
	"e a fake reply key by clicking the Edit -> Print Public Key menu item and typing" +
	" the recipient's name in the address field of the dialog box. The public key tha" +
	"t appears in a new window will automatically be copied to the clipboard. Close t" +
	"he public key window and use the fake key to test the mail program by clicking o" +
	"n the Send button. A public key icon should appear next to the to: field indicat" +
	"ing that the recipient's key was found on the clipboard. (If the address on the " +
	"clipboard key does not match the address in the to: field, then the program will" +
	" not recognize the public key. If the clipboard key doesn't have an email addres" +
	"s, then the program will display the key hash and ask you to confirm the key.)\n" +
	"\nWhenever you send an encrypted message to someone, the recipient's public key " +
	"gets saved to a public key file in the Mail directory (usually /home/username/Ma" +
	"il or whatever directory is listed in the settings dialog box). If you have more" +
	" than one username (such as a personal and business address), then there will be" +
	" more than one public key file because the public keys are stored according to y" +
	"our username or email address.\n\nIf you want to send a message to a recipient w" +
	"ithout replying to an email, click on the File -> Send Mail menu item to open a " +
	"Send Mail frame. The from: address will automatically be filled in with your use" +
	"rname / email address. Then you can type your message and enter the recipient's " +
	"address in the to: field. When you click the Send button, the public key icon wi" +
	"ll appear next to the to: field if a public key has been used before for that re" +
	"cipient. If a public key hasn't been used before, you have to find and copy the " +
	"recipient's key to the clipboard and then click the Send button again. (If the a" +
	"ddress on the public key does not match the address in the to: field, the Mail p" +
	"rogram will display an error message that says \"Address on clipboard public key" +
	" does not match address in to: field\".)\n\nYou can view the public key files (a" +
	"nd delete public keys) by clicking on View -> View Public Keys menu item. If you" +
	" change the tabbed pane to a different tab / username and then click the View Pu" +
	"blic Keys menu item, a different set of public keys will appear corresponding to" +
	" that username / email address. You can also view the encrypted public key file " +
	"by opening the file using the Java text editor and entering the passphrase. (Eve" +
	"ry file that is saved by the Mail program is encrypted using the passphrase in t" +
	"he passphrase / settings dialog box.)\n\nBecause the recipients' public keys are" +
	" saved in a public key file, you only have to find, copy and paste a public key " +
	"once for each recipient. The next time you send an email to the same recipient, " +
	"the Mail program will find the key for you and display the public key icon next " +
	"to the to: address. In future versions of the program the software will retrieve" +
	" the public key from the recipient's email server every time you send a message," +
	" but the email servers first have to be upgraded to allow users to store their p" +
	"ublic keys.\n\n\n\n8. Mark any messages for deletion by checking the box [ x ] n" +
	"ext to the server message number.\n\nYou can mark and unmark a message for delet" +
	"ion by clicking on the check box [  ]. The checked messages will not be deleted " +
	"from the server until the Delete button is clicked.\n\nAfter you click the Delet" +
	"e button, the deleted message numbers disappear from the list and from the serve" +
	"r. Clicking the List button doesn't re-number them because the server doesn't re" +
	"-number them. You have to click the Sign Out button and then click the List butt" +
	"on to re-number the list.\n\n\n\n9. You can add an additional username / email a" +
	"ddress to the mail program by clicking File -> New.\n\nWhen the new tab appears," +
	" enter another email address. Then open the settings dialog box and select the i" +
	"ncoming server for the new tab.\n\nYou can change the colors of the tabs so that" +
	" your personal email appears in one color and your business email appears in ano" +
	"ther color.\n\nYou can delete a username by clicking File -> Close. This opens a" +
	" dialog box which gives you the option either to close the tab or to delete the " +
	"username. (Closing the tab just hides the tab from view, but the username still " +
	"exists and will reappear when the window or program is closed and reopened. Dele" +
	"ting the tab deletes the username from memory when the mail settings are encrypt" +
	"ed and saved to disk.)\n\n\n\n10. You can restore the tabbed email panes by open" +
	"ing the passphrase dialog box, typing or confirming your passphrase, and clickin" +
	"g OK.\n\nTry closing the mail program window (and the text editor window), and t" +
	"hen reopen the program. Click the List button to open the Passphrase / Settings " +
	"dialog box (or click Edit -> Passphrase). When the dialog box appears, confirm t" +
	"hat the passphrase is correct, or enter your passphrase, and click OK. If the pa" +
	"ssphrase is correct, your email addresses should appear automatically when you c" +
	"lick OK. The selected tab or email address will be the tab that was last selecte" +
	"d before the program / window was closed.\n\nEach time you close the mail progra" +
	"m window, the tabbed panes and settings will be encrypted and saved to disk usin" +
	"g the hash of the public key as the file suffix and your passphrase as the file " +
	"encryption key.\n\nNote that if you create a public key using a different passph" +
	"rase, the passphrase dialog box will display the last passphrase that was used. " +
	"This may not be the passphrase that you want.\n\nIf you click OK and your email " +
	"addresses do not appear in the tabbed pane, open the dialog box, enter the corre" +
	"ct passphrase, and then click OK and your email addresses should appear.\n\n\n\n" +
	"11. Create a public key for each user name by clicking on Edit -> Print Public K" +
	"ey in the Mail program. Use the same passphrase and a different email address to" +
	" generate the public key.\n\nIf you want to be able to receive encrypted email, " +
	"you can publish your public key on a webpage or you can email it to someone who " +
	"wants to send you an encrypted message. (Eventually this problem will be solved " +
	"by the email service providers if they upgrade their software to allow users to " +
	"send / store and retrieve public keys.)\n\nWhen you create your public key from " +
	"the mail program it is also copied to the clipboard. You can then use the clipbo" +
	"ard to paste it onto a public or private website.\n\nThe Edit -> Print Public Ke" +
	"y menu item displays the public key and the 32-digit public key hash. You can wr" +
	"ite your 32-digit public key hash (or just the first 24 or 28 digits) onto docum" +
	"ents or business cards so that other people who write to you can verify that the" +
	"y downloaded the correct public key before sending a message.\n\nThe public key " +
	"hash method hashes the digits so that the key format can change without breaking" +
	" the hash (unless the number of ciphers changes). The public key hash only hashe" +
	"s the digits which means that the email address is not included in the public ke" +
	"y hash.\n\nIf you include your email address in the passphrase address field the" +
	"n the address will be printed on the public key. You can delete the address from" +
	" the printed key using the backspace or delete key.\n\nIt makes no difference wh" +
	"ether you type an email address onto a public key or erase an address from a pub" +
	"lic key. The sender will still be able to copy the public key to the clipboard, " +
	"click in the to field and press enter, and the email program will still decrypt " +
	"the message because it will generate two private keys (using the passphrase and " +
	"the passphrase + email address) and it will try one or both private keys until i" +
	"t decrypts the message.\n\n\n\n12. Write down your secret passphrase, usernames" +
	", and user passwords.\n\nIf you lose this information, you will not be able to a" +
	"ccess your email accounts or decrypt your emails.\n\nYou can save your passphras" +
	"e in a file by typing your passphrase on the first line of the dialog box, or yo" +
	"u can type your passphrase on the second line every time you close / exit and re" +
	"start the program. If you store your passphrase by typing it on the first line, " +
	"you never have to retype it, but then if you lose your laptop computer, someone " +
	"can get access to all your email accounts and your emails. If you type your pass" +
	"phrase on the second line of the passphrase dialog box, then your emails are sec" +
	"ure even if your laptop is lost, stolen, or confiscated, but you have to keep re" +
	"typing your passphrase every time you close / exit and restart the program.\n\nO" +
	"ne option is to type your passphrase on the second line of the dialog box and th" +
	"en minimize the window when you are not using it. Closing your laptop or locking" +
	" the screen will protect it because laptops and desktops usually require a short" +
	" password to log in. If your laptop is lost, the passphrase will disappear becau" +
	"se it is stored in volatile memory, unless someone can guess the login password." +
	" If someone tries to bypass the login password by booting the computer from a US" +
	"B flash drive, they can get access to any unencrypted files on the hard disk but" +
	" the passphrase will disappear from volatile memory because the computer has to " +
	"be restarted.\n\nYou can also use two passphrases, a long passphrase which you t" +
	"ype on the first line and then a shorter passphrase which you type on the second" +
	" line. You only have to retype the second passphrase because the first passphras" +
	"e is stored in a file in the home directory.\n\nAnother option for protecting yo" +
	"ur email passphrase is to encrypt your home directory. If your operating system " +
	"encrypts your home directory for you, then you don't have to worry about storing" +
	" your email passphrase because the passphrase file is located in the home direct" +
	"ory. Encrypting the home directory also prevents someone from reading your unenc" +
	"rypted files and documents by booting the computer from a live Linux USB device.";
	
	
	static String howtousepopmail2 = "";
	
	//  More text can be appended without exceeding the java compiler string size limit
	//  by concatenating the two strings howtousepopmail1 + howtousepopmail2;
	
	
	
	static String table_example =
	
	"Atomic No. (protons)\tElement Name\tSymbol\tType\tAtomic Mass\tIonization Energy" +
	" (eV)\tGroup\n\t\t\t\t\t\t\n1\tHydrogen\tH\tDiatomic gas\t1.008\t13.5984\tIA (VI" +
	"IA)\n2\tHelium\tHe\tNoble gas\t4.002\t24.5874\tVIIIA\n3\tLithium\tLi\tAlkali met" +
	"al\t6.940\t5.3917\tIA\n4\tBeryllium\tBe\tAlkaline-earth metal\t9.0122\t9.3227\tI" +
	"IA\n5\tBoron\tB\tTrivalent metalloid\t10.810\t8.2980\tIIIA\n6\tCarbon\tC\tTetrav" +
	"alent nonmetal\t12.011\t11.2603\tIVA\n7\tNitrogen\tN\tDiatomic gas\t14.007\t14.5" +
	"341\tVA\n8\tOxygen\tO\tDiatomic gas\t15.999\t13.6181\tVIA\n9\tFluorine\tF\tHalog" +
	"en diatomic gas\t18.998\t17.4228\tVIIA\n10\tNeon\tNe\tNoble gas\t20.180\t21.5645" +
	"\tVIIIA\n11\tSodium (L. Natrium)\tNa\tAlkali metal\t22.990\t5.1390\tIA\n12\tMagn" +
	"esium\tMg\tAlkaline-earth metal\t24.305\t7.6462\tIIA\n13\tAluminum  (Aluminium)\t" +
	"Al\tTrivalent metal\t26.982\t5.9858\tIIIA\n14\tSilicon\tSi\tTetravalent nonmetal" +
	"\t28.085\t8.1517\tIVA\n15\tPhosphorus\tP\tNonmetallic element\t30.974\t10.4867\t" +
	"VA\n16\tSulfur\tS\tNonmetallic element\t32.060\t10.3600\tVIA\n17\tChlorine\tCl\t" +
	"Halogen diatomic gas\t35.450\t12.9676\tVIIA\n18\tArgon\tAr\tNoble gas\t39.948\t1" +
	"5.7596\tVIIIA\n19\tPotassium (L. Kalium)\tK\tAlkali metal\t39.098\t4.3407\tIA\n2" +
	"0\tCalcium\tCa\tAlkaline-earth metal\t40.078\t6.1132\tIIA\n21\tScandium\tSc\tRar" +
	"e-earth metal\t44.956\t6.5615\tIIIB\n22\tTitanium\tTi\tTransition metal\t47.867\t" +
	"6.8281\tIVB\n23\tVanadium\tV\tTransition metal\t50.942\t6.7462\tVB\n24\tChromium" +
	"\tCr\tTransition metal\t51.996\t6.7665\tVIB\n25\tManganese\tMn\tTransition metal" +
	"\t54.938\t7.4340\tVIIB\n26\tIron  (L. Ferrum)\tFe\tTransition metal\t55.845\t7.9" +
	"025\tVIII\n27\tCobalt\tCo\tTransition metal\t58.933\t7.8810\tVIII\n28\tNickel\tN" +
	"i\tTransition metal\t58.693\t7.6399\tVIII\n29\tCopper (L. Cuprum)\tCu\tTransitio" +
	"n metal\t63.546\t7.7264\tIB\n30\tZinc\tZn\tTransition metal\t65.380\t9.3942\tIIB" +
	"\n31\tGallium\tGa\tTrivalent metal\t69.723\t5.9993\tIIIA\n32\tGermanium\tGe\tBri" +
	"ttle metalloid\t72.630\t7.8994\tIVA\n33\tArsenic\tAs\tMetallic element\t74.922\t" +
	"9.7886\tVA\n34\tSelenium\tSe\tNon-metallic element\t78.971\t9.7524\tVIA\n35\tBro" +
	"mine\tBr\tHalogen liquid\t79.904\t11.8138\tVIIA\n36\tKrypton\tKr\tNoble gas\t83." +
	"798\t13.9996\tVIIIA\n37\tRubidium\tRb\tAlkali metal\t85.468\t4.1771\tIA\n38\tStr" +
	"ontium\tSr\tAlkaline-earth metal\t87.62\t5.6949\tIIA\n39\tYttrium\tY\tRare-earth" +
	" metal\t88.906\t6.2173\tIIIB\n40\tZirconium\tZr\tMetallic element\t91.224\t6.634" +
	"1\tIVB\n41\tNiobium\tNb\tMetallic element\t92.906\t6.7589\tVB\n42\tMolybdenum\tM" +
	"o\tMetallic element\t95.95\t7.0924\tVIB\n43\tTechnetium\tTc\tArtificial metal\t9" +
	"7.00\t7.1194\tVIIB\n44\tRuthenium\tRu\tRare metal\t101.07\t7.3605\tVIII\n45\tRho" +
	"dium\tRh\tNoble metal\t102.91\t7.4589\tVIII\n46\tPalladium\tPd\tNoble metal\t106" +
	".42\t8.3369\tVIII\n47\tSilver (L. Argentum)\tAg\tNoble metal\t107.87\t7.5762\tIB" +
	"\n48\tCadmium\tCd\tMetallic element\t112.41\t8.9938\tIIB\n49\tIndium\tIn\tTrival" +
	"ent metal\t114.82\t5.7864\tIIIA\n50\tTin (L. Stannum)\tSn\tMetallic element\t118" +
	".71\t7.3439\tIVA\n51\tAntimony (L. Stibium)\tSb\tMetalloid element\t121.76\t8.60" +
	"84\tVA\n52\tTellurium\tTe\tSemimetallic element\t127.60\t9.0097\tVIA\n53\tIodine" +
	"\tI\tNonmetallic halogen element\t126.90\t10.4513\tVIIA\n54\tXenon\tXe\tNoble ga" +
	"s\t131.29\t12.1298\tVIIIA\n55\tCesium\tCs\tAlkali metal\t132.91\t3.8939\tIA\n56\t" +
	"Barium\tBa\tAlkaline-earth metal\t137.33\t5.2117\tIIA\n\t\t\t\t\t\t\n57\tLanthan" +
	"um\tLa\tRare-earth metal\t138.91\t5.5769\tIVB\n58\tCerium\tCe\tRare-earth metal\t" +
	"140.12\t5.5386\tVB\n59\tPraseodymium\tPr\tRare-earth metal\t140.91\t5.4702\tVIB\n" +
	"60\tNeodymium\tNd\tRare-earth metal\t144.24\t5.5250\tVIIB\n61\tPromethium\tPm\tA" +
	"rtificial metal\t145.00\t5.5770\tVIII\n62\tSamarium\tSm\tRare-earth metal\t150.3" +
	"6\t5.6437\tVIII\n63\tEuropium\tEu\tRare-earth metal\t151.96\t5.6704\tVIII\n64\tG" +
	"adolinium\tGd\tRare-earth metal\t157.25\t6.1498\tIB\n65\tTerbium\tTb\tRare-earth" +
	" metal\t158.93\t5.8638\tIIB\n66\tDysprosium\tDy\tRare-earth metal\t162.50\t5.939" +
	"1\tIIIA\n67\tHolmium\tHo\tRare-earth metal\t164.93\t6.0215\tIVA\n68\tErbium\tEr\t" +
	"Rare-earth metal\t167.26\t6.1077\tVA\n69\tThulium\tTm\tRare-earth metal\t168.93\t" +
	"6.1843\tVIA\n70\tYtterbium\tYb\tRare-earth metal\t173.05\t6.2542\tVIIA\n71\tLute" +
	"tium (Lutecium)\tLu\tRare-earth metal\t174.97\t5.4259\tVIIIA\n\t\t\t\t\t\t\n72\t" +
	"Hafnium\tHf\tTransition metal\t178.49\t6.8251\tIVB\n73\tTantalum\tTa\tTransition" +
	" metal\t180.95\t7.5496\tVB\n74\tTungsten (Wolfram)\tW\tTransition metal\t183.84\t" +
	"7.8641\tVIB\n75\tRhenium\tRe\tRare metallic element\t186.20\t7.8335\tVIIB\n76\tO" +
	"smium\tOs\tRare metallic element\t190.23\t8.4382\tVIII\n77\tIridium\tIr\tRare no" +
	"ble metal\t192.22\t8.9671\tVIII\n78\tPlatinum\tPt\tNoble metal\t195.08\t8.9588\t" +
	"VIII\n79\tGold (L. Aurum)\tAu\tNoble metal\t196.97\t9.2256\tIB\n80\tMercury (Hyd" +
	"ragyrum)\tHg\tLiquid metal\t200.59\t10.4375\tIIB\n81\tThallium\tTl\tTrivalent me" +
	"tal\t204.38\t6.1083\tIIIA\n82\tLead (L. Plumbum)\tPb\tMetallic element\t207.20\t" +
	"7.4167\tIVA\n83\tBismuth\tBi\tMetallic element\t208.98\t7.2855\tVA\n\t\t\t\t\t\t" +
	"\n84\tPolonium\tPo\tRadioactive metal\t209\t8.4140\tVIA\n85\tAstatine\tAt\tRadio" +
	"active halogen element\t210\t9.3175\tVIIA\n86\tRadon\tRn\tRadioactive noble gas\t" +
	"222\t10.7484\tVIIIA\n87\tFrancium\tFr\tRadioactive alkali metal\t223\t4.0727\tIA" +
	"\n88\tRadium\tRa\tRadioactive alkaline-earth metal\t226\t5.2784\tIIA\n89\tActini" +
	"um\tAc\tRadioactive element\t227\t5.3802\tIVB\n90\tThorium\tTh\tRadioactive meta" +
	"l\t232\t6.3067\tVB\n91\tProtactinium\tPa\tRadioactive metal\t231\t5.8900\tVIB\n9" +
	"2\tUranium\tU\tRadioactive metal\t238\t6.1941\tVIIB\n\t\t\t\t\t\t\n93\tNeptunium" +
	"\tNp\tArtificial radioactive metal\t237\t6.2655\tVIII\n94\tPlutonium\tPu\tArtifi" +
	"cial radioactive metal\t244\t6.0258\tVIII\n95\tAmericium\tAm\tArtificial radioac" +
	"tive metal\t243\t5.9738\tVIII\n96\tCurium\tCm\tArtificial radioactive metal\t247" +
	"\t5.9914\tIB\n97\tBerkelium\tBk\tArtificial radioactive metal\t247\t6.1978\tIIB\n" +
	"98\tCalifornium\tCf\tArtificial radioactive metal\t251\t6.2817\tIIIA\n99\tEinste" +
	"inium\tEs\tArtificial radioactive metal\t252\t6.3676\tIVA\n100\tFermium\tFm\tSho" +
	"rt-lived element T 1/2 ~ 20 hrs\t257\t6.50\tVA\n101\tMendelevium\tMd\tShort-live" +
	"d element T 1/2 ~ 1.5 hrs\t258\t6.58\tVIA\n102\tNobelium\tNo\tShort-lived elemen" +
	"t T 1/2 ~ 1.0 hrs\t259\t6.67\tVIIA\n103\tLawrencium\tLr\tShort-lived element T 1" +
	"/2 ~ 3 mins\t266\t4.97\tVIIIA\n";
	
	
	
	static String html_example1 = "";
	
	
	
	
	
	//  This random data can be used to test the mail program.
	
	//  The mail program should be able to distinguish between
	//  text files, image files, and binary data files.
	
	//  int size = 1*1024;
	//
	//  byte[] randbytes = new byte[size];
	//
	//  byte[] hash = Cipher.hash(new byte[32]);
	//
	//  for (int i = 0; i < randbytes.length / hash.length; i++)
	//  {
	//	hash = Cipher.hash(hash);
	//	
	//	for (int j = 0; j < 32; j++)
	//	
	//	    randbytes[hash.length*i + j] = hash[j];
	//  }
	//
	//  String randtext = Convert.byteArrayToBase64(randbytes);
	//
	//  System.out.println(randtext);
	
	
	
	// random byte array converted to base 64 and to string
	
	static String randtext = "    ";
	
	
	
	
	
	private class MouseListener extends MouseAdapter
	{
	
		private JPopupMenu popupmenu;
		
		private JTextComponent comp;
		
		public MouseListener(JTextComponent comp)
		{
			this.comp = comp;
			
			popupmenu = new JPopupMenu();
			
			JMenuItem menuitem;
			
			menuitem = new JMenuItem(__.copy);
			
			menuitem.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					Clipboard cb = Toolkit .getDefaultToolkit() .getSystemClipboard();
					
					if (comp .getSelectedText() != null)
					
					     cb.setContents(new StringSelection(comp.getSelectedText()), null);
					else cb.setContents(new StringSelection(comp        .getText()), null);
				}
			});
			
			popupmenu.add(menuitem);
			
			//  popupmenu.addSeparator();
		}
		
		
		public void mousePressed(MouseEvent e)
		{
			if (e.getButton() != MouseEvent.BUTTON1)
			{
				popupmenu.show(comp, e.getX(), e.getY());
			}
		}
	}
	
	
	
	
	
	private class MouseWheelListener1 implements MouseWheelListener
	{
	
		private JDialog dialog;
		
		private JTextArea textarea;
		
		private Font font;
		
		private KeyListener keylistener;
		
		
		private class KeyListener extends KeyAdapter
		{
			private boolean shift, control;
			
			public void keyPressed(KeyEvent e)
			{
				int keycode = e.getKeyCode();
				
				if (keycode == KeyEvent.VK_SHIFT) shift = true;
				if (keycode == KeyEvent.VK_CONTROL) control = true;
			}
			
			public void keyReleased(KeyEvent e)
			{
				int keycode = e.getKeyCode();
				
				if (keycode == KeyEvent.VK_SHIFT) shift = false;
				if (keycode == KeyEvent.VK_CONTROL) control = false;
			}
		};
		
		
		public MouseWheelListener1(JDialog dialog, JTextArea textarea)
		{
			this.dialog = dialog;
			
			this.textarea = textarea;
			
			this.font = textarea.getFont();
			
			keylistener = new KeyListener();
			
			this.textarea.addKeyListener(keylistener);
		}
		
		
		public void mouseWheelMoved(MouseWheelEvent e)
		{
			//  Increase or decrease the font size
			
			int rotation = e.getWheelRotation();
			
			Font font = this.font;
			
			float fontsize = font.getSize();
			
			if (keylistener.control)
			{
				if (rotation > 0) fontsize = fontsize + 1;
				if (rotation < 0) fontsize = fontsize - 1;
			}
			
			float maxsize = 48;
			
			if (fontsize > maxsize) fontsize = maxsize;
			
			if (fontsize <= 0) fontsize = 1;
			
			//  If the user spins the mouse wheel at high speed
			//  and the font is at the maximum size, return
			//  without repainting the text area
			
			if (fontsize == this.font.getSize()) return;
			
			//  Change the font size
			
			this.font = this.font.deriveFont(fontsize);
			
			textarea.setFont(this.font);
			
			dialog.setSize(dialog.getPreferredSize());
		}
	}
	
	
	
	
	private static ArrayList<JTextComponent> textcomps = new ArrayList<JTextComponent>();
	
	private static ArrayList<String> documents = new ArrayList<String>();
	private static ArrayList<JDialog> dialogs  = new ArrayList<JDialog>();
	
	public static void display(
	
	    Window window, String title, final String document,
	
		Font font, Color foreground, Color background)
	{
		//  Displays a document in a JDialog frame
		
		//  The window can be set to null so the attached files appear
		//  in the upper left corner of the user's screen instead of
		//  on top of the user's email frame which would obstruct the
		//  view of the email messages.
		
		for (String str : documents)
		
		    if (str.equals(document))
		
			{ delete(document); return; }
		
		JTextArea textarea;
		
		JScrollPane scrollpane;
		
		int rows = 32, cols = 44;
		
		//  If any line contains more than max line chars set
		//  the line wrap to true. Otherwise the horizontal
		//  scroll bar would become very small and difficult
		//  to scroll because for some text documents (such
		//  as the GPL) each paragraph is only one line.
		
		int maxlinechars = 160;
		
		boolean linewrap = false;
		
		char[] charray = document.toCharArray();
		
		int j = 0, linechars = 0;
		
		for (int i = 0; i < charray.length; i++)
		{
			if (charray[i] == '\n')
			{
				int linesize = i - j;
				
				if (linesize > maxlinechars)
				
				    { linewrap = true;  break; }
				
				else j = i;
				
				if (linesize > linechars)
				
				    linechars = linesize;
			}
		}
		
		//  if there are no newline
		//  chars set wrap = true
		
		if (j == 0) linewrap = true;
		
		else if (!linewrap)
		
		    cols = linechars;
		
		int maxcols = 64;
		
		if (cols > maxcols)
		    cols = maxcols;
		
		
		float maxfontsize = 40;
		
		if (font != null)
		{
			float fontsize = Math.min(
			
			    font.getSize(), (int) maxfontsize);
			
			font = font.deriveFont(fontsize);
		}
		
		
		textarea = new JTextArea();
		
		textarea.setLineWrap(linewrap);
		textarea.setWrapStyleWord(linewrap);
		textarea.setEditable(false);
		
		textarea.setFont(font);
		
		textarea.setText(document);
		textarea.setCaretPosition(0);
		
		if (foreground != null) textarea.setForeground(foreground);
		if (background != null) textarea.setBackground(background);
		
		textarea.addMouseListener(new Documents()
		
		    .new MouseListener(textarea));
		
		scrollpane = new JScrollPane(textarea,
		
		    JScrollPane.  VERTICAL_SCROLLBAR_ALWAYS,
		    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		
		if (!linewrap) textarea.setSize(rows, cols);
		
		
		//  Create a dialog
		
		JDialog dialog = new JDialog(window);
		
		KeyAdapter closelistener = new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				if ((e.getKeyCode() == KeyEvent.VK_ESCAPE)
				
				 || (e.getKeyChar() == '\n'))
				
				    delete(document);
			}
		};
		
		
		dialog.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				delete(document);
			}
		});
		
		
		textarea.addKeyListener(closelistener);
		
		dialog.setDefaultCloseOperation(
		
		    JDialog.DISPOSE_ON_CLOSE);
		
		dialog.add(scrollpane);
		
		dialog.setTitle(title);
		
		
		
		int xpos = 0, ypos = 0;
		
		if (window != null)
		{
			xpos = window.getX();
			ypos = window.getY();
		}
		
		dialog.setLocation(xpos, ypos);
		
		//  Read the screen size
		
		Toolkit tk = Toolkit.getDefaultToolkit();
		
		Dimension d = tk.getScreenSize();
		
		int scale = 45;
		
		dialog.setSize((d.width *scale/100),
		               (d.height*scale/100));
		
		dialog.setVisible(true);
		
		dialog.setResizable(true);
		
		dialogs.add(dialog);
		
		documents.add(document);
		
		textcomps.add(textarea);
	}
	
	
	
	
	public static String displayHTML(
	
	    Window window, String title, String html,
	
		Font font, Color foreground, Color background)
	{
		for (String str : documents)
		
		    if (str.equals(html))
		
			{ delete(html); return ""; }
		
		JEditorPane editorpane = new JEditorPane();
		
		JScrollPane scrollpane = new JScrollPane(editorpane,
		
		    JScrollPane.  VERTICAL_SCROLLBAR_ALWAYS,
		    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		
		final String[] html1 = new String[] { html };
		
		
		//  Set the content type to text/html instead of text/plain
		
		String doctype1 = "text/plain";
		String doctype2 = "text/html";
		
		editorpane.setContentType(doctype2);
		
		editorpane.setEditorKit(new HTMLEditorKit());
		
		
		//  Read the screen size
		
		Toolkit tk = Toolkit.getDefaultToolkit();
		
		Dimension d = tk.getScreenSize();
		
		
		//  Set the size of the HTML editor pane
		
		int  width = d.width  * 30/100;
		int height = d.height * 60/100;
		
		//  Without the preferred size the editor pane will not wrap the text
		
		editorpane.setPreferredSize(new Dimension(width, height));
		editorpane.setMinimumSize  (new Dimension(width, height));
		
		editorpane.setEditable(false);
		editorpane.setContentType("text/html");
		editorpane.setFont(new Font(
		    "monospaced", Font.PLAIN, 20));
		
		editorpane.addMouseListener(new Documents()
		    .new MouseListener(editorpane));
		
		editorpane.getDocument().putProperty(
		
		    "IgnoreCharsetDirective", true);
		
		editorpane.setText(html);
		
		
		JButton text_htmlbutton = new JButton("TEXT / HTML");
		
		Box vbox = Box.createVerticalBox();
		
		vbox.add(scrollpane);
		
		
		//  Create a horizontal box for the button
		
		Box hbox = Box.createHorizontalBox();
		
		hbox .add(text_htmlbutton);
		
		vbox.add(hbox);
		
		
		text_htmlbutton.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				String contenttype = editorpane.getContentType();
				
				if (contenttype == doctype1)
				{
					html1[0] = editorpane.getText();
					
					editorpane.setContentType(doctype2);
				}
				
				else if (contenttype == doctype2)
				
				    editorpane.setContentType(doctype1);
				
				editorpane.getDocument() .putProperty(
				
				    "IgnoreCharsetDirective", true);
				
				editorpane.setText(html1[0]);
				editorpane.setCaretPosition(0);
				
				if (editorpane.getContentType() == doctype1)
				{
					editorpane.setEditable(true);
					editorpane.requestFocusInWindow();
					
					if ((foreground != null) && (background != null))
					{
						editorpane.setForeground(foreground);
						editorpane.setBackground(background);
					}
				}
				
				else
				{	editorpane.setEditable(false);
					
					editorpane.setForeground(Color.black);
					editorpane.setBackground(Color.white);
				}
			}
		});
		
		
		//  Create a dialog
		
		JDialog dialog = new JDialog(window);
		
		KeyAdapter closelistener = new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				if ((e.getKeyCode() == KeyEvent.VK_ESCAPE)
				
				 || (e.getKeyChar() == '\n'))
				
					delete(html);
			}
		};
		
		
		dialog.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				delete(html);
			}
		});
		
		
		editorpane.setCaretPosition(0);
		
		editorpane.addKeyListener(closelistener);
		
		editorpane.addHyperlinkListener(new Hyperactive());
		
		dialog.setDefaultCloseOperation(
		
		    JDialog.DISPOSE_ON_CLOSE);
		
		dialog.add(vbox);
		
		dialog.setTitle(title);
		
		
		int xpos = 0, ypos = 0;
		
		if (window != null)
		{
			xpos = window.getX();
			ypos = window.getY();
		}
		
		dialog.setLocation(xpos, ypos);
		
		Dimension size = dialog.getPreferredSize();
		
		int x = (int) size.getWidth();
		int y = (int) size.getHeight();
		
		double multiply_x = 0.40;
		double multiply_y = 0.60;
		
		if (x > (int) (d.getWidth()*multiply_x))
		    x = (int) (d.getWidth()*multiply_x);
		
		if (y > (int) (d.getHeight()*multiply_y))
		    y = (int) (d.getHeight()*multiply_y);
		
		size = new Dimension(x, y);
		
		dialog.setSize(size);
		
		dialog.setVisible(true);
		
		documents.add(html);
		
		textcomps.add(editorpane);
		
		return html1[0];
	}
	
	
	private static void delete(String document)
	{
		for (int i = 0; i < documents.size(); i++)
		
		if (documents.get(i).equals(document))
		{
			documents.remove(i);
			
			textcomps.remove(i);
			
			dialogs.remove(i).dispose();
		}
	}
	
	
	public static void setFont(Font font)
	{
		for (JTextComponent textcomp : textcomps)
		
		    textcomp.setFont(font);
	}
	
	public static void setForeground(Color foreground)
	{
		for (JTextComponent textcomp : textcomps)
		{
			if (textcomp instanceof JTextArea)
			
			    ((JTextArea) textcomp).setForeground(foreground);
			
			if (textcomp instanceof JEditorPane)
			
			    ((JEditorPane) textcomp).setForeground(foreground);
		}
	}
	
	public static void setBackground(Color background)
	{
		for (JTextComponent textcomp : textcomps)
		{
			if (textcomp instanceof JTextArea)
			
			    ((JTextArea) textcomp).setBackground(background);
			
			if (textcomp instanceof JEditorPane)
			
			    ((JEditorPane) textcomp).setBackground(background);
		}
	}
}


//  End class Documents













class Icons
{


	//  These images were converted from bytes to base 64
	//
	//  String filepath = "/usr/share/icons/.../filename.png";
	//
	//  File file = new File(filepath);
	//
	//  byte[] bytes = DataStream.read(file);
	//
	//  String str = Convert.byteArrayToBase64(bytes);
	//
	//  System.out.println(str);
	
	
	
	
	public static ImageIcon get(String imagetext)
	{
		//  if (image text is compressed) decompress
		
		//  ...  ...
		
		return new ImageIcon(Convert
		
		    .base64ToByteArray(imagetext));
	}
	
	
	
	//  16 x 16  ~ 1 KB  menu icons
	
	
	//  Note that images that are 16x16 do not specify the size
	//
	//  Icons that are larger than 16x16 such as 24x24, 32x32, 48x48, ...
	//  end with an underscore character followed by the size
	
	
	
	static String new_ = // (new is a keyword)
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAAlxJREFUOI2Fk81vjFEU" +
	"xn/nfd/ptEWNIa1pKwgSC5suSLCrhdggsbDxD/iIxM6GpaVFE0QkFhZWaGnSlYSdBYLamGDho6aDTs10" +
	"OjPv3I9jMe98JJU4uefem5s8z3nuc++R2bnpYyJy2zm/DRRVRRVAAeogT713UycO3i8A24EFYD4cnlEA" +
	"ZmYffF8q/Vbv/ZpsNmMtFD5q/t0VU/l66kfpw9764tvReuPbkZu2eGJUVYniOB7blMlSXa3inME6i3MW" +
	"ay2qStrOsWvrfBTXvuR04BCD60eprTw6O5TdE7ufJy9FxliAHrBrpfeILxA1n1Cp5fG+QWb3Y0TSFBZu" +
	"UFv5c15EipExBmAN2HtHmkXilTdsnViiN8YOFIFU6tPzwauBNQbQBGzx3iXpUfWkB3Is5Y8BvsvgyxTf" +
	"HyXdn30dGGNQSNxXFBCEQATLCP2Zw9TLr3CNz6BVcEVMfZ7a8kuX2zFxOWh70A5pTyJYHaHu99FsrBL2" +
	"76H87Rrl79dJrZuk2ax7CcIXkbEmgbZqt0ZAGAhhEFLXSfrW7+fTsyHWbRwjjj2L+SkjQfpRODzjOyZC" +
	"QBAoirRUJDOSgfH7ZMYXyA557t576DcMxtnTZ6aqAJExBgGCIOiARNoU0uVhJ5Lewpcfs+pdaE8nZZN/" +
	"IERRCJqApUdFm0AFEcEag3Ou41lkkyuEYdSpLkhXRbJqq0EwxuBc90k7HoRB2AL3Zo+CVm/9g0BECsvL" +
	"pVw2u5n/RaVSBqRkrInbZ3Lh4rnjUSq6ZZrNEVVQFJKW7t2Dkkr1/TLGnLt96850m+AvJs5tnjST/VQA" +
	"AAAASUVORK5CYII=";
	
	
	static String open =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAG7SURBVDiNpZNN" +
	"alRREIW/uu/2e2lMlCidXoMYFVyBOBTX4EQQBcWBDuwFSIuRZKQOHHVWIOISxEwdxZ8FBIyQDOx+793f" +
	"chDthA7dk5xRFZdz6tThlqgqZ4E5ExuwAJtbGx9CDLdPPhTGODHy3rd5OBgMfs8TEFXl1cbw4PGjJ6vG" +
	"HBvy3vPt+67/svP5j3fhlFNj5NOzp8/v2qOmGIvIal1Pjh0UBetX1strV69fmiXnnHn77s3N6QqFNRNV" +
	"ZbQ94tf+PvAv2Jl8FaXf7/Pg/kOsNeOpQMd2xqqKAsMXL+cGBrC59RpVxVo7mQqUZTlRVfprawA416Kq" +
	"qGZy1mm9snKBXq+HqlJVS2MAuXFve2+poxeXu93KB09VVuicFUQE5xxlWTJpGtcGObA5Ju7cuqznlytK" +
	"A+e6JZUtqEpLVVqMCC5mfEj4pNStJ2ZhXDtGH79iUwzsHfp8OFEUxRjHvN8pIqSUMGJofEgpBmwKgbrx" +
	"qimDCCKyUEBzBqDxUVOK2JQjdRM1nxBYBM0KKK3PmmLAxhipW0fOxf8xM4xTBQCtT8QYsTlFfuz+dNYW" +
	"CyfPIsbkcspHt3AW/AUFsPYztGLNkQAAAABJRU5ErkJggg==";
	
	
	static String save =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAA9lBMVEX///9OmwZMmAVNmQROmAROmgVO" +
	"mgZOmgZOmgZOmwZOmgZOmQZPmQZOmgZOmQZOmgZQmwhPnAcuNDYxPzFATD9FfRNOmgZYWlZaqA9aqRBt" +
	"vh1twB5vcW1yxSF1uDZ4zSd6uzx70CmChYaGiYOIioWJ4DOK4jSM4TiNj4uQko2X2lec2mCc5lOdoJqd" +
	"51af51if51mkpqGu33+u4nu1uLG5ure6vba66Y276o6/wbvH8Z/NzsrQ0c7Q863Q867T1NDh4d/i4+Dj" +
	"5uLk5eLl5uTp6+fr7Ort7ezv8O3v8O/x8vH09fP19vT29/X5+vj7+/r+/v7///+SYRA1AAAAEnRSTlMA" +
	"Li88Pr7FyMrLzM7T193h7fBljohdAAAAiklEQVR42qXIQwIDQRAAwF7Gtm3bttP/f0ywnDlvHQtknF3k" +
	"geTsJkxUBJfFoKFgHZZ/uKy8EubeKLkspsc1QQlbtT1dFJv1lKgE74mVWsVC1M2AZJL1ByKZTDjg8w6l" +
	"WOHj/no/b+fDti9F57JbI+Jpttk3pMgdN/NBJV+ebY45KeJXTVyKEAHgC8pvFhDBKb9BAAAAAElFTkSu" +
	"QmCC";
	
	
	static String saveas =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACn0lEQVR42nSSQ4NkMRzEh5e1v8Xatm3b" +
	"tm3b5ti27Zl2j222XZvk0O5DnPz+VfWe08KFC22al4tLzT8nJ5g3TxeXZnt37QI8nJ215WvXonLDBmOj" +
	"EIeA6PjwebHxEfy4xCjQ5uHmBsGsWRBOn25sFODj54E/Hj/x7cfnjjcf3swzAujjHmlPrMFgECiVSni6" +
	"u4M3bx44U6eCM2UKuDNnMkBDQwP4fD7iE+Lw6OkDvhEQEx8BAAKf/v276EXffv3AWbYMhRMnslYyfz58" +
	"+/ZlEO8hQ1BcXIwbt67CGlDzz9kZ/P37ITpyBIVz5yJ33DjWCmbMAG/HDnA3bWIQDoeDs+dP2wBao5ct" +
	"6wkYNgx5K1Ygf/FiZIwZg4zRo5FLYNlEhT+pHkJGauPQkf0mQFCoHwB0FRQUGCLOnYVX795InT0bBST9" +
	"/FWrkEYy8CZ7oUcOIyoqEgKBANt3bjUB/nn+AglQ5un5lx0WBQbCe/BgRI8YgThiwWfgQGT8+IGcnBx4" +
	"kDtCoRCbtmwwAT59fU8BKg/PP9Qfk5ibmIhA8jiQQFJCQpCfn4/y8nIkJiVCLBZj89aNJsDzl0+g1+t1" +
	"2dlZaG1rZZ9LJBIxEFVUWVmJjo4OdHV1ITk5GRUVFdiybZMJcPveTeh0OmRnZ7NKjY2NkEql0Gq1rMlk" +
	"MtTX1yMjI4MBamtrsW3HFhPg8tULUKvV+Pr1K7KyspjX3NxcFBUVMSVVVVVMCd378uULWltbLRWcPXcK" +
	"DY0NNAdWkaohlowKNBoNyB/KVEkkEpbB+o1rTYB9B/c2vXv3BiWcErx6/Qr37t/DtevXcf7SRZy5cAGH" +
	"jx3H9j17sXbjZqzesAnLVq/B2g2ry42A/wsNDfQIDQ96BDKVGBwcGvggLCwYnJkAcY1ibxnpYwcAAAAA" +
	"SUVORK5CYII=";
	
	
	
	static String rename =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/" +
	"oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9cMGBEYOVNIzVAAAAI0SURBVDjLjZJdSJNx" +
	"FMZ/75y1uXrLad1k9oFCFCQGGZGQF2YX4VVBQm43XUlXEYi5C1c5mzMDMyJIpQ9D7yoqIQiLwo+bqWFU" +
	"YqYkEcL2boa6j9fX04VMtLbsd/Xn8H/O4XnOUbw+Tx0i7p2BQXKDA1j0WWLmzczacpnOKiJs2w3grql2" +
	"XSEJZsDtzIsTiU2TU3EVs5qNsRBifnKEmffP2bC1iGcL+W4gaQMTskTwzT1yTpzh56s2Pl53MHG/Dj34" +
	"nb2nz6PaDYon7uB3UP6neMjBcZPZiCPRMCZdIzg+xpGHOpGTzczGtjP2qAWzEmf/qTIsGbYnfgcXV4sR" +
	"3pqW0swYxiLxmTF0XWejTaXjxQBZFTfYVvWUHx8mCH8ZZk9JQZpVtd0cOkfLcCUl6bYtPQCK1+cRZ77B" +
	"TE8z7SNxSl2PsW3KwD/kByB9cYHCqU522efZUZDH1OAnojGFA66XjF4uBq/PIyIira23BBBAErUES/Go" +
	"fLt9VsYvZUq0+6jonzvFeHdBhioRU8JTe3sH3d1daFpgJaRQKEgoFCQ8N4flcAWRCKQdrEIZf4AER1fW" +
	"CEBv72tSUbovm7vlKoXuHkyTXYgRW3MHAGRmZiUVR7/20VYGxH4te052SI1NDe5U0y15xzjUufxWFIX6" +
	"+mvU1rpobGqgptqlJBUlQtS0gGhaQADRtID09/eJqqoiIuL1eWSNhfWw27OxWq04nY6/LKzL6s0kyyAl" +
	"qYL9nwb/DDbxB+A3QNIFNj+7Er8AAAAASUVORK5CYII=";
	
	
	
	static String delete =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7O" +
	"HOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAlwSFlzAAAN1gAA" +
	"DdYBkG95nAAAAAl2cEFnAAAAEAAAABAAXMatwwAAAAZiS0dEAP8A/wD/oL2nkwAABmpJREFUGBnFwftX" +
	"znkCwPH35/t8n3ouPUk3pBsppaFOKUpMMquhYaNhNZiZXAfLGIvYOHPG5WAYl+ZkrZwz47LsGDPnIOzR" +
	"McyOy7oM0qQQSh7ddHlSz9NTz/f73fbwB8xv+3rx/yZ44/0MKY4eqkO9DRS4fW76A+gyzHbvxyCGSrHS" +
	"Bf4ngy30UHdqlfTQBmrr6KGtZBI9tBg1kh7aamUsPdS7rlTQSlV310lQzogDIgtYciS/9V16iF27srMl" +
	"CYrDjh1TVX5K181Svf82YaZXln+9vy6vUHEoGV1f6Z+xSHtH608r1VzS9gI+tHIYsGCjFIjXyrW9QL3w" +
	"oxm0VdpYrRdeIlf01S3qDn61rKWi2bp5/tXSE4W2knP/GPk480tJIk3WHZSvqHck/TjnNCvlE55H9Ute" +
	"kXF078RwNa5sfFlwhrW8YugvmeD6tqu00w30KfqdbjHgftu9wm07yAZ5jc4AbkX6U25FoJ9n3GwZDcYr" +
	"feYNewzqVFeh819w57Piwwf0+yZ2//iecoHFz+WlcrxIO6eXlfWuFdL28X+PTk59O9tnz/cxq9LyPvYL" +
	"PtWQVj7yfB7Uja4o+9kLuno7nY4VYPA2XjPpQP5MnyUXgnxTzpBOgvGv5gWWMDDlek72PwU+/l5zwlPA" +
	"EG2x+mZAf2uEGv9J8AFXoxLhGLRnatXp0iNXB7tdkgPMEfeSrh4cNGz82LK5P/sfsy9uKax5AH3bBgUl" +
	"VoPv8hCGPQNtkHhf9yk8+7U+ptYdrqwvSbr+BNon2Td0jAPpi1cjpYkgpI7V+IJke5lztgh07+gNxnJQ" +
	"bnQ120vAsESfGZgadkSK6j08MKwwV341+2Xis0X+o0uGXBheuByGhiXtnFwHhgdYO1KBRDnfdQvqbE3t" +
	"Dd/Cb+Yaqf4QBJ6IePJeIdhPt4vOfBAW0SQugrRPmiY8QMSKJBEJ4k+iTEwDo2KsNOWDZaxnrf4Rpmun" +
	"mk/UL/P5Wm6vbE57fn5KwsOIa47vK+ZdDLoV/lXcsgwP/W/9OwYZQVwRA7WtUH+5vbixGByHVA/3XGhq" +
	"fupbuxGeapWllZfBkGIYbBgO8km5t7wU5E1ykXwHpGLdeekwmGXzYdMMSKpONo3wAnVv75MhI0CX3mfo" +
	"S6mq4oXWyiH1fGVl/ciqUSVifHH9D5V7buR6TXpquj34jA9UdzwquGmC2m3dCbIJYj6MXRx7HyJ7DRkT" +
	"uA1CQwd297kOwdGhN/0eQWB30Kfe+dBvVP+r3nfAb5/fOs+v4eXDpqjqn3A88H5w+UZOyweCN+Zmh9lB" +
	"tiSHpx/pF39l7fABIz8Y9ypxrWuK7USVL7hSta1sgeLrVWvafMCyLdIa3gYe0yz+9lHQUdWx2l4Lrre6" +
	"Q9y9wNXUnS8Fgo22qS2LoTPH/rkWB7ZMW4oyh4vNx5tnNZVsaJB5o3Z3x4cg+ohbkkvaL9ab13nm9p7L" +
	"WvFnfaBzIcjB0kapFfont4VIMaDL8X7m8Q0ETAgYZowFNUNJCK0Bc5nRELMbtHY1gdXw4mxdyq+fQMM3" +
	"jfca8qBq+xOlfSt1jX9pXNm46G6dzGur7s5qfgWGeVmTRbkuSrfDtNK7KKgV5BT1nPdpkG26Q7oScHtY" +
	"f1r1AW0n+XIamGoNRcGLwbDRvTGmBOq/aLz/nxfQfb0rx1UKljCPGQG+4HzqfFubD+bp5lVKKKgx6gE1" +
	"CWReaxBj9D+Aa0dnjWO+3Xn32q0xl6POZkfOEjO4pqWLUskmnGI/+6r9G0rb7uk3hXWGZCavkM8oC9XV" +
	"9iqwF9h/qRRgfOxe6H8fvLf0CgqshZbo1rjqC9C91DXbOQBYxBpxDFCwkQ4yrx0Mmhne1OufjjybT2uL" +
	"vWBV3MOHZzdcat8R+9LVoSPVFNAa0dYP9Af1k6LzA47njA6ZkhJC6AK4h14Zw1N7WWd2zQYGaJHqWx67" +
	"QQlWd4kb0DS3ueDBPaBIPckyzimBip/q4iMSOEqe2CD4nT5aujBxcCrYklu9nGdm+kQ9jhwSmb23M2B4" +
	"wJe+5z3b1enqGaWY44pJXaHtQ1E2K57aAlDnKvPUPpi6JncFK4f4Y83lmqPWJzXfWQ3WdOuE2fGC3ylz" +
	"//SikAvgetfVreV7XReJ0hK1K+Gwalbj1E2WfsQTRphmZDkfixEg5oiVRAJZZBENoq8YIP4t4kWDKBDH" +
	"G6c6HY5d2rDb9v8CPvG3QEV9ookAAAAASUVORK5CYII=";
	
	
	
	static String print =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/" +
	"oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9kFExMhCgGDcZIAAAH5SURBVDjLpVJNaxNR" +
	"FD0v82YmBANthJYxDIg/oKKgriSkWahYAlbM4MpFNyIuUkbML2gxrakVRdzoxo0N2oUUuumXLiv40UXd" +
	"qC2EIW21oW0kM/NmptdFa5toUwJeuIv37uHce889jIjwP8GbFR4+KpiOKwwA4JI0ZvbfLRyECzUjcFxh" +
	"XLxwCWdOn4UfBEYzHPt7hQej918LT/QeBFZkZbw/e+dqwycRNeS9oQFqFru1BjzPDw+GGWN9siznhBD6" +
	"H+Lqr2pDo+iRKAAgPzxIiqKUPM/LE9Ezzhjr6+o6WUgmUurN27dgWRamZ981VT0ej+Pp4yf67NvpwsLC" +
	"Z3CZy7lkIqV6nouv377DyGT2wL7vY/cKAGMAgLFiEZ7nIplIqV8WF3NceEJXVRXrlTXYtsDS0jJWVldh" +
	"2zbqBZYkCZxz2LbAVnUTxzQdwhM63z+bg9jRGKZm5g41TmdnBxzX+ddIjrAxOjLQkvs+Lo/jxPHcPkHN" +
	"rmFmag7lchnbRAABhDp/1L1DjEHTNNTO1XaMlL6S3gqHw9H2WDtibW0wrl0/tHvx1Uv8WN/A5kYFjuNU" +
	"2fnu7ufpnss3QEFI0zpaWqG8sgZA2n4zMfECRISsac5bVokqlZ8tpWWVKGua80S0o8H7D58me3ozp4Ig" +
	"4K1MIEmSH4lEJgHgNz8dJSS6U816AAAAAElFTkSuQmCC";
	
	
	static String close =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJHSURBVDiNpVNB" +
	"T+JAGH1TupCWthiDu4uU5cDeTIxHL2tbvHHgtAd/Ys+9ERNt9eSBxJAYTx5AWLYijbRYLJ3p7MGFiAcv" +
	"fqfJ9958+d57M4Rzjs+UuDq4liXmZjMbhIBp2ol5fk7fEl3LEnNhaAPYwIUVSKZTR65WW3K12iLTqeNa" +
	"1sZwEgROUddbsq63SBCscREA+GRiK7WaWTs+lkAIBp2OOe/3Hdey2gCAhwenWK+berMpgXMMOh0zur+3" +
	"AfwWASCjFNlyiWyxQBaG0A1DGpyemtFw6ACAquumbhgS9X0ImvbKZQwAQDjncAkR00bDUSsVs95sSlkU" +
	"QdA03HveMwDUDKOYRREERcHg7CwOx2Pvy91d2+ScklUKLiFiUq87aqVi/Dg6krP5HDlVBQCwMISgqhhc" +
	"XMTReOwV+v22yTldb7A2ixBxoeuOtrv7q3p4qID+D0IUMbq6moej0aU0HK4vb8S4KkYp6HIJulgAWfba" +
	"TFPQJAGj9D0dGxLCnR1HLpeN6sGBnCUJcpL0OvTlBUI+j9H1dRw/PnraZLIpwSVEfNreduStLeP7/r7M" +
	"l0uQfB4PNzdzAPi6t6esen97vTh+evK2gqBtck4FAAhKJTtfLBrlRkNOZzMwSjHsduOZ71/OfP9y2O3G" +
	"jFKkYYhyoyHni0UjKJXstQeMMbA0RRrHAIDJ7W38EkVe+fm5DQCPjDl/ej1j5+dPGZwjS1Ow9+/ALxSc" +
	"gqIYAJDM5963JFnr/AjfMHGcy9kAUGHs5G1UH+Hks9/5H7T3XUu6f4WCAAAAAElFTkSuQmCC";
	
	
	static String quit =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/" +
	"oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9gHDBMvHNIyLkEAAAILSURBVDjLnZO9S1tR" +
	"GIef81FNci9StA1CFEqhi0M3Owii4NLVUXTqUpFaxNGl9A/oWCRbByu4uEjBobZTESzJEkiGILEkapMW" +
	"kmJubvTe5HZI7jFRl/bAy/mA93l/78eBzvoFBP9qQoiy6AKCnZ0dCoUCjuPgui7NZpPLy0s8z8P3fWq1" +
	"Gul0GiEEQnTcSqUSugvAsiwikQjtdhsAIQRSSrTWeJ5nzqFzuMsQYNs2D9bWGD4+xrZtbNvGsixisRjR" +
	"aBQpJUoplFJorVFKAVwrCIkje3voyUmqs7PGSUpJEAR3K9iCYAsozswA8GxlhYe5HCPb29wDE63XtNZo" +
	"ra8VTG9sYNbVFU/n58kfHKCSSUqLi3g9ECmliW4AvutycXhoHpVl8Xhqikgmg9zc5MfCgokcdqGviK1G" +
	"g3YQGPPqderZLKMTE8QTCR4lk7fk9xXRazRoddsHIAcG0PE4p6kUlWKRs+VlpOP0pRAq6KTgOAyMjxtA" +
	"4PucpFJUXZff6+v4g4OofN4AeuugATK7u8b5ydwcxUwGd2yMi9VV2q0W1fNzyuXynQD5+e1zsQQkvn4B" +
	"oHB0xNX0NK3Xr/hZLfE99YlMdh/UKfdHnD4D0B/e7HdI3ZmUL19wMhqQ+/YOt/kHoQXDcWlG+2YXzCQ2" +
	"mmUq75fIFz7SPvOIDgmiQ9yavJt7eKn8z3eWUlb+AtlD1+xaXVvgAAAAAElFTkSuQmCC";
	
	
	
	static String add_24x24 =
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACYklEQVR42uySA5MYQRCFY9u2bds627Zt" +
	"27Zt27bt+xnR4WWmsrGOxWzVt6N+/XqwAMC88t9gbgxuK8VbXJONGbsiEw3a0vGcGlwlSRMrhpFeMwrH" +
	"hFZclo4cm1MDWnlS5TCMQutgG9uMC+JhmFODS5IRiCzsh4pnOQyCanBeNHhuDWjFgVldELUrhLJHGc4K" +
	"Bczc4KpMtMVlqcixixLh5ChCcV4sBLflot65JbWC3SgDYrYFuCgS9O4Unw9O8nrjBI8XTnB7jJ3i8bSY" +
	"ksFFyfAxy4h6OMY1UeAQ2wjb6EbIOBbioVoiXuqkwiS4BtaR9bAi0Fgdv3IcZXcZm5LBedEQGAZV47Zi" +
	"HG4qxOGGfCyuyUWDXjR5TaQfg+tkjq7dUownJOCNQQYOszhhSgZnhQPHnpMqqYjF8DOshpl4pp2GO6pJ" +
	"eK6TDg6TbHCa5lDAZZYLFqNMHHptP7UdnBbytzjN7zv27Yw9cZrP9515ZBOe6maAz6oQJ7g83h0iFR96" +
	"44CDr+1x8JXd2BEWx6ndAfkWEhZ9z1EOV7gkd4DFtACiTmU4SBL/HEN1/zRgApcQVhBWEVZTDrM6wzOj" +
	"B9y2ZZDxrMaBV3b4ssbErWB0i/5lsJgRbCZsJ+wk7KEV++YOQti1Gsr+TWAM9jDr22k8o1s8dQMmOeHY" +
	"gdf2427pfdAIbYOCbwPomM5/M5m6wUJmqysJawgbCQf2P9QMoUlp5bSlYzrPrK+h8Yxu4ZQvmdnNMsIm" +
	"whHCOcJFwnlmvIlZXzzlS/4ZKmSSrCV8mgDUUEEonw0kT1lhh+kjZmQXj4w6GQAZUmedruV5hwAAAABJ" +
	"RU5ErkJggg=";
	
	
	static String undo =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxl" +
	"AE9wdGljYWwgRHJpdmU+Z7oMAAAB2klEQVQ4jaWTP2hTcRDHP7/XlIiSDBbF1GKsSKhLxUWXFAq6pNDF" +
	"QRRRCTwUzeBSOrgkWRRKi/8oRVtqBwVB6FSQ1ApigtFMmiItTYJpEmpIUi1ioMl7eeciDtKGQL5wcMN9" +
	"P3cHd0pEaEdaW27A9i8LKy12lPsKhgUmvNdksiWCiCAhtOgcs5n4LWkYvyU2R05EaCVshJUWPcKMy3Pd" +
	"33vmIZmPAUyL562uoJaeMO3yXNT7vJOsxgJsrL1sVm8BC0qYOnuDCIioxWmnDF7+AGaKRm2taTfLMinl" +
	"khTScX5t5paHApxU8w+Y7Xaf9vcP3iH57i7fs4ldAZ12O93uXtyePr7Eo2xVNn225Ba6YSSo1Uf8pwau" +
	"Uqv/oJhNP7owKrf/B8yPqZ7U19Wxeq106dBhO+UiN7VgUKyVKnohlX72afExDkcnhsnwThOcH5VC3WB8" +
	"Y/0nXV1lDAOfBhAMipUy0fPZ8r3PiZV8zWRiJ8BMWPUYBiMHXPsolxzUDV6rZqf8Iqyc2xYDSuEV8Nr3" +
	"2LzHju/nRP9B3r/5RqVS9dl2dQNDV84p594OGqJQSmg0LNYzRaJv85Qr1WU9RKQp4NXTJTrsoBT8ndMC" +
	"FlBM6SEiiEjTFVpR29/4Bzy26ApqjzNxAAAAAElFTkSuQmCC";
	
	
	static String redo =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxl" +
	"AE9wdGljYWwgRHJpdmU+Z7oMAAAB5UlEQVQ4jcWTT0iTcRjHv8+73/YGlhTpMpa5CiLRMagO/m1Y5Co8" +
	"REQQdBFGNj3WEkEYBolSEQndBoIEXkaXilH2B7ZFZIYt6TAI0uVW4UDUNd53e3/v06FO5STx4HN+Ph++" +
	"PH+ImbGRUjZEAxD/23g2tKWHTe4F4cHhTKE/GGRzXQmY+Wr3sfvVrQcu9L3fbQsNDJCyLoEp+dF06gWu" +
	"tNxDk/Nc51TVb4kAAALRmRHVy8R+AjpWFxNiyYfQjBwutw1DM3Kdk/ozEBjUfseacNidrqO1LTi0zw0h" +
	"rGum2WqphE1uQ//YRYgTQ8JbUWl3eTzNSHxMIBINQ9O1kvDBmjqcP+lDeGIQuZWfIWEW4Xfs34nX76L4" +
	"/OnrOLO4/ipYmP8bPH5DHazZW93naW3D2JO7mEulRj1c7BJSx2m1QkNqMgNDx+3ozfw/MADIAl8qK1cR" +
	"fjyO7+mF0ZhV+l4G2VRkEZH0bBblVTZIA9caemnPqlswMPzhbfLLt9nsSMwqffznDqgxIE5tt6sRd/su" +
	"zCWWkEnmUNRlnBhxJo7rFhmfGuKlUjMRb24ZT5sCmJmZyLqc9TtQ3+yAYlHAxFCYsJhdXnMjgpmZiNyN" +
	"gbx38UfeP/083QEAxAATQ+qScaS0gDb9G38B+g/M6Rty9hcAAAAASUVORK5CYII=";
	
	
	
	static String cut =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAM8SURBVDiNjZFf" +
	"aFt1FMe/v9+9zU1u1tnGSpmzs12XtVtmqwymayuypW3aMKxs4IbWPzAUhw99UWwEEZFlSXPd2ECQvU07" +
	"dTIqo1DBh07cZjoftpYq0aVxTUTsapomoV2Se+/vd3wYHRsieuC8nc/nHM4XRATjRPSSYUSGiAj/p6Ox" +
	"YyHjeOQiEYEDgO7Sn9y23TdiGCOH8R8Vi4WH2tva3td1vQPAHQEIVm93wNGyrfXj2PHIwX+FPwq/3tb+" +
	"RMS/t1cTgsy7gtulUrFQXEZfb5/W4m05E4sd2/fPzdGXfb72U/693c58fgmWWc7fFXCGVCY9T/lcFn2B" +
	"oLZl69bzIyNh/xocNcLP+3ZsP93j79FyS4vIZNKSiKUAQAUA26q8MvXj1en+QO06yzLRHwhqUsrxaPRo" +
	"N2O8bofvsU/9e3q0xYU/YJomfpiaKgm78hoAMCICABhGeLC+fsMnnR2dbqfmwPoaD85+MWqtq65mA/ue" +
	"UwvLWZTKZVy6crm0mP3r1Xfeever+wR3Tj06UO1eP9rV0eme/fkntmvXU4jHr8DpcmLL5mYRvzpVKq6s" +
	"Hgy9HZpYY+4TAEAkEtnscKrfE9HGA/sPgIgw9vUYFIWnyret7uHh4fl75xkR4XPG9iicnxZEjQDAah5Q" +
	"qj78gOWdDkgpwSom9NB7EisrHABUzjO2lG+8SPQNOwvsd7rdnz2+c6f+oMcDMIbfb96k2eQNdmvozYTQ" +
	"NH2jcfLR3YcOkWd5mUFK5HI5XL92bXW1WDzMzinKtx1HjvQsTE5Wfpubk1xR1EAwWDVx4UJZ2HarAMhR" +
	"pd4IPjugTYyPCxJCNHm90lNX57wej09yIWWXK53GXDLJLNN8xrQs1TRNSCHoBaL0S0QZaQu7UqlASMmF" +
	"EF3zqRT31NZCSLmbq5zPFgoFbGhosLnDEW9oaiovZLNS4Xxs7VEKY+f/XFoSTV5vuUrTLj/c2Gjn83ko" +
	"ijLDbSHOzSUSpZbmZr2vv195pL7e9cvMTNkS4uSawJTy1K/T05WHampc/t5eh3fTJj2ZSJRs2/6SXQTU" +
	"W5yfkMAgiDSVsWRFyqFBou/ujWuUsacdimJIKVvBWJkBZ7iUob8BpHmjYqtE7iYAAAAASUVORK5CYII=";
	
	
	static String copy =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxl" +
	"AE9wdGljYWwgRHJpdmU+Z7oMAAABg0lEQVQ4jZWSy2oUQRSGv6qucaXuRFwqvorOmB7fIgR0J0iDZCUo" +
	"woCCFxS84EJ8BS+TCT6NqCE7jWZyTtfvonvGMd2LSUFBURTfOf9XJ7x7//a+1V4pK0lCEsqZxTlLSHgq" +
	"isnW5o1tjq9Xb16Y1liPnz60ZYGVncw9AXz78ZUQQrsBAgCSOH/uAkdmqVMdSG7eHFJiNp1BCLQEAIZX" +
	"rwCweNcBmFsLGLBRbhBCJKwAJAFgZv2ABbkoCqafp00EYpNAMLo2agDuvHz9XMfFLjsoYkFZlhSxIMZI" +
	"CLH5hVy3EYytzZv/FX/y7FGVVrN9/PCJGCMxBsbj681lG8fc2dv/3hGbFtlyzgxHwyXA3RBCWTBoOtjd" +
	"/dIRm+qcHUhnTp/tlbSUCYzLsiM2hRgmt6tbVV3X6Z+gpvJiWGIMXLp4mZ2dWUdsZ7Ikce/BXUnSr4Of" +
	"+v3nQPP5ocyO5O4yM83nh5KkO9uVeqfrJGJ7AScR2wtYV2yds/cC1hEbAj4YnJr8Bf6RZNsaEpA/AAAA" +
	"AElFTkSuQmCC";
	
	
	static String paste =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxl" +
	"AE9wdGljYWwgRHJpdmU+Z7oMAAACMElEQVQ4jX2Su0+UQRTFfzPf7C7ZgAUEiRS0Rgut7DQUBHkstpb4" +
	"irEAozYbAxofCcYYg2gWC/8I7RCRymBiZ22l4ttoomEh7jfz3WsxuyuwxJNMMpm5c+45Z65RVbaj8nDu" +
	"avDZFVHJW2NTlyTTk5MX77YUAubFXP9MFqSsmjlVRVVZqQ1wfvIS+XyeNE2pzN/jEAvEewElgL1TuvZ6" +
	"2qV/auUDA2ecyxcBWP2+xvrzN7x7/xaRDGsTqmsb9A6eo293BwA+XXcvn8yWgWnnQ+pcvkh1dQVVeLSY" +
	"MjFxga7OzqbME+MnmZ+/z+WRAsZAe99hvK85AOd9iiLRj4GuwgbXb95o8bqvt4AxBQAUwXsf3zye2qv9" +
	"x6dY//AKgN/VGh9DH1+1FxFo5KIizb2oggpJkrvlvE+RTBCJv9FRzPP5Zw+nT53dKfQteFCZLbvgPaqR" +
	"vYGaDwB8+fYJY0x9AZhoQZWe7j2k3ruYgWRRVh2hTuCcY3lpOYYTGQAYOjrYrHN+BwU++DpBjtHSKMZY" +
	"zCaCRq33Hhe8R7IMlVYFSZKw9GwpWsBGBwrDI8P1RgHnQ4pqhqi0KEhsQqlUIrEJ1lqMsfEXJKs38rgs" +
	"BESyLRYaCgCeLixircVaw9jYsXhYt+NDwAHIthAbQyIiDA0PNQlC8Cga7ebqCowxoba+5ord+zeF9AOA" +
	"jvZd/A+ZSDCV8baZEHxZVV3jotp1hF9tB8nk3+TFadTmNBqjkssVbv8FD5FThvOz3GkAAAAASUVORK5C" +
	"YII=";
	
	
	static String selectall =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAAj9JREFUOI1tk01IVFEY" +
	"hp/v6q1xalGSRIRBMEUKFQQlEYm46JfBEJVWQRRRrWvRIoiCFq2iILM/XCT9uRgytIU/oNiqTYaa6CKo" +
	"nMrRQdHxzpx779difrw6HTicc+Djeb/3PeeIqvKhJ3ZSRNo8z68ERVVRBVCAZZBe3/ceNDa09LJ2qCqx" +
	"rs6fs3MJ9X2/aGYyaZ2O/9Ku7ljq9buOG1n4yrQA0un09s2byllcWmR+Iclscoa/iTjTv3/wZybOwvw8" +
	"p45Hyyq2VNx8+ar9erABC8AYF4D+0QQDY0kGvy0wNLHI8FSK4cklBkamsSyLutr6svXrQreetz85mgeU" +
	"ZgEGAN/36egZJeVkAAiHbJrqI7zpm6Sr/wvRw5XU1ewvG/40eA0YKnTgGkM+vJSToao6QlV1hJRjUJSL" +
	"LUdoPlOLXV6JZVniOM6Jh4/ulwQsGDQXaDhkMz42xfjYFOGQjSB0fJzgbd93whs2siuyG2PcEmOMHbDg" +
	"FkI5e2wPqqCsJH3udDUAkqsxxuCrH8jANQXAi/dfi646P85H95KvV1+LQwThQsM+tKAmRRAA13XxvWAH" +
	"xiCAiPAsNrKquPteUxHAGBff84IAFxAsS7jUeABBVomLrBxUFdcYvCDAzVmwLIvHnZ9XqTXU7ERVERE0" +
	"+0EwxuCttZBVsrjafAhEsg3klCWwqmoxQETiyeTctujBHf8NbSXkgqk545p0AbC87Fy+c/d2q8lktubf" +
	"ALkvXWqXFvag2Pa6hOM4V9panyrAP1tUT11XE9uXAAAAAElFTkSuQmCC";
	
	
	static String findandreplace =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOgSURBVDiNZdNr" +
	"aFtlGAfw5z3vycnl5NaYNG1am9bFLevF2NFBO2WOrDUdDNdatENUNhS/KIwJouKgICpePhQniG6sH6zU" +
	"3djmVqbL6jrFKYy60Zpk6SXpom2SprmnOc25vn6QFpz/rw/PDx74P4gQAhtpfe0HI0boqAqjbkkhHgAA" +
	"mkLTokwmZEKGAyf2FeGBoA2g+fAFL0Oh012NDrPHaVM57QYwGmmoSAKE4znp5E+zOUFSDoZG+m/8D3C/" +
	"NOZlVaorz7a6dflsEvyT49LK8gKWxHWoffgR5c03DuFdXW3w+hc3ud7Q+FuvLv9mB4A0EHISuQZPGWmK" +
	"WjjgbrbNBO7Is6EpQKqS32GRQ253k+nWVKwhlxb29nT70CsehnKOfgWMcwuwhQIvx+PnscXte8dlqurB" +
	"FR7PzEwRozr04RMddZOffTzU+MLgQN9gv1e8e/fmGf3q4i6xTodmW1qgoNOCua6eVs+Ga2lKEbprdCwT" +
	"CAQkzJSvt7kbF7p27oxKUmUGAPQajYbtfazKUdLYUOOWrdDc3AZXL5wFWzAIbpUwT4s859EgFSiCgjUk" +
	"GW5qejy9o61tSaXiS8vLwaOFsWMd21Jzl00deyGUUmA8GgFGxwKnJhWeLeyjFbECgigAptVAgVrS69mK" +
	"7iGGVxRDpTS8Zztaz5xv7+3TaPVrwK7G4PuSC0g5A5wJb2/4OVGkQBGmM8UM0Gq1LEB9iyAIKiEnYX6k" +
	"rwWtZyadvj6jVo8RVxBBmp8Gw9oSjPwu3h4Y/u4+AAAlifzEUi7OWy1GmtVu8/05m21M+D/tlFPRG87e" +
	"fpPWgBFXkCARmIfFGAcXwy45UxKvbvSAUogynCgmi7IsgFrLEH61+ktj1H/G6Ttg1OrRv8uhCMxFC3CO" +
	"GYJ78QiF7l9e3gTiv3xelIlycDoZKG81J+h3XV/jR337Ga2BQlxBhkQoApFIHsao9+DXxT9goLMKaSjx" +
	"uMNuffo/VXbsPuI993zK3+xpx3olDuVkEpKhCMwvpOGj3CH57+IKqlGvKrtbq2lbFQsnTn27xguCdxNI" +
	"+Y+YiSynbd2fYFJagbnjgxC895d8LPXc7ZJMXyPRS1kklYdq6p34yc4dZgaDcvrspfwmcPgZzzcWg/bF" +
	"t19+ChGFI7lb1+6sx+b3tI+StY17HXZrLwCMWixmrrba2hAMLwC9MYwu5bxpthwkpPw+wnjC/cFc7sHX" +
	"ja+kf3TYrT3ZbP5KNpsHAIj9A3SxvrBSK0QzAAAAAElFTkSuQmCC";
	
	
	static String down =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHiSURBVDiNpZPN" +
	"axNBGMaf2c12m5iYsEb8QDGxgke1ehJFvQhazMGif4B49+DFpgd78KPqyT9AvAt6EakX9aYnsdBUEfNV" +
	"CCQ1SY1tdLuz887rQTbamA2KA3N555nfPO/7MIKZ8T8r0l/YO3FHMtgaqP7uRSuvrq8PBUBATF+ZhGkY" +
	"G8o37z8m+hsHACB9wsLSCoL2DmadkAZCAJ4kkCJoZjAD61L9K0BB+tRzIH1C2KhDAUr9AnjDHGTOzl4S" +
	"Ag+CghUx4UkFXykECbueD9syhRuz3ezEbCB9Z0hxSjAzxs7dnUkm41dPHjsQNwwDna6HlTWv90oqbsNJ" +
	"2DCEwMdiTRU+lGtehI7Unky1RWBzLHfvYdpJXhw/tD+23HHhK90DGEJguxNDo9GiwvvSZ5LqcPV5vg4A" +
	"vbDLo5nLrfbX1wuFkpuKjYC1hlIEIkJqk4V6o6kLi6Uv2tdHg8sbAPzoAsloJFdfbhVL5ZpMRC1orZEY" +
	"tdBudbiwWF7Vgo5X5q5Vfx+i6P8Lu87f3mJLc373np070mnH7K51UfxUWSVNJyrP8vP9KfwBAIBM7kbW" +
	"0CNvt25Lp9rN5jfF+nT16dSbQTEOBPyE3BoXZLzUWk8uzeVfDBQBADOH7n1nZjYPO2dm/ADXoxo7id9B" +
	"7wAAAABJRU5ErkJggg==";
	
	
	static String text_indent =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxl" +
	"AE9wdGljYWwgRHJpdmU+Z7oMAAAB5UlEQVQ4jaWTz2sTQRTHPxN2t5c2SBNBxR+x0ZwEUyF3xX9gK17E" +
	"FhS8CUJN2lBUguKlklLFqxCQXGUXKl4FRYqhaZImeogVJL14sD3FZDbZ3fFQUlpiSqAPHgPzZt77zHzf" +
	"E+mFOavT6ZgMYSIg7KUXy1P797Ti2rr5JPMIz/dwpEQ6zu4qHaSUSClxpEOr3eLL59W+QiIanbCazeZQ" +
	"BIYxYjcajQMEQik1zN3BzyrOcF9AGp/85EUek1F+L5hKJy3f8wbSKeXbAaFIxp9/ODM6EV8ob/KGpyLQ" +
	"O1ApVcyTp04QPh5mLDiKbuj4vker1WJ7Z5ta9bspCrd5dexs7EF0OsXPfJa/W/Vc/AL3yCg/cj5iyXZ7" +
	"IIGuazYfr6Kt3mLz12JCeYWMKt/VVWmGO0ophnGtG+ZZMDQePX0lxrf8azpON5eI8RYgNT9r+b7qI1Bg" +
	"L2dfTgEEHJfpy9cvsf7uPX9+7+QSsV18gEq5aoZC4wSDY4yMGIBCyja1jdpeUs1xWVzJfUpqgpXiJLPX" +
	"9qnwo163qxvVPgJd1+w9GY/cB3PzDy33EK0BBMJeyh6cgZ5ppVLFvHHTRAiB53m4rovrunS7XTqdLo6U" +
	"FL6uDSwgIpFzVvsQrQEMw7Abja3/Ehz5D/4Bd9b7ccJaifkAAAAASUVORK5CYII=";
	
	
	
	static String font =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAAtdJREFUOI1lk0toVFcY" +
	"x3/nJhMzpDOTeXUe1zyMVhdFTCVgKyo+UNvUBwq6cWPVlSWtm1gsCF27kFBpgxWpT3xjJGIpZCV2QGMg" +
	"gsiA8UF0MnNnzGQyg5PMnHvv6WKSOJoDH+csvvP7/7/vO0copbj7T993QojTlmU3gUIphVIACmAKxIBt" +
	"W7/v3rl3gE+XUoq+/ptvx7PvlG3b86JcLqmxZEL13+srXr1x+VgF/iE0gFKppHsbfYy8GGEyP8Gz+FPS" +
	"75IMPxnCyCR5/eoVnVu3O4OB4PFLV851VxvQAKQ0AQgG/STGEjyM5zh/Z5BYfJIL/UOYtkTTNNav2+hc" +
	"UFf/29lzf62ZBdRWABKAxFiCQCDAyjaJf1UzyeQYfn8Tw8PDXL91FVsq2r9qd/4Xu98NPJgDmFICiofx" +
	"HCvbyjx5XeSPE/fxuOqpd8ChXcvxiPd4fV40TRPT09Pfnvqzp6br8BFLm3WggPFsjuDnQZbpdZw6uomD" +
	"nYvZ0NHCyYtDNDcvpDQ1xRdLliKlWSOldFSVUOmB2+0ibaR5kZJc+zdGfHQSATjrHWSzOYZeTvPNqoqg" +
	"reyqJpqVHuTzBRrcPk5ceMSeLV/y969r6T22GQHo0SjF90Vm880Z0bkSKg7cpDMZbAURj8YCp5eB2AiF" +
	"ouTlqMG+bR0AmKY5d2duCgIoFAosXbyM71e/4aeeGF5XHUuaAmzs0Hn8vECwMYce1pHSxLasaoAJCA7s" +
	"/hojZfDLDxvY35kmHA5hpNKEIiGMlEE4FEYIgSklVjXAnLGTyYwT1XUu9g/S0OAi/+gNHreb/OAobreH" +
	"NTU1eDyNSCmxLHv+Q9KjUQzD4MCu1RiGQSSyoqIcaSeVShEOhZnN/wgghEhOTGQjPp+fz9pcACxqbQOg" +
	"paW1sje3zkxqEhBZacoSgFBK0fXzjztqHbW9slwOKQUKBTNfuvoMCoejLiOlPHy698xtgP8BgvOCTohe" +
	"vlMAAAAASUVORK5CYII=";
	
	
	static String text_bold =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAllBMVEUAAAD///////8AAAABAQECAgID" +
	"AwMEBAQFBQUICAgRERESEhIZGRkhISElJSUmJiYuLi43Nzc/Pz9FRUVSUlJcXFxdXV1wcHBxcXFzc3N0" +
	"dHR8fHx/f3+BgYGHh4eNjY2fn5+jo6Onp6eqqqq7u7u/v7/BwcHMzMzNzc3Pz8/T09PU1NTa2trk5OTn" +
	"5+fq6ur4+Pj////nUBw6AAAAA3RSTlMAwcJd/YFNAAAAeklEQVR42o2ORQLCUAxEy5+U4lBXnI/b3P9w" +
	"aHXXt0zGjFYo5nTyAw+x7wfJ6lxcmOGHpPmFl0UUhRMMzDtrETs42P8OvHpDS0RgQX8P6jkWiNXrov8/" +
	"8Agba1LDyQ83c4SZ77uY5hbOUaDzltMmiz4stw/VnE5ltOANw88OzwIPwjQAAAAASUVORK5CYII=";
	
	
	static String colors =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAALNSURBVDiNfVJt" +
	"SJNRGD33vvfd5ubmNtdEh9oUP1JTg9KgIAohsIgCK0v9Ef6QwIhA6F8QQR9IQmBBoGWKmBj9SH8UGiKJ" +
	"URKTQMVpUzZN57dN9/2+tx+izbQOXHju83AeznM4hHOO/6GioCqJMfaJc94iSdL9lq/PvZFzGvlpNJbm" +
	"NJvLBprjylu3eqIoPrVaLQlms/GWIAjOioKqI5EctlU0xV59zCi9np6brhwf/pH3wnD5ZG+aPqxUKk6l" +
	"pe9ngWCQrfbb4PNJmQAGdy0gHEXWJIsqPtZEFPmi+vu34QaRMelAVqra6/Nj2jmLQDDoAtC6p4KQJFdN" +
	"Oqc/mvQGtcGgwaJJY1FHKaHVavBkbAmeoAAYkzMASNYzDzfJTHCTSBNfGa50mLQx51KSExXPpDnoLCYY" +
	"Y2NQ7/Kj9GLRLoNfd/T8UQAAEsNNt2elONYdrTitj0bX1CxfmFsMQWdRDI31A2QQlJcAELY5hHOONlGc" +
	"k8PhOAAIK7PBVDkIERmQ5/y9ufF1jjzXbY3eIeg00ZgYP4gVd+EmmZDNE1oJ4ceqqwFCIEuAw+aB2arC" +
	"L3cjwinU0R6vTzxRfF4EBDR1ta1zfyj1Q61nfkcOFkdHsTgyguWxEejVLoTWvkCXLCIzKzu50rUkavr6" +
	"QImMvLRshaBW1u04oZXSNXCu225SIL2EIaXoKLRGLZbsdj7knOEzly5QkSnR3t3pDYZ8x7sfbNgoAJTJ" +
	"ckwZ52TrZZXTGp1Fv6GNUUFaXcC8fcr7JprNTjgd8Ac2kJ+RHSWyqIYdOdiCrYLso4JwNyHTquGeZcyP" +
	"TQa4LL+donj5c8Le6fGuR41PzwQIxecdHmzLJ6RSoVaJguRDYGkBK+7VkCzzmp5Hnl5Zkt/Zp10DEg8f" +
	"fn9vpXrbg78UmKlA6wlwljFCgkHpTn4zr92VokgT94KtghQSgmuc48ahFh7614Lf2FQti1mX03oAAAAA" +
	"SUVORK5CYII=";
	
	
	static String image_viewer =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH" +
	"1gsVFAIu7WunzwAAAn5JREFUOI2V0VtIU3EcB/Dv+Z9ztrPLWXjJyrx0mXTRhK4oRQ9CxJD5UrMoJMwe" +
	"0iClkN6l2xqS0lMQST304AWhMIN6CYJAwxCDFJfYDcvc1uZ23M7+lx6ESjaJvo//H/8Pv4sU6PS3UWoG" +
	"OOcKVo+wWLRL7ZevdGVU/IFrRjwRF5xzwRgTlFJBaVqk06YwzZRIpZIiHAmJm7euLmWTFUqpbWzsDYhE" +
	"QAiBRAgIkUAI+f1GCAFjTMsGEADQnTo+RC6iuvogwqwTB/ZX4dNiC74kmvHVOA+nrq86mwIATl1HJErx" +
	"8kEdcsZH8aq/GME1tfj8U0M8FoZmvw0hqXB7PNbg8HAqawetpydgHR9FWXkhHpuHAJKLhsYTaLrQgMoq" +
	"L6LxOCpcea/h88mZgO5C2w03Qu496BlxIb9gE+qOnYRVK0X/i+uoLN8G1VWKZBr0CFM7MgC73Y6lJY7a" +
	"liGMJfNx2HsW94f8uNdbAyLmsHdnEXJswFyq8InMko0ZOwCAux0zAACelpHmBOfqu7GlKBeKTEAZh0UR" +
	"SDB7iMMsWAFIkkSng5OKZl2+ksXmwLv3UzCK14OwKBSZIG4YMClhNhHLS1ExvwJQVWt7/0BfQAihLAN2" +
	"PH/aB2fBVrg0QJUBk0J8DMsDOp/xpoil529AyjiszyfXJNgohaREWEm/Ied+19jCOp3NHi/V5jVPyVSZ" +
	"LEtnGu6EHmYHALg9HutabvfL3KgXjOZzQRZMydbbWDTcWrJxAyKxxQQX4pHjR7g5K7Bauk6pTTar2l21" +
	"b5djYjKYMJKpEfnf3/7k2QR/e7QCOyLRmHt3xXbH1PTs5v/qAAB6fZC/acogo9yrqsrgLy0jBzNGV5PT" +
	"AAAAAElFTkSuQmCC";
	
	
	static String html_viewer =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAAnRJREFUOI2Fk8tLlFEY" +
	"xn/n+77JBsHKC2liUmiaJeZKhZDMoJuatGhVu1ZFtAgXLYIW/QFRkVgELoqkCxlO6kIooVWEJZFBIS5M" +
	"TWd0HB2dy7m1cLyMBr3wwDlwnud9znPOK6y1BPq6TwshOrQ2RWCx1mItgAWIgRgwRt87f+7CAJvLWkt3" +
	"z6vfs3Mha4zZgmQyYSenJmxPb/dy18tnN1fE1+EAJBKJwl07s4kuRYkshJkNB5kJTTH5Z5zp4BQLkQhn" +
	"Tjb783Lzbj193tm20YADIKUCQGuJ0gqt9QqMQSrJTGgax3E4Vn/cn7Ft++0nnY+ObhKQAFvIxmiMMWij" +
	"efG6i0AgQOXhKj/WtqUJKCkBmyKrFFGjlMFYQ35BPmVlpRQW78FxHBGPx0/df3jXBfBWHdhUoMYYhn+F" +
	"GBkL47o+IotRaipyKCnKQghByb4D9PYFXGOND9DexgwABj+PorVDc/1BFmMKF8OXkTGUllSWFrDa0Fiz" +
	"IQMlVx+VwU8/aagpJ+n6kVKyvByhtbGa/g8/8Hk+Vs+rVNO0EGMJzeKSZDwYJRia59vwEKXF+cwEQ4xO" +
	"zOOlBJRSa5y1DASQ6c9AKoORcTKFovd7kun5Puqqy9lflLvuQCqM1pv/gcDzXC621PDu/VcSUtN4aAdH" +
	"Kiro/zjKpdZaPNeHEAIlZboDldq4rkdDbTkyscSdB2/JzMpGxYa4cbmJqrK92JUBQUqJ1ib9CgCu4yKE" +
	"4GxjLU0n6hBCIBAg1jL+t4AQYiocnivIzs7hf7WwEAHEnFQyASCstVy7frXF83ntMpncbS1YLKRGeuMa" +
	"LD7ftqCU8kpH++M3AH8BStmWidBtVswAAAAASUVORK5CYII=";
	
	
	
	
	static String message =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHmSURBVDiNxZPN" +
	"alNBAIW/+bv3pr+2WWhyExvBVakW0YUgKAUfQcEXEPoCIvgAQlFfwNaCrkUsSVvFlxCrLyAF6cKmpTTN" +
	"vfPnIjXtstKFB4aZzZk555sZEWPkPJLncgP65aul+9roZWtt41+MxphtZ91jHWN89/DBo1pez/HeI+Ug" +
	"1KBaJMbT63hsTuh2d1srq6/fSuddbXxsnM9fPqGUIoSAtSXWlpRlSVH0KYo+/f4RIQSMSdj6/g1jDM65" +
	"upRSMjo2SqPeYH2zjVIKIQTOOZyzw1lrTZpmdDba+OBJswwp5QCiFIJGs0Feb7K+2caYBKUUzjm8dyRJ" +
	"SpaN0NloU7tUI6/XkUKe3EKMoJSi2WxQrVZpd9bIsgoTExeYnJyiUhmh3VljenqKPM9RShEZ8NB/gXnv" +
	"KIo+PjiuX5vnw8f3gDhmHrl54xbbv35S2j5SicGpww2I9Ho9dru/uXP7LkdHhyzcWxhSF0KQJCkzMy22" +
	"fnwlEomxerpCxFrL3Ow8Bwf7FGWBkGI4EFDagr39LnOz8wQXiIRBAmPMTq93ePFys0VpS9KsMozHsMCJ" +
	"SltwpXWVvb0uWusd7b1ffLO6sqyUnHLOnekVaq3xPnRDCIsixsjSi+cCSM/kPlHx9MmzKP77b/wDj3fl" +
	"BS4mziYAAAAASUVORK5CYII=";
	
	
	static String directory =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAFQSURBVDiNpZOx" +
	"SgNBEIb/2dvzJKSwsMg7xNhYW9pY+RBio3Yi5BGMiqWoYGMtCD6D2tkaQbDTwiCi5nI7uzNrkSOiIuTI" +
	"D8M2+3/s/LNDMUZMIjORG4AFgP2DznkIYfkH2RATmWPvtNNut1/+A1CMEbt7O88b65sNY74fxMzodu/4" +
	"+ubqldn/MUbo5fZWe80CgE2TNyJq5Hl/dCFJEjSbzalWa77x26yqODo5XAQAWlg9e8qsztZrtTRivEAJ" +
	"hM889y6YntUgWFmaizP1aWQpIUsNsjQpy4KMAQcFex2eZX30XTy9uIVVFfTeWfoMjDtRImBQsKjKEOC8" +
	"RKIAjNkCQHBe4hAgAvaqhGoA9qoqAqsSULBHjFrFD+cFKgFWRVEUAdCIKlMoWKCiZQbMKD/l2HIcMMog" +
	"54CqSzXwgjIDweP9g7NJUgkQRJyKDndhEn0B9KnUOpQlM6gAAAAASUVORK5CYII=";
	
	
	static String file =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAAe5JREFUOI2Fk01rU0EU" +
	"hp8z96YaUNFosbWIG2s3in9ARNz4ASq48Eco4qoLF4I/QRQsVYQuKhY/sNCgm/4btbFtmpBQNcmZmePi" +
	"3pvcpoIHDjMM8z7nPTMcMTPqX1dviMhiCPE0GGaGGYAB/AFZjzE8v3vn3jrjYWasrn38vtNqWoxxXw4G" +
	"fdto/LC1L6u/Vz68fZzBR+kA+v3+zLGjNXZ/7dLpttlpb7PVbLDx8xub2w26nQ43r92qTp6YfLL8bmm+" +
	"bMABqHoAQlB88IQQsowR9cpWcxPnHFcuX60emDj49M3Sq0tjAAXYJ44xEGMkxMD7TyvU63UunL9YxWx+" +
	"D8CrApaLfS7MxNEiU9NTzM3NMnPmFM456fV611+8fJbscWD5g5oZBgiCk1FWq1WOHD7E7NlzqPpEVSsA" +
	"afkNihDABBBBxJGmLjsXoSgYLTICeC0+NZMLCI7ECYlLRuAC4BWLVgJoAXA4ZxiCDL2Ul2zjvSeGuBcg" +
	"gHNueLuoJrmjMkDVE0MoAzwgpGkCloul5KIAmCAieFVCGeDzFpIkHVYXZOQiXy0bEFSVMN4CQOKSTFzO" +
	"koNstv4BEJFGu92artWO87/odjuAtNRrP2vLjIePHtxOK+mCDgYnzcAwyEe6vAejUpnYVtX7iwuvPwP8" +
	"Bca6QeO45pDPAAAAAElFTkSuQmCC";
	
	
	
	static String edit =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAACZElEQVR42oSQQ7hjWRRGM2+bs65Joa1x" +
	"s2w+27Zt27Zt27ZtxE6+5O/c+1rPx1pr7+9Qbt68SfaouAj3xJQ4rmxuO2uOjA13++ft/vXrr1OvXHmT" +
	"WFPqGiqNGpprpNNzEzig7uG8uX+4G9V15dKlRw8b6NeuiahffsljfvmlAYWAeTwugkL9MToxhIBg37Nm" +
	"8r4iwBvZNhZoMTPFjpcX6DIJRWYFIUhITICKmhIcnR1Pzarqykj2MkVSfCTGxkYR7OeJHhtr0L78kkMp" +
	"LssnBZub65ibm8HS0sKpuTFEF/EBtggN8UVeXjZcXZ1RYKQvpd24oUjJzssgBTTa4elOPcBijDIWXb6E" +
	"uNUIsxmK8PdzQ1igt0ygm01+Ykpawr+CpuaGfzoJ93vcxJL7NyTMKXiA3aRnCPF1RLyrFgmTgpj4yGMZ" +
	"0OlUMOiHWAx/hiXP7yBuO4J3kp5i3OBjxDhp4B+YFISEB4LP54HBoKGltQksJh2Dbr9i2ZuADY8iJz7B" +
	"hAymjVTB2dXhuMDH3xMCAR9sNlPWWTjoTcRWgQ4k0ylHkRMfY8LwY+wOVIDFYsLc0uS4wNXdCUKhEFwu" +
	"B23trdioMAZ7pgJEoVY5Y0z/Q5REOWFpaQn7+/vQN9Q9LrC1t4JIJCKzGOqsQoztbVDbQrBTqo/19Bfo" +
	"L0vC5OQkVlZWQKfToamjflxgam4MsVhMSp7f/hlffP4OWpKN0V+bjKH+LhJkMpmQSCQgioqa4nGBroE2" +
	"cUn28eFu4jEpPK+8lHt+XKCmoSxtbqlHT1/Hpb3xrwHVhYYH/0MxQM/E7D+pGNkAAGxUrxfV7TuTAAAA" +
	"AElFTkSuQmCC";
	
	
	
	
	static String key =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABAlBMVEVHR0f//4C/v0D/zGbbtiTjxjnT" +
	"sRbmzDz/4GT/42fVth/sz0jx1VXHpArSsB/KqxXHpg7sz07bvC/bvjP43mLQrxz74Gnz2FznykXkykrP" +
	"sy3RtzHXtybMriPUuDfXvDrx1l723m345ITgyFbw01XexVLix0fw2Wj25ZD65orp1HHs1Gfp1Hby4IvJ" +
	"qRfYw1fv3IDdx13izWTb0pjj1ovp3JbMw4POxYLPxnrZz4Dc1Zne1Zni2Y7j2pHl1orm357o2ZHo4Jvo" +
	"4Krp4qfr3Jfu6Lvv6bzw4aHx7Mbx7Mjx7cn078/08dX289v39Nv39N349eH49eL59+f69+X6+Oj6+Op7" +
	"qwuQAAAANnRSTlMAAgQFBxIXHiElMTU2aGt5hKSsv8DCyNPV3N3e3t/f4OHl6Onq6+zs7Ozt7e/v8fHx" +
	"9PX+/v7D7Z/IAAAAdklEQVR4AWMgE7CwoHC5JbR0hLkQfB7dIF+fUGU2uIB4iKOzrX2AqryctJQsLwMD" +
	"s4a/iraHpZW3u4uDnaceAwOjUqC6gZeFuZORqaGJvgBQi1iwm6uNmbGakAyfKD/IDE5NP19na0lWBiaY" +
	"qRwiigqC7AxUBAAbRw7cIqt8rQAAAABJRU5ErkJggg==";
	
	
	static String keyring =
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAADcUlEQVR4Ac2TTW8bRRzGOSBuIEEFFw6I" +
	"EwdOHBAXLsAX4IQicUH0G6AiDlyi1rW99u7aaVpCBaQ04kVELRSaBNuxG9vZOE5w7NheO5t4/ZLajhPX" +
	"L4m9Xnvreh9mVsoFKfIiBdGR/lrNjub5zTzPf57534YgCM+fu6gkie/J8t76Xk5SxWxSi8U3VCESjH93" +
	"62sPyzOPGKf1Cf2yLuZ7lrW89q/Et9PxTO2wMhwM+hgOh6Qeo99XcVSvYTUSREqMYzQaoT9QkS/mRq4p" +
	"rsswVz8wJR6JBq1yflfXNA2dzon+sFxSxUwKaTGBcqWE+qNDhIQHiCU2sF8poqcqUHoKXG72xMJbXh0L" +
	"CEdWlHa7hUJR1v/ainaufzU1cF/j8cv8z1gOeLC+KYBYBl9gCaVyAemdBNR+D8TKEcvb+LGAQNA7bB83" +
	"8SDk06em+W99/j+fXL4yCTEjQoisGsIU4FleQKvdMADFskzs6oNzOStjASuh5c3SfgEkUIV3O4fV2kPY" +
	"HVeh6zrKByUEw374/IsIr62gRQ4iSknkCjtGTg7O1hsL8PqXPvT6F7qJZAwO1oZmqwH3NQ6q2kO1VjZE" +
	"B1ofitJBLi8hKcaNLLpKl96gZCrou7/P35y/85MyNe3CQa2CH36cox4bgeZLeyiQykppkNZFfDtGwt9H" +
	"+7ht3JRhrrxhCjI7N/v+jRn3QXg1iPWNCEgeoOE3mnXk5F1Eo2uGeErcJpmkyE2b5DBVneWYlt1++U1T" +
	"EJ6ffIlzOVqSlIXHu0SsYhEKryCTFSHLOaTFFLI7GZx0jg2otLuDw6OaTvac2DjbW6YgVqf1HSfHdHx+" +
	"r7a2JhC7buPGzDRIA4C8ZJ3acntu9jGdp1Lb2IrHUK8fUUiH7jUHsVpfpkKNRh2/3bsLn8+Dz7/4DJOT" +
	"l16xsba3GcbyMV3vdjtYJ9aFhRCF0Obo2u2Wd01BiAB92fj13h1sxqKg83+u03JydvgDPiws/oFms2H8" +
	"Mw2o1w+xuHQfieSWsfHsgxxDFNPQtIF5gJOzfTlz8/rQH1iGmEmduZF3s/fp2mmxLkfAFMDB2S/N3vpm" +
	"QNuWdpUBMD/MW0T7fy+3+98AisW8cfpqtXyugGdJXbh48ZMJ8h76hYJMH9kp4AJdPxcAqdcnJj769DQ8" +
	"CjQPMDeeI/UCqReNL50/beNvZknyLaVP6mIAAAAASUVORK5CYII=";
	
	
	static String mail_signed =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAH6SURBVDiNhZHN" +
	"a1NREMV/c99LGmupSZqXttIPrPgBItKVhRapdWXFhbhyIQruXbpwI/pn6NK9XbVIILErRdAmFmxRBBFp" +
	"bUtjIk1rCe++cfHKS2JqHLhw5845Z+bMlXx+fnRmZpZqtUql8oP9fUgkIJUapFMkk0kKhQVci7kcPllS" +
	"qWwTxHYUCBEGF9FpgCBoFMrlMtaGAsY0UwTHcfC8voNUcVGmQ6BEMM/zEGklAk1vBxcFFxgNiwII29vb" +
	"UfcIfoB33RiZTKal5jZABhHIZr1Gh4j87zwSCC2EE/i+fyjxvxM0/IfEQJXd33Vyb75w8fwwpc+b7H7Y" +
	"ZHbqDN3dbQISEQGez5fYKNdQhfu3JnjydJG718cZHjjG3KsV7t2YCCdvWDCRyK9anb7kUR7cuUQ8ZuhO" +
	"dBGLGU6NZDiSiKN6yA42f+7ydb3Kt/UKG+UdrFVqe3VeL39n4OUypU8bPJt7hzHCzSvn2gUGM70c93qZ" +
	"vDDCVmWPpdU1rk6e5kXhI7evjfN+dY3ZqbOMDaValttkQRAxFIsl+tM9vC2uIGIY6+9CRDiZdTkxlGZp" +
	"qdiyK3L5BVVV9X1ffd9Xa3211upWeUettWqt1SAI2o6qai6/oK6I1FU17jhOy/966R46haoiInUpLOYe" +
	"2sA+UtV4R8ZfISJ1xziP/wBBbdA4WYqeQgAAAABJRU5ErkJggg==";
	
	
	static String mail_signed_verified =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAK0SURBVDiNfZFN" +
	"bIxbGMd/z3nfmQ6qzLSj7VVtqqUVEVpF3JKOWtxoNxIsLBBhQWwkIpFaiIWERMQO8RESVqIsepub3jsN" +
	"dTVq+iH0y1eKaSk6ZqhSk/fMsagqRvyTkzwnz///e3KeI8Hg33mVlVXEYjGi0ZeMjoLHA15vNj9rb92y" +
	"rSnT7J2jH+Jnz2x8dKqxsR5bo1aNtTVe74zv7PqH8Lm2PeXFRcXb8vML5P+W/3YADzUKGzEBgERiwhyJ" +
	"RNB6DKAUhF5emzni7l89c1aGNPVeZc6U6idAADHYGAJjRvkG8Pv9yNfro0jI3eXUZc2bXyj3nzeTG68Y" +
	"3lR2yA8EMGADeQCdr5q40XeR0vS1FExbAsDQp+fU9u9ncWkpnYNNeAbnsj1wfKqITB0fpsaLuidHKSlb" +
	"QOvoBcJOK5OmW9SGaygrWUbv21s44Ux2V5zHsiyU+habAORMWUDT00vkFmbSHDnPkZvrWbJoOY+Hb/Gm" +
	"GzYXHePDu4+IKEQkGbBl8WF8saX0DNwhrzCLyuV/0Re/Tfj+exa5juByZ9P6MMqVYBefPjvJAEvZ7Prz" +
	"BOnvltIZvk3vyL90h/rxDdWwYdVKTlwOUZCTTvXKYq5d70kGKKW+Qk5S9Hkj4ZZU9q24Qporj8meFFwu" +
	"xZzcDCZ53Bgz8QR7vHj1doS+FzGevYgyFAkwS1cQarNpvhcm65973H0wyOmrrSglrFs9PxmQnZHGH/40" +
	"yhfm8jr6kfaeAdaUz6W2sYtN1SW09QxQtaKY2Tle4BdLVEoQUXR03CXTl0pLRzciitmZKYgIBTNs8nN8" +
	"tLd3/PALNATrjTHGOI5jHMcxWjtGa21eR4aN1tporU0ikUg6xhjTEKw3tojEjTFuy7L4Xn5fKr+TMQYR" +
	"iUvj9YYandAHjDHu3yZ+kojELWUd/AJVVx3+pc9AFgAAAABJRU5ErkJggg==";
	
	
	static String network_transmit =
	
	"iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAMAAADzapwJAAAAvVBMVEUAAAD///////8AAAABAQEPDw8SEhIWFhYaGhofHx8h" +
	"ISEqKio3Nzdvb290dHR1dXV5eXl/f3+AgICEhISGhoaHh4eIiIiMjIyOjo6QkJCRkZGWlpaZmZmampqhoaG5ubm6urq7u7u/" +
	"v7/Dw8PFxcXHx8fJycnKysrLy8vMzMzPz8/Q0NDb29vc3Nzf39/j4+Pk5OTl5eXm5ubn5+fp6ent7e3u7u7w8PDz8/P09PT2" +
	"9vb5+fn8/Pz+/v7///9LwFWaAAAAA3RSTlMAwcJd/YFNAAAAr0lEQVR42ozOA3pFMRCG4ZxM7bC23V7z3/+uju3v8RvMsB5x" +
	"AE6VcXWgahya6KjqGO4RHeedI+zX98N15njZpqQTZHxJabuT7I/ltQ3aJ9r5QoLznwmCbKg81j8jHsAY7jZo6zPVoRXyO2BB" +
	"m6+xMgyMkB8I+n8fJcrHp0Kc3wc9r2L0W5yJtLfcxvep2v+MOe6EuJgijLOSz5wUUr8V4hHesMSKipy2HfbYYiIiVgEf/htu" +
	"CI71bwAAAABJRU5ErkJggg==";
	
	
	static String mail_send_receive_24x24 =
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAADcElEQVR42mIYNODtWxW+79+15b5+1TH58kXb/dtnnSAgDgfR" +
	"IP7Xr3pGIDVkGf75s54YgJRyAHoejaLweqwdzyzGa9u2bdu2bdu2jd+2a7dJv7qxk57/vak/48yc+J7nvpgoyo7badpOx2vK" +
	"9tdoynYP6uoOz2vawW/Rme7pOb3X9R23nHDnfri04wmqvMO9LOhdTdn2t1pgA5BVZbs5dE/P6T2NSJJ22Hxc4cAem9K0UGeq" +
	"tMOxrNPrmRdRcKNhgETXDMDTc03e4TOC0JRRbTcoeNZmXvGU29zSyf975VOWd33iKqd6dMiqH5yloLZdZwna8rw6et8Zwl6c" +
	"Kez3vSHstnUHQOGBJVck3njjGffZ559C26+98RC+/uZGv7Ba+YWFWRhNthX2v82njqrZlcNe6gCo8zfefNpRVAWkRqPh23UG" +
	"WNF/MI3n0ZwWB6OJvlHkc7F40RmeVT18ZQdA00EdG4aBdYF1raF7sG2ehf8JQ3/KLzaNe3zwcHLdYGs9zsaC+afBrh6eGAKg" +
	"4mKxgGnTp4Fk20UW/hc09RlWeL4f4Lm1EbtX5Z2gaxdi7twzGODIyBAAyXEcpFJJ/Pb7LwwowTRnMcBrUJWrW9NkjwxQDmKA" +
	"6zBjxrlwysetG3YErutC0zUEggH89scP8NjQDf0rKPJ9FNJaI52uWyMq9wDOYt8+jN9/vxxe+aSVwwJMy4BhGhBFAavWrMLv" +
	"f34F15nDOnsbsnR7J1hTdmLetnOvKjdAlm+HabyHt9+5D5Q5BEALq2qKb0WVkeXSmDbrf/zz3ydwnP9hWx/AMh6FqV8PnjsO" +
	"xcKxEOpnMvCVkMR7IAivwrKWgbKGBbieC1EWIEoCCsU8Vq9dDhLHc/juh/cwc9aTWLT4Tixbdg1KpQdhmc8gl7sdlfLTqNU+" +
	"QqmyArZjjwJwHdTqFeSLPMLRAEi0dev1astF5gjreiFE4Q/mX1nNSkSi/yGdC4MfyMG2rZEBtIPyBQ7JdBwkWmxBrKEudF0T" +
	"qqyJpqu+KyBF4yG/zhoNYNs2m/cUSOVKkXWUBZfPIEfm08jyKf99hkuyjskJpLJx36RIPADTMocAWr+Kpxzd0EGiYVodm7Cs" +
	"fpt9NjomaZqK1994yqHMIT+7119/2iX6VPzaa0+765ZclqDM0X/XkzRlUBZlrh8DMWAUAACGNBwMF4eXZgAAAABJRU5ErkJg" +
	"gg==";
	
	
	
	
	static String about =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKUSURBVDiNpZJN" +
	"aFRnFIafc+83M3ccHYyDkmSibQ1EqhZDownWoOKm0q3QRSkttIgBQSm4ct9AsT+rUleCrS5dSummNVAt" +
	"VqLRJv6RmWQYk0o1ZjIzmTsz9/vu6UJaEohQ6Nmczfu+PJz3iKqy1ly/IIFvkj8h4lzUeu/AJ9pcS+et" +
	"6QbEyYlMtntvZn3nkDg58UrdWgQ3vpWkZxLz/ccu5cBn4soHC7Ftd79zUtv/iUCcHO/o3JMKOoYJNh2k" +
	"o2sgJU6Ov5Lgty+lD3gD6PV8fyciH/V/eHlDcn0OJEG7/oKJH96vofp97Ox9oADM7D+jj+XmF/4N8aQ/" +
	"k8tHG/K7k+ktW4N1mwdI5/rQ1hiIQVKHCBce03h2h3Ch2Ko9mWwtP5tLaBzflVufm1+3dPUM9Rw+bSTb" +
	"jTIDfhV1L0B8BIOKILIZvDQi29D6PE9+/sb+VSrf9D8djq+GtdoxWytnsj27De0yGj0ArwkagYYQ18GV" +
	"EZsAG1D+5Xz7+XRhJm7bo6Kq/H5Wsr4x1zry2958/d2RQO098BfBeC/PHAO6ETF7mP3xu+ZiqfTAWXt4" +
	"cFSrHsDgqFbj0A5XZkvFyuQY0spA1cJSBEsvt4QZKvfGqEyXinFohwdHtbqqxn3ntCHOC40TtFKDqoNG" +
	"AMspqDp0qYZxijhp7junjX98ZmWn2nR9gUlBPYJUFyxHIICXhbBJQBJtur6Vnn8Dxkck7xvf+IRoBAvT" +
	"f8RPHxZCgM4d29O513o931O82PPGRyQ/cF7nVhNE7EoEgV2cLTI3VVjWWMddZD8D9M/JwldPp4pD3bu2" +
	"p5PJIArD+lvA6gCxTLWXGszdmb7tInvq7Yt6fQXpkdsfy4H5icLXsYt7JebRqlf+P/M3E/ozPa82wvsA" +
	"AAAASUVORK5CYII=";
	
	
	
	static String check_filled = // check mark
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMA" +
	"AAsTAAALEwEAmpwYAAAAB3RJTUUH0wwSDQkt+1vCWwAAAJtJREFUeNrN07ENAjEMBdDHiTnoEegkBkBC" +
	"oqCmYhkGoKOluxbaW4FdWCM0QYqicBeozpKVKPb/tmObKckeHcKIXrApEdzRVgRqcS0ZQgW4yX2bH0pc" +
	"YJk/zivBK6zx+pZS7pzKFscIfg5F+dR1wjm59/Ec/a+QZNBHDQlZNYEICpHEPwRjbS228ZEN0mxgkG4l" +
	"w65ylDscprOBb4zTLNM9Tse/AAAAAElFTkSuQmCC";
	
	
	
	
	static String java = // java file icon
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAL+SURBVDiNpZPf" +
	"a1t1GMY/35OTnLguTdOssT9maverbkIWKO3SzfZiymSgc0x0sBsd809YEbzJ1QZBnOKlXoggpaAmHTqZ" +
	"oLuQWJzxIuvarenWpktZ0qUlSWPanJNzcr67WCv1ei888F4978P7PI+QUvI8o24vsVjMu8vjuqC53G81" +
	"m81wva53CiHYvbtlxe12p3XD+Lm0WhnXdb0ajUb/uyqklMRiV44rTsdkT3fPnuDeXtHZ2UUg8CIAxeIT" +
	"VleL5FfyMptdbNQ3jIZtyxqQAj58pkARX79x8tSeo6GwKFdK6HqdUnkVp8tNR6CDl4JBhl2auD93T0sm" +
	"/9DOv3/Bk0wmz6RSqQllS8ne/kOviLn5WRazDygsZ1h7lEZfm0dfm2ez8hjd0OkNvkypXCKRSDA6OoIQ" +
	"YmT7B4uV9crRA/sOiftT35O9PU45PwcOJ8H+E/QOvMP+gT7yhTzSlvh8PjKZDFLKX7cJForFJ33+dr93" +
	"38DbHBw8g0tzIwDTbCCFwqa+QS63ZO9qaVEikWPcuPELwI8KgISbd+/eKSmKQsO0cDg1QKFhWRimRa32" +
	"Lw7FwaPcknLk8BHi8QS5XO4mMKkCuJ3mD4WVwrW6XpdOVRUNw0DT3DSbTWxpozqdbGzUWF5e5kFmoWrb" +
	"ciwajX4F4HihxdXa7u+aNC2rfymbFYODxzAMA4eqYFkmQoKiOJiYGKdhmnT3dM/oxubYaydGjGcGCuWa" +
	"v90/+t6755FI/ro9hebWAIFDUbGlza1bv+HSXFy6+BE+n2/A4/F8sx0kRUr7bCRy3FJVlXAoTOqfv5me" +
	"TlOtVllfr5K+k+bhwkMCHQF0wyAyNCxrtdrJnVGOT16PH7z4waWhNm+bKoRwzdyb4c+pJFJKWlu9RIaG" +
	"CYXCTU3TrO/Gv01LKad3ElyuVMqff/HlZ/u7OrumQ6Gw+eap0wfavN4+KaFaXc/l848Xrv+UEIVCPiSl" +
	"nAUu/68LALFPr74KnANeB7q3AJDfwu9A/OOxT2Z3tlE8b52fAhHAV09/2872AAAAAElFTkSuQmCC";
	
	
	static String python = // python file icon
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMLSURBVDiNZZLL" +
	"a1xlHIaf7zvnzC2TZJI2IUlJ1IhNbOOlaCQlES+LVFDajbagXfkHaAPiogXduKkUsgq4KEhdKFREg3Yh" +
	"NFDFS6OhTbE1saVtLAQbMkmTycxk5pzv+/3cWIzx2b2L9+FdvEZV2Ur/obHdNghPpKNoRJS6F4lVtexd" +
	"/O785PhPbMNsFfQfGisUmvILR155Kd/T1RkkzhM7x+3FIp999aVDNT0/OS5bBfY/NmOPvTi8P1do7Qx6" +
	"u1pY2zT8sRjT3dlFOooUaNi+wG7LzakoE4UWZm4UEfG05EOqtQTnEl5/4sL/BKbv4LFmG4SnrTEHrNF0" +
	"Qy6bymayeOdobCowMvQcosK5ryf8hwdOB8ZYyTU/nETZ7pN7R6feD42xbw89+djB4cHBlPeKF09lM6FU" +
	"rSOirJY28eLZqGWCKN3inx59Ndi491f6xqXvj/94xlwOjQ2OPv7o3tTcnXVWSnVUlJ2FDM4JqoqIZ3W9" +
	"TGfTahKmogR8Ll/I88i+58O56XMnw9DqA5iQm4vLJM7T29nIzzO/xCvLC9aAWmM1FdbsiRcurLR197Wr" +
	"LyJ+iUx+DyLSE6qa2uJyKbWyXqW7Lc/N29fd4d1ni4PPXuxQFWOMAZT2nt72jof6rI+voBJjUhGoRqET" +
	"vVPaWBtoygZkU4ariwvV/c9c6xgYftlmcq2IOlQEE+SMxLcQvwG2mXplFRvYu1bFvfPrpelyYzrGe4/6" +
	"uEFViNKtCAbn0yRJlrjmcLILsfsQBlj6cz5R0U/D+cnxb/sPjb01e2X6uDE8KOJD9XVRY0CEW7NTlNfW" +
	"sdYioqA2QZNYpDIloqe2X9kAOz9+bWLpqdGjBhwm2IW4ImC5d3eOhas/nB16Q47c74T/3thkgRyQMYcb" +
	"UXX4ze9ItU3giu9h7A7iupNyBW+MaQYqqursP+U8UAB2AO3e16ql1TKJjlBd/gTPHsobHbp4fTb+6HM9" +
	"A7QCBWOMvb+gDCRAFSifv5i86eSbD8Iolw+CdMoYtRul4m+Xf9dTX5xnBqgAdVXVvwFbgIwSfOG6ogAA" +
	"AABJRU5ErkJggg==";
	
	
	
	static String message_48x48 =
	
	"iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAXGSURBVGiB7Zjf" +
	"bx3FFcc/s7N79+6917Eb27GdH0i2k4raVOrfACgI9f8olfrOA1LfKoRA/AN5QcoDErwgUFupaoFUgEor" +
	"IAmQ2IEHqNNWkLR24oTsvftjDg/7a+7eX04CtSz5WLt7Z/bMzPd7zplzZq1EhIMszn4DeFg5JLDfckhg" +
	"v+WQwH7LIYH9lgNPwB314sUXn3/CbzbPCbIsIuqhVhEQu3EfopQShXwV9eJfPfvsc2/X348k4Deb5379" +
	"zG9WPM+biE5KXFLBG2iL3V3cqrv091htFYb3Vs6ff+UcsLpnAoIse55HatLaiwKwICIIkmErf1tX3mZI" +
	"X/0in2fY+Lmj8whqeRjOkQSiKFIASimUbbS8UQSVkuxmGTXrV1jGLJQZiCCV36Q+Qb/NiON4aBiP3MTG" +
	"GIwY4ijOSOQXSqFUtnCxeNVS2Z9SfX0V0uHgh0renyQpIgZjzFC1kR4AcJRD2A0REZpBM+ssYrNYOLdc" +
	"2Rxi5VH4JqmlSUK3180NMgLjpIU6nQ63d2/TDcPJqH4oUWBSw527d2n6jbGqe6oDc3Nz3Lhxg7B7DztL" +
	"2PKDftcZuHnzJp1Oe6LqZAKSxcyJEyf5+quv6fWiPDlKvvOqq8xIQ+cZ26wAOZqt61scnT06EdqeCBTQ" +
	"ULC6epqrV6+QxEme5iwO1gg7NfZdNeVyfC6e2+Da5gYLCwuMCfv7IdCfq7V2OHPmDJ9c/AhjKkBVLaiN" +
	"lgp+H+oaMRHBbzS5dPkii8eX0K4ewPFABMoCJYIYgxEhCAJWV07ztw8/AFReqLCISBVi9D/6q3QmCkUr" +
	"aPP3f3zIwuICQRD0KWTGG41xYggZEURMPlFGYnpmhpMnT/He+xdwHG0tZB0DpKSUNyxv5cZRStFqdXj/" +
	"g/eYnZ1l+siR0m1FVZ4kewihDLwRQUzWBmFxYZH5uUXevfAOWusyV/fFfwGGWuQguK7LVPsIF/76LlNT" +
	"U8zPz6OUsjy1t7w2PoQsQJn1DcYIxgiOdjhx8ji7u7f5wx9/j+c28P0mruuitYNSDiiF5EVOKwftahoN" +
	"n6nONIHf4s233uDWrR2WlrK4r0LP3ujjiYytxPYhrKqG1YRXrnzOE48/SRRFvPb6qzz66M84c/qn+H4T" +
	"v6FxHI3jOBhjSNOUJE3ohiGXLl/k2hfXOPvkWZp+wKVPP2ZtbR072kpPTnDEWAKZBwxQWbI4Q2xubrC2" +
	"tk4QtPA8l6ef/iUbm1f581/+xPbODlHUI45i4iTGcz28hovX8JmZnuHYsWM8dfYptNZoT/Pzx37BF19u" +
	"sryyTN0DkxhM8EC2iVV+/MxOoMI/t7Y4deoRWkGLOO4hgNaa9fXHWF9bL0Nv6BG71hd279HwfFZXTnP9" +
	"3/9iaWmxpj8W4d7qQJmJjPDtN98y95NZ2u02cRLl7+xMVf/dD7wWJyBCrxfiuprji0ts/++/NevL2H0w" +
	"OYSMyTcj7N6+RSsIaHfaJEls5fViicJiVfz2eYDax03hDYRe3MP1XGamj7J75w6ddtvOvg9GoFgMhDAM" +
	"cRxNe6pDkiYWRUqg2ZDqOfh7dCiJCFEcoT1N4AeEYRe/2XjILAQYMSRRQpqkdKY6pCX4ikMFnhLkAJnS" +
	"Kzb4wayTpjFew0WMIYljtK4fK+6DQNgNCcOQXhTRCpqEYchgMrW41IGXZx2LWD2sxNYrCAIKkjhLvb1e" +
	"98EIdLshYfgdrtug2+2N0bSzhfT1ZdilfJZwpQJcjLL7ilnSOPsqA1BKeSISjySgsmoVAMFLL7+wtb2z" +
	"/UgQtLJ3I6GPbvU3x2piWWCgCuxs76Ad5zpwTCnVBUIgFBGpe6AB+EBz48rGb8WY51NjTozA/n8ThfrP" +
	"p5c/+x3QyrsMEAGJqp/4lFJ+rhiQkfHyAeNi6MeSRn6lQAx0gbvAPRFJAQYI2JKHVJEG0pGKP55osug1" +
	"gJEhYMcSOAhy4P87fUhgv+WQwH7LIYH9lgNP4HthfyTNHXKJsgAAAABJRU5ErkJggg==";
	
	
	static String text_48x48 =
	
	"iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAASdEVYdFRpdGxl" +
	"AFBhcGVyIFNoZWV0c7mvkfkAAAAXdEVYdEF1dGhvcgBMYXBvIENhbGFtYW5kcmVp35EaKgAAACd0RVh0" +
	"RGVzY3JpcHRpb24Ad2l0aCBhIEhVR0UgaGVscCBmcm9tIEpha3VihlQHswAAB09JREFUaN7VWEtvG1UU" +
	"/s7M2HFezqN+JG0eTVuElD5YwJ5WZVMpoLZSVRCvwqI7/gALVpWQ4B9UCLUIRFElioAiEAUqFsAGIbVp" +
	"Q0IFVNA87CQlHj/iieceFvO6dzxOiGuDuEpy53qcmXO+75zvnHsNZsb/eRj4n4+GDly//tmQDeMcs3iW" +
	"mRMAEGZrs7VzyeF7tq5r9wTjlm3bn6OmvzU1NVVuiwM1ptcOHXjkpUw6q7UKrZpd0y2rOlY0C2P3lhaO" +
	"LM4vnLv6xUdvdnf0v3748OFaSx0QAs+nUxnN2qiCBbtYsoMkAwz2UXbQddbBtfM/zveDa13T0Zvsx/6B" +
	"HYnxkbHE73/89urC/Pyxy9cuHzv1xKm1FjogEkQEIYRvsBwm6uwa77vpxQ1A0poA2HYNpbIJXTPQ092L" +
	"h/Y8nOjs6Hzszq93bn7yyeXHn3zy1G8tcYBZ+Aaqsc1+kHM43pXZZUdKCva8YKBqVWCaBWSzw9i1cySm" +
	"6/qumdnbP125cvnYiROnvm8BA86rBTsMLC4soVKptEw9mBm6QYjHVzEwMIh0KqNpmt43fevmtQ8//ODo" +
	"yZOnf2gNA64j2aFMwIAfF14euFizhDrXz949L4/Moonl5RzSqTQ64h1I9iUxObm/69b0zauXPr508Omn" +
	"np5v3gHBimG5pRwqlfWWanilUkGxWMTE7nXEOzrQUdtAsjeJvXv3JX+5M/flhQsXHj1z5sx6cyEk5QAY" +
	"SGfSCvJQLuV1RNyzrGLBXKmU0WUmAAAxI4ZYLI6qZSGTyRqlcmnvPf7zIoDTTYaQHxtgMHKLOVSrVksZ" +
	"sCwLpVIJy7kf0ZPsAQHo6ulCf18fxsfGO8y1wtS771985rlnXny/GRlVZDKTTasSqXoLhYfAd3/NUAHx" +
	"HCiaRRTMAkxzDWbBRLFYRGdnJw4cOojde/Z0ra7dfwPApUav3oKBoAjlcnlYLWbAtm2USiUUi0WUy2WU" +
	"yiVoGmFlZQXXv76Oo0ePINnT2/fOe28ff+HZl680JaPe33Qm5d8jJepJyYNAh0hRKf8/JKViwdjYsFC1" +
	"LFjVKizLuS6aJnL5PL777gfsPzDZu7q6chzAlW3LaKBDjHxupeUMhIcGA92JOEZHRjA5OQlrwwLbDIAe" +
	"b7qQsYtaKr0DJDvoYqziG1px6F5ErkTmictcLBZHb38varXayPnz52Nnz57d2HYh816xnFuBZbWXASJC" +
	"KrMDROSCw4jH4mAA8XhcB7CxDQbUriyVGfQxpwhJIDBY5sSr2NGk1DPgd7NBF0hMMIxYA/3ZakfmFzLn" +
	"ecv51bYxsCM9iFjMAFEADksACBbQm+2FvJFKDwYS5EPLCMgO3Y5CXCkTjBAZAfLeM+WWnbbdSrCaA21k" +
	"wIv/dDYFTSN/TURBUdW33cxFMECk1IKACJI+DLig8H6BGhRMjlIz9p+52clJQwdsZqVs5ZbyqNXstqvQ" +
	"8M4siMgXBPLT8e42GbBF8AACMkMZkF94CeQjShIbpBDBFFaqBu+qW7CURtQcA4LVVGtlHejv70OyL6lI" +
	"sP8uDzFJlJlFA/z/aQ4wnALj8Bwg6V+T9xPgHF5vHjzSX3btp4bnT9tiwFMC39hGRkvyt6nxJItwVJNM" +
	"blEMJfrdJreU5L1RMpyo3miSc4Co3ihqgDsh1AfV13oRqkn/fEvpVUYi5JfyLd+RRQ1d1zE2PgqNtOCc" +
	"STQRQn7cucg7pxIB+h7K4VlFm9R6sZUOhas0PwgDQkghw1hazKNarf4rDOyeGA9C90EZ8BAfGs76MR+N" +
	"vsSOkvRqVW6UxazsF9TqLJpRIVlGiZyTuXYwMDo6iu7uLnWj5BZBatDWbK+ZcxEc3pmti32PZpkB5zOZ" +
	"hSi1QuS5UjgvmKn5OuDEXfC2hYUlVNfbmwOapmHfvr0g0pQKLUSzMiqN4eGhujY3YEFCPIS+olpSDjU8" +
	"nvdP8/BgldhhgCUGFtvOgDdisRgm9kw0X8iIiF5/45xy/DA0nI1QoFDcE6JzIapXCp0iRZ1ms5TEhYJJ" +
	"WzpAQTXSWKivWJrPNaVC8XgcExMTWx3AKAfAfmvB3t5EYHl5WSMnOZilmDJCxhMADYDhn067sjY0nNmk" +
	"Aqvoh2uBs7+mTQ4XGpwReQXZZszOzibcYxWbiITnhFF3OAbEAHQSYAnBhkaupLJTkZkdKXRmJxn9dQS+" +
	"/rZf2ZgTovaRYQecnRlDMPPc3Fy360AVQM1zwgi1gBqAOICev9YKX92cvjF16OAjRET4r8bs3M8w19Zu" +
	"3L9/v98zHoDdKIm9MKJPP716obpeyQwMDjzGgnUl5SIQC7cDW623vOfuXgtrhdvffP3tRRdcCqtA2AHh" +
	"0lSemZ65MTM98wqAHgAJ97u6O9MW7WUzgyUbbNeODQDrAAoAVlwGbDn+jNADPAdK7vyX+x3NNd4Ls1Yb" +
	"L9vg/dquPcING8+hWqQDzMxEJCRHanJIhX7bOTjCGZacYVlKjVALzW7Cet5H7UT+LQeiHAKH+oq/AUU7" +
	"XkMzsWsLAAAAAElFTkSuQmCC";
	
	
	
	static String view_grid =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAARVBMVEUAAAD///////////8AAAAgICAi" +
	"IiJERERFRUVHR0dISEiZmZmfn5+qqqqvr6+wsLCzs7O2tra5ubni4uLj4+Pk5OT////6xN3CAAAABHRS" +
	"TlMAwcLwZ4/dPQAAAFBJREFUeAGdToMBxVAMfLZx+2/6bbaNnSNLiAHgJwE9FdD9QMondy4EESDlyZ0L" +
	"I060dnKnAseN+KmAqiqsO7lzoagCbU7ubWXD21fojCygPfeICVzZH65+AAAAAElFTkSuQmCC";
	
	
	static String summation_sign = // capital letter sigma
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29m" +
	"dHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAACzSURBVCjPY/jPgB8yEKmg0aHxf93/6jPlR4vP5P/I" +
	"+p9yFMOEuvP7/pedKerJ7cmYnNwTOx9DQaVB9/8J/3McILyw/VjcUFA//3/a/QQBPI5MOT/7f2QBHgWx" +
	"CRHvg2bhVBAjEHY/8DaecAhd73/GswfCNvmPoSA4we+8x2kQywLoTP33aAqCDHzeu79xrLepN+83uq/3" +
	"Xwvdm94Jrvsd9lvtN91vuF93v+Z+tX5S44ICBQA4egHkwuNCKQAAAABJRU5ErkJggg==";
	
	
	
	static String settings = // cogwheel
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN" +
	"1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMjSURBVDiNZVNd" +
	"aFtlGH6+n9NzkpM0dYmk3bRpu3Yi+3FFymCNoBdlpl2ZDHQ3u9jGvNmuxGXZAkPwIpCFMbwQESeCP3eC" +
	"IjpErNM5221Xtpnup6PtMkzanDQzS87Jdnq+7/NmkZI98N48PDzwPu/7EKUU1iOby4wAGADwdSqZFtlc" +
	"Zoxz/pnneQdTyfSvaANtJxhjU6FQ6FNN077K5jKvcs6/2TK0ZZOu6+l2LQDwdkIppe+bfKNj6tLPe5eX" +
	"l/cn9oxrmsYxf3d+RzaXiWuadpgQYriueyyVTNd4NpchhJCjlNIhIcQC51xyzjGR2GsKIcAYAwD09/UH" +
	"V8orP2weGDRv3b7puq57AcAlDiBKCPlo50vDtPaw1uzrjRmUUgghYFkWFBQi4QhGd8f9SimslFcwl5+1" +
	"AUy3Vqgwxv5cW1vbHt8d9wNA4X4BV6/N1JvNZgMAfIYvMDKyK9gdjaJUKkJK+X+YRCmFbC7zLCGk9Nab" +
	"BxijHN99/2290WgcB/DlE93BgBn4cDwxEbQdB9Mzf9RrtX8NxtjnzGd27NI07YtQKLShPzbQUbbKWFxc" +
	"sJLvnjoUH30FT2buypXLx7q6nukMmAHEemO6aZqsWCpu5ZTSqW1bt5t9sT5IKaFxDih4T10H8DSuQQiB" +
	"a9dnnOqDallKeZxSyn6by88+mrk63Wg0GohGe6AbeiSby0yue65Jw9Aj3d09cJwmrIqle543nEqmL7Yy" +
	"6KGUXhjcPDQ+vPNleN6a+vGni4772F1UAHS9o3/PWMJPKSWVyipu3/m7WbbKl4UQidYjWYSQHT6fH5ZV" +
	"xsaNm8iRQ2+bq9XKNiggHI6gWl1FPj+H6oOq9PlMn5RyDEC4ZRBnjIVt28bSvcX6/N07/qHBF1gwGAQA" +
	"FIt52LaNv27eeCSlPMsYe5EQMquUqrYM8kLI60tLC4894X1Srz/8ONTZtaFQuCeXCgtuqLNLPv9cr19K" +
	"iZMnTr+3PlzS3kYAOHf+7C/d0Z7XiqWiI6V4nVF2RjeM0WbTISdPnPav1z7VRgDwPO+DYumfGqDeTyXT" +
	"vwspJhzHfkcpNd6u/Q+HYWPb3U3S9QAAAABJRU5ErkJggg==";
	
	
	
	static String mail_send = // postage stamp
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA3X" +
	"AAAN1wFCKJt4AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAR1QTFRFgICAlZWV" +
	"kpKSsLGssbKtsbKvsrOvsrOws7Sxqaqnqqunqquoq6ypmJmVmJmVmJmVmJmWcp/PcqDPeqTSf6jTgYuT" +
	"hazUiK7Xiq/Xi7DXk7balLfalqm7lqm8l5iUmqaynq+/nr7eorLDo8HgpMHgqMThqcTiq8XirMXir8nj" +
	"r8nkscrkscrlsrSys8vltMDNtMzlts3mt87muM/nu9Dnu9DovNDlv9Ppv9TpwtXqxdfryNnsy9ztz97u" +
	"0N/v097p1NXU1eLw2OTx7e3r7u7s7u7t7+/t7+/u8PDu8PDv8fHv8vLw8vLx8/Py9PTz9fX09fj89vb1" +
	"9/f2+Pj3+Pj4+fn4+fn5+vr5+vr6+/v7+/z+/Pz8/f38/v7+////G5V8JwAAABF0Uk5TAgwO9PT09PT0" +
	"9fX19fr7/PxDxSt+AAAA3klEQVQYV2OQ4+eXY5JDYAY5FxdmfmZXIHYDYheggLObm7uHh4cnGHDyMvBy" +
	"eogJQoGYtxwjA6Ocl6AhFAj6sgC1sPgImsnIamlp6VgI+vkCBbx9Ba1NlEQV7KMCRAK5gWZw+QnaWVnJ" +
	"6+s6xIkHgc3wF3SytbV1jIuLFQ9hB2phDRQ01VBXV9fWsxQODwEK+AcJqUpLKdoYG2oKRfIAzeAOElJW" +
	"UVEzNzJQFYoGmxEkAXOYZAwHUAtboH9weFhIZEx0RHR0JFDAl1uAO5BHgCcUiEOC5Rh4+XiRMB8vAM8X" +
	"J6pC9hEGAAAAAElFTkSuQmCC";
	
	
	static String mail_send_32x32 = // postage stamp
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAUpSURBVFiFtZd5TxtXFMWtbmpVKX+0VRWp36AfrQK1ogXR" +
	"pCpJS5dAUhqyQNoqkIV93yEsZXMAL2CDHWxDMBgv4ICNsTHGYE7vfTNjbPDgIJWRfho/jzX3zHnn3TfWANBUVN7HaRobb3xw" +
	"mWOGa2sUAamHTj8T4+/4fBljPjIKCAS2sLu7g0TiSIz5HI3u/e9jVQFcnEVcJixCcSRNAH/JF/lHj4fsyKuaU+XbVKrfjqph" +
	"u7i38vSciaQAJSDKNHCR9hk3OnQedDL6dLr03gvB98h/YkIwuE0OJLI78B39uHfWg5qxVUHteGbqMjFxlv45LwqfmbGzE8D+" +
	"flQ9AxyQQGAbBU9NGDRvoFHrStL0MpV1QXMqU+oMz2/gWs28EMAO6DM5oBcOJIRNrHZ0YZOmYR3VnVOo6tSifcpFU+IWdF6Q" +
	"cYsfP9SygGD2DASDAaFWu+hHr9EreFjThdy8PBQW/YzKuh700XdM/6w6/NSDJp/4PGV7g6L6BYRCQeGAwahTd4BtYrXTji0x" +
	"DQovTF48bn6BvIJ8XPupGG3jViqymcYIseQLI3YorfvjY1ra0UMsundxs8Eilnkstq+eAQ4IC/ixbgHG5QBGLZsYsyr4BSNm" +
	"N8oeVSPn6xyU//McA/pljL/yC7bDB1A7/ui0kYCQcMBo1GdwwKATDoRCO7hRb4F5NYiXZJ3EFtkoY5co/+sJcnK/Qu43uSi8" +
	"fh13H1RgeHgIh4eHGQXc7XYgHA5lzwDbdLPRAqtrB7qlbehTWZYY0tuQ/30BioqLMWP3o2/ChO6+Ptwpu41bpb/B5/OeEXCv" +
	"Z0kIUHWAg8EXWUBxkxV2zy7mVoIwKThPMBPa+RXobD7xmUkkjkUh56oTjU31mNHNUAaOkwIe9LGAMA4OYuoZiMViYp5+abZi" +
	"mcK0sLYDi4JLwqpC7DCR9sRHR0fifspR0b+MSCRMosiBWcNZB9gWdoBt+rXlFVb9EdjIBcaeilfCcYrQXlw1gHw8GniNvb1w" +
	"9gywgN9bX2F9O4rXG+EkKxuRdDYlnDKuN7Ttplh++vh7kAVExLSQAwfnOLCLW62LImy8DAXWk+WoLLkJBWpYk1kwOQMUQge1" +
	"+gji8QP1DHBAIpFdlLQtiqU2MOejBuSjjiY1oyGGOtywQGo8IwsS/ypYJEYtJ58N1FM4hLzXsAOzag5wQDgoJe2LdAM/OmaU" +
	"3s9bsAfdMj0Gb7JNi7ZM7dYfisFGHc9Aznlo+qZt0gMw3Ece9i+lvQ2pZoAFlJKAAXryhkmXQOyGWnkHpN2thWidcqN12o02" +
	"EsnvDg5vmIK7J/KipYIc3oW1kBDPHbRyYJk6rezAXCYHaGmwA5xUFtBt8ODpqBPPxiSejztRw+8B8h5fP7kmaNCuCYE2d0is" +
	"HO6c61t7GKei7Ewz7aI8bZKAKHXKuHoGOCAnAryygFUqvposXjuxhrpTxRvpHYGdaZpyJd8BWlLeB1gA9wEWIDlgzOQAZ+BY" +
	"LJUS2QExz7PSHDP9NJ8MTw8jAmr2pQU0E3ydQ5j6NqSaARbQpVsXIkrbbbjdYcMdgnezsi674M9uu9hcyhlaXvd6HbifZCkD" +
	"DlpJHhKwf84qkB3gpL49UQE/2Qn7GTi5fu5eEI/HkxsIn7ONOVAXGXPx1GnQaDQfEpqPUv+aGYz6A2l31IuWpbRNPqeO6Xpc" +
	"/n38ImPlkAV8ygI+Pv2n8erVT768zLEC1f6cBbxPXJEHn8mqLhOu8YVc74rIgAiDRvMu8Y4yviy4BvEe1+Pxf4jm5YOycGM2" +
	"AAAAAElFTkSuQmCC";
	
	
	static String unread_mail_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAYUSURBVFjDxZdNjFtXFcd/577nZ3tij+358HyGJEwnExLU" +
	"UpLChj0bJCQWpUJCSEiwr5DYIajEBglWCLEAhIRg0xWggIQERI264KMoJCXTKG3TNlGYkM6XxzP+eO/ec1jYM+MZzyRIpe19" +
	"On5PT7b/v3PuOefeK2bGex/PRry7XCRP0oo1LxLFZsGPeNelS8rk+Ta8GI76pbx3gKdOtNs6pirVSLUSHCdESQDMkUbKjhPW" +
	"k1L0Dlzf+T8CiNvefnLCzMZEdDaCuiE1MyuLaA/AXCoiTcE2AjyMouh2sXjj32B6BIC4F17Afft/lG99dalu5bguQU+Tc3Og" +
	"M4hMiFCOc19fyrJf3BM6LTOamK2CWyHT+9she7Vef+OtXQgx+07M2itTmDuLST31knu87yHvpTXu4u6UuayOhAmTbAzRURd/" +
	"Zixf/FHd+9+00ta31kRkB3NbYrl1LFo1i1csVK6219218bOX/iO2+rk5n7mvEfFFJzJrSvw4AHNelNQReVG6jigTyMScSn7k" +
	"1+LcGcDotJ/Dwk0TzRnkjJCzSBOPJA/El38eO/tJjLmzRPLsH//yxNL1WzV5XEokOU95dIfxsU3Gag1qtU1q1R3GanXyyVfo" +
	"iQMISfI90vSHkvqXZLORY2OzxOZmNa6ORKcufLT5nDd5KU5N6rHZ3PVbNfnG89/Eueiwv1jv1nu2BqZ3MHsd413i+BLOPYVI" +
	"aQjWRacpFH9AoaiURq9Tn7pClq3z8sv35cLpxlwcuUmHl5whsRm4KEJVUQ2oBkLw+BDwPiPzKWmWkmbbpH6LLGvgs3uI1I8U" +
	"P4SCcx9H/dtErk0ul2H4HJnk3ODXQvCoKiJu3wDpXyBAAMuAFGjTaX8Xs7XHVk3a+T7BljHrEEUBcdpHG+SUiK2tBiEERAQR" +
	"QKRvPXkO5ajZCt3285ilx4p7fxXvL6Oq7P4LJsMACFQqFR48WCGEcHQJkoDEQALkgQKqf0ckHAugdhtYR6yAkBBCBBbbMEB/" +
	"TE/P8OadNwhBwaxvvTw0ixErgowAJzBKwBRQfETdelTLKCWMElmWQ3BHAPRFxAnz8yd57dYyID3h/ieSBxkFyhgVsBrIqYEp" +
	"2SSEq6i+vf9O26hNYlYBqdDuFBB6ERhqOrutOZ8kTE1Nc+2f/+DpT1zEa8DMMBOwadRWEZvAaGGW4LMrhPAHgr8MVHrz6yZx" +
	"0efR0EGtTtBJYIKVB5tgK0fkAL1wmypqRrVapVod42+v/JVcnOwBquXBTmJMAtOoVmm3XyTN3sHsDEiJLOTZ3t5mp/V7Oukd" +
	"fJhBtQ6co9UqDBToAe9BzVBTTHvzPzszQyHJ8+crfyKfFEiShCiKcG4SYwFsDuQU4haI3CJx/DEajSnW18cxW8DsDEE/goY5" +
	"Mr+E2tIBl+OhrmeKGYhYv5s5ulnK4hOLXP7db3nmmU8zMT5OlBRwbgmzOUK4hYYVGlv3uX37GifnT5FlXXBTBC2iWqWbnUW1" +
	"hkh0PIBh/VrtRQPgzltvcvHpiwAUR4r86+YNmltNtppNtptNEKFUHqE6GlEuF5k/+VlGqwkjxUluLt+jPrVI0BKmgvWv4wGM" +
	"vQgg8GBlhcWFJYL22nGxWOTSpU/1k3HQdO+uarQ7Rjd1nDv3JMvLrzJRL/ek++V8sEkfIlDt5cDG+hqzs/OEkJFmKap9IdW+" +
	"4KANwPSFvM9Y31hlcXGJxsYWx+283KEaQE3ZbjapVsbwISMLvl8Vu2aY2pFR0EMQQQMbjTVmZmdpt9pHQhxu7KTdLsXiCF79" +
	"UIeyvUQ96DFm++IHpqRn2ztbjFZG2dlpwaNzwHAuQk2Rfh4MCg82qqEIcJT4/nO32yGX5DgchKEqQAa8teEOud+U+6151wbW" +
	"DI7ZVWkIe4vhHkASS9ebehHodDqUTow+ajc4tG7svbO9vVPfSxsGN2i3WrvLapaqZbEX/xBzdz95fv38T3/2Y8cHMC5eWFXM" +
	"7qq5h2LLX5ih5r/shS9hchJnsbxPwtbbnGWqepc4/lWs+V/2zgWv3Zhk2hbSjDpec+TeJ4IMiF2mgYeFqPA69aW1AycjPtCx" +
	"dzIyPszh+JDHfwFiNvTMx0YJ0gAAAABJRU5ErkJggg==";
	
	
	static String read_mail_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAA" +
	"GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABN0RVh0VGl0bGUAT3B0aWNhbCBEcml2ZT5nugwAAAGkUExU" +
	"Rf///wAAAAAAAAAAAAAAAGZmZgAAAICAgAAAAAAAAAAAAAAAAIiIiAAAAAAAAAAAAIePh4SEgISJhIeMh729uL7DuYeLg6am" +
	"o6qqpoiLiImMhoeKhIiLhdve297e25KVkJWVku/v7O/v742Nh42PioyPirq9uL2/uPX19YuNiIeKhYqMh5mblqCgm6CgnqOj" +
	"oKiqpbKyr7S0srS3tLm8tLm8t7m+t7y+t76+vL7BucHBwcHDwcPDw8bIwcjIw8jIxsjLxsjLyMvLyMvNyM3Ny83Nzc3Qy83S" +
	"y9DQ0NDSzdLS0tLV0tLX0NXV0tXV1dfX19fa0tfa1dfc1dra19ra2trc19zc2tzc3Nzf19zf2tzf3N/f3N/f39/h2uHh3+Hh" +
	"4eHk3OHk3+Hk4eHm3+Hm4eTk4eTk5OTm4ebm4ebm5Obm5ubp5Obp5unp5unp6enr5unr6evr6evr6+vu6evu6+7u6+7u7u7w" +
	"6+7w7vDw7vDw8PDz8PPz8PPz8/P18/X18/X19fX49fj49fj4+Pj6+Pr6+Pr6+vr9+v39+v39/f///f///1umC4QAAACMdFJO" +
	"UwABAgMEBQgIDA0ODw8QERIgNDQ1NjdCRUVPUFNcXV1eXmBgYmJkZGRkZWZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZm" +
	"ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmQ+lF" +
	"kQAAAfJJREFUGBkFwctqnVUYAND1ff9OQtKTSy9BkVK8tQmKIBQcKaJTceQT6FTwkfQdfAcHCoJOStEiLVJK02PaaE5PTnP2" +
	"/lwLAAAAQABgtjVNk9776hyABsDBwWibX/thtZ61FwACDq/uEQGAwtnpHA2ufZMAABjfz9FgN08JSUgwlP09aIAHSzA7Erh/" +
	"bnYbaIDbUqQAjilAw0YIaRJIMAQ2LmlsXcdf55gdpwBp4PCflcaNHvLdyCBDgiGH7DceS/a/g0SGjIiISJF8u08jNiYenAMA" +
	"dt+T22iww5GQkUGGGtSwBQ1jZ7H6cwkAuPK+7YGG3D1b3zKFKaZg0ql+sZolGrz99+ajJQBg587FNWgw3frjMDJsBg2sOTlc" +
	"QIOMO79tTuFigwzU8N+bF6BBRH7wy3Ys59VTZb6+4/x4KaHBVLY/+uly9dlriXHv14PND19FBTSIUDs3H361XvQx5FtHP77R" +
	"K2qChAjx4ukXy9V6lP7q7PTLZycSSMjM9e+fL0ZVVTfG5ZNPH78EJGT4+eNFjarqOurZJw87kCDu3b0YVaO6bujG/O4jIGE8" +
	"uXmpRo1e3dBrDM/fOQENFtnRqTHoZehjcfUlJCwnDAoAjAZNrJ5fgUJhUJTi6SoqMveuNwAAwHr+74jMnDIjAABU9TH6+B9N" +
	"n9QuIabq3wAAAABJRU5ErkJggg==";
	
	
	static String mail_replied_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAcnSURBVFiFrZZ7UFR1FMdvmoGYaWhBWT4qZnqMPf4wbZoa" +
	"p3KyqT+YmmaaFEPUHwKKDxY1BEJkXyyDgOJYlFNBFKY1KiSQgBuF2y4LyyYswcIGbWvb4rL3d+/u3rsMQ79z9+HuQggVM5+5" +
	"9+49nO/3nN/vd+ZSExMT1K2QyWSLpEXSNVLF0Zckckm8RF6Q4EUSD7/BO4iZSa5wbhlwVHF01YkTpe8NDvYnjI6OJjqdzu3j" +
	"4+MIgPvR0ZHEfvKurLxkC8T+awPNrQ1rG5vqtzdcrkUhNF+aHZdDgZxNTfXP3tJAU0u9UBm5/1+BnJD7lgagWvgHu90m4HDY" +
	"g3AEYJiZA/GQEzoxKwN9RgPSG3RTYjQZSHJGwOkMBd6Fxv0LA+FVh1YVLuqcgpvvIX5GBhBC86YyMDvhqY34DYDGlAby8vIi" +
	"5UWS+GADwa0Mbmm4CMdNJjzGbwA0QGuSAWlhwVtnzlRvgCPkNRDc+qmr9opx0xBmgOSurq7cAFpTGBAjj8eDgg1Mbn14xV4h" +
	"j2cywSYAyHmZ5IZ70JpkoLBIKgQ1KxsCBqZagtliNPUFDPhzT2tAo1UJ1+mr91fqmQHeTkBOlaZtegMwrfTdOkHIZrMhQ58e" +
	"afWa/4TB2C0UASZ0eq2gMW0HTCYjEbcii8WCrFbAKgC/gSnAOyXtAsHTMRx/jD8eBlugAxR120QZFTGRR80JMeAgbR8aGhLQ" +
	"6jSoTaX8T0AXoBCzmeS0DAUMjO6lFtOHIjYyOdFPsCLqyYABRphcZAMa+whGoSMmk4kYMgWMQTKz2SxgsZiFbk3GHIiBPBar" +
	"GQ2ZTQEDllTqMVt2bL775Lr3LOnUzoAB/2YDE3q9HvX1GQh9AUN+wJSf3k/3l/4iitP6DQL+dwaDAVltpAOk+mADPduoeEv+" +
	"o2dx+YtF/Yg6edMADA8fsI5arQZ1d+sFtFotunDhW/TVV1+g059WoMrK06gp84XKzuToEW3iHY7a2gs+030COp2OiFsFccGA" +
	"5aaBrgTqrO34yz/YS54/37WFqgsYCB8gYKKtrQ0plc2o9lKtsAmF74Xx8WRj4Ya6XtHKEXfdQbdu2wIHVF5RcRK1trYijUYl" +
	"xFqssBx+A949UJ6XKurcGvGbu3Z/j1WxRteZQJ0IGAiZZr4zDPtA2aoUzjWYso8MpxqyVl/tP/zYDa4h2z2mlLk7k6IcsHQQ" +
	"09x8WVgyaD2svbAfwISpJ+XGj5X5PyfdNWA79cb1sSsS+x/ipwY7N1PbgwyEDhIbOUKwDHAP5/nGgHbvtX0reobEz9r5xly3" +
	"q/RJhm8q4K7tjr3RsTWK9tOeGEFrEyPpjiR4XkBDh3RoocOY84Rt5PNNrOfSfsfYlXzaeGjlgHYTtS5gYHzcIwCCsA9g3b3i" +
	"DmRWn3+/K3Xp8PWSV2i+4bCbVTyMmZwo2nX6NSdHTPjhm8Uc3yLh+CtSgozjlYCc41sVHN+U43ad2+LkPnzGyjXl0p0Jt/We" +
	"eZuaG2TA+6ULonqy8YR9QMQH6kolXcmL//yr4k2Wq8twM+JYTB+OxHTOAoxzF2KcvxgzBUsxI74HM9IYzMhiMVO4DGPFMswU" +
	"LcdM8UrMEtylq2hcvJz2fJc6OvLxG391JFBHQgaRHzj3MBNAnAySnfpdsYN/HFvPci1ijpEtZ3D+XT7RaEwXLGUcYoLkXoaW" +
	"xTC0/D6GVixjcNEDDC4hscdWMGzZQ9hVHoddHz6Ond9scnLKPFqXFDH45UZqJUWmYkgHYPd6x6n3q8hsHk65VlMo16FF1pFP" +
	"3mb577PcuDiOYeQxGMtjvYJFDzJ08SqWLnmEpUsfYXFZHItPPMriU6tZ9pO1rPPz9az7/LtOj7qYczaKXL0Z9w/XxlObifgC" +
	"wrygQcR4ZzcRtjtsAsNmU0p39y+71Rc+OtKRvOT36+WvYu5KAeeqWEsqXMG4v3nXxauKef7nEi/qUkIZ72k/LtxzP8k5Z0se" +
	"x17a57KUrKPVW6NGal6nkojwEp+Bm3vAKx4KOU7J/f2/pnV0daRfrf86qz3tgd4hxfM036bgXF9uZHnNcV63K8ah2RLBBNO+" +
	"NZIw36FOWmhT74j+XZW2zKCSvnn2UOo7HxDR+wh3E4TPM0qhkG+Dtv/TxyVZiuTh4d/Senu70ztVSpE2c7Vq4OjTo2PqY9xY" +
	"VwXXnhiJq6urcquqqnI/q/zsA7hWkeeamprsc+e+zrp48eKhxsb6Ay3KlgyRaE+6r/pIWH/BQL40f03RscLtMoVkx3SIpWKU" +
	"eyQ75WBW5u6LO+Lqeg6ssvMqhVudMI9OSUvJTElDmTtT0QG4wvOu9FRR+t60/fsy9uzLPJixJzs3K00k2vucT3xuwAD5iyDM" +
	"J0TNgju/f4tK6t29ZLh9E/Uneb6HcC8hxncPVUYTFhEW+tZ7vk/rdsKcwAcJPPgc3T5brm6m1pNxWj3D+Lk+rTnBX0R/Axot" +
	"oqSeXw53AAAAAElFTkSuQmCC";
	
	
	
	static String delete_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAfdEVYdFRpdGxlAEFjY2Vzc2liaWxpdHkgUHJlZmVyZW5j" +
	"ZXMt8LM9AAAAFnRFWHRBdXRob3IAQW5kcmVhcyBOaWxzc29uK+/kowAAAB10RVh0U291cmNlAGh0dHA6Ly93d3cuYW5kcmVh" +
	"c24uc2Wh63rNAAAHO0lEQVRYw8VXa2wUVRQ+d+7Mvl9dcNuV2ta2C0bKUhNCYjAmRuM7MRr8o/ERH798BCMaVPCFAiZK8Bl/" +
	"qIkm/FMMIT4So6I/jEGiLfRBW0BaoC/sdkv3NTszdzzn7ux2ty0V/eMkJ/fOmXPP+e553TvMtm34Px8F/udHvWhJxtiZRGK9" +
	"IsRGnN+CnosJ2w47n2bwfRLfv8Hx85ZTpw7BRbqW/aMcY8rZ9vZ7QYg3WTDodzc2epXlyxUWDoNyyXIAywIxPg5iKgUilbLy" +
	"ExMFM5PJovzmy0dG9iIQ8Z8BnGlrS+DwFff54t7OzoCSaAbFxUEYBjC9CFYqLeV4XQQE8imeYiYP1skRmO3vz5iFwhgT4rbW" +
	"06eH/jWAkba263HY57/ssoC6rlMRmRSY3b0gJqaXTqpYBPgV7cA0HxSPHhMzo6MZU4i7rjxz5vuLBiCNc74/mEz6oS4IRlc3" +
	"iL+mgakqaNdcA2rHauAda+RIj9nTC2YvgkMq/vwz2KYJSl0I1EQ72DNZODcwkEWv3bEYiAUATqLbFds+HOrsDAk9D2b/AAkB" +
	"b20F365doK5N0jJMjVpFJTW2BJPbsgWsoSEgFm9uQm+4YLKv73xRUdZ1zguHMj/TMXkOBOLxgMDdGn3HJNv94AMQ/HIfGl8r" +
	"RRSFyRHz06E5ntrRAcF9X4Dn0UdQuwLmqWGwOYe6hoYAt6wDUuhCAI43N9/DXa4VrKlJMXp65LY8D9wP3i3PAfN4HaPVxheb" +
	"I7nc4Hl6M3gefqgUoj//BDUWU0h3Vyx2z+IAcCWGY3cgkQiYp0+DnckAb2kBz6ZN0t1zxJwQ0K4VSdW8alnPE08Ab2sDO4+V" +
	"ce4cLGtuDtiM7a72QgVAX2Pjeub1+oTLBebICAaPg/+NXbhzTwXj7j1vwcuvvgQzM+l5oEDytr24VcpU9oS6/Dt3SF3W5KQc" +
	"udvt/XXZsvULAOBkoz8a9ZooaAsB6oYNwDHm1U96Og0DAwOw/bVXYRrnQtiSaE684yeOw+zsbM0ankyCipVDOq10GiLRqA8d" +
	"sHEBAGxXt3K/n1uplOyi6pqOSnbTO9FTm56GS+OXwtnRs2jwFTQ8LYnmxKNvTz6+yZEvVwaCWLNG8gSGVfN4OMb61gVngRCi" +
	"3sbMp3iRsLJ6tRxL0WJSWTgcghee3wav79guDb78yoty7cTkhDRO30imXJJEcjPJEgAoFGRl4JlRX+sB9Al2q4gglLpeWtSx" +
	"urLzUq8ojSUQW6E+Vi8NE9GceCXjc7JlKgMQ2KDoYDDQVjkR5zxAwniw2I7vyrtYrFMv1j1rwcI84HNryIaoWq+UpRFOmuEh" +
	"Q02DEob6QLVSDJEcKeY7dr5e2XnZE8Sjb9WyZSp2H5E6bSpZBED5XEZUSUJ8m7CKRQBNk9+M7u4aJURpzOKdu3bA6Ngoxjwu" +
	"3U5Ec+LRN5KZv67Y1VWaIwALN4nun1hQBZZlfW1ksxb2ArmD4pEjVUpKO3rvg3dhbHwM4g1xePaZLRAMBiXRnHj07Z1399Ss" +
	"ITK7u6RO5nZDPpezDLS1EADeZKampnLM7y+hPvgTGEePVikSEAgEofXyVjT4LIRCwYoBmhMvkUhAKBypWUOh1H88KEMA2Jgm" +
	"UqkcJuPnC09DzMpfotHxppaWmD4zA9bUFKgrV0L0wH5E7qk6/ZgjvthpWC4/p38UdZi+404w+vtBCYVACwRgYHh48sZstmFB" +
	"DhADy2Pz6NhYRq2rAwqFeeIEZPa8LXdCHW/OtaLSBctU5peSsPSeee99MAYHZTtXMVTDqNu0rM3VZVRzGh5Mp/fq+fyYyOUE" +
	"b2jA08QDuU8/g9k33wKBTWQORLVBURNvCUgvSOC5jz/Bs9wNLBoFQ9dFFq9ovxUKe5e8kHwXDiewORxuTyRCRerf2SxQebIV" +
	"KyCM/V5NJpe8khm9fTC7dRsIPNCosyq4CQ35PUND59HWutsLhaF/vJLtDwRuCmravvaVK30mKpDtGUuUEknrXAvqqlWg4VlB" +
	"lw953uNVzDjaAya62/z9D9luGZYzlTTHtb2Dg9mcZd15d6Hw3ZJXMsxDAusl2unx3HCVpn3Y3tjo0+JxxUKldNeTRLVMDWUu" +
	"geVRS0bp3shQlqNcYXxc9A0P5/pM89EXLIvug3mknF11Va8AYHStAfA5RCBC13F+9WNu9/aI2x1pSyRcAhNJGsByYtQxq+pC" +
	"AkMvCSSOp96xwcHitK5Pf2Saz/1gWb+QYYfyaDN3IQ+UjRPRX08Lomq8T1Vvul1Vb/Z6vVpTfT0PRCKMmgq1bekF8gYm6fl0" +
	"2h4eH7ey+bzxrWl+tde2v8YveLuBYaSs4wECoF8wB6rC4HHGGNIKNBW7VlGSGzhf1855wiuET7VtN63BBq7rjGUHhRj8VYhD" +
	"PwnRhYbP0b8N0hRSwSEybl30n5EDxkUXYyTNIbcDzq2V3m1DYgDdMUKjQbnpvBfnG/13/4ZL/68yp4f9ZyV/Aw6RpnOWYQwb" +
	"AAAAAElFTkSuQmCC";
	
	
	
	static String star_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEkElEQVR42sWWU7CkTQyGn9F/jLVt27Zt27Zt27ZtHttc27bZ" +
	"/1YuZqdqj3GRmpnv63SepN+khzVr1sTYXvpiF2N/sVg5v3Xn6C8HzBMF4Ok5irx149crZzonCsALR9Y9d8TrtQu+gCZBAXz3" +
	"YvfGlVfDO1JGVeDu/XOUTlCApxcZ+OAcR4BMlw4x86UzWwFNggAAmhdOhB1fSlMgWf8WFHjpxGv/vaRIEIBbx6j88BzhQErA" +
	"Akh28wR77p1mVLwDAJpbKpj7VkYDtoAOsNo+k/p3TnFrcmX08QrgvI0014/xvE5ZsgFmAmUAUl45QmDQXhrGGUDQGazCD/wR" +
	"WbFLh6l1+SDtQg+y03sHG4EkgE4AtIDtqZUMDT2AT/h++lw+TPNLB6kUdpR8IUdI5eDw78rguwZD8D4WBu/lrDJ/ZXeVfVL2" +
	"QdmdoD34qc8zAbtU8G2smNCLMoClseoBs9KFyey2iQV+u1irKnFA+TkF7yFM+T5R9lXZy5C9XFWf7irenpCdpBJfNMdXktVn" +
	"B6Fe27m4dRp5erYhOWAN2AB2knFyII18Gky0oZM16UScSQF78bVJnhyb6UNI576FZT471RBdQ3lAK77ogaTVSpH3whqczq/h" +
	"XPlC5ATSAqmBVEAKCZwUMBfnv8QJ/IeAyvqU4p8mqQUZji9jrdMGrvZtQXkghazXIGdoBaSzsyPryeVsvLiWwHXjyQKYyUKD" +
	"mP5fA0c20yFrxc9sdFuSqMSOKnOsVY58QAbABkRDRkKyQKgPL2DU2VXcObmUIrG5aE6vIc2ZVfidXMbm7OlILxWxRoIrwzQD" +
	"M+SsN02ltSrbo6OLqR+T4CeWUUD5394/n4kSOCVgienxRXCWaWYPouLBBdzdv4CB0Qmu1tc9uJAnGybTUYSbQrSjiXQOCIRB" +
	"FJxmah8q7ZnDi8mT0UZ1Wu6axan1ExkiQk4qldVEaxCJoGxmDaT7xsmcBgxRBNCvGs/kFWNYLZU0RHRTRrrZyrGsXDCU6YBZ" +
	"FAEMY7tRb80E/I19YgqgU5n4D+1IfeC/qFYgX2ZSrxzHu8GNsY8VQB/Vw4tH8D6z2hD+nudLRlJtySg81WfPX1Jio5a2mT8M" +
	"99n9qRMrgCl9qKM04AnYIu2zeBCp5g5l+9zB3Jo5gB7zBuM0bwie6piKGEFYTOrJkhn9mQloYgQAaCb3ZsaYbiwDLP/vgln9" +
	"6T2zP08U2NwiuUgLfyz5xO50U88fzuzHkskDsAXM+rWi9bQ+OAO6mALoJvTEsXdz2g3pSMnJffCc1Aunbo0picx4ILl8T1u5" +
	"NJnV+jUK+v6E7rQvm4dMk3rzrkExLGMEUKYMFkrNH4Z3Ypf6fDy0Az2AFJJ1Mhndehkw9gKUqkcLKo3piv/oLjiqz8eD2lIx" +
	"RgADW1NWBf45vCPbKhcluwRICVgjvW1yCVlIRdJaW5NSBR6lAN4O68T4GM2BAW1o0Kw6zYBMQFrJ0kzEGNEEtZErPGPRPJRW" +
	"ifQWn6gDIK0EZDT696szzSQCXzMZwenluPQxATAHLI3LHVUzORbLiDohskwiDxwpSMT7/AZA2qVcxzF33AAAAABJRU5ErkJg" +
	"gg==";
	
	
	
	static String save_24x24 =
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAEB0lEQVR42mL4//8/TTHRCgNmsRr4zWI/7DuLbWvAHFYzsi3Y" +
	"vx9QSzkAx5cEYfxcOpTOto2y6654tm3bdmzdJovYyRqxbWNtxk59Nz31r3d4eedLVWd3Z76vf6+np1/zUZYmQ725UY9fx2Py" +
	"c1C58Cleaz0bz8qvgkZfC4NZA71JDZ2xHkaztp68YoA4uW56bmJ7c2sTOzvb2N3dwd7eLm7LOwbDK9X40XkD/+71ebG1vYnN" +
	"rQ2sra+BPFqDWschUoCGZoPaapvf2dhcx+rqCjOugr6zRAIg7hBgfmEOyysxRJciiMTCWF1bYWszO2pdrVoSYLRo4fE54Q96" +
	"EIoEEGPmlbVlgogAVtsi7ZGGtORhXheq6yogCaDzDEeC6BvsxsBQDwaHezE00o/hsQERoLHZgpGxQabpQ/9gD3r7OxEI+lBZ" +
	"UyYN0BrqEGXldvW0w+Gywut3IRDyIRINiQATE2OsDy44nFbMzk2hubUBHq8b5VUl0gC1rgax5SjaOprh9jrh87v5U4XCARGg" +
	"q7sD0zMTGJsY5lXojGo4XXaUVhRJA+o0VaxxS2hqsaBn1oBnSy7B65U3oWYgWQRIU7+NRxSn48Xia1DekMmPxmpfQHGZShpQ" +
	"U1/Bb4PJYuCJq+wfweRLwGvqK0SA1zRXwhJIhGzuCTynuBoFyjzYHVYUliikAVW1ZVhnd1qn1+Dl8muRPXsfVL5H0bOkQnzP" +
	"nQIgruc2vqbwPYwPBi/GswVXITM7lfXABWVRgTSgoroEm5sbqK6pREbZF7hbdgLe7jwPGZ5b0BbLFgAy793IcN+MtzrPxT1M" +
	"82Xq68jISkUwFIBcJZMGlFUW8QFzOm1YtM6heUCNpxQX4RntyYiz34QC3/0c8IP1OjytPQlPyC9CmU7Gr+zE5CibiSjyFXnS" +
	"gJIyFRc1McPX33yB5198Fs+8+Dju/eZi3F98HD4avgQfDV3Cv9/z1SV45MkH8PiTj+Irpu3oaOWT/1NBjjSgiDUoHA6iscVE" +
	"L7i/Fc1tFqytrSJXliUNULEG+QM0jaX8iGjIoofeM1tbm9jf3+NB32mN9khDWvLEYlFk52VIAxQqGb8JMnkupqbHeej09UjL" +
	"SILeoDlgTS2skYeanJmdJg0oYA1ysAYnpsQJxrSMZITCQaSkJeKHuG+FsNoWkJD0o6AjDz1cemaKNEDGGkTGz7/8RDCaLUYA" +
	"4PMRjYaFoJsWl/C9oCMPDVpqetLBAPZ3ch5rEFXwxluvCsaauiqYzAZRBfGJP6C8skTQkWfROo/k1ARQroMAV2TnpIezczPw" +
	"5NOPC8bBoT60tTejta3p18HWWmhP0JEnKSWeji1MuQ6sgMU1LK594KF7w/fefzf+TpCHvJRDXMH/GD8DwNyulA408sQAAAAA" +
	"SUVORK5CYII=";
	
	
	
	static String urgent_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAdVSURBVFjDpZdriF3VFcd/a+997rn3zp1xJpnJpJmZDBOi" +
	"1kcGrCHQ+qUtWEuLpVRMi6n9IiJKpdgP0m/9WOgDtA/6AFtsRKnBFvpFtASLYPpNpRTbNCZijGYymck87+M89l79cM6dnDtT" +
	"66MbFue913/919r/tQ+qyse1X0Pz//leVRFV5cOM34tMOfiKg2MBDgbYJYCCGFg18LaHP3j40zdV3+RDjg8EcFzk5gh+Zqw9" +
	"snfXLvaOjTWH6nViY7BASFOSJGGz0+HSxkZvodPxIYQzOXz7mOorHxvA8yLxGvwKOHrdzEw8MzdnpdvFZBkGQAQxBlEFVUKa" +
	"or0ePk15b21N/7W+3g3wkod7jqmufyQAz4hMAi/uqtcP3jQ/34zjGGm3MSJbJhVDBC3Nd7v4xUWSbpfTq6u9S94vZPD5e1Xf" +
	"+lAAnhEZB/4+u3//xNyNNzpZWcEkCdZajAi2dJo5Rxgfp375MrZ0HvoG5JcukS0v8067Hc71ehsCt35d9ex2AKZ68RuRCHh+" +
	"Zv/+8bmbbnJhYQHStKC6fFmADOg+8gjR756gPTmJVJgxIhhjsPv24Q4cYKrVMnO12rDCX06ItP4ngGH4wTX1+g1z8/NRfvEi" +
	"0qdp2zEDovlDmCgiuf56tJzIVN8VwQwP42Zn2VurmQljPhHgyfcF8LTIrMKD1x0+PJSvrKAhQCU9VRABwBR3vDFo5fnWUIUQ" +
	"MCMj2IkJZmu1OnDHcZHD/xWAwE9mDhyo1UZHCWtrgxOVokGx7gsA5QgoQQvT8l1UtwLQEHDT05hGg2ljmhH8YgeAEyItFblz" +
	"6pZbXHb+/Fbk/fi177h0EirM9K/7zzSEwqrngJudZbcxAhx6SuTgAIAE7hjbsyc1eU7I88LhNslkx3XJgLIFIISwE0hpMjQE" +
	"tRojoAa+OgDAwl27pqZa+crKoONtEQZVfD/afpop75XOQwiE0mnYBsKMjjIi0jRwVx+AK4831EdHyVdXkT7l5WT9Jdinvb8M" +
	"G6YoH99skoSAESlYEimAQHFe1kwIAeKYuPA3s70I90SNBiHLBnNafliNPFUl/8Lt1MfHAZh++GHat32GLAS8Kr6M3FfYCP2a" +
	"sBYLeNg9AEBhxNRqhDwfoDt4XzgvJ/CqdFS55ujdhQQDYi2No0dphzDgXMtrDaGYJwSwFilYtCdE7FYKBNbyJGmptaj3hJJq" +
	"AQgBzFW9ylTBuQGNcLvHWVOlpoqIFCz2qa+c+ywjL6e5W9VvMWBgIe318N0uSanh+fo6ea+HL9H3ozPAxWdPFMC0sMbEbrjz" +
	"Tnqq5OW7Ps/J2m2ylRXSS5dIzp8nWVggLQK7MlCEAf7RuXLlUyOjo9I7e7afp0JeRbDGFPpuDOoc/rHHOXXyJDf/9HFae/cC" +
	"MHX/fZx98wzxc3/E5XmRgioTpWp2C7/nBmrAw4nlCxfabnp64IN+d9NSETUETJYxkmXse/U1/v3FL7H815fRxUV0aYmpBx6g" +
	"G8dXu2JpvgxIRdhU3Qzw7AADOZxsLy1FXgS7Zw9+cRHKroYxYC0YgxiDFcGJUBMhznOWHn0U89CDjN7wSWLrMHGMZhl4f7UQ" +
	"SwBBhA44C3/esR94WuS3u6enj03Nz9fWXnwRp0pkLZFzOOeInCv2BMYUa75cBR7oqqIzM/hej9p772G8x+c5aZ6T5Tl5CGgU" +
	"sZJlfiWEl+5RvX0HgOMiewTOXX/kyJBLEpI33qDuHHEcU6vViJzDWIs15upOqNIPfF+ivSf3nixN6aUpaZqSG0OiyoUk6Xg4" +
	"fK/qP3d0w3tVFwV++PZrr226ffuwY2OotYi1WOdwUUQURVjntsxVjrUoouYcNopwzmGcQ6wF59AoYjnLuh6e+xaced8Nyffg" +
	"R50se/XC66+nzUOHkFarkNRKJ6xGPdAty4qnUsRqDNposJZleUf1wo/h+8CQiLgdKRARAwx9DvbdZ8wL45OTUzPXXuu4fBmz" +
	"vExkLW5bDUgVTEU9M+/Jii7L0saGX0qStadEvnEyz99KYANoq+rmdgAR0GzA8K1RNHW/6i/HoujGqYMH40a9jn/3XSRJCk2o" +
	"1EC1efkQ8CIQx/SyjMvr6+lyml58Er57yvu3O7AOtEtbV1WtArDAUBNaFlqTUbTr4RC+MyXytbGJCTu+f7+VJMGvrkKvh+Y5" +
	"6j3GGFQEiSI0ivAirK+thZV22y+qvvJzYx57J4TlXp5vZLBZcd7ZsS0XkRrQasCQhVYrioYPi8x9OYSHdsOn6yMjfmRkpB7X" +
	"65hSF0KakiUJWZKw2W4nSbdrrsDpF0SeOBXC6bbIZi/PN7PCcYciBetaOt7xX1AWyHADmgEaTWhGzg1Nqo7eLnLbQdXPNlVn" +
	"HVzjoB4gSWG9I3LxLTj1EvztnMiVFHo+z7seumnhuAOsqmr3A/+MpEhwBAw1oKkQO6gr1CxE6pyjUDTJC0kK5HnIIQhkOaRA" +
	"mkIP6FJQ31XV8JF/Titg6kANiOuFhBtAtACggPaKzVJGAaAHpFq23fcb/wH7Gf9Kuqnp+wAAAABJRU5ErkJggg==";
	
	
	static String mail_important_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARTSURBVFiF7ZfLbxtVFMZ/d2ZsZ2yP7T7U2sZlk0RRNzza" +
	"Cqmwhw38A6UsumDDiofKpms2ICR2NEUVLGj/AFQWLIBl1SpUVUubVn2gikpJ07GdxE0Tz+MeFvPw2HECAkVd0Du+c+89d8bf" +
	"5++cc++1EhGeZTGeKfpzAs8JABbAl199cTbw/RMionYSTCkluVzu9McfnvxgiEDg+yc++eikMgxz5BVBomaL/kiLJJ/oGcna" +
	"BM/31Ozs1+8DwwRERBmmiQ416evxl4roqJ/WcbZorDP9aBz3tQBCrbpnkypW0gnDANFgmokKAqIBlYziu6Tz6RUDMkQqM0a4" +
	"+NIh+o9dWmCd+/SUKHh0TKSeEjCUSXe1Q6VSxbKsGEClYEqIxwkBhUpcoRTIwD76jDIM+o9d3j52jJzj4Pd6XDh/fj9ks0BB" +
	"tVplcXGBMAw3SfVvi2maLHe6AOQch/nZWXKOk85vSsN6vcG9+3cJQ03s8KHAGhQZjGTYnhTLsmi3uyhz6+QaEIhBlKFotQ4w" +
	"f+tm6nEZ8n0MPpgcAw35XAH3sct6fx3bLv4DApAGTyGfZ//+OlevXsFQxkjES+YHj9KL7nbBZmlpCbfjsmfXrhFqWxKIo1Zr" +
	"tAi1Wo1abTeX5y6Rs/JDBJPIltiWuMpQBuWiw8LiIn8+fECjXkcZmxdb7XmbCYiATnJXR/5vNhpM5Av88uvPFPIT5PN5TNPE" +
	"NAxUfBmmiWnlsO0i1courl2/xvytGzSbL1AoFMgEEMHTp1G7tjZeARGN1hEJLRrDNOj7HtNT01z48Qdct41lWkxMFHHKFSpO" +
	"lXLRwS5M4LouZ789g2WaVCpVHKccaSSDcE0JxC1kFiJB0FqnagDc/+Meh189HPm1aPP7jWv0Vnus9no86fVAKUrlEiW7SLFU" +
	"4ujrb9Co16k4NeZ+u0zrQCsl8fcE0iUWULC4sMD05AyhDgkCH9u2OXLktTEBqdNWa8HzPDpdl1dePsTNm9fZu2/vtgpk0lBS" +
	"+budNs1mizD08XwPrWMgrWPAbB0JTBGCwKfTdZmenmGlu0py7tyWgABaNE96PWrV3QShjx8GcVYkNdpYxqmgR0iEOqS70qbR" +
	"bLL+dB0Ab3mZ6swM/ZWVAQGllJko4PX72HaRQAeEYYiOwUXrVAUtOrInc1nwkd1QRHiytkqlWiG3dw+X7tzh0u3bzD14gIJH" +
	"iQITEb5gGGYKKBngFEiPSK4lJjYOfNDv9zc4PHeRd1aXefj5Z8FxKL0LLaWUsoB8kgXxlpc5eCThkd2Cs2tfXDN7xlaL3pUj" +
	"R/HcNi2wvoc1YOk4NCzAVErJxsaGKpcq499Oo2TQHdqcMrkuGfZZ4n67w1tTU1i5HIHv89Pdu/sAZQHa94Lvznxz+r1t0P9z" +
	"eREs07K4Nz/P5MGDqV0BZSI3WOzgKfmcUgtvTk5mFeA4GBawAXgx+I6dikVkKZYdIqBHcbtzoNuQSQNK/e//Hf8FAZtUplnN" +
	"XN4AAAAASUVORK5CYII=";
	
	
	static String trash_32x32 = // trash can
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAoESURBVFjDxVdZbBvXFb2zcRVFURK1UKIWblpIaqdsOY2l" +
	"WHYcO2mbpQ3aAv0JUCAougAtUBT9CfpVFAUCFP3rR4q0KBw0iWvLrmu4rhw7ixtRtHZR3EmJpCiSkiiK+5AzvcM4RdBaltF+" +
	"dICHmTfz5r7zzl3eeQD/54t43MeJiQlplmW/ShD0S3KZbJimqVqO42SVCieucBWKBx4NEBU0UgSSyGL3sFAoLvA8d0XOUFfu" +
	"37+f/28AEANjY2/IZYofK+tqa55+aoI/MT4GDQ0qAgEAQzPAMAzQNI0jScDJoFRiocyWoVQuw2EqzccTSXjr7T8QqdTB4WHm" +
	"4M3l+fmfo13+WACDNtvLjEj0zpcvXKAvPn+WkIjEkNxLQcAfhO1YDLLZHGRzWchmslBiWTTJV4FIpVKQy+RQU6uATq0WLJZ+" +
	"aFCpqmP+fPUa//7lGbZYyn9zyW6/fCSAvtHR1pZGdfiXv3iDzGbycPfeR5BMJKBepeRkMsk2y1a8NEURHAd5iiZKhVzRq1DU" +
	"GitcmcdGsCW2hEC0aLENl92yt39ANjSq4eyZKahTKeF7P/wJF99Ltjsdju1HArA99aW//eynPzqby+Zhbm4OFDWyfZIiVtX1" +
	"jX6zecCl1bavpdIH+gpb4QmCEKE7lisVOM0w1D66JCWXKzxyudSaKxTUi4uL2uWlhfZMLtdfLJZaR0ZHCKlEAr968ze37R9/" +
	"dO6LAMjPH5DKCZWyrkpzYnevKJXJPPV19RFVfX1eoZCleYrMEzyUkfcST3LICJfheb6IjLDY4giqyKEdiURCoJ1cvaohWCoW" +
	"Vlwebzqfz4NYLAZEPfHvLqA/f6AoSuzc8MDp06egu7tL/N77V0cy2UOi12TaMuhNUrVKXSQqXA4nLgFU0O81STScoGkiR9Ni" +
	"RqVSITMcs7ufqnG6PR2fzj9oFUkkAz/4/nfppqZGuHr5L0DiHEfGwMUXvzI3PDhiq69Xgrm/H8x9fcgKA5FolBNYuXX775lC" +
	"IVfI5XDafLGQTqc3lXVKTblSpkUMI6EQSa1C0ajRNIt7TEaio6OdFDNizJAy3P/4E7g/Z4dYYsd+48rM+CMZUErlF5dXVhLT" +
	"z0xBaHMLZFIZ9Jh6YGRomER6YeLEeG2+UKwtVz6LfqwHPRwyIUxQQoqLbKkKGLOo+i9F0UKNgEAgAOFoDIJbYWhW1V080gWX" +
	"Ll1KTl+4mMocHtY53W5IJneRZhk0NjSAAIBhRMBiru/u7UI8EYcdbBWMwmKxCCVsSqUSNC1t0NjYCDTFQDAUgtW1NUzDqzD1" +
	"9NNQKOSTly79NXkkAOFChqPDQwN1Bwd7IGKowjt/eoe5cfMGhVUQjAYjCHcWi00Ga0Emm60CK+Dqs/icPjyEnVgc0ukD2ApH" +
	"oK1NU94MBFl9p5YOBHxMiS1HH1WIyC92sLSGV9fXwGo1Qzi8mTs/PR3Wtmp2njp56mBtdTWxv7cXv/vBnVg+m9n3ul0prszm" +
	"QsHAvlrdEAn5A66mxoYQZkroxRde2NhPJF16gz7p8Xro5uYWwPebjwJAfbGj1rSdODM1OR6LRIWKlt9PpUqTpyfJXC5HnDt3" +
	"LrKzE9+y2cbtfp/XOXHi1LXt6Pbhmampha3Q5srXXvn6ymH6kJiYOEk7NzYIbXsbP+9wSLXt7crIdgwisZ2bsfDWzccywLKs" +
	"f2NjgzMYDei/VUKvM8DS0hIYjUbC4XAwFouFv3NnlrWdsMUwZjJjY2OZW7du50+ePJWcmZmp9Pf38/N2BxgMBs7x4AGp1+mI" +
	"QDAItcpa9Fw5eKwLSIKPyuQ1bCQSAbPFQrq9rrLZYuZ9fh85MjJCrTlXK88+dz4zOztbeO07r+1+8o9P4heeP5+4ffs299Ir" +
	"L5WXl5f4oeEh3uV2ktahAcLjczMWswUi4WhJsH0sAODIiN/n53HF4HZ5RMiAdHFhke7QdogWFhZq+nr6lR/M3tFOnX6m8/K7" +
	"7/WcsJ3ounnjVufU1JTm+sz1lr6+vhr7nF1s0Jno1aVlkdFgokObQUxNcdX2sQA4kotyPE9GoxEhECmvz0NZrRYiFArC4OAA" +
	"43a7RJOTkwjGwbz88ovUysoyffbsNLWwYGcwRui1tTVmaHiAxHHUwMAAGQwGGat1AFM2QQq2jwVwKJdHo7EdWq83gMfjIfV6" +
	"PbW4uER2dGiFWGCQGcZun5OO2sbY69dviIeHh6h79z4UjY2N83fv3pWYTEbR4kJ1HLm2usaYjEYqhDGA6SUSbD+RIDnz7HO5" +
	"b3/rValIzPCpVDqJqohIH6RlOp0OFhYXDrDgpOftc2y3QU+EfAG5wajP+Hz+/OiojQ9HtlToJsqxOE/UyOSiTz+da+w394vf" +
	"evuPufv37sqPjwGhGLHF/c6OTvD7fIRO161cXlqsx5SSOZ3rUtwjWhLxnR6k21Ipsebzz53vQglmmZ6etm1vR2wmk0k/75jr" +
	"xtTTrjvX640mI+31eAXVlDhKkv0HAIqkkv6gH30+COGtsAjvZAjLam9PH+F2uwkMSMCABHWTWmAEOjo6ABkAs9lMxKJRzJZR" +
	"Ir4Tp4cGhqTRSIQy9ZiA4yH5xAAUcnmTpq0NvGhU26kFzH9oaW2F5ZUl0LRpYGllGbQYEy6XG/NdD1jpQG/ohtXVFWjRaABT" +
	"EctwG7hwP0EGwOv3gapO2fpEAF5//fUmZW1No98XhAGLBTaDIVyZBYRA6sftOYo1fhiZ2Y5GYWhoEKJYMS0WM7rLDz29vbCJ" +
	"TGEqwubmJo7vhRhWwBZ1K0jETJNg+1gAES6SkUpwO0WB6fX5oFoPcCVdXd3gdG6gUNGBG31qNJqq74X++voGdHZ2wfrqevW+" +
	"seGCbgxYgUEBzN7+viDvYNY+yx0L4NpvrxEHBwcZRa0cpiafgd3dPbBarLC1hSsyCxtUGDC/qysX8vuzlfZVt96+vv5qXxAz" +
	"ka0IjI3ZoEndgntKO+RQSrsdbhlOIX7sZoRXXW1tTXdqP9UrVyio4aEhIEkShLqw4XSCTq8D5/o69nXVPuY5MuOsChe3x/3Z" +
	"ilN7MDoyBgqFAqLRbXj3/XdLwUDgJj5/CMIBBhPtcQBEWLfjzc1N47FYVCWRSKn+PjOo1U2gwQCjaBK0mAUMQyMYA2YMjQGo" +
	"Q/XD4Pt2QGVc/U6jeHF5XPD273/HorQPfHjv41+jbaEQCdnAPa4QCf16bGZTr+FVq9X6jRqFQjmOdA4ODtNCyrEovVIHaYjv" +
	"JqpiJIOHlHKZBWVtHZ6OWPB63WWsGQTK8fSDB47LXrd/Bu2tCyGGLf+kZ0MJNiFqe5qamgZb21onurs6rCjVmzmORz/yDLoG" +
	"VbmgDXk8rHCsIMsL+VwiFAqvY4zMJ5PJFfzf83Di1BMdzY74LoBRYNM8ZEcoqVI8jAhBRaCGyD/0be7hRNsP70K//D+djo/5" +
	"j/iXkjtidU9y/RND8M7k04iMGgAAAABJRU5ErkJggg==";
	
	
	
	
	static String dialog_ok_24x24 = // check mark for OK
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAADMElEQVR42u2UA3AkaRTHO1Zj1rZte3cQa23b7AxrtLZt27Zj" +
	"27aTSZ/m3r2k+mxr/1W/wYfnbuJP1QcN9yKHS2SCQntlteDhrK3DH2rcRU3YiuR09tPwA/AkbD/M3Nm9FB1FjVhl1/kPcSCU" +
	"UZsUpxw436QTcDdUBiFpV+DAw3ngoKj+/ncbHyql2jqpale8ij4Al3znwYk3Y8E74Rgs3NfPIJTRy3+3A7Gceb/33mzjg1At" +
	"HH7hDreD5HDy+YrPJXImdqiaMP+dpbGbMGljW8OziB1w5MUoOP5qAvZgG7hq6nMjpFS/32XcQV2dFsuYwvOvV8P5d/Nh32Mn" +
	"uBukBtVpx48kcvrULzY0ejRh9kPraPzgmmPDuJv+Ctj9wAFOvpwGZ1+tBLFMUIrR1/j55q2xaSiU0llCKfmxiKWX4pLJV6Xx" +
	"su3moKzFXXnPwv7HHrDrvgPc8JXBpE1tDWh85s/Xlq3G4ATE6y+4fnbm5VKYuKllOUb2YoTMro5aTZhi9GHrL3kYT76YCdtu" +
	"j4CTL2bAusseRmx4cFUgPyeJjHm26ugg7vTLebDvgSemvhC8Tgz9BJ0UDWftbo3b0NxQubb1thB23nWE489x5pU1uWGsXZdf" +
	"VHeRlM5RnRUaTzybBdtuimHzjeFw5PEk2H5jNLip6xt33xkPu++6wsZrQ+Dok6kwb3d3TiKl9/zy8VtDtsMyxM3a2aHiwIMJ" +
	"sP2WI6y7MgC233aEAw/Gwa47rl/933DFBTCgggFralK/7glVE9b4sBxzUdcuX3dJAjtuOYP+Un/QXexbSdXvXbc9wU1Tt3wY" +
	"S475zfM+QkqOwmxKlx3s+dm2646gvzAQNOd6w6arIliyv/unIhn9+ve/DlYxzcQyKmzsuoYG/YVhsO7iENCeGwxonBuxgmrN" +
	"T85vkhligVhXa04wwtXkPnu5wLDqSDcYra9fMXQltQX3aIRCSMQWsUYs+Ls/KhPEHLHiL1GIAKnRe7rNeCFLFwhX095MY6I5" +
	"rtVDaiM1+DMUf8cKMf+p7EwRi284IRGaN1IdqcFTnV+jEfIbxi14G79IJjxmiDl/2ZLHgl8zQ0x4/h59AQsZW3Qa+M/kAAAA" +
	"AElFTkSuQmCC";
	
	
	static String dialog_no_24x24 = // x mark for No
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAADJElEQVR42mIgC4yC/Q4OLEcMDdcAOKOGLj2CKBptYtsc27Zt" +
	"245t64/ErrFt255Zf6nZvtTtidHfySzuqXveu6iuBsBldfr6/9DJmMq0tVmTiwtvcnXl5YJj9jddua4ua3J3l3TwYKY8XEuL" +
	"NTk5Lcw9fEhzT56QMC9ght3vOuzmnz5d1Dk7QydfUqKu/rLexobP3rpFkydP0tTp0zT74AE1isJidXXJLEHwRhE4Ky4xdebM" +
	"ou7uXWqwteXI+HeBqurLeisrPn31Kk1kZNBEcjJN5uTQzO3b1ODgwItVVBgAPnvnjnSJidRUmszKounr1wleZMg+UcGJE6wO" +
	"JZcuSebxhASpbObaNWqwt/8MgE9mZtJ4YiJNpKfT9OXLBA+8yv/DsmWrCo4cYTVmZnzy7FkpZDwmhiaSkmj6wgUAX/Z9NnXu" +
	"HNWYm/OCo0cZvN9ylJbkHTrEqkxM+Hh2No3GxtJIRATOHzwujrCDBtp/hMuXsIMHWZWxsWJUPMNQeDgNhYRIGBYFmGEHjUy4" +
	"fMGnvXtZhb6+Ykg8U39QEPX7+0sYEBwz7KBZ0u0/7N7NSjQ1eZ+4bY+fH/V4e1OvOAGJiyLsoIH2v97//Y4drFBFhXcFBlKn" +
	"lxd1urlRlzh7goMB8O+zLvE10MKjtASCd9u2sfxjx3i7MLe5uFCroyO1i7PDx4eKVFQUAHi7qyu1iR007eKL4IFXtuTNli0v" +
	"cw8e5M1OTtRsZ0dNNjbUYm9PLSIk9/BhLvYMAMcMu2ZbW0nb4uxM8CLjnwWvNm16+XHvXt5gbU31lpbUYGVFjaKE7d/PX2/c" +
	"KN0OAMesUYRDA8DzSXhfbdz4UvaJXqxfz97v2sVrTU2pzsyMxA/kmGH3uw47aAB4ftbJljxfs4a9276dA1+KpQcchsIgCMDz" +
	"uLVtmxeugiqub9dpsg2rsJN8wW/sxue7jYAogDBFVLgPxB59z3F7n++nSnIpUAdSK5HjQuScAFoAujSkCU1pTIMY0JuLXJYi" +
	"pxKQ08199HYji7w6MEUFqlKL+jSisRpQm2pUpDSFScikn2LoYIsccpVDNllkqP/kDopIEdd1Q7g5AAAAAElFTkSuQmCC";
	
	
	static String mail_attachment_24x24 = // paper clip
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAC90lEQVR4AcVSA5AsSRTM7sG3bfv/tcNn27Zt39o2gjs827bX" +
	"to3xsutd9aHPmN5DRmRk8WUW8G9DwF/AZDKFkECnCRBCAAoCIIHwFQn4SiDhuYsvvrhCtQEvfoEgonTzls265cuWY9nyZeBG" +
	"sNvtsHH2dHdPzpJ0/qUXXvqi1wYWi+FkEjQv+vr6iFqdFv19/XJhEINshA0bNgBEKC8vlySwky654JI34Q2MZqPhk08/ovqG" +
	"WrJYzXX8NOdaLJbtVqt1l9FiPN9sNTXU1NfQF19+RiaTsRTewmQ2drW0NdOrr79C8juA48knn9QrAazG4JdfeYnaO9qIrx3A" +
	"H0CLPwARbVmyZAls4zaQQCcYTYai6ZlJH4OpdFQAPtKL0zfYbONYuXIliNg6rw0YkwD6XrVaXZSPr49cDB63Z019ff1Zo6Mj" +
	"WwkMer0eEmP4I4h/bMAUPXzkMBwOB955+200NjaAm8njfj9fo+IETNE1a9agvKyMp59cMzk1NRwUHCyn1ipr53oCURTBC8vX" +
	"4frZOKekXKe3BsomieuihYuU/s9VMZNUXJH0s6QajVYp9msVRQ0Yze2Kfp3WPTQ8JPdnOPnVTfIxFQbEmNPmsP02ObHod995" +
	"Z1ySKFoem56ekgOo+EXEHnv9tdfvB2gdAOH7Ip249ebIZAAykZWTHqOYq0VGVuqk2+MmrpSUlLREGc/I2JCRmUpDI4Mkq7dX" +
	"9PO36O/u7cTGjZug0+E6cBQVRS4kzDx3xNcHfX298mnHVRsQSUllZWXw8fUFCWJkcnrCCXbX/He2b98Zum3rdnz4wQezYHQu" +
	"1CIyMlKflBLf/PFnH9FnX3xCRSV59MZbr1JTawMVFOZQYnLczZgD9JzLL7784qNT0hI8b7/7JrV1NtP7H71LWdnp0p133/oY" +
	"gI2cK+S1aoqv4tzOeeSkk46/5sGH7yuLS4hi99x/15fHH3/s3QAi5Lkf1qxSY6LhXPjD5s2ce7Zv3x7G9QDnDs4NnMs553OK" +
	"+D/wLdCvzve7+kVnAAAAAElFTkSuQmCC";
	
	
	
	
	static String attachment = //  paper clip
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAUgSURBVFjDxVdrTFRHFD733t0FVrSwi+wutl0RWPFBC9rW" +
	"Jjb+atpQk8aYWuWpJRY0lh/2B5CsmrShP0xqfzRp64MISioxpNG2tramjUl/KIsQSaQ8ZekW6iryfrh77+7M9Ays62W7BYFt" +
	"OsnJ3Jk5c853HnNmrsAYg/+zaZ6W8fSV0/rY8djtTGDvCAAbccqM9AwAGxZAeIB23BYEsT4uLu5adna2/LRyhafxQF1d3QsA" +
	"9Mdofcwqs9kCRqMBoqKiQKfVgeJTQJEVGBkZBrf7PkxNPeqihG7Pz8+/GxEAFy5ceB25vln17KoVtjQbuO+7YXDgIXi8MiqX" +
	"p0FEIxjjypWQlGSBXmcvuFyuIWDCztzc3N+WBODixfM2QqXWNJtNazIlQsvtlvHJiYlPqQQ/MIX1ezyekfh4nZEQyUpBehuB" +
	"fJi1eVP06MgotLe1KYxCSl5eXv+ic8DvFwrjjXFaMypvaLh5z++T38jN3ft7CNv9ADlqa2u/a7zpuLLl1S0JxgSjDj21F+c/" +
	"mUuHONciZXTPaqsVnL1OkL3ywZycfyif1QoKChyK4i3t6ekBK+4jlBbOF4K5AVC6OgFj29/Xj0mn/ylcCEMnCIHLbrcbDAYD" +
	"35+ypGOIAiRRFEFRFMjLLVD4XE3NmUzCxBxRgG2YPZnAoBdxtGBfU1RUdG3fvn3e6pqzoI/R434iLRXAjFWBvrq6+jnC4Fer" +
	"9XmDxWyCeEM8TE5MrhsaHlrX0dmxq6rqVOH+/SV1DLNPkjTB/YsOAaEkAGSm9xHvaYytISV1Dbj+dMH169ehvb0NYmOXQ9aL" +
	"WRrK2Ak18CUDCBVEKctITU2BW45G6Ovve29y/JHJ/XDgpeamZppoMnE+U319vbQQAJoFANiKNSNGr18GI6OjwIjw7cGDB0Zw" +
	"fuDkqa98Wo02CvnEqakp7X8FYBmShHUf64MP/AoNVjAWEqrQPgIhIGHHqnqhWndFMgcI8FL9WBC3lIcgVDAfM5jhc0U6Cbl1" +
	"QYH4LWIBCAcgyOeaGfP6EREAjLJZ9UAUJcDr9l/4nsSeEH9kcmCWB7DO+rlgxgWPqS4t4mlouMH5mMViIdjAK8uRyQG1JdMC" +
	"eU6gB8bUfMR/oquzU6aEfVFcXOzjADzeqYiE4Ebt+XO87wq6mgWAqBCUl9srDfGJyysq7KVBz6lCt2gAjCh70N0HBOZ9LVAJ" +
	"+WxYwdzy2aeHBkv5oguR3V7Zh92pwPDOk+NG5txKQnJn0R4IaW6G+TAxOQHC9DNATgrHdLTyaLIoidN5EmkAoBB/Q2dXB6Sl" +
	"2wCvZXvYR6bPf3z9+g3Q3d01nUMRBUB95EiTwwEbNmbw+36P3V6WqV4/cqRim0ar27U2fS3cbm5mjNDDEQVQWXm8aXh07LLT" +
	"6YSszVkiOrmuvLx8OV8rKyszE+av2/zyJrS+G8bGx79G/saIABAEQULSIkUPDj/4uKnR4TGbzJCSlprOROXyoUPv7xQ0/qu2" +
	"tbYko9EIzbeaxgcHRo/xfUv6L0ABmkC6c5ICpCkpKdq9Otn6+Zvb34KOtnZw4is4zZYGqfjj8vPVq+Ruj3P32TPnfuEHghdK" +
	"TqjHvyAAAfSaMKTl/QelJR+ZLKbCjRkZkLwmGUE4ofVOK733171jJ7+sqnqsWE2oiywEgPDYYpUH1J4Qc/Lf3Yq/Y4d1Ou0r" +
	"ske+0uv847NLl75vV1k+rwem7/v5KJArXHkUUkzgdcSTbwWnHTuy+fs/FkmPFI2kC4AU5pP9NyFLXq28eQcNAAAAAElFTkSu" +
	"QmCC";
	
	
	static String attachment1 = // file and paper clip
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAABLUlEQVR4" +
	"2rWSPW6EMBCFX3KEVDnHlmlpKKjpqVNEOca2nIAmFVus0BYRSpEWpBRuaSzRUJgDWPzMSxOshcDuKlIs" +
	"jeQZz3v+PDLwD8sDwEW8bjXfr9Q+ANydxTOARwBvP2b+NQKe7X0AX1EUUUR4PB65ON80cMJhGDiOI0WE" +
	"WmsGQXCRwp/e3XUdu65j3/cUEeZ5fpHiCcDe8zwCoLWWIkIRIQAqpVyutWYYhr8o8jiOnUBEqJSiUsrl" +
	"U22L4r0oitUbp9wYM6NYzuIhCAInaNuWIsKqqmYEdV0zTVMOw7BNcTqdCMCJD4eDw2+ahn3fU2u9auAo" +
	"JpMkSWiMYVmWtNY6YRRF3PpUbhbGGBZFwaqqbhLOKOq6dsO6VTijyLLsT0JHAeATAHe73cu15m88QWrC" +
	"NHlDUQAAAABJRU5ErkJggg==";
	
	
	//  static String paperclip = // paper clip
	//
	//  ...    ...
	
	
	
	static String compose_mail =
	
	"iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAA" +
	"GXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAABN0RVh0VGl0bGUAT3B0aWNhbCBEcml2ZT5nugwAAAGDUExU" +
	"Rf////bkN4aGhomJhYmJhomJhN/NOb3BuYmNh9DLmIuOiY2NifHfSo6Pi42Qi46Qi4yOiY2Oibq9t4iKhYmMh4qLh4qMh5aY" +
	"k7m8trq9tru+tL/Bu8LFv8PDqMbIwsnHn8zPyc3Pyc3Pys/QytLWztPU0NTQldTV0dTW0dbZ09ba09fb1Nnb1dvc2Nve2Nzd" +
	"2tzg2d3dwN3f2t7h29/i3eDj3eHYeOHk3uHk3+LUXuPl4OTm4eTn4uXo4+bo4+fp5Ofq5erff+zlsO7eVu7u7O/w7vDaK/Hf" +
	"SPHy8PLcH/LcIfLz8fPdJvPz8vP08fThQfXfK/XfLPXfNPXkW/X19PbhNPbmZPbyyvb29fb39ffiOvfmXPfzz/fz0Pf39vjj" +
	"P/jmVvj5+PnlRvrnRvrrbfrtg/ruh/voVPvoVfvqXPvtePvxmfzvivz89/z8/P33wP39/f74yP761P763/786f797f7+/f7+" +
	"/v/86P/96//+8//+9f/+/P//+v///f///v////riEqAAAAATdFJOUwAcKEFUXXCEk5mtse75/P3+/v7WebCnAAAA2ElEQVQY" +
	"GU3B1VZCUQAE0FGx2xHx2N0Kiomt2AH2tbsLBbvm073y4GJv4I8ji8xMwL8U155+Nvoy4hCVnGeMKe0+uLkeT4UtvvBO+rw6" +
	"v4g87QeSgMRsI8vaPZLtS5MO5CwYhUJjxyff0tv2Si6oikPL2rncCr+/3i89EJTKfIPVo0GdnWr2g6BeVNLU3D41v7Y8sy6C" +
	"2nxWsTFF5XWPtyMiqLlFd5Vsle7hXhHUREe9/DbVNnhFUP2t8keppVEE1aWhAV9Pp9fTphoRBauKMZ2PNCdjONN/AUHWQY/o" +
	"4tIFAAAAAElFTkSuQmCC";
	
	
	
	static String compose_mail_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxlAE9wdGljYWwgRHJpdmU+Z7oMAAAGIUlE" +
	"QVRYw8WXS2xcZxXHf+e7j7l3bMceO87EpmlsOWmVR5NKlUpjipAIdFFYkLKsCqiIDQukIiHEjgghAwpUICQECJBYAUskVKEg" +
	"sWABiHaRUlqrSWTcJI1fGc/Y87jP77DweB5+xYhKXOnM3Dv3m3v+3//8z+OKqvL/PNz/ZvHc3NxjxrWfV5g2mCmFaQCBBYv9" +
	"t8BCafjBb178zPUV50geZJnXWlvb2JiaWoj2e6YcloHvXPv2laHikZ8///ynspGRkTAMwsD3Cx5AnMRpq7UaNxr/TG/cuO5+" +
	"aOLdXz9++r031ZCI1SqOuddo6Pz4+Fv1hwL481+ufzfP8ldUtYcd6Xzsdfh+jYHifYrBCr6/juc2EJOh1iXJBkiTkrbiY3ka" +
	"j/3kmWde+sqBIciz/Ksf/9hzrjHmUMyoNrD5G1hbwdoItSuo1igE3yKJXwWaiCmKSOC++a8HX2b54jco32jsC0BVHWMM1Wpl" +
	"a+8iiAggSJsI6SFEeBuReVTfQeRthCZ+4WsY5xJ+oUgcfYk8q+G6UAwKpjlkzxTh9UOJcLWyQpzsrZ+gEDIxfhSRNWAZI0sY" +
	"5wKuewXHnQXAOBfxCj/G5r/H5vfwvEDIdfLWrdOFU6duxgcCEBHKR4+3d9y7e+nchwroJkIVz/80rve53WnmPg3u0+T5G3ju" +
	"j1DDSLlshoAYoC/QV69eHVRtK65D+5bz7VD0W4KIRclIk5+hdmEfnVRJ428iJiOJCkOuGwS7QjA3NzcWDPh/6P3jyoP7RHF/" +
	"CMIgZLJ8og0wADwED2uFNP0hfuHVXQmTJb9CtY7aUf7++hOveO7G9cuXdwBwXP3T1MmZ2yLy4W4IJnftul+Yg8AQVkuIjGPz" +
	"+T2zVVlC5ChZXuTI0ODyX/8287vLl3myLwQKF1+48tkX+nXQtV5tdMMTgJQxZhLkUZRRAKy9TZb+Fpv/A8hRRhFzkiQZ5amn" +
	"XryU5c6FXSFwHAfXdcV1nE7xWVq9TxS3DqwDIhFhYCh4IxT8Jmn6RYR5RBKsFoBH8fxTuM5jRGlEwX9cRF7TfdNwcGios/uJ" +
	"Y5M9QtzbtiifQvVd1C6geh90HCUG9VGGESYwzmnQOki4fzPKbU4xKNJsNkiShOW1pYcy0GXCUPCLuM4oxgkRMhQXzxlltHQG" +
	"klM47gLW2v0BOMYQFgdoNBpYaxkbGe9UvoMY6J4/iWqMagORGGs9VEOSxCMVKAZFdpb4HSEQxsfGqVariAjLa0vESet/6vdh" +
	"UGSy/AhpmhIWw4fPA8YxlEollpaXGR0eO2DX7NJHu5d0DBRVaDSaFAcCkiw7BABjQOB4uczi4iK+7yFidtHdrQm9DQq2uruy" +
	"3eWjKGJ0bIQkjZE9aoS7Vw9AwDUuj5w4wa2bNwmCABEhjmPu3n2PZqtJK2rhGKctXksYhAwODHLixEnCMEAVWq0mE5MTpHnS" +
	"RqqHYEBMe5kSFArMzJxifv4dkiSh3qwzO/tRSqVSj5gUEKzNuXPnLn+8/hrnzpzH932mp6fJbNrZt+7BgNkrnYxIh/awGFAu" +
	"HwOBT37iOQYGizRbDTY2a1Rr66zXKqzXHrCxWWP82FFe/sLLxElMqVQiJ2trQdhvpNoNwAhitkEI9Uad9eo6s5dmiaOIJEnI" +
	"8xyrFm3H2lpLlmc0mnVqmzWe/cizVNYfUK/Xt7wK/fX8IABGus7zPGdxYZHz5y7QjJpYzbcUjvapXZW2KVmWUalWOH/uCVaX" +
	"VsjStL+5PDwEXYXfun2bM2fPEsVN1G47s/2ptm19ArPUNtc5e+48999fhgMm730mT+HuvTtMTU2RJBG27djq3iD2Y2SzXmNm" +
	"ZobVtdXDA1BVKpU1hodLZFmy48G9Zvdx3gMKaEZ1jo0fp765cbg3o2arAWJQzTtJ1i0svd/b1Y49HPezkaQxYThImsQHA1BV" +
	"kiTBmN6IavtCe/K+f945sEt2VuUYx2Xni5ArW4oz3//B96KNzY0w6M6LfcD6r3c4V+2B1wW8va73t8p6BSMmEhEHsC7gAF4U" +
	"x9d+8cufft1adXocywfxBiwi2nOeR3F8DfCAVNph8NoT5kD73GkL1PkA/CtggbxtKdAA6kD6HzZSOXt/ag46AAAAAElFTkSu" +
	"QmCC";
	
	
	static String settings_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxlAE9wdGljYWwgRHJpdmU+Z7oMAAAIYklE" +
	"QVRYhcVXe0yV5xlHQC6CWuecE0Ym0dQ2ccmWrq5psixZZ7esrVZbGlxqV+vmbAtSKkURhXO/fAfP4c7hUi6FchtykZtclatc" +
	"BEEUQQVFENQmMxJ1q3M8e35v32PQ2WVbmvWPJ9/h+97v/f2e3/N7nvfDiYicvs34VsG/EQIqlcrj/0JAUbRrjGa9ymTWV3FM" +
	"602aQCcnpwX8u8Wk6P/KccGkGBq+UQKcnbfZbNi+a9euhQazdmtqWgq1trVQS8sJUiyGKSbxTnxiLPX19VF3dzdZY2No3759" +
	"S41m3W4mNM4Rwnss+p8ImEy61xjkqj0tmUxmXbfBpNEWFH5OIyMjdO7cOaqprabE5Dhqa2ulU6dOUW9vL2XnZBKDt6SkJlN7" +
	"ezuVlh0hVuWG1qxd918RgLRmi2FucHCApqamqKm5kbI/y6T2jjYaHh6moaEhGhgYoNOnT4vsAd7T00MdHR3U0FhPXd1dQhEE" +
	"l20sICDATWfWvQBF/y0BXrDEZNIGazSHnmf57mHziYkJGh8fpwsXLtD58+dF9qOjozQ2NibIXb16VTw7c+aMINLV1SUC4CDE" +
	"ioywgiOx8YfJqOhbw8LCvJ5IAFkbFV1JZlY6JSTFsXR6rnULXb58mS5evChArl+/Tnfu3KEbN27Q2PgYDbBC/f39gtDMzAzN" +
	"zs4KQigJFMG1pbVFEIJaRyvLmYSuKTg42P0RAgBnk+3M4hoiY2Q2OTlJV65coUuXLtH09LTYHCSQJYjV19dTZWUlHTlyhPLz" +
	"8ykrK4tycnIYqJ9u3bol3sNakADJwcFBampqYkW0tWzqpcCU2E4LOJz1RvUnn2amC7aQGbXGFURAwOF0PP86Ana7nRITE8Xf" +
	"eAfK4T345eTJk1RQkH9fpYk2M5YmIiJihcR2clZpD77MLVWWnJJA1dXV1NnZKQJmw0aQ02EqB4G6ujoqKiqivLw8EfMJpKWl" +
	"iWc3b94U5YE/sFdvb49o48KifNIZNUEOAi5c72a0WHlFGTU2NtKxY8eopqZG1N+ROeL48eMsczZZDpthrjmNNvo2Ar+NJj3P" +
	"BoViY2MFgezsbKqtrRUkQABqooVhXqhrVvSNwAYBtxircru8vJyKi4upsLBQRElJiXC/I+vs7CzSGdSzu3bvrHjuuZ+87+Xl" +
	"9Rt+9xcI/N6w4adBu9//Y41GF31XUUxCkYKCAkEA4OgglAS+qKquhMl7gA0CnjFW898hKTLHi6mpqVRaWiqci9olJyfS3vDQ" +
	"geXLl2/l9c9zPMPhz+Enw1/e2+Dr6/tW+P6wYcViFqVBCQCMrKEAcIqLi0inV0EBLxBYwhLOVlVVUUNDg8jcYrFQZmamkD8v" +
	"L5dCQvd0ubq6vsRrn+VYxbGMw5tjkQxvec8Ha9zd3TeGhoX0xcfHCXCQAAF0kaOTbHExX/JadIPTcqvN8gVqD8mMRiPxQCKt" +
	"ViukP2xT5tauW/u2BF8hASGdq6yhi/ztJjPCmmfXr1//Hr8rTAwDnj179mEpYOr4BNt9XvcdEPgel2AGzoaBTCYTHThwgMLD" +
	"w4WTi4oL6YOgP8XyOl8JADBn6eD54SyfYY1vcMiHyXX1x8QswQyAAlC0tbWViv9chMSgwHcFAb1RMzk6OiKkAkP0d3R0NBkM" +
	"BtENGZ9mPIiI3BfGa90B9LUHy1ckPA4cDI8sKMx7gC7CDMAgggIAR5un2JPRRV9KtZxWaA3qiaGhM2LoXLt2jU+4NlIURaiR" +
	"lJQkhk5Obg5eqtIaVb9yTLHHzhFnvV79a6NJW1dcUiRqP/+wQqAdUVaY3GDS3kbywgManersya5OUS8wzsjIEAMlISGB4uPj" +
	"KT09XagCk2ZmZ0C+CZ7pddxKdgR+W23KZF7+Z/z+aZEtRjBaGPuh5iADJeC11FQ7abRR/Y4SLOO2Sfg8P0+wRN9i4OA8Rwti" +
	"foMAugLzAa164sQJIWdTc5P4OAFQX3+fAHCcgngX+4F4VFSUMHVhYQHLn0Sc8MzHH++JZuynQMA7MPDNl9SaqPOczYPp6a9K" +
	"gCmGwIa5ubmip0EAwwpRVlYm/IG+RolAFMSxHtlDahBBCdRqNYWGhpLNZqPEpHgK2vNBrGxZMQc8UAaOp3V69RdT16bEhjAL" +
	"NsCZgNkAUpATWWFqHj16VKgBQCgCAlDFMbywDorgiu4CAavVSlZbDIXuDdHLFoSpH7bOKq7LcEdn+8OTDgD37t0T3QEyyBjZ" +
	"IVM8Q38DDFc8R4AAyEM9kELNVepoiojYz6NcRxq9amzNmjVr5fBydbQOhshTW7Zs2sifUH9J5jopFuOcNdZy/+7duwIUmyKQ" +
	"keOTDNnjXnNzszAeeh33HWsxR0CU5wy994cdOVGqyG5gyKnpLrHFEME080QpAgK2vvJRaFAqT7KdRqN+DAQcQI7MQAC1Rf0d" +
	"95Et7uH7AAdXRUWFIID1SoyJ/Pz8fs77/1BK7ykxF8wfIK7yAdj5vf7G69vA3PFtYLen4AT7R2qaXdQWnsCBlZSUIDwCICiF" +
	"Ftsb9tEor72PtRjlkQf3V65cudJfzn4PibXgkU8yGa5SmsUc3//9jrd3RKsO9vEXMn2yf2+nv79/8GE2EQiI0R1nhaP7zRbj" +
	"Axxm6PeklETavPk13YsvvvBu5KGI+m3b3tomHb9E7u0yf5D9y+e4VGOhNCa6w2/z5ld/6+bm9iNPT8+fcWZzNgZO5MzV2qgp" +
	"FxeXV/eEfFjKfoFCf1OpD50LCAzYLo9oH7mHt/TZI+BP/L/gsYPFQ768VG60ysfHZ93Gjb98+XfbA9/d8uYWfB88vXr16h9v" +
	"2rrplcWLF6/jv38gJ9wSeXK6zz/A/uP/jB4jslButEhuvEyaaZmcZkvnXb0k8YUy44cn55Nw/gnU7JYsxim+swAAAABJRU5E" +
	"rkJggg==";
	
	
	
	static String font_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAChVBMVEX///8AAAAAAAAAAAAAAAAAAACurq6uvK7JyckAAAAA" +
	"AAAAAABTU1MwMDCztbG4u7bIy8bLzMifn5+hoZ+QkJCgoKCio6KxsrC1trS4u7fHycPJzMednZ2dnZ3Q0NDR0dHX2NbZ2djj" +
	"5OPk5uQAAAABAQEDAwMEBAQGBgYHBwcICAgJCQkMDAwNDQ0ODg4PDw8RERESEhITExMUFBQYGBgZGRkcHBwdHR0eHh4gICAh" +
	"ISEiIiIkJCQlJSUmJiYqKiorKyswMDAzMzM0NDQ2NjY3Nzc4ODg5OTk7Ozs8PDxAQEBBQUFCQkJDQ0NHR0dJSUlQUFBRUVFU" +
	"VFRVVVVWVlZYWFhaWlpbW1teXl5iYmJkZGRlZWVnZ2dqamptbW1wcHBycnJzc3N4eHh/f3+Dg4OHh4eIiIiKioqNjY2RkZGS" +
	"kpKXl5ebm5ucnJydnZ2enp6goKCgoaChoaGioqGioqKio6KkpKOkpaOmpqWmpqamp6WnqKeoqKioqaepqampqqiqqqqrrKqt" +
	"ra2trqyurq6vr6+vsK6wsLCxsbGxsq+ztLG1trO2tra2uLS3t7e4uLi4ura5ubm5u7e6vLi7u7u7vbm8vLy8vrm9v7q9wLu+" +
	"vr6+wLu+wby/wrzAwMDAwr3Bw77BxL/Cxb/DxsDEx8HFxcXFyMLGycPGysPHysTIyMjOzs7Pz8/Q0NDR0dHU1NTZ2dna2trb" +
	"29vc3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz" +
	"8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7///+8tFt7AAAAJHRSTlMAAQMEBxMTExMfICQlQKGhoaGiorPr" +
	"6+vr6+vr7e/7+/v7/PzS5jKdAAAClElEQVR42mKgCuAQlF65YvmyJYsXLVwwf+6cmTOmT508acIESX52qLy08qVrWMBZRQk2" +
	"AJP0mCZnEEUBeAWxrTu2bduMMXHHHiu2bRttf0ZzVOvJ7XpG5+95y0XB/I3jPpeqqoosS6Io8BzLMk6H3S6Orp9LwUq/R5ak" +
	"rprksMTyYY7DFmub1Wrh3csoeEcEnud3bNUM7y6ALqcDW5vVYjabTGSQgjeEwTidWP2OyseStkaDQU/6KXhF7HYcZLq5Z3N7" +
	"eozZHAXFRoNer9NqSS8Fz4gZsy08ubS5LRMMhigowvIfhnRS8IgYDIZbUK7HUemg1UZBIZYUnKPgHtHqtIegQ6fTXQLQ63GG" +
	"p015LV+1/8gZCm4THPs1LOPEh12pcWA0RkFqAgAkfdOTkxTcIEajyXSqMhSSD7ZGWSxRAFWaKoAtRnKMgmvEbLFYrda/v200" +
	"0RD81/onGLLN5CgFV4nVZrPbHRhnINGQg5eVAxFWoqHgCgk0jE2zva694xfLRkOck3HGQpKDHKbgIt4ky17Ozt13pD4s+I4Q" +
	"DdDH9QBUMJNgkHAcfz2sxCFJUmOQQYqGEMgCgGFuEvQTXtDHw5CsKOr5alWNhrKdQRC8V+AnQS8Rpf2Qo7pcbhq7zekyP7Tg" +
	"55gE3USWi+GA2+Pxen0Yr9fjcbsC/2cSXCCKmgJPsfWP0PjRUDIJziJIgB9Yj9oGuPGxsdEAmQVOI6iDAQTe0obxiXEKcIpp" +
	"cBzBy8icn+r9+gJ1bHKC2Uss9XoU9XttWlKTxukPxDfZe7xLKFi0bhyF6sJjeLwYDz0E9uP/JScEkmfkAUxG7izWjCMnw8MI" +
	"VMDEzSsim4MFyIrwcjOBTGDl5MIBOFkZQXYws+AEzAwMALKt0eNrRGtiAAAAAElFTkSuQmCC";
	
	
	
	static String text_bold_32x32 =
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAATdEVYdFRpdGxlAE9wdGljYWwgRHJpdmU+Z7oMAAAGfklE" +
	"QVRYhe2XW2wcZxXH/99lZnZmdr12YnvtbJfEpo1T4Zg6FFmoQhQUQVoFjIxo+lBViEtDkCgSLxVCyAIa0iLgIUqoFFAFqBEV" +
	"L0ipUEAgUik0wZFApVRKaOsmThzfNvau1zuX7zLz8bDrNHbW4LyQF450NKPRzPn/vnPOdxlijMHdNHpX1f8PAIC3enj48OGi" +
	"YWaAIO0loNsIwXZK6I4UpkSM6U6N2UIIIcagboypAmaRgEyD4rcqTk+Nj49XNwtAWjXhd78/vlwoFGjWz7GM61pOJsMztgPL" +
	"dmDbNixuwZgUURwjDCNEUYhqtYqlpXJQr9csY8wFSunPkLKXxsfH0zsG+PZ3vqVGRz/HwzCEkBJpkkBpDSkkYiEQxzGUVgAI" +
	"EqWRJBq246Cjox1pkmJxaRHlhdlQiPhtCj525MiRdzcCaFkCJSWEEJh89zI4Y4jjCLXlaloPVwIRxZYxKShlglDuMW5ZlHHU" +
	"6wEq1Qocy0Z3oRudXdu869NTu5UWE8888/Tw888fnd40gJQScSxgDDC/MKdnpqfqBDhhDC4kCf5u26nWGh8AMGgI2UsJ/aid" +
	"8T1KGW4sLWJ2fg5tuTYM7NxJq5UbHUEU/4kQcr9pke4NABRqtRqCoI6py5MRDB06fvz4tXWvXQPwewA/OnToqcfS1LzIGPOF" +
	"EFBK43p9BuVyGXv2DLMwDIoHv3ZwP4BX1mu1nIZSyZnTp0/hn2/8DbGQz7UQX2MvvHDiN0FY902aIo4bPSJigaVqFZfeeguM" +
	"29k4jL7R6tuWGfj5iRe3/yfBltBSgqa82aAaSikopVBZqqB/+/ugErVz0wDr7cCBAw+Bpp8GoffDmH5CyDZCqA8YikYWKSE0" +
	"5g7JRHEMrTUIIchkHOhEw3ZsaKV77ghgdHS0wDh5mnP2pWKxlO3pLbqu61JKKZLUII5jSCUhIgGhJKI4zly5MoUk0bAsDotz" +
	"WJYFy+JglEFJaW0aYHR0372p4X/50PDI1vvuG+Dz5TLemZzEwkIZWiukxsC2GDi3QAgBpQSWxeE4HK7rNsU5OG+AMEYhpWw5" +
	"0NsA9j6yd8gi/NV9j3yq3c/myMlfv4zlWg2MU2zZ0gEYg0REK7UVRdJUZ5olSB3HSYaGh51arQ7OGSzOwa07BBh8bNDeGm09" +
	"s/fRT7YLqcjLv/gllFKglKLYWUBcr4VBPbxEQJ5ljL0RRdHM+fPnY2OMefjjHzO5thw8L3Nz5DdBOIeU6r8DtE37j1OX2W35" +
	"dvKrkyehdQJKCXp7u2ESLaqV5T+ee+3cZ1sFklIil/XgeY0ScMbA+Xtl2FQGVJKM7dzRl52dnYFj28g4pDH63h5cfPNNKYX8" +
	"XssoaCzfnuvB97ym+HsAjDOoTQEoPXBPqYS5hQVksz4oISCUoKurExdqK56U6nKrILt27crl8znpOLbtey7YOgB7syVIlK7B" +
	"GMCkyGY9UEJBCIHFGbJtuXhhbqEIoNIizoP3lEoy0Yntex4YZ2uyAGDDEqxZimMpzlYWb5h8Ww4530c26yGX9QEQ7N49aOtU" +
	"f7N1FPPcRx4a8aWS8HwXvueCcwYpFSrVZVRrNUi1iRLEYXzu6rWrXx0ZGfG1VjfneL1ex4Mf3mO9/vo/Hu/r7/PDIDwaRdG/" +
	"PM97v+/7hz+x9+EHBgYGyKWLFyGFRF0pSKkgpYSQEsbQDUuw5kBSKpVcy7amnvzCk12EAElzSSWUoD2fR7FUxMT5Cf3a2XPq" +
	"+sys88EHhtT+/Y/ahZ4CeeXU73RfXz+fmZ2FbO4DUioIKdHV2YWzr54RKysrjlJqfm52ruc2AEIIA+C2t+c+XyrtOHbw0Jc9" +
	"JRWCKESapEiSBJZtoVjchnxbGzzfQ70e4p23J3Hs6DERBIHzxae+gqtXrzU2I6kgZAOEc47dg4MoFAr44Q+eRaVSzQOIjTHy" +
	"VgAXgAsgk8/nf5LNZT8zNjbmdhe6IaRoNhEBQBBFESqLS5iYmJDzc3NBEAQvZTKZrx944glopaB0Aq00lNZIkmRNyv/8h9MI" +
	"gqAbQAQgui0DADIAMoyxfZZl/dh1Xb61sxMdHe324lJFLZbLTEipKSFXhBBnkiT5K4DUtu2fGmPyAFYDGtLQNOs8lFJuvy0D" +
	"N2tCCAHgNEEcAPcCGALQj8Yp6CKARTS34Vs+XRVIASTNq27eawCq6SvGmKBlE25kTSi2zlcByC3Cq56sujHmzo/l/0u7679m" +
	"dx3g33MOTvchE+5fAAAAAElFTkSuQmCC";
	
	
	
	static String document_print_24x24 =
	
	// 32x32 is too large compared to the other icons in the retrieve mail frame
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAA" +
	"ABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAANdEVYdFRpdGxlAFByaW50ZXIIJrITAAAAF3RFWHRBdXRo" +
	"b3IATGFwbyBDYWxhbWFuZHJlad+RGioAAAQmSURBVEiJ3ZbLa5xVGMZ/321mMpOZzEwymZiYJjZN28Q0tdbahaKIlMGFCFIV" +
	"LK24qIjupDtRl0UEEVwI/gNuFNxUyaKIhWqgiUmbNm2ibdNL2qQzk8ztm2/mm3NxETMk2IK1duOzeQ/n8D7Py3vjGJlMhocJ" +
	"86Gy/y8E7PVDrlS+LKXa8l+QGgZ5UzS2dnR0VG2A24XCo62hcNeRQ6/ZQ0PDjAyP/Cvi+fk5JqYm+O77E6F8rjgETNoAhmA4" +
	"3ZUWWiukFLjVCsc/PU5htXBPsmKxSDQaxTRN4ok4xz44hjY0SirSqZS1slJ4HJhcq4FljHR3pcJaawKOw5Wrl8llc+zaNYIQ" +
	"4m9WCIGUCt/3EUKQz+W5k13GcSyUUqRS7RHLNHfDXzUIOPb+dGfKllJi2Sb51SIAU1PTd7WO4zA6Osrep55kx47tOI6D4zhU" +
	"ymWUkrQnE4bt2PuaAiaMpjtTKCVxgg7bBgf46JMP0VrfNT2maWGaxqY7IRvYAZtAMEBnOIJSemdToCFV3+DgAFWvyq7hPViW" +
	"dX/V3YAb12/S0tKCUiqZy+UcG0Ap5ZybOU/2zh3SnV0PJDA+Pk5bLA5APhq1bACtNXNzv7O8vMSLldIDCVy6NE9brK2Z3uag" +
	"VVwX328QiUSwbZu9T+wHwNg46xruVpaTP40RT6xF3RCCius23wzA2L1vv9+3pdsWjQbL2VWEELx96A1eefVlfrn2LWU/33QI" +
	"Wq3s7XmJZEsPAD/8eIIvv/oaJxAgnUqglMayLBZvZ2VWiZgFmOlHut8vld2QbZpmXQgG+ns5fOQwdSfHaM/zRFvaCTohIqEo" +
	"sXCS7vhWYuEkgYBDMtnOxOQEtVodISRSKnL5gkRrV+Rzn5kAl2bOHhCNhp9bLdKRTBKNxUjEE/R0bKNmlAiFguzsfprntr9O" +
	"Ot7HkvcHZkATibSSSCQIh8N0pjooll0KpQpSSjl7YebAwsJCwwS07/uLF89Nv7OSyy4MDvQjhSASCdMW6iAV6WVLYpjV6i2y" +
	"lWukWntZKl3h1OVvAE24JYTneTzW10upsJo/P/3bx7Nnpw42PO8KoMxMJqOBkpTyYigUjA8MbCWfX8G2LFzXxa8JRF3TF91D" +
	"e6CfVjPFC/1v8Wzvm7iui1KaQqHE0PBObNuOKCF+llKeAlYzmYxe7yIJaK/qxZZuL7Jw9SpH3z1Ka2v0nu3Y/sx7mKbFjZOf" +
	"s3jzBhdnZ6l51SC2LRDCzWQyclObAla9VjNOnT5DuVxBNCT1Wm0T6cbVsXjyC7RW+H6dSrnC6fFJal4NGxyxwWejgFf3697M" +
	"9FTYME1+HT+jDWPzvrkXPK9qzM1eAGgIISpAM5J1AQ3cqhSLB4F+wC4XCuofsa/BZC3N14FrQNPXWP+2jI2NWUALEGRtAO8X" +
	"GvCB6nr+Af4EYsjl9ioFkAUAAAAASUVORK5CYII=";
	
	
	static String list_remove_48x48 =
	
	"iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAAZlBMVEUAAAD///////////////////////////////8AAAAf" +
	"Hx8nJycqKio0NDQ/Pz9YWFhfX191dXV6enqHh4efn5+wsLC/v7/MzMzf39/n5+fp6enr6+vy8vL09PT29vb39/f7+/v///+/" +
	"RXPnAAAACXRSTlMABouVlqns7e9nCXRtAAAArklEQVR42u3VVYLDIABF0Ym76zhv/4scqeNQt/Pd2yToy0k9OX4MqdhzuN8H" +
	"UArYwoWGywQhQGYpAoRMAGBOpGYA9xWspsx8lFyYcKkp+H4T+JDNNIA+EagPCuCyQdXQFkFXL70DIRuMoC2CkhnWqw9IvzEB" +
	"Bh/9mWw0gHZYNUHgnDoQvdJXutGtgtd5idznTNsHWUHTjJLtjhtygVY20xEYugvFhZSrv6xE//v0C5fRdhHT3BzSAAAAAElF" +
	"TkSuQmCC";
	
	
	
	
	static String reverse_colors_32x32 = // paint brush
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlz" +
	"AAAN1wAADdcBQiibeAAAAAd0SU1FB+MMDRIqGAg71TAAAAVkSURBVFjDxZdbaBxVGMd/35m9Zi/ZXGraxCaljVHp9gJVUMHr" +
	"g4IPXloVbKumRQT1oYj6qCgUBPGCYou30qq1peZJUfGGlGpLL+mDVqRemlRL7CVN4052k53ZmTk+zOxuksZ0twge9gzfnpkz" +
	"53f+3/edc0a01vyfRfE/l9D0hr6+HQ9o0a+7ns74LRp0xZrhv28J4hiG+sPV8pktpRd67+09VQuATHfBrr4Pz915x6qmaDQ6" +
	"eYQLlsJ4npHREQYHj1lDQ0MemkfW3P/g9roVcF23KRqNcmLlSkp7vqtLTlm7mhUbN0Y753dy8OCBN7fv2NazdnXvs3UBaO1L" +
	"XCwWsQuFugD0L79QOjXEogXdiFKJw/2Hnvhgx7b5D6zuXVdzEJZd4tg2VrFYV3XODFMojCGimNfWzrLly5KRSOSe97Zveapu" +
	"AP+uInbzTaD+JVmmt4+ZiOuilCIWjdPS3EY2m02KqOe2bn3ntroB1CWXwG23Mr6oG51KVQYNtbb6Zns7KpmstIsHMvgHB/r3" +
	"8e3ur9m/fy/5sQLZ7OKEGLKzr6/PqB1Aa8LLl5FYdTcHSjYDrXMYaG7mXDzOr6kUAx0dnAhHONnWRjGRYKSzE8swKP11EiUK" +
	"UQrP8zh+fBDtCbFYXP2dP3tzXQokHl5HOJngTHYxiUQDw8kkn8fjXNHQgDQ0MB4ySMbi7EunScfjjBsGQ3+eoKW1hY6OdhYu" +
	"WkhXVxdmLkdPz+XpkBFeVzOABsJLloCGhqVLeCNfYF9zK2ta5/BqJMY38QTDoTCPh8JkMk0cFcUzE0W+/+EI4VCYaDRGIpFk" +
	"Xns73T3ddC+6TFzHuau2NARUYxpJJQHNFUuXsPndrTTGE6xHKBQKeJ7HF1qjLZuNQV+n5PD3b7+zQQSZvD4gpJJpXNdtqBkg" +
	"+fKLaECAbDbLyNlh8nlz9nVAa866HirIDh1cROT8DLugArE4oNFak2nK8OVXn+AF88rnC5i5HDnTJJczfTtnYpomyYYYIiqY" +
	"OSD64gBEQGsQUYiAh7Bi+dVYtoVtW1iWVbVtG9uycFyHd97eghKZuk1dHIAE3vNpvGKOPXt3BzM2yZm5qp3LVfrFDAeZtECJ" +
	"9idzEQDK5w96H/1wLQ89uYkxZy9upIiTKeKWijj2BE7JtxsX3sKnuzah5K1g9hqEi1egPHsBjHCUseEBwqkOxLFRjo3rWBiO" +
	"Rcix8Rwb89RRjFC4MmA5F+oC8Ka5wP8JPdf38vHON3BL9r8frwyDK29cPy0LAhWl+u5ZASgDBIOXAVbc/RxXrXweEPo/30Tx" +
	"5CHmtrVzuH8/3dfcx9W3P3b++YByAPha1K1AeR2oBKTvE0ojP7Ogq4vmVASrpwNz+Kdq5AuTjmxSTUdkRgB1oRgQkaBW7dyp" +
	"X8nM6cIrjdPYcimjQz8hyt+AJNiIRClU8DyzxMCsm1ElDipAAcDpAdKtnbgTo6RaOzGHj6NEUKIq1YdVlX51Z0EVoixiOSDB" +
	"MMJ4GISTc3GMCMoIV1a/sgsmecJPR0B7dSpQDaappa3nWo79uIfo/Bs4frSfud3XTVNpai+Z5d01AehJ16JlseDGDRwbHOSj" +
	"V9YzNGLRds2jnD59Gtdz0drD0/4eotGgdVWJmlzgTc2CqW6AaDRCS3sPS1e+QN4cIxKL09iYpimTQRCqY+gZd0sRiWqtrRkB" +
	"RCT5ymsvjRYK+aamTPMM4vulMd0EHfPrOrLn83lE1BjQIiKjWuuJmRSIHDly5OU339r8NEKqEkC6Bjdd4CNXaz1+8OCh94E5" +
	"QB6YOO/TTESSQDOQAbzyQ/9BSQTVBk4CFQXk/LSTcBCczn/8IRwJfFrSWpfKjf8ANhWoYMnd0fgAAAAASUVORK5CYII=";
	
	
	
	
	static String edit_delete_32x32 = // x
	
	"iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAB6VBMVEX///8AAAAAAAAAAAAAAAC4uKrGxsYAAACuvK7JyckA" +
	"AAAAAAAAAABTU1MwMDCztbG4u7bIy8bLzMienp6goKCQkJCys6+1t7TGycPJzMagoKCio6K4u7fJzMednZ2dnZ3Q0NDR0dHX" +
	"2NbZ2djR0dHj5OPk5uSIioWLjYiPkYySlY+WmZOanZebm5ubnJicnZmcnZyenp6eoJueoJygoKCgoaCho5+ioqGio6KipJ6k" +
	"pKOkpaOkpqGkpqKlqKKmpqWmp6WnqKenqaWoqaepqqiprKaqrKerrKqtrqytr6qtsKqvsK6wsa6wsq2xsq+xtK2ys7CytK+z" +
	"tLG1trO1uLG1uLO2uLS4ura4u7a5uri5u7a5u7e6vLi7vbm8vbu8vrm9v7q9wLu+wLu+wby/wL6/wby/wrzAwr3Bw77BxL/C" +
	"xL/Cxb/DxsDEx8HFx8LFyMLGycPGysPHysTX19fY2dbZ2dnZ2tfa2trc3Nzc3dzd3d3e3t7f39/g4ODh4eHi4uLi4+Hj4+Pk" +
	"5OTl5eXm5ubn5+fo6Ojp6ejp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHx8vHy8vHy8vLz8/P09PT19fX29vb39/f4+Pj4" +
	"+fj5+fn6+vn6+vr7+/v8/Pz9/f3+/v7///+atvMTAAAAJ3RSTlMAAQMEBxISExMTHyAkJUChoaGho6O26urq6uvr6+vt8fv7" +
	"+/v8/PzDEKF9AAACYUlEQVR4AaySg7fkShCH31vvwdr2tW3btm0rPJNM7sxEY8+q/tKt1M3xHu8v6u7vq0Gl//snufvo7eHB" +
	"/t7O9tbG+trq0sL83Mz01PjYmwd3rvitl99+wF8S/fz8JgkPv/6Oh0OhUNDn85qmoWuq6nFfKor589N9El4ko4iQIdQ1DSli" +
	"pyxLeuQZCduAwEJWKdYidcqSwyGK0E7CBngwbqxDZkGiAs9z0EbCGijWunOZR0SV57M8x7EMA80kLILDymBaHiMIVuFZblo3" +
	"c46BBhLmgMfMpqWl5Z2wWHeUi8MJEupImAYGl+Wa9PT0ojOOOyvCQY3MMMw5VJIwBhzH8YK/MSMjo/TiohQfjX6Bx0UoI2EU" +
	"BEEURSnQmpmZWV2Nt9aAhAuCAMUkDIFDkmRZVkIdWZSOkCLTH4ICEgZBdjoV5fLSHe7JxvSE3XZDIJ+EXkDmxl6pSn8hpl9R" +
	"rcahBTkkdAEyVdN010AFZcClX7XdFtoBoWGY6khtbe34ON5GVNMwULKFNtAN0+vVJ1taWuZisTl8TOr4dg3dFprB9PqCxnxn" +
	"Z+dKPBKJr+Bg3gji5rCFJvD5gqHTvr6+zUQck9jE4am1f2yhHoKhcCR5PLyb+k5J7Q4fJyPhUNAWqkj4U8dYXDEMxQAsVGZm" +
	"7rW30niZIvYPfZi0dpmiq/SE0k9SKZWSMk18iW/BmYIAUKQUKK0VBalACJ7BgQ9cRLzgQcT+dZgg3AsRXRF3Dzi2mO5KUcEJ" +
	"ABIArMmrZYe9XZtv0fwBt/OaTYFTrfcWuz8sevWqw4dCuZJBucAHy/UycS3rAoCtaceEJbX7AAAAAElFTkSuQmCC";
	
	
	
	static String session_logout_24x24 =
	
	"iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlz" +
	"AAAN1wAADdcBQiibeAAAAAd0SU1FB+AIDgELMbnXPhYAAALuSURBVEjHxZXNa1RXGMZ/52POvbdGJ7NLMiCikI0UKkhR0IJ7" +
	"daWrui1UcOHKRf6AdqN/gNsS2l1EEBeCLgxhQDBVlCZ0YmRME0gJDDTp3Ou995zTRTLHmWkyxo/SF16499x7nofn/YT/2MQe" +
	"5yeA6BOx3wK/7vXxlBCiBfiP8Z27pwD0Xgze+8MzMzM0m03SNCVNU7IsI89zsiyjLMvgs7OzCLEdDCEEa2trh7s4ephGYwzG" +
	"GKy1WGvx3odvRVGglEIphZQSIUQg6bWhBEmSEEUR3vs+cCEEUsoArpTaP8EvWj96YW3jB++JoogkSbohCyC9wB9M4Kw9e+Lg" +
	"wdPfbW2BtSilMMYAhFB0AYuiABhKIAF+lrI1DX4avNLafn3tWnz+6FHWr15FbG6Gy1JKtNZoralUKuF5UM2/FHjvJ85OTSGk" +
	"BIiEEHx16RJ/NBq0pqZQ168jJyaQUgaP45jJyUkWFhb6FAyq6IZIuKJgs9F4J80Yxo4f54tajcVbt/CXL1OePBkI8jyn3W6T" +
	"JMlQArmjQJSdDq4sg5edDpvPnpEkCV9evMjIvXscuHs3EIyOjlKv19nY2Aih6YZp1yS7NMX1lOL2oaNMU4gilDGINA0EtVqN" +
	"+fn5PgWD4H0hKtMU59y7WtcaMzbG3+02r58+pbhwgfzcOWSeI6VkdXUVYwz5zvtezRYUlFmGrte7cwKcY73Z5M+VFeSNG3Dk" +
	"SAAf9GHdrAGElOsv7twZA1CVSnbszJl4+flzKuPjqJs3EdUqsih2BR/0XZP8rXPjV7ZHt7JFES/NzaX3223Gb99GVKuhyQa9" +
	"KHOaS78RxY448ZjIEsVuaCcLqdTskzy//xP8+H1P0nrL0PmcpeUntN68xDnHodF95ADgClis/aY7y/t+1Jq8+Ivl1mMWm3OA" +
	"Iz4gQ/W8r9GGjuyibLP46gG/v3qI956RQ6IPcND3TbDVWaX5ZprXK48AGKnSB9C7ZD7UPmllKqXCyvzflv5ns38AzwU/tmXl" +
	"rJoAAAAASUVORK5CYII=";
	
	
	
	
	
	
	
	
	//  These images are included to test file attachments for test mail
	
	static String image_example1 = // color circle
	
	"iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAAAAXNSR0IArs4c6QAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0" +
	"SU1FB9cJDBMdMq3ye0sAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAAZiS0dEAP8A/wD/oL2n" +
	"kwAAZ+hJREFUeNrsvXm4LFdV/v9ZVX3OufdmIIbBDCCgQZPIoECC8BURJCDKoCDIEBUZnJhEJhE0IeKPSVAE9AvKpKAIKBqZ" +
	"ggRlUkKQL0MgiIAEQgYIme90Tnet3x9d3b1r1x7W7nNucofaz1PPOT1Vd1fveutd73rX2hXDGMYwhnGAjGo4BMMYxjAGwBrG" +
	"MIYxjAGwhjGMYQyANYxhDGMYA2ANYxjDGMYAWMMYxjAGwBrGMIYxjAGwhjGMYQxjAKxhDGMYA2ANYxjDGMYAWMMYxjCGMQDW" +
	"MIYxjAGwhjGMYQxjAKxhHEzj0cBn2u3/AY/0Hv994EvAPYdDNYwBsIZxY44HAb8N3Bf4kfbv7wA/4zznt4CfAt4wHK5hDIA1" +
	"jBtzPBN4OnBFe/u7wNOAZznP2QAOA1aGwzWMAbCGcWOOOwCf9O77ZHv/bJwBnA08bzhcwxgAaxj7+3gjcCLw1uFQDGMArGHc" +
	"mOPzwCnefae09w9jGANgDWO/Gq9ot5u2t48G/hR4+XBohjEA1jD2t/HPwGuAc5naGj4EvAp493BohjEA1jD2x/E3TC0Ns23Q" +
	"qoYxANYwhjGMAbCGMYxhDGMArGEMYxjDGABrGMMYxgBYwxjGMIYxANYwDobxZKYlNxe02894j/8mcD7Trgyfce4/CjgH+Bzw" +
	"fuBI57Ghi8MwBsAaxj4ZfwWcCtweeBTTcpvZeDjwE8DdmZbgPNgDpXOBO7Z/n+88NnRxGMYAWMPYJ2OP8//3Ahc5t58KnAWM" +
	"29vfcB57AAtf1luAn3UeG7o4DGMArP12XLL7Jnxr1/cewN/gPOCylhE9xrn/h9uQ8YI27Pt+57HjgUva/y8FjnUeG7o4DGMA" +
	"rP136Doiew7gL3C3FnBeArzWuX8E/EcbLr7RCxdTY+jiMIwBsPbbcdyO3Ry3/ZoDHXWBPwfu6tz3TeDt7f/vBO7k8krguPb/" +
	"Y1uWNYxhDIA1jH06buX8/xDgQuf2+5i2Rga4N/Bl57H3M+35DnB6+9xhDGMArGHs0/Fc4LPAF5m2RH6s89gfMs34XQC8FHii" +
	"89hZwP2Y9sc6DXjhcCiHMQDWMPb1+K021DsZuJfHsK5huhjF7YE7t8A2G1e1QHWHFriuHg7lMAbAGsYwhjEA1jCGMYxhDIA1" +
	"jP16KGzTNU5u1njgZIUnac2LVHiTwnsVzlM4P7J9sunfd177ujcpvGgCT1J4oMLJCtuGoz2MAbCGkQak47mdHsdD9Bieprfg" +
	"TL05Z+pNOVOP4gw9kjM5jBdT8XyBp8tURD8deBhT5/qpTG0Noe0U4K7ave/U9nUPA04XeKLC05Xq+croxcramcq2M5QdZyqH" +
	"n6kceaZy1NOUox+i3PR2w681jAGwDgVQ+gFG+kMco7fj9no77qIncBe9DafqLXkAwq8CzwFezNRxPtvOBM5AeBrCo4D7CNwJ" +
	"4ZbA4Zb3lfhDhwO3FLgTyH2AR4E8bfq+cibIGdONM0BePP188qvK9z6g4dhTG255F+VWd1FudXvl1scotxwNv/IAWMM4WMYq" +
	"JwJPQTgb+ATwKYTzqHkvwnOZFitvmyOMeqjjbrYwcr6L3EvCu57dUwFsA7k7VM8FeS/TsqBPTb+HnA3yFFg5cfiRB8AaxoHI" +
	"pu7K8XoXnqF35lz9Ec7XO/FJav6emidQcRsqRlHUKKBIFhBa6vM7kKcd5JztW9p9ywiq20D9BBj9vfJDn1ROOl/54XOV2z9D" +
	"uePxw2wYAGsY+xtA/Ti31Xvyy/rjvFDvzplUnIXwOOA+LLSkk4FbzM/1EHNyUcZHHJ8uyb76NhLYdQpNRYBbtN/vlPb73gfk" +
	"cSBnKXc+Uznlhcopv6zc5bbDbBkAaxg3NEDdlx16GifoadxV78NdqfklhDOYdjo4A+FxCCf3ACgV6uViNFmKdaklZAy/gXS4" +
	"VBxZYx9cTp6CFmeAPm+qh9W/pNzjrso976rc8wTlnjuG2TQA1jD2/a91T4TXoJwPnE/FC5C2jUsMbCTBmrQgtisRpwLP0LKn" +
	"O6/TAMClAs/pY4vXyPdD/QLgfNDzQV4D1dDddACsYWyaQT08cKI/kEfqA/l3/VnOp+Y1CD8eBabZ/5X3y87us5AUMgSm5PsE" +
	"IMm2my7TioeKVfSLSe+d5s/7cahf03Df8xtO+/cx932kv/cxD5ZhNg6ANYzQSX364qySd6D6INb0F7iX/gJn6kN5ITVPRrgX" +
	"cFeEH0DYgaBRHUoyUVRIr9pHp6cdmGzg5T5/uQMgCrID+AGZal73qqif3PAzL1QedOaEB93rOk5bG3G2LkD34QN4DYA1jPnp" +
	"+JYpEdHHcEt9DCdzGA9FeGqrST2Piv8TIBESBJycJmUBKylGnS2AtZxQZtGxLPsX6R7ECqH6P4I8DzhDkKcexmEPVX7hZOXh" +
	"t5w+5x06zNIBsIbRZVm3RPg9lI8i/C0VD+2dw1XmnM3dZ2VaqczhPmFjmvkQFvaWE++kFyPr/IC6QaQ8VKj+Fvgo8Hsz0BrG" +
	"AFiHJjD9Zvc8mzyeX2p+lXdS869U/CLC0Z3zy6I3pc5zjbw2BX43OJ+wIGQYwLSYiflZyJAOBsDRIL+o1P/a8Oh3TnjML3Xf" +
	"97FDmDgA1iEQ/v0Fqr/OMfob/KL+OmeK8GQRfh7hRISjg0CSCuOk4D4KQkChVCXfQpVLjMAmAWE992FTB6W3HS3IiSA/L1RP" +
	"Vn7lTOWxv6j88jHT+u9hDIB1MLOrp3EzfSonUHN66506Q4RTEaoo48kJ55YQ0BrK5QT65eK8JUBLCxA153ztPq5J0CIYRgpS" +
	"CXIq09rGM2B0uvIbJyi/drNhVg+AdXCC1dO5GcIvo3yYipdRcVInErGcjxU20VzNBCUMRlvDHWTzT4llE0JmMAmAU9UL+aSI" +
	"mopzisz3cRLUL4PmwyC/rPz6AFoDYB3g4PR73TNRn8nTqDgP4RlUHNcDnoqwnaiEWFSB/cWATY1gZmFg+0zHyplCJXC7a3kI" +
	"h4uuQc19XRrRta91HQf1M2DlPOUpT+vi/TMGfWsArANIp/r/UH0m2/T3eIo+h5cg/HrrRj+ud75VRs3JqmGlMou5ME8yEZqy" +
	"DwT5XKozjNySAC//8f7zFu8rvQyiRLSyzmPaHtjjgO8H+XXlt1+iPOMpym9vE14+6FsDYB0g7OoP2KEv4Bi28XDgRQjPRjjJ" +
	"u5iLSZuKhYMlr7OU6iwLYPsMtKziGt7B7IOcmg5OkfGUhZeLFrw4CXg28CIYPVz53WOU5wy1igNgHRBH8540vBnhrxEOcyIQ" +
	"6YR+lvOoyrCp2P5imlTo3KtIezaXK3zuvb0mgUqdEG0BMlqAwNKpHezeH/o/5MuK0V1t9TANI784B/EwkL8GffNQqzgA1v7N" +
	"rF7AsfqHnEfFaxHu2YsyqgRQxKxAFpaVY1h5gpKOxGx2KBM/CoNZ374vXuBHNLzzTZ9V4UGyXTUWUCeBK4QvQFZMwUpeqzzv" +
	"POW5xw5nxwBYNy44vXxxFuz+I27SvJgHsMpLqTgV4dYI2+fnVJUAnRBI5QRzS9RkNZWSYF5+6LcPZWTN2u/7j4nZ61F6QKzh" +
	"YRW7CinIdpBbQ3UqrL5UecEDlLNusvi+LxpE+QGwbrghz0D1eYi+nBNXV3kYwgsRTvfAqEsZKsrKXyy+LCivFbSc3zmJaYtP" +
	"Nwl2CJTgM2waWPxAaxR0bOKhJvdbAZV4+z4deCFUD1NedKLy+yI8dxDlB8C6gcfR/BDwlkr4C6m4c8DyEw7xUpFJSE/qRRuR" +
	"25jPWTvbqgzYsEk9S4woKVmfRUU6u+heRSDejyflw+rqYNq5OlXz+wKgeGeQvwDeAjt+aDh5BsC6YUPCP+NRjPggFXegYjUr" +
	"iqduW4HIwqxi+0tHV/HbeKHhFgjwfseqdOyZZzZxHwfkTWr9H0WTILg4sDrXzHzVTTrg5XyOVZA7QP1B5WWPGs6iAbD2DTj9" +
	"5WLG6qu5pf45j6PiWQjHz8EqJ5FUiTAvFZWAzYZQUqmSA6cQydknIaEk3sjiqyKD3BU2w1qsNlEyoFZlYvjgj74KcjzIs5RX" +
	"PE75k1surgmvGXStAbC24LR6Iqp/xaq+jjsy4jEIr6LiR+dZ7hx7SvkSyTy+jIhekj20RGM3wMITNlRcVkgvyQj243jt/NDQ" +
	"L7iuyAvzHfBSkB8FeRVUj1FedUflL1aFJw261gBYWzbug/ByKl5MxY5od5IKm45rZUI5s2juvaC8/1WVCDWtzKw4QKywZRHA" +
	"llHQwP5jPpLFa/vlPnGflnSuMuEfQjo+rnq2j9a3Ve2YLhIrL4fmPsMpNgDW8mHgW5ww8E38ITWvpHL6qMeYVQWGiCLMqirs" +
	"yavU+Zc6t0PnPxG5JsW+NtHbXbPglWtUn0bZuAYl2S8vAcARR1APv2+dCUerdh8xAJUfh+qVymv/cHGsXj+EhwNgGU+styFy" +
	"OqpvZLu+hTMRHo/wgwjbsiJ6qeguxserBNPZTE/3XKFzCnkKwaqv4feRVTM9m9VAE2VLfFaVFwrmhP8q8WPnJohsA/lBkMcr" +
	"rz9Tee124fGqvHkArQGwDEHKI1F9J9tZa3tWVRwbBZYqo0nl5ncJ4FSFYFQVRFdkNLAQAulyYBV/sxKDmMVsZkH03BWkJENi" +
	"eSzEBOf3HwucAaunK3+3XfiVQdMaAMs4xjyHitcFtSnLnMxZGaoM8FVGcpDTlixalFUeAnNpTtnyhTFsDLGnmV2AYGkORQwo" +
	"VZTpLi7WLdGxhKdqYGMS9KEIIK+D9ecMJ+EAWPET7J8czeqdvI6aZyc1pxJhPTa/c2VvoVCwRNSvCthZSS87ElpY/qGOSaHs" +
	"lT6UxEChiiK29g4oAc2rLrzi9N+7q3uFfzSNmu8EqJ6tvPV1iwvA3w/h4QBY7WR4NyI/h+o72K7/xJkIp3dqAUO+wxyjKrE6" +
	"lBABsJfzWLTsG6RnO0Zw8rN0KdpnCf9sgl/Kd6XR8oWFebTsqlH12GJgMs1qEU9X/v5M5a3bhV9U5R8G0BoAC+SBqJ7TalZw" +
	"BtUcrCSpp4oh1MsltiDuei/RxEraJ1u7LuQUFN3UwwZWtazJM37QpHPFia6Wgz0LAuHq9VJxvvO4LEBrpmmdvV142KBpDYDV" +
	"jg1Hs3JLw3IZPWvEENPBYiwNEr7DgjCuwlZuV8LyjLYGMehb4dfkwjwoi3PJ0N04OErwPcGvH+xrYNai6tiVqZKuprUxaFqH" +
	"MmDpBx3N6v2tZlViQyi5r8oAVowYpLLkZJic9TMuk/3fskDQuu5gbPWbZdrA5K42Egj3cpqVv9WU+VQsk6d+tvLPjqb1bhkA" +
	"61ABq39H5L6ovo/t+kFHs6o8HTTHglIyRQ48SICUxc5gZV5k3jclA5VSJ8uxL4I1n3WlZPsciEG+2LN7QCUAIuUgWS0pdnau" +
	"SI6m9e4zlXdtFx6oyvtlAKxDQbP6SVQ/1vFZzcBKotFGLMyrjfMx1XFUsGcRyUQzJToWCeAqbRa4T0V568KMttoiDbaOKb0C" +
	"ldZd5YAreQWSRVNAzoC105UPbhd+WgfAOlSG77Ny9dh81jrP4lMyRe1EDbkSGzGCHtjtDBXxPlpb1BK5jJz1gUc7GTqr4FZF" +
	"1hwMPccSmvV/SImAjzr0XHtUXQz/x66C8/cX57mvg/EhrWkd9ICln3A0q49FfFa5C19ObsgtDmHdv7WPluWin2JOMaCdqeKb" +
	"yTBmQ8I0DbXpXN0PoEnEz2UxrFmO8A8tTkpZOhmbUnHTKoCOnq2c62haH5YBsA4WsDofkR9D9T/ZoZ/gKQiPDPqsLHM1pK+W" +
	"eK1y9ggLIFozhaFzkiWBbZ+FfCkxjUQsm2t/DPZ6phSwQT7Va7/CaHFoGdzPTNN6pPLhpyj/vkO4lyofkwGwDgbN6pT24ltx" +
	"b+BFVBzhGJJtNgRr54VlGJL7lwJd1lp8bW2LTEJ034choUaBqaSJfayjgtU8Z7lKlVDxkpKD0BUwOWlmPeOPAF4E1b2nR+HH" +
	"dQCsg4dl/TQVv03lrBPoz6/a+2vxT5XYGFL7qrFbFCwaV2ltrmWJvi0CLvUc7ZJlT5X5S4uBli7qEBf2BS0q+nTFSOvrXVCt" +
	"Ez908WQ6DKrfVj7200NIePCA1XHU/Aw19zUZPy36klX7yu1rmf7vJSU/pQmt1DoOWyTEL+Bq8y0q7MJ8t4Baerdj4BY60LXx" +
	"x87VJpZkDZMT5b5Q/4zyH8cNgHWggtQXnVm8yhOpeKjJ65RL6tSZC17t7bemrCPJMuJ6tSRIWSwQuVbrSweGub42+fJpTQJU" +
	"jo1t5kB39yO9sghLCjmkaeUnoMY/00OhfuKCxX5aBsA6kHSrk1H9MqJf5K5UPJ6K44PMvV6SAfkAZendFpqbdUY7wwBQ1v5c" +
	"qWoQi2a1T08Bq8ofWxe6JOPRvU8T7EaKMni5x2vySyaFQExymoRCdTxUj1c+fVfl/4lwZx0Aq3w8GfgkcEG7/Yzz2FHAOcDn" +
	"gPcDRxof+33gS8A9s+8+5i7A+VTcqp0v0gGqOgA+VUbDkoj2ZdVxK+e9K8NcrIy3l/ExyhKbq5TrVoGUBNiTBLShnBO9pL+O" +
	"v85gxeYNpKlQ0GVIPiD6Fok6sp86wuTmHq1bAeeD3sX4A/zm9Pl8CfjMlp9/ByBg/RVwKnB74FHAG70vfi5wx/bv842P/Rbw" +
	"U8AbkiHhf3M/al4WBQyLzaAm36kh5LPKSRbLaFQW60VJK+bS3lkspWOpmkGry57cjuqba8wXBxYtsxIYwsnYj1x39DINPp7T" +
	"yiyu+fkEfJnyuftlDvzDgZ8A7g6cCDx4K8+/AxWw9jj/fy9wkXP7AcBb2//fAvys8bEN4DBgJfam132NHToV2H8yKZTXhXOw" +
	"MgJYVbiPzb6vFLC9kpZSeVwpQaMg6mkUCXMtX5ZJkdb0+1HlfrB6ExMhDqwanXB1RrOwfJ7qJxW573V8Zkfit3kqcBYwbm9/" +
	"Y6vOvwNdwzoPuKxF5Mc49x8PXNL+fylwrPGxM4CzgefF3nCH8BAqfqIIMHJgkttPvUmNK3dxtmYyrZ1GwbZ8Xw60tByxYmL5" +
	"YlWdklgWwk31SmLoVHwvHiOqvbKbeomrVMgJn3t97YFciqVVQP0TO1h9SOKn+eFWsrmgDfu+f6vOvwMdsO7WfuGXAK/dgv29" +
	"saWwb41+GeF3pOJuvblZE29bFJYMbNpSKSDW2AuoLVJJ6WrSqYxiqkXUFgnxXancX2KLgJCeszX0bQvLF36GyoRC9YQh/aCO" +
	"CPo+WNXEK+nj3SEkCKrhiSZUd6uofyfxM4yA/2jlmjd6cs2mzr+DIUuowJ8Dd3XuuwSY+UaObZHc8lh/55dM57h+k9vqNzmP" +
	"mh8NWgtSGULLmoIWVm4JDS21t6XmantnXnstpGWtwoyOpYVQlm4QFmqmZw3JJCB6p4TBXBuO2hTTS7QcJ5bl8YFHEmJqnQDw" +
	"Cqh+VPnKecpXbjv9Lb7mHsBvAm9v/38ncKdlz7+DCbBu5fz/EOBC5/b7gUe3/58OvM/4WH+aH4fqxaxScQ8qTkWoOxe3zZg7" +
	"60IgMUkMhqxjjuWVdCipsFuNMDCsLSl+juta+Q9iMaOFWEuNzUi3rIYQC/+sIFmqSSRLhxSqGqpTQe6h/M+q8P3u4X8fcN/2" +
	"/3sDX172/DuYAOu5wGeBLwJPBx7rPHYWcD/g88BpwAuNj4VHzalUPCx7cco2dtwkwFUJDXXZrSZdalZlMusWnRpsq/cUGkfF" +
	"DFAWS31sKficgFcTtjCUbeqFfbrUFWrZHz+2QEZN2CbhtqOpHwYrp3o/wB+2Gb8LgJcCT9zU+XeQANZvtVTzZOBeHsO6qj0Y" +
	"d2gPztXGx2KAdV9qfj4pfKfYviVjWCfmVB3RbWMMzJoxt+pWFouEtTkAhGsLZdMxX6AkB/JN6a2xc0V81eZuAz8196ha/MgS" +
	"Fc6thlHL5LEzMUlmEDsT9+ehvq/3U1wDPKjVsO7cEovlz7+DTMPatwLZlfwRNU8wz4OQlhUzkNYJcMgtX1cHNNmURltnz8Oy" +
	"Ep/NFEGnVor22ZeUQZZGtSlLnxtbrx7p2BZ80byKLLFlLfz0r4R1IHtodRqn2ZR676cJWh1vHChA9QTlkj/iIBkHLGDpV9iG" +
	"cD8qjs+aPVNa6jIh3DIX1TpzkbU81/K4pRzO0r0lJS0tmSkU05Jefgtja7/p5XSm+EEtC/k0qzHkmFRt1Nq6n0/zWZXjQe6n" +
	"fHnbAFg3FlhdzeHcnJ+j5hZFGlVO1JYEkNWbnP/LglKdmd/W9RFLF27N9c8rAC3NxJdqdrVb0qHWTGBdCE5xY6cUeVriV0Dt" +
	"hKHd94utJi19DSuwCGx9Czjq55TLDx8A68YYK5zIiL+j4vuCGmtlAKVQdjl3/7KCeipZZRX3rR0nSv2SKeDCGB6a9aswo5Jk" +
	"RjBGBe2dPjWbgQvVLpZZH8QEjl0NYKqpzcJKifTMCgOreqGu+16BusPvg/rvYHTiAFg3NLvaw62ouH+25ZAUAEkqe2zRResM" +
	"G6sDCYBUQXTNch4wayeVCptZNNY5YnO/oLfDnGvWWkEers/r9sDqCooaFdJj4V1tnFyjSLjmlwjVzDxUYsjmaLQhoH/somHB" +
	"/ZUrbzUA1g37ie9OzWOzLKXG1kFhs+Gd1Te1WStQTuJYRoOzdnColtOs7HqVVVSLdQpNHeC0BUGjr7Vm+OITQgxhp8wZUf6H" +
	"laIfOHjVeyyM7j4A1g00rt9gTYWfRDhh02Fa6etqw1zNifi1QROrN/HZUomn3KIZFj0rJ8IXgRXYnaqWqvNSU1sdYSo50Ks9" +
	"wTt0NZEM3S4tm7AWr+Y0geoEqH9S2VgbAOsGGNuEpzbCvRsBrSl3gVsujjX2lchDOqw1nEtpWqmsp2A3ZgtpEzjYFnoNYUvE" +
	"1uC2y+q3ztIEgNm7Ikiw44K1BUsuDBTj1UoSS3rlMoRVwY9b8qOb9Ix7w/ipA2Dto7Fr4qwrWHEawokq0AAqoNV0y150xHix" +
	"k8xFsDayp5zGVi8BqFarRW7ub3aRC+JZwvYp2tXmc4I6BuCyFC+HJkDpAa0jAFUbYvQ6k+qtCiZc3/elxgyNRt9PgOpEqE6b" +
	"/V5jxjIA1haOHTV6/ZjDd014iLZg1bmCxy5ONfn2LcvaD5bJhFeZeW3VyUJbafSQAzKLPysdEmb6YWHQrChgYCUHPXYAa8PV" +
	"qN7ERCmZSGHTqRgnoARLKxafQ6lPHDN+yAbjw0eMdACsrf6QFccgPLuBWzTSMqsZy2JxW60Ln1qkhVIfoWX/dSFo1UZgtQJg" +
	"SU86i+S0lOgOuSpsXSo7koqvrRmTulC0DAOZmidM6upTGydCmRbWJixuATxb4JghJNwHQ4WjVLiHwloDTARmwNU4mzphYjJE" +
	"svqrauPcqQ0XcCuT2sqaWktDwJxLvsro4tbfsLejuPYkpoLg8KISujQNlkxIWJGut3J9UHXmClRnYveRU3BdJ1mXep6smEiq" +
	"CM2iWeIaVPeA6qgBsLZ4XKPcaQKPU2DCglU1LEBrDlyVc1/lCPM1YS9UqQUhJW2IIYTLnQ8WZ34dAZ9cdl4S3x/ylqgqkdgz" +
	"catlOjT4X5CAGNnN+EkRQ8ppT+kfRJOvc3+UUe89NDgxwwtkaORzaVT87xpMG0f/coFrgj5uD5M7DYC1lewKTmngER2g8oHL" +
	"CwvnYIYjyteZ8GmZkC+lJdkMy3ZmlmN6OStRjc2nGRPgWdbOkLM1lPR8Krct5MGrTlwh6qTALp2iZKvmUJkmojqbJLpISNBb" +
	"JnPm5W4N+P8/AuSUAbC2cDRwksJNJx5YRbcZcIXAbBkx3dq6uzZoThbAqY3gWAJWJeEjbHnzvuUa8sXaDZdm/OIHXLNXsZQG" +
	"4HYWtYr3ftiYT2FL4fdWp8WOOgA1+7/pAtdNG+SkAbC2aHxHuX8Dt584bMoFokkCtHoaV8wGUSrIWzPd4kUDseigNjCu0nKd" +
	"0P6EvCHc0hywoE1yhDE7mgsZ4FpkvdRgLdBIL/XYa8Rw4LQXkvV/UDEBX2UCQPezSTSE7O9LqWjmetbsPBHnnFmEguqcPxO4" +
	"/bXo/QfA2hp29aQJ3K8JgJQGgGoSY1sx4PJ1rVJWL5vIAJaI8DlNLHY+5fqE5cLYVL1h0czpdgqVnmjW91P5K9ZIEoxmbKRG" +
	"slcIv4to7CDP3ncUKLGxGPFKLBNhH5m2n1M7KwGLp1HVNFQeGHVDwUkLXA5IuefK/Rp40gBYW6Nf3bYFJk0yqvYxtYKXFypG" +
	"M9w1ZVJEDlwsviqrX9EizZTozrl6w6XDQ7chXW7twPiKM2FGtIyIbgGWyiB0pnUyNU2ENG2XRE3iIrxbLEfmMqnGAanQxd09" +
	"rxRuOwDWJsZXle0XKfeetDYGBfEPdg68mphA72tcLmhVBcBj1Z0sz7dmE0OvGRkkmGVW+lmmAWBWw8pnBdU7WcvSqFaaW3v7" +
	"D+1rZASw0qZ7Fj2hjmpYs9BvGv55Wq0DVJPMOTI7r9rXr12O3vsSdPsAWEuMEfwA8PoJnOCDjg9WE49dTQLgFWJbTbVgW66v" +
	"y1TwPCrI6o0MgJQDLcu2GS3OutCFJDAoqVf5S8+HBTLtrcwsSRtD+P9R4Q9QZzwr3U3nHqk0KIqJQteGCSde6EdATJ8yqzES" +
	"BanUeTGBExReX03PuwGwrOMrurh2K9zaZ1ZNAKxCYaELbO7/wTCxChhQJSDMd1sdxefrqDAEjG0jZyvJIo4KAC7Xoz5VXE6e" +
	"XXXXdc4XL0q0JYsUxtLWg1sXbxI0hi57sPPh4gyoFiBVzTUqP/xTLzml3nkxiUQdU6alt24v2VzU/h0AKzNOEPTLytoEflin" +
	"C6wlmZJmwCv2t7cv6W9JK4TVepAL50qY02a3zTjrlwoDY/TL2uK4ZjlTZ73FB7hEFKwNqeCauFO+Cmb9FvO8r08tNg0K6xOD" +
	"XNKeS9UY+eEL0bVbTyPFAbCM0/vHJvBwq+9KA8A16VNes4er8ZzzHeNpLPzK6UipMHK05Lk0Mor2lky6pQaXjJ5lzBLSsTWU" +
	"tIdd9gClKGgs7KsNgGmNz8vqtBYaVR+o1Mv2NYm5bgWqpvMePHw7/NgQEpZZGe7dwEMDtLUHTk3mKqKBDOIk8GP3wk6nNnF+" +
	"27VB+CFgzsE+SkQiVUbv3bpopvs5aiN5yRVIF9kaKk/Psi5dFBPFRwVfOvTFR8GDK+bnh2L3mJ4mve+iDjhOQ7/asSdIx57Q" +
	"tPqURvVaMV6Ydc7GAs9/KNPVoAfAKrAyTFK60yRz1ZjEhcXo88cxZuaI8x07RA06csDKcsG3RDCjyDkZ0rNG0fMtD27W2shc" +
	"23UswLXZLqGj3odWM+UcGSjpKMK6RoVXiThz0oy42fRKaFyQkugF17r1gU06oOVe4NubA2BZxmeV4ydwGysYWewMlixJljLH" +
	"NK6q8AJvAZVSBmV5rtWtHwsXLZ4sc0jox5hVVGyO0UPpXSlyYeKoIJsxwh57V6YDLoH3UK/mb6FLdTWq2DwtCfk0IaH4UcwE" +
	"bvM/6PEDYNnGoydwj6YQXCabBKsUI+tMEJdxOVnGaJRiybDXmdduRdJrVJDhj2XWId041CS6p9YmK8kwpD70aAmWlXreMp6T" +
	"EfFeWbOsX+Vl+ghqVLG52Wzygh0S7tvn3EPh0QNg2cLBRzRwYrGvKqBZ5QApddvfxpGs4kycn4WO2XBvtIkMfCg0TIWKo0Ji" +
	"YWmmuXQBdKq5fBgEJPn4yBAvW8CqhGlZXuczxC7wuRpVE2BVk0SGr3+fLhWFpNhX+5oTG3jEAFg2wKpClLUx2hlKAKlJ6FuT" +
	"zDZu9a2JdEt8JjPGFQOnEBOznjPWUDIEaqVsL9S3rk4AV1bDWmYxhbTBTZM0cgSsJIAttq1472OlrmG/1qx4uulYFMQBqIVG" +
	"5WupeeYk5ugiBXKTsDWiGgArMd6kyH8q3zeBFSv4NIbHLa+dGAAr9Lz55JJAB9TKKa5eZr6PjMCVY1Ejg4RjYV0xFmYGLMko" +
	"+aXa0yhy34ohxBttAZsaZTOX6nR60AibivoCM/MvxcTS54JkJJZ5mLjyOfT7PrIfGkj3C8D6IThaplaGm1qzHtarymQToWCT" +
	"Ablx5Ko4LxeqMsJ8DFxGCd0pd85a3PIWsEp1eTBrWLlOoiWp0+4XkuCXGGXEwJHhAFgPZvxH6utTVYdNjQvmZOribLmgW/2I" +
	"3utvqvDQI+HoAbDC0/pY4KkNHOunWXUT4FVGl+1Maxx4zhjYEBi7bIu2bXMdYFujjK1o2ajGJxsr3n0rlOvRsa6lWYaVAyt7" +
	"Zk/NIl33C09r//xwr24fc7Wm/qa93uoplB/RUDutXBZh39giMVhsNoZE0hhlErAspKpFAufYsQpPZXpeDoDlj2baleH7Gqd2" +
	"0BfdtfAqkbviWCl2bAKNHeAK7qMNFd3sYlM5/q3Y/F8JnFshsFkxANpKgR6W07Is6xxGQCu+rHydCO1GHqPyD0wOiUcs+lmF" +
	"nrtgadrZX43bmE8yB21h+KwckKo62tSk1Y76my7NkrTnodKgLULTAnuMHEh7Pq4NgBUGrHEDtcWOsKyVYbM6wCSjbY1zwOUu" +
	"lOEyrlHgHLSGfzmgCt2/YthfrtTH7MVyuy/kluK2aE+hL+h+qZUAkKVjYgmGl7mD0tWoFmbMBVh05QKJzBspupjGzwMtNlQb" +
	"zqO6mX6FAbD8MYGb+UhfYowr8WlZQG6z9N3XtnqahV/qU5r1yz1vlDiHU6HmypKgZcoQhtbt82v36gKRfSXx+Ergy6SeG89q" +
	"LELKkceqFkzKnwvjxIWtycyf0gtm44FizmCaJgPqRxY3GwDLGx9STprAA0qygxawaRKp4tRkGBuucpOMvhXdX6txzdjW7D6t" +
	"EwDiA08MgFYiQJV7zUpGP6szliMTcPmdQ30LQA6YViIffDUi1oX1rPgBWckA4Giuo03anlRdW4IkL27W+RWaQ+OEhrV4nWSj" +
	"CUvHk27BNTTwgI+jJw2A5YwxnDqBhynxdq4pkBpj78pQ6reyMK0Qo/LvG4c2gUnV3ZoqIMmMjGBjOT9XMlFTLoOfWpHLAyzt" +
	"MKySUDD3hUKPrfa+oAYOhGa/uC8mjuZZvwkV44hGNY6wqyYyN3Iglmf+unSiKRZSRl77MIVTB8DqTuzjta0ftIZ+E0OsbhUw" +
	"xwVelxIwG0dCQ3+bOeXHlSPM1wnSUApIOaKSCx9zbniJg1a4b3vKwxH6Ei7YrGQY18o8jIsdCDVlKhYZRFejmrRdPccJsAlZ" +
	"XWLPK00Idee3Zgv7S1rLRCKQ2zRw/ABY3bGqRt+JJZvSYBcuLT6X1BVynGBSk8z9of874nwdCRVjYeKqEcRCzx8ZAC8EYlXc" +
	"i9VfGafbZjiPwqOCL9dHXQmi8IqTbayjFHWW+ZvM2w5L9ne3gNek0LYQyi42jlhvFebLuzyoe3t1AKxuhtBcmLxM1sNSnrPZ" +
	"rclkD2MhwxjYcO7bmHm5qkV9YjNyrBA5VjQ7t1cjYLaaeXyUAK8U05JuKKhB7cpf/aZOZAn6YCWdD+1/ke4XlAiwSfILLjSq" +
	"cY9RyRxAxmjnd0sx6ZxulboYNp6Q3gclCc79cdK3pT1hPca41Hn+AFjdDOFqqhgz5Rsp6SZqtTKMM34sa1ZwnAkTYxN+/thM" +
	"oMdhXNaQL0ZMVo33xchLDriiWcI6ybD64V7qQ606YV33S2oy4xCPiZsWqCaOPcH/jTaADYQNQ0jozwFrCVi8nlA7tYDLZ9Cl" +
	"w85ykUbr1h8Y1my8c5ohvM2yFNbCnKymvDHp/u8W0X1sFOZ90Npwth6oyUKgn3u4RolzejXzN8a0VhP7jIFWQHTvSlmhkHDm" +
	"e1qZC+YSBawwNRTnPvU+tAbROizKTxnV1PQ5njOr7u+Q+33HiZAwx6LsbF0yfq6yRn6TyMU/AqS3ec9+lCm8UQFL4D4NnFzi" +
	"sSpp4FeiX1mvhFH9KZYNNGhZoW3dBbMWtGZdImag1QGu0Pk9Oz/XMhiQ2iygJSl2lWoLE/swLtCsRT+cdkBqFg6uZsS7KVg1" +
	"1PPQbyakx5hv6vdK3d8HL+09J2erGRsALadnNZksZGY7WeA+A2BNkf3uDfxgCVgtUzRqLXS2ZP5KM4Qh1uQzqon3mAta6879" +
	"6zLdZgA2mYWJMabkn+9rzmYFq9WEXyu0+GovQxiq9VuJUMPUh/e/xCrCGjIHqcXfGHIrIybUbVg33Tb8Y4yy4QDLRk9r1FbL" +
	"Sgvu4TkjJktDCQtrvKzhpBCcYmU/znN+UOHuA2AxX4p+e6p2cJlUbUm7mJhJb1ygR1nE9djjoVBwPQJyY491TapFuKgriTAv" +
	"9L8PXmsGvIhpaEENy2dY3TAwBEDdD2VB2pUMvZz+bVqgGlM5YNU9rov/FzqVf/wnno5l0STLwkI1luKE/FhiWuarKWRZCtv3" +
	"p6Xsb2zA2l7SIdESxuWydiWZwTHlvitr6DCJANJGgm357GzdySqOK49xrRlY1mzbFrk/FyL6S+xFxXbXd+V+kJXIB9vmfagQ" +
	"uOXDxabVqCZUQXCKaYcxXbFU27Kw9CbCwGzzVEwh4KQnptu78rbb9gGwpgdmkgMjNdoYLGBlp9d2TSEFXBsZ4Aoyp8iVvx+6" +
	"eJvAxgy4Ri1wxYjLtsT/2yIAFsKFUUrHqiKhYIhdbYt8yNgHWYver3OwGrFBxTrSbt3juh4BLitAlfrtJhnWnnO9T4xJoZzY" +
	"vmSbpskAWPR78ShltYS5dsehfuy5cNHifA/ZECYGFhXTqsYZkIqyqxB4zYCrhskKqH9Oh8BqWwCstiWIji/CB0Gry7A0yIgW" +
	"b6DBD+F/kNUkmjaORrXehm6L4yfJY7cROM6533Mc0SBLTaOWmlTrOeDbISZdE2ix8D577gBY2FZyXqbdcWlbGUsBam7yWcI/" +
	"C6MaJ5jVOrDXux3dPODqAdT2AFBtd/5ujzxnm4MRfmgYDAlXPCtCiEFtQ3pvtha5veYB3SoNK4wZseGAVZKNOlvKYrLYwmbR" +
	"LoCpyZfXRMNJNXQH0SQDC/mumozvyup4P+QB6w3K0RMYxSjrhLI+7iWO9mbJTGCuwDlG/UNX640IuG0YQ8PYttfb1mca1wia" +
	"1ZZx+SC1PQFW24Edzn0usVnxhPcewxpFVP7t3rbD+5tHTWWNhhUmLVDNQGqvA+p7A8dmPSq2pxId0nteyK9lmVNhzUuNfkDJ" +
	"dguxzn1beyaZsbTRW9GjD1nA+qtpfHC7xhHdrR4Ti6dkM+U4VtCyFDinvFY5oXcjExquB07KvYltj8B6DeMVB7i2RzYXP3YE" +
	"HveZ1ijEsNzM4FoEIXcAh0XefHvwjZVtNKwyZsQ6NXuR6HdeR4OgvmHYUuL7OAhWkvXlpS+CslTpVyy7mNNq7eeQ0Ewz+bd7" +
	"M7p6SAKWwA6Fk9oDscRy23bNatmOjhZRPefB6pXbZLxWIVDKhn45oAJ2t3/3AHtb4JqsgrqkZYe3HRa5nQKtDsPy2dW2xBsc" +
	"FvgAfeBqWGuBqpoD1fx7eexqukkPoFKMy5I9zDHk+IVME0XPkm0MmbYryFKLq9o32a5wUvujHHqANW7YNm643QS2LdO/qmR1" +
	"Z2vYaA0BLf2vrExr3cCu1nPZwQzT2uNtu2cAJrC3ho1V0Blm+Nvhke0wD7hmepa4DGvkiOQ+o3J35L7ZYc5zDpvfbtjGBiP2" +
	"ULMb6QJw538NHgMry1o3ZAu7j2kS1LrzQjLsXbMXw2W6kpTU2CY6NmxraG7X0Gw7JAGrEbapcFttAatUr8rVRi3jZE/pUJaQ" +
	"MHUltmQEffBKnVR7AwCVAyqXae0GdrXbngr2jmC8Cs2OCEAdEbnflZympUIXKXxOqS7qgtVhkZ0eEUVFZQcT1lhnhT1UHaDa" +
	"7QKv831d1pViUiHQytkcwqxLjGBlb59t7Uqas/aU9Iub5M+3ba3J+9AELBVWG5muyrFMR4Zli5wtzKq0gDXFojYMwJXTrlLM" +
	"ymcRezzmsTsCVjPA2ulsuypYX4HxNtAZvhzZbkc4/7vbYexiO19lxCcY8UFq/lrhL6H+axh9EFY+Adu/CoftWrzoJu3m7/iI" +
	"FqgOY8J21lllD/X8c+7yQGp34PuGwsO9geMUA62xCaTyt0uL4XOFzRZNyyZ/qKnJZaB9zVqDfJ/uB72xbhTAmsDqBI5rnNYy" +
	"uqSAbm2hvEydljULaOmHFJvM/gniptvXM2GND1Z7Ayfvbg+k3G13CwbXO9vOCvaswuSwFkNuAhzlbS3e6BF8vLk5T5Jzubtc" +
	"yGnVdfxBDa+u2P0HwtdOEz5294bvfZJy5Mf7O7pJd2ccwYTDWGeNXVTzz7XTAVefWfX0uQCI7Y2EhzGbSAqsLLpVzvKSmyv9" +
	"Bn5abICOA5ssu0jxagPH7Q+tZm6ckHB6AI6dgEwo6+Ne2mU0vNhk/HXLiuq5YudxBJw2Ioxr3Whl2OsBVUq38gHLZVjXA9e1" +
	"27XAdRXsWoXx4cD3MF0D+Hva7eZcwZE8kx08c3IN/5a+OF37b7D9mXDkM+FmVyx2MttuwpjD2MUq11NxnfNZdjqAtcv7f3eA" +
	"Ze0JhMfWxIU1c2ixRFjYlq1DaXyBC4v9Z2sE99k6hXLsIQtYCpXCtmWZU8myXMtmBmNGv1L7gqX3VamNwdev9gTAa3cEtHYH" +
	"AOt6BySubbergWsErqth1xpsHMF00aebs0dvxkc5hr+tnsHnVv+S9cnzwg1mJjxLVnnTesXvfQ6O+Vvl5h+Fm+2Bm6EczQaH" +
	"s5M1rqPmWoRrZmDps74AM9wdAa1cOLg3omlttAL6RgbEStnWsh1Jx0uyqNIWM364GNO+dKpjVYcqwzJn+KyxfMPyTdKWXS0n" +
	"p0+UaFbrGUG41NawxxPYfYZ1vbe5YHVNC1hXAd8FvitwzQrsPhzGN+N8bsZb5F5cOvs96z8K99GteZku8ob3uxRu/pYJNz9/" +
	"g5uwk+1cw4irEK6cAaTzGa73gCsGWnsi215DpjAnxJeyqni/NDVlnpeduw3lFh1Lkiv0/yEPWJsp2FwmfCwtirZcLUubvlmy" +
	"gbFatxhI9WwLAWa1OxBizQDBB6urgStbwLoCuBy4DLh0lQ9VN+cfl5tsx//jlRzxoSsYcTnwnXb/VzmA5YOWC1g7O+Cr8/99" +
	"PSsGVDHw2mg9WxsZcNowZIDDv7mYC+nLOpRqcsmv7gVdsyvnWNqUH9KA5dYNKvYWyLnMyFYsLmFZyimnZeUyTLn6QatutR7R" +
	"sWKCu5VdzQDrO8C3gUuAb053vfT4Juy5pAXAb7dgGAKt6xyGtdPPaAK7WptDyN6wJ5CEiJlE3SSHfwEpAa2NJUT40jZGIcNo" +
	"qA9WE32uvf5WI/8fqllC82o4JaUKDVu7vmAJsI1Zzptl6cBgsTWkmFZIu7re+XutA1rXeOzqOw67ukz56uXKtzbz21+OfutS" +
	"9KuXOYB1pQNYVzufIxQS7s5oWXsz2cHSkDClOVpaYscZlAaLmSfJjGG8HMfScslakpNia4cswyr1UlkWVN3XgFQCVpNA2Bhq" +
	"1Dcm3UIm52yPgVUqQxjLDIbY1RUtsFwKXARf+ppyyWZ++/9FL/kGfOkyj2Fd6bGsaz2GFQoLU+L7egaorNnCXLY3XQyv5n7v" +
	"Pggtq8+GtSlNGkVLNONBdE9Q0VJrQ8lWslxXaTbImiHMdcHcwFbgHBOdd0WsDLsi2cFrAoL7jGFdClwMq9+c1twsPb4Bo4th" +
	"9ZKWtc10rO9GQsLrPIvDzo4nS9ttdiyUvagnvGu7pT1ZJSZeO5uWBFi56x0uynfi81GimlP+3BBTRJNvNaOHJmAp/b5XmxXX" +
	"t+KqtOyyXtauC7k2vBsGtrVBvGYwZGtYhmHNQsIrHP3qUuBi4W7frDhhc4BVnfBN5G4zsPpO+z45DSsUFvYTDMIepzxnejxk" +
	"XrKzWe9VTs8q3WJO9NCiEqUdG0ILVKT7z1lEeRkYVunS8SW+qn1tX1iWheWygzndKqVlpTSsnRHvlQ9as5DwSickvGwKWkd+" +
	"e+p/X3p8B464DI70NSw3JLw24Mfa2WYFu6U6U4AKOd5DTCqeIbSFhamSq5Qvyz7npKjzrd2yI1u2AvohK7pbVvTIOXgtALdM" +
	"MfTYmNmx9PDeINzHPeZ6zzGqzRQ850ArZWuYsayvw7HsYW25X3732v/CsZe2+/tOQHS/xgOsUKYwxbJSGcKQ0L6XeFufjS1i" +
	"Uct0+Ug16wtfUMXctz2sAYspkhkY1ibDwlQ/LEuDspJVcSwLplrd7Tkz6TrpNsmhYl//ZJ2dyL7hMhYaXuPpWC5gzULDy7W+" +
	"HyvbnrLcL7/6lEvQ0y73wOrKToZQuRYNAJXMtasQEIcKoC1tZqyudmtWcKMYmJbddCsXSzVvhzTD2oyIbmn7utklvVKTLJch" +
	"Si1Lvx64PY4wq5zgHvNgxYyjPli57Op6Lyx0tawrgJ1sZ0NueiLVsQ9DT7nD4gd9VljceMpkcf+d9A4cXz1sz03kpKtH3XDw" +
	"6jm70la/kiC7CtUT+t81pOn1S3PUvGpOLDOY89SVdKUNzz/NhH5SvDL68iRBD+2QsIFxA1enVryxmEKbTaZpl12P0NI2xCLK" +
	"bmBvLbOMF2tvBLB2Eq8l9EPDaxF2ssKYw2k4imkV9C3uCMc9n+Y3foWNp96C+mXh9NGrauXXxrfgsZNf4Rh9Pjfnjvo9MD4C" +
	"dq8tgPGqeSgoc7AK1RLujHiwchpWv8e7FPuwUuF8yUUsN3eWqX21Nqy0SCvh20IDVzfTj3hIMqz1CVzawMSiRy3f/6e822iu" +
	"tmtMeS8sy2IT60bQSrX6jelYfl2hf/LvpO94nwJFxR5WaXBbNhytcNMdcPgjYPuzqY89Hf3Xk2k+cSf0G7dl557j+Z/mtvx7" +
	"cyf+RU/m2Op0tsuzOZxHcDQ7OBrlaNAjYWPbtJ3NdRIT2uPeq1hPrG4xuCbBPnXs17E28Vu0P7boVnbQksQ81qXW3bTWGgZA" +
	"azKBSyfTw3JI2hrWFS5uYG9qWa/S3lcWZjabMMuspGPtcRUT2dfJl3n4ZlJrO+Q9ER3LtzbEGvi5LOt6hN2MmHAY055V38Oi" +
	"d9VNZN7LSm5yMnLUy+H6z4OcC/JSRJ6NyEsRzmUnn+coeTk3kZP5Hpn17pN5K6yjoTkC9ozgWtApw1OuQx1mpW2GULNdGlzt" +
	"ataBdLOGUVvxs2SXql/G+BnXuSQroUxa31TXMrG4L7Wkl39OKbpX0Ysb9NAErHHD3olyUQN7resR5hr07YuawpJaMAuzmmTS" +
	"4tZuDbFWyXsSbCvly3KZ1l5GTNhOv4XxkYH7Zs3dt1XI6k1h7f4gj2GF+7MmN2WNiu30uyIf6e3uCNDtyJ56Kq5f3wrsM7F9" +
	"N8JOJNuloUR0D7fw0egFZqM48aLFLWesbZJt7Em8zJ+0i1VIBKS693e7/creCXrRBN17qDKsPQ18rYG9uTAvFS5aQsJlPV2W" +
	"lsiWFVOsRbKlIWBKjI/1w9rjZA19lrWXmjGr7QrMsebuM5ByF4yYLVa4AlRHIHJTao6Yr+41W38itahFu+n26aIYeyrYCbor" +
	"oVmFMoSWXlj50FuzjKrE7rAZycHSOqakmWX/3JFIuY5fKK17J8jXGmTPoQlYFXtU+HIDu5cREFOxeK7H1rIxf2npTm5NQss6" +
	"eDHgSrVNsRREd098YYNaJ6zRXbFmB7nVbPrrfFXdRZ9XPdDaEdmVu3DOjum6iesV7JawAXYPtmLnxXHSpG417twWUylVzMJg" +
	"XyVnuU4h6Vo/XaqRn4EY7G6QL08OVcDaDbs34MIZYJX0x7IwrSZDrRvS3UStRtJUh9Kc5mUtCUmZGy0N/VIi/F5qGlaBHdIH" +
	"q9gagrFFCZ3ln2eANQqA1nbiax52b8t4BfZWMbE9XR+41wOhlHblPi/lj7NaWKzh3zK6Vqof1iRj/lzeoyW7x3Dh7umhP/QA" +
	"6/XCuIGvNrDHP4A5HSuXts2FkqVdHC2LUKTCQ2v4UJIZnN3OhUExY+k6FZPOAqf+Flo5dcc0ZpsDlr9efdWdTj5ghVapdzHQ" +
	"Xze1/SjNGoxHsAd0j8cMLYtNWFbLCbNcNa0AvayFwWIgzc9d6TCr0tWdC7Y9Cl99LXJo2hoA/lLY20Cz7CKpJeU7JUWk4wJm" +
	"lcoeWkEq5npfL/BibUQEZg+odB1hzAgN0p7w0vCd/8VnViseYDmzqnaI10oAuLZpFyMDYDXbdA2aEWxUeQPtXtJ1g/2LgRYV" +
	"q+cK2C2m0dJ6wbQXUYJLhOXaNuVaJHtb82rkRhfcb1TAgvxCjyV1hpYfJzVJmoheYAGr0i3XzmScuW1J03dP5mkrk6a3dPy2" +
	"CEBt8wDNZVSrzjYDq7rdpKth1SnAcv4GQKoHXtsRXYFJDetia9KXWjVnBlazBSjGgfCwtD2yRVbYbBjYZP63aLiN4dza30py" +
	"9gvAsoSCy7CpmO1hGaG9YbkuDSGAc7WQsQG0xj1B2N7kb3ayToGqBtakC1RrgW17AFUSYKUj0BkytfrVrAWJeCyrB1zSBahQ" +
	"dBr4KLoGzUqYbaW6MISPnbTAJMal6dP1gssWyZcA1xi7JGI9R1wrw2QArCRg1ZstdrYswW1ZnSe1iGpJaU6o02jIhxXq4uC/" +
	"Zp1w3aFFgN9AmHTCPx94QoC16qHHqocyq91QUEYgtaNfyQKzJMKy/G0t8PFy4NW+djKCjSnb0lRXhg0TgKlphecNbB1F0wXQ" +
	"mtWxcnPdX1giPdfVwKikt+K6s9UDYE0PxFXLWBSaTVggJgWvL6XyVk/WOJKB8k+uMfl1CkOhzoQK7VGaEEqsZUBsNQ5WHepU" +
	"gXrsqgqEhingWo18nNXER2tJ3qRCShZLHROuOkiF5LHVcKxtZHyx3LoWYbqkRoIFyt05rktLKs79Vw2ANT0QFzZwRWlcbTWb" +
	"WkT2UoAq8VxNHCCKTWxLdwBLFrE9gbShRrN0Zi3y2GoY4HQlAFZ1X7/yAav2nmYBrcxHCW4rU1F+LMuv7DwOLPMVF9t1qQvU" +
	"ZtfNXKZuNta8r6CTwxUNXDgA1vSAfKSBL4X0K8VWFK1srsZwXDA5rEvY54qhc4/7/68T7xawDrqB6IQaWJHoGZ0969fiz5UW" +
	"pLSlNL7vCgGZdZJxQMtlWi5YrUQ+0lrm/7XUR9cZ29IN0Jy/bRwF/fDFZSPBrEoWRLXaGCwFynG21S/T6Z8HalwARr/UMPnI" +
	"AFjTA3KuwhdK+vNYRMiU8FjmHA6L7jk6n0pnlwi7KZbVAhUNlcBI+iiwEgCtlTRNCT53xdOs/Mxg5SCT0xZLIkxr5OlaMRBb" +
	"0em2amNYc6xeQbRGJti7LeSO/0aGWdtqTd0lvbRYfG8MInxpxYeNZckXdsO5A2AB7xC+28B3cge1JPORc7U3S7CmyRJgFbq9" +
	"YfBopZYCcx7XhgqdU5eVwLaaoTMWwHL37YeArtgeACsCOtZsW4kwrpUQXmr462Q2HUFTT8PE2AKpY08IL11vcGyUCfrN+MQc" +
	"7o0ji0uklrnb/Ao5HYb1nb9n9N0BsBZh4XhzZQN5UMv9uCUlOQ1lK/haNY5JJmx0r/JToKrFdvamWFbs9opHgVxqVHlb3Z9G" +
	"Ethq+obSGMvqfCQp+9ju/a3rYiJobm3IjUjG1hry51mSmDSo7r40uq6gBazSEYcYFjBW9oemffsVYDUgy5hDtZDyWgBxmULo" +
	"MfGeW6UerQnJIludILPsn4TBZcXItmY0pN16+wqB1UoAuOppdlDpiu5zlqVQ6eLpowBw1YHdzz+KpDHY/pWlqabHcANV390+" +
	"pltH2AUw7QDG2BAi9i9kslQ2cDJvByObTki5awtaGZci6EKcHACrBaydLgApy69JmNKsfD0q1SSwRDTNFVCPI6wsV6qz0Kmm" +
	"NoXF2TsKbDmWNXveahfgpN1iwKc+u3I2nTnbq+nmDwEqaTemwFUFCNuKE/Z1vo7EcTSH1THMHSGNTIFr3RHm14O/hToCu0TZ" +
	"rxu6dX9r7TWL7OutuvQydb4fy+Jin3j9sCaR5JV3Du4cAKsLWP/dwMdL4uxJ4VVmM038Gspbzlh0MMOVWRsE7QDFKHCmrgbO" +
	"3BCgrUZevxKhOaOpyB7UrULudgkAViByDNodJP7RUmC0Ynxe56uJaCXMgCvnSrcyZqvGmdKyLO1fwmZSMfkVLRd57zN8fAL/" +
	"PQCWMxTOb+BdVle6peZwMyC2THPA0n7vuYzTbBJO6UmdCM1S/8doSO61o4jPqu4ij1QBwJLFr+prWbOvEhPi68jb5/B21ci0" +
	"ureFGlFZMJ2+CC9F/c76/a9kKTtDCgBTF+sJ9tbicbBS/z3etQHnD4DljPcIl07gw7GaQqWsZ/sEe/hYWjBd2nytMYKX87hO" +
	"WvNnPwRcMTKpUeBsTulRMXF9tFCtNZQZ9IxW6vixRLqESyKMqwZqhZHGSeT842gYY2uPKNaJw9I/FKI1jEWYebdiJVSh9QBC" +
	"mmVKImjmoaJm2yHnOo1OsPd7m0RDQPXWN/TbJ+uHz0YuHQCrHxY2mgERXTI1WxLuxTSu2ETJ1RpaWouMO4J6JdPsX8gePipg" +
	"Wn6oF2BPGjrrA4YpqR025fuuQsZRn1l5L+mQNe1/zVgEXEucKNYBthX6eqP44UCQSRsiWlb0dn1VTeaC1V+O3nefaycraG1Q" +
	"uUyTS79FckjQ11Zwb6b5MAbA6gMWE2dBilJgsqyAu9m+7ptZqzDyfB2DNqAaDP3qTJiWA7RR5iwNCeqx+2Ysqwp4ryJJJNEw" +
	"cHUYlnh/EyHiKMOcSr5yHT2sM1G+vYjkNEjteK2axAWrSYZ/kvRnWb2JyyxEHD8/dO8EZQCsMGBd38AnJtPFKczhm8VsuuwP" +
	"OKZcjB8b/FhdX86cVWXO0noJsKrTACYxapPQrXq+q4jgrpFQUEIifODr9z6W2jE3FD6GNLHEYdIKGsmJ8RK9aFkviiULRljN" +
	"o+G5raXNBfZMpufj9QNgBcYELpnAKxq4xLrkVww4xthWu7UaTnN1iCVtappF+KfMw78c0ylhTysJwbwOZANTzMpjVFJNz2QN" +
	"hINBpiXdu+dP0ykASSTxGAwPJY3dvZIfMRBJTT+nQpqp4VTdUDGU5Rt7XqtxxpeXnpfaYWs5L6KaBHdxPFgmL9YlDfKKBrlk" +
	"AKzA+IhwvcKHFK6xgsxmH0/pDZZCaUuxq/d8bV3qEo6BRoVbHTA01RHgCtGKFKiF7AuV47lyqZNX9Ax9oJo9rW4ZlUg/RKwM" +
	"WcM6cyhWMiSz02xCEgxt/r9MgUtl0v5+6U17PquUDBFei1DmxcolS9Xnog7trEsoPd+jdhdZvUbhQx9EBoYVGx8Vrp+0Df1m" +
	"k6PULBq66uRodkO+cd94iUyNc3+rU8mspCaxjYz/jzLMKBVC1pkthiQeq9KQB0v6keIc2zQcEtbGzapDWQ9NrfFDHzjUKkrT" +
	"6o5+fWDjCOoxh3tuJad86yPNhohbsGKOts+t90ew2q8Aqw0Nv9UeVImBUSmA5Wqrcsa6nHUi005Zp5+7ci7pydgnAyojw2tH" +
	"RooS2meVAS8/HKTPriCcLZQIFsbe0npIcqxrFv7Vxn0GsV2gRrSa/8ZaYjLOza9+R1BdqrIjLpekNSxdMDtpb3+L/XTsV4DV" +
	"wJsa+FiIMYXi95JlvixU2qpvjdOeLW0ntE5jn7pt/5I72yxZwpipM6dEV4tMn+YYXB0R2UM2hsoT4GPZQl3YHoR+R5pQh1K/" +
	"3rDKkMUZKAVxPKRpie1wd/cxM5zKBFHrGpUpBu4WIne1MQ2uxmzVYRviKzn3BfkOQH6sgTcNgGUY5wtvV/hEzjBqYVElbKmk" +
	"j3aqLnG8YFSeTlUS+8RAZJRLpRFvieB6qhIaVccEGmJVvhcrwbDmzMrTrEJdHGrypTwhptRnQbYIOxQWjhJhYThyFieTqE0g" +
	"EdPtgRWWFvweWd3lu/JrDKYu4GlNq1Pg7BKET3wEefsAWPawcJc1I7j5FW3tYWMmFa2TVqdyqn2NwFQlbmeElVSoqKkzr/JW" +
	"u/E+r8Rc7bEtwbAICPBVRi6LfbTKWVW61nLc7x1Oscl5wf1Ni7kdC4T2l4aT7EXTEuItsY5gx2xtXaS4fd0u9uOx3wGWwpUN" +
	"7LWAkJJvuVFS/Gkp+wnsT2dXqm7B3GYZlVWIj+lTVQIQR5SJ7lXcupC8HWFdIVmszmQLc9heAlqjDKsqub44bEsjmlFsfnVD" +
	"R4m2L7YCmhvmNQkmpvHPt1fhygGwyhjWBxp4tZXy+p6tZcyllrqtSIjpsKpa+g3MR4ZLdskZUuXFHm0v+zKKvM4JD/19qXTD" +
	"wdm+ouAVKHp2/VYScED0RPhW43KZk5tRjB0213A6SmhdKRCrUvit4b6FtaOBdQ/tLETUBtFurZ7O281MvP5aYQ+hdDxZJbWF" +
	"vmalQbCT2Dnw6gl8YACsgvF54cIG3qcGy4JFcIwZ7SytZBOTQ6fdFGoJZ/9SwLKJTQ0iudQtWFWBEHGU+GyVo3HN1hj0Na0U" +
	"Ai0wa97QLxdJ+lg/07zc0K/KEMYQmNRGJjYHpFB4KXG9K33dEa1ofVtd75Nfv5dLHE1afUmjwKNJe0+s31UiG/m+85ELB8Aq" +
	"Z1nfnrVOTv0Ype2SrR1GIyCmM09V2PkYi10qgy6VO6t8bSkHXjl9rMqEf24bmVlGMARW2ELCKFgZLA8VC3d8ZSCp0cc1cWhk" +
	"geWbJcT1AuPVEeXHnhXCUk7TdNiVRoqXY/vSYLfR7sXYfb2OJ+i32c/HfglYCrsUzlHYqQUgZBQViwqo/Zax3VikyoCTZbZb" +
	"fFi5Jnp1JHbx2FMUrCSjW+XKcDJgRWZXErE35ACqWvIQl2pULuOyAOaCaeF4t4IdQkvWGiht911gHN3Znm+7BsBaYvy38NW9" +
	"8IQGvhqjw7l1Cw2r2VqaATqsatbv13ppryLKblV49kTOEEml2HK6V8RDoO4KzqHKZWOmMAROsWyhL7yLr2nRLefpHGqnl1bW" +
	"iCp9Kc8Hx5G3vzoThsYsa506SYVKhc58EsPFc2E3CNkcuis+ayABJR1WpV7Jj3b136+OkSd8juqrA2AtOb4uXNbAyPW5xIo/" +
	"0xkRm6Uh8DzVuUOylv6sTanCuVAr1QWhKr30FzKvKt4qRsTrJFoVAleXJvfCQQzhYO1rWnT7Z/mdHuZ6l9quH6lDVXn6WfZw" +
	"a9wz1ulGIVAhCKJdeSFYRJ/PZLsAJcEWyY57PdUUc2bFGH0RuYwDYFT784dr4JwGLndLdTSiYU0KNK68H0Zm4V9e44madUap" +
	"FNfS+fP063PA2dYASooeVBFBPQRMXkvk3EiFgJYSHpF0FF4Z7Q+5n2SUuZZUEWE+9/5tNlFl4d3yBXK7ZKHBeZ+TSLzFJqSB" +
	"yydwDgfI2N8B6/VNon2ytQvjxD4h2oUf5pfvhO5TGxjSiHR8kasErgzCuQV0HJuCxIA3lwkkw6o0LWl1XqZ9tlUValq9TSJm" +
	"U5bzbuWuIyniXGnm8ZZtSafguKDjiJgaVKZqB533+vAGvH4ArC0Y3xC+0MCFmmFRGknj+j6tyA8XyP6JURcKLdceaiNcEt5V" +
	"2Ut0z7Gu7v+j+Gsk516HeMe9KoA+EF35OYlzEu5OU5E+/EHw8jKItX+7gOimSHRtnAq1q5fpIlQNT5nZQhiqTpg3SWq2M81K" +
	"gkt9TTKyRyD6uPB/kS8MgLV1LOsLE/h8gfZk7XE11xG65p+qkMmEOh5UBvE71rolJowHymnUywBK5RQl1wZdLfK5NNQ+RgLA" +
	"ZcgSprKFJD6WOH99LcvdR+37tqTPtnqHUtPXlVJiHWV20i9+6D+v7bkl8znp6lsTQoXMEmnS19W4cs0C2vPqgAGrAwKwFD6s" +
	"8AbFVnKTAjXtCuqtTiWSBxJL+GX0NZnE9chjEmBMUpE3MpliKtJudkjWD6oSVN1TEWYMEyWC2bKJQ57yZeXqGZ3aQRM5rrzn" +
	"i+EzTn1b4rAgLS0lC4NXsmXNGxr48ABYWzSOUeQy4dsTeH8D12ogCxi6nRIcdX5qzRyRtQFQqkx4VxJ/WNJXlkzhMqAa6W+l" +
	"3m1x28ekgCt+lUmGhkSiy154qIbrg/Y1o6xfKpIJrLTc+5V1lWiX0dXZ653YVz/XZJSRSUJd28D7v4F8+9ZTL8sAWJsdl00z" +
	"skwa9kwa3jcDLQ1oWCng6nZUgL5TPbHeXpR5iUGBFQMbS8x6v7Yvr/bmwSmkdEuuTtAAXiJ03T3STx5qRPaKflzJZBaVToMM" +
	"0bDVIPjTSmIVn9DPLf2wMsiWZp9BPMWg9XhZQHjWmtkJEcM94STamcHXrLwSn2snNO+b0OwBuGieBRkAa0vGyi4uUvjdBi7L" +
	"pGmDYOUI6tK1LNdklnTxBRPia1alZmAGdDQCMuKHganXWzqEhvpexeIzl4F5AKUxS4MHZkJeiK8SGpfkCKTn2ap8KVLjhyK2" +
	"TmIdASWfObmJg5iPrHY1NnGmYOYnXWh2MjvcrgXC0itOiZusFS4DfneVXRdxgI39HrC+Z4J8+wj06pqvT+C/Glg3+Kt00Us9" +
	"VfuXa8xUUf46g6jt/y/WDGQM2CysywPhaEFzgElJDIgiepYEQkOwFUPn/KqVIZs405wEe78tn3X1+m9lfvJlJc3U82VugZhn" +
	"tBsHuJZcx3O9gf+6jPrr3+AIPYaJDIC1heOqenEJn8A/TuCTTVqzUnf12j73t4rillnqZ/dK8+abmd3WesAE4wq2Oc6J7Dkz" +
	"aUSfIoBtVYRNhUhflSaB4etICHA03nnBgvk53+5mgS08XWRuOPUE+Vy1R6D87JMK/ziXXah1AKx9NHYL72zg3AT9dXJVfo+q" +
	"lGaVOrnrIFfPi+VWcT3HjqygWWIErSK1iOLoZpJBnioOVJqxNcT+lrIsSUh0EtCj5uK3xH/2mPwopG15kiHEkSqpqLMl/PPK" +
	"7HhN5pnuuDQSaQ5w7hXIOzlAR3WgfeAGPtpMs4admqh2KS3peqpSGo5kwCnFngzLYBWxqJTpNHBbAxqWVhkBSBL3hRDCeUwD" +
	"bEoTCOW62WN45zf5q4gvb08EELIRs8ZBrk7kJFIgJoafM8SaQn6yXEQe3p/MnPIN2hPlU5nyCfr+Cc1HOYBHdQB+5v9s4O1d" +
	"VjWr/RMjI8mquVskSpS+xhLWeexIrayxJt+ETzxLQxXQsCI+BQ0wq2xE6a9jKPkKoRQYZWsPJawQ5JwguevPEt7cpWxyvc8h" +
	"4vTdmutb4Rbe0MDbG9b/cwCsG2iMFNkQdil8ROGLDYyJsipLg6XciS4spzuVdGywChsZ8JIcAOZU65wqTkR41z7REk+E18Ld" +
	"W4T43FezulJKDnmty3txrWvUlqgWbl1iN9pg1qK5QaWBSQNfbJCP7GL7LuDdTNce3O2dYu8C/gf4PPAR4A7OY0cxLZL+HPB+" +
	"4Ejnsd8HvgTccwAsZ4xbX1YDFzXwcKi+HObTkHZux7h6yclumY2Stxa4+9CExSHLuFJtEOif9RrTpSrv8VgSSdICe+6xXimi" +
	"xtlV8CeQjKbl+bFi4WbwdTGXuoRtEUlfVmwaqMcWNbNiEGGTrDjZxAWTmldytMD133vg4XtgZmN4FfCjwF7vV3kjcGILVGcB" +
	"f+OB0rnAHdu/z3ce+y3gp4A3DIAVPgHGwJdBrszzc0lYBXx/Va7cPzcjvf1rqsNb4EyLltqk9KgADdGQm917TwmBp4MmEiiI" +
	"1tCSXkLQKJ1qUCoh64PYdX7RuGZVOQu3xgqukzY16YryKdFdXPCR9M/cE+cl3NerSrDKTkir3kIezHxb0raN0UUbZLmyPV/G" +
	"7dE8Bwi1Qz67jSYBPg7c0nnsAcBb2//fAvys89gGcBiwciACVopWzsYrAopHGeWcgtaLofpomgFZ/VR1hJOX6lCVBwpGXaq8" +
	"n0oc2CTFClP92SWhkIcY1Ez3Ml9o4qAkCctC72NLnxRWLiiJIQeiZYc6WeAgS0mR9v2TySFJb/rqwrv1UYUXO2BlHc/AsT8A" +
	"xwOXtP9fChzrPHZGC3bPOxABK0UrAX4EOMZB8uUpp0zeA/VboVq3zRRrWCeJbOEyIohFtbW8dsZ0auOMds58qYxAJYE2ySkl" +
	"HY8uadjXIORZWEHiMq6Bib1AudQfVS0JRLVxWogWXA8lN10FYS/wlgZ5T+E5/CjgF4BnFZ7zbz0QAStFKwV4WeRALEs5PwLV" +
	"q+zCecafFNS2cq+pCywNuTrDHDWIZe1SupmQX1cwZCgVQ3yXiQGjlobILgPttcLak5Z9vd5PJzZ5UgLrJNZbyKI6dgdJJxfq" +
	"xPQLHqPm1VSTUhvDLwJ/APw0cI1z/yXAce3/x7Ys66DLEvq08teZLtT4rcBzl6OcsvtCkA+ES/xLOXqMl+cYUKhhUwzILL2B" +
	"c8BX0ltYDM+zpO0CdEmhuD0y2Lo2JHMXGl6UovdVtai0MjwlZpqW2rvxxKwXUW2qIIdTB1SM7vRzunvLB2hGJesMPgL4I+B+" +
	"TOsN3fF+4NHt/6cD7zvYAMunlbdov+ifbiLMjFBOOX8KatW1i9mVO6lLOL5hdmudBh2tSRdSW8LChDFUJSyel2hUptveQ7nO" +
	"JDE887N2OTbW+UqSluNi3R6SIZQaksIayfL5P1com6d5CdXys6enqbbG0muBM6jk/MjRv7jdjmz/zsZbgW3AvwCfAc5zHjur" +
	"BbLPA6cBLzyYACtEK+8AnNAK8l9vf5qvA2ubopx6hCDXXYVcd1bLtDScf87ZDXL57s2qqoZNU+8FcXd8nWBzqTUFIzFTyNme" +
	"aiujGWblN/OLRpFqDyFjnR9yrnWTcyVggahTNgqNt8fZ6mmTanhYIYgqoh9gXc5ir1zFavCKcst2qzzJZqW9/SPtdjfnsata" +
	"oLpDC1xXHyyAFaOV57Zi+23abdL+3bspyinXLU6Xsf4xWv1zXBDP2AosrWBis0gk7aOSQJio3jLwEqrrs9gbfF3L6idLZAPV" +
	"2lohRMD8bqOhk10CgCTxnEDwhA14pkzhZOg1EhC01SPr0n1+7WcnI9YIP5NnTTJ0pq3Gv0uXvP8z1eSP5z/FuhxQxc03BmCl" +
	"aGVqbJ5yrlx1HlKd180ahmZDHbmdW/k48rg6Bk6xFpVVi15XGjkjxTdxWsE2lwSQvi/Lf75U9tCwdxFpT1bFwL4i/6dqDDsA" +
	"IvZGFfMsosHz1F1TMLC4qyVU07KS1SRTlL7xtBbfQLtOJedx/cp5HKRjXwBWila6Y+Td3irK+U6QVzuzQ8uEgJJQ0q/ty4kl" +
	"kgCHKr5vicU6rlkU0sYma4yVU8QLdC7xNCtX08qV4+CxH2spT4flZdztJRF/cTindtIuGLpPRD+DOvt9NcI7OYhHdVB9Gz1G" +
	"kMu/Ait/AvIpqJpwtasUzJh8z4+MyzE+29Sy0nLs/cmkn6Df0jMUQlKQviPDsgwLq0riPmstYeejO7YDsNchWq4tIQ2rxD2S" +
	"8krlkrY5CXXBLKVdSOdTrPAnXC1f4agDp0f7oQ1Yclnbsv0bFyMXnwLVp/Mtji0zJ2PKXJa5iTUZYEgMSOAzqh9uJlRbNRhE" +
	"NSWwO/FfMBSUsmJn0TQxzH2lKtFlKHht0fxPkPJRzci832c+180nVGzhb6nO29PHP8135BQul2nG7+qDS7c6eAGrP14C8gmb" +
	"Ece0VrpRS4r1qPJmvOZ0JqtwHgE2iZlMA8ghmdBQ3bsyq+fMxXNNRKWaIXISd2X0wq4MOKTAaL6fRK1hSPSWQJbQ79lemniO" +
	"lbbGpur08U9M5/mhMQ5ywNp4D1RnT4ukLWzFkkNOmU5LYgbxag0D/4u1LkXy4JXUnjJhn0Z6t6c0LL/FTK5cpxedBqwQwRWk" +
	"JZ+HCGUfxXs8174mFW6G7AulUmadCAlD7zmdbldScTYN7xkA66AIEb+1G+S9UP1D9zJr6QCaY1olYnoO/FKZzMDM1VxZTumW" +
	"AB4NaV45McoieUlaNoOyyiD/9cGTX/Ogkiq4tmhLy7RW6zA1zXdTFWaO9n9AeS+Xy+4BsA4a0Pqfz0L1ZyBfD8cG1rIYI5jE" +
	"OiZo5H01ZRiNXPKlpCo4ahcvYG05FNKonNVhW0G7Qkwwl7zoXrICT7SHlvZd6OC1qglpVuqEiprPmZg8yjH/V+8aq8DXqfkz" +
	"LpbPcgiN6pD4lnLhBSAPhvrSdOVsara5QEXkDEqIDhLxRyVXWU7QAQ0BSkk7zlyHhhADKvBimX6XwPuE+r3nACn01choUKG1" +
	"DDvPl3ifqtnjrv5nmU644nwMyKTvFVu8flYneCnCg/maXMAhNg5+wNKTpjNLvngByDNAPhdXWK2dHayXUksoadGfLJ+hkI6o" +
	"tfOCJf4K2RnUFhpKJhSEwuwiNvsZhYc55zyhZCqJfV2Q7v6Fis8hPIOvtmD1/QevheEQDQkvXJw58tm3QfUikMuyy7e7M1pT" +
	"vT1CK9iEzqySlXYMICQO8GhMZPcARTNaUhBZUuC17LmSyBCGFqiw6lmxcC8EEiXyn1XqTJUKxbKThinl3H8ZFS/iv+Vt8+/8" +
	"tYPXwnDohoSdSf3pt0H9INushH62zptZ7jp+HYG6SmhBhtBPjdaFaBor8J6udUFiCnWCSankuzP0wMwRtEJaUglTKjWWBr1W" +
	"Wt4/K0dsZ5pXpxWNhheFdUPUXI1+1QttH8QXHLA6BEd1SH5r+eSngFOguqybPpKIZhXh6uq1QpbEAqXBGsZQa5jK03cyNEDI" +
	"2B+s5lQy4SOeDyvU4SHBooLhn9qiTWuHBonpQXR9Uqn1OTr70+xaHuFFMbwax9BiRiJ5hYG27KbiMuAUPiuf4hAfhx5g6amy" +
	"AC15OlSfiyurGc1JJGJdsC5VHOq0kPNQWXQryNcVZprzuc+RXLmOJkhWyCrhhX2pXbMk40o+R8Om1tCCFNbVqEuvF6kkw+Iz" +
	"zDSrp8/B6k6HlmY1AJZ80tG0/sPRtHIxQElxtEVct874nEqcAqqIJpUtw7GYowLhXmd3YtPvTYCjZTXaITCIfU1LDiS1mLbF" +
	"ahd16pNrsDHVrP7LCQM/e2hpVgNg9U6Yj3iaVmVkM7ECZIvO5ArzrqBPIdBZ318SjC5HY7ZCZPd2URlAqvM13R7xWmZ58AV3" +
	"nNBQCmRG38IXBKvIuoEkfjb/M3ZJ/oM479DWrAbACp5EHwpoWinGBV0zKAFNKsXQiCz0UGKv8F6v1n5ZGEPDzGOq8eelOECu" +
	"P5Yk9C9xkgeGa0IwBFymrX5NxMiqAV1KFlNo9llqtZaEtj4rnWpWHx80qwGweifQfWQBWr6mlQIPN7wyrAuooSxg6syxijeh" +
	"Pu5ktK3Ycy2tY3zwiSxJH9OlJLdbTUe1ub7vUiDlWa0MobxMrE9XMOci+YUoKk+zmoHV/zm0NasBsPrsytG0PtD1aanBOShW" +
	"AycGocSqIMNy/a28+7VgwYnecStxvWsarPzyHDz9Cs2bQZNgJvEC6GWBjAzIIeU9IaXVrD5cLcLAjx/amtUAWNkT8b0LTUsy" +
	"neDEcml22x3jvdZvtRxhbEWqcEHKTFJN/wzN/KygpZHyGx+5xKNoOY0rRSb9esXK8JoqED6GOj4kI3b3/bQv+Kd+xpoHce6g" +
	"WQ2AVTxW/6vVtD5d1mXBU1nV0sPKAzXJOdarhEpcRcAmFIYmRCXNifDGLqT+SzXxkhATcu+DftYPXxDXgIt8tk+NC+q9xSik" +
	"v9pPRIrsL/nleL2QsCTanxKfBk5hjf8azr0BsAo1rQcL8k5Fzv4UcAbI20C+HV+dMwZgnsalJRbqZWpHDHl/SS2KmloFxxAy" +
	"LhO45FpsxTSwjiaki9uInWCaullLwlWiYRNoLkspczMoCN9GeBvCGZwjn+JsUe4/aFYDYBWdRGc7mta73g3VC0HeDvK17uwE" +
	"U9M8WWLpeLUAU4oJhfZDRrDBqoonEE1tANW7T+Ovz/qzJMLoPLCJOctzmG8t3wkSW+3aFabPkfZ5XwPeDryQ98i75685Z9Cs" +
	"BsDaFIC94wvAc4GnQ/W1tGAC/bUIIV6PKN1aRFLN8mJ+KuJCu0C66Z/z/uKFnep/vgg2KVOLQynuqc+YtBsOkhHGZz2bS9p/" +
	"pZZjjNUe9vpSaR+Ioj4yibG7ryE8nYrn8m75wnCSDYC1xaD19uuBD0FzL6j+Lt+LBGz1GM4JG1JxNdefN9GlQQ3gphIPFSVD" +
	"j0IZvmh3Ga+jX1DX8syhFeG+751jFtHKIO76gIhPK/S4VxM4O1ZzjYr+2omxljOLn/XvaLgX8CH+Sa4fTq4BsPYRaL3teuRv" +
	"LwZ5KcibQa5Lr21esuxXJHUl1sbiJY95mpZkxPNeA7+c2FQSCsY+pvQzc7nXYWBl0UonsSVareWbi/2rA3bXIbwZ4aX8g1zM" +
	"Pw5gNQDWvh76WEHe9BlYexrwDyAXgOxenPX+klkZMURztYCxXiYGsV1yCrbFq5UCJQmzoyhiSfyjWJhSrk47B1Cb9VnlPm9Y" +
	"IxOE3cAFwD8w4mm8TT7DIwdhfQCsG4Rlvald9/D/XoP81a8y5gmonNM7kUW8Q1v19aqObhQrNMudiaVnufTDQROo+c8XG04F" +
	"9SrS2cHoa7XMmV7a7MI/VL0ciZaVb87DxOYcdPwE3iq/yt/INQC8bRDWB8C6McZYPoNOngjVE4KiiPqNAB29SCyxSxUAvgp7" +
	"5i9RbCcpj1eoxYw11jMAkKbCzgSDSX3dEDiSAJiSJn0VXRIdr0FUr3TnCTT6RJrJZ4aTZQCsG39sf+1e6tddAdveBnIGKu9A" +
	"5fJ5fCABX5apbhDyXUUxMq0c41oqNjbcpenQzapJkQG3FHZb7Gkl5LXKaluCcDnwDuAMRryNN4+u4K3b9g4nywBY+4mu9VRB" +
	"/ngn8sqzmPACVP4GnS0plloWPldraAnvrGwrdsYbG/GVAFeOhKVWCMu4NPLAo3FHe/D1alsXNtRkr78/Rfg6wt8AL+B1chZ/" +
	"ITv5tUGvGgBrv9K1/mxxhqz86ReoX/4sqB6E8vVwG0mJLPcukbDPM4K6Qv08vJKAbyrGpDSMCGrsPhpjZr5NQSSsX+XInaWJ" +
	"BZR5YaNYLcnuQf1aQYm9j6J8HeFBvFqexf91vFWvG/SqAbD299GMLpyug6ingZzTr46NiCAaU3093Un9NQ1dbYxA33WId6rT" +
	"7uuXXt4+Az65x2PPm4GyRUh3Lwix2r8QcMUE9vB7eToV5wCnAQ9GuHCY/ANgHWBg9Rxh9EcTqhdfgLzoXJCXgLwa+HD4su6Z" +
	"OzWT3QsubGo1HuXaz5TGc9hAC4OGZY1aJcPIilonxzaJH7ZZaQ18GOHVCC/hFXIur5QL+FOZ8LQhBBwA64A6oi/phgBy1r8h" +
	"Zz4FeCVU/wJycevdIujBkoCPS3O91qsCRlQqxJeIUIH7tATfNO/Lcp9XIsBjwO88A9uNcDHwL8ArebE8hZfIv3Ve+8ohBBwA" +
	"66DQuv7gXcjvPRh4IvDxZBwksb5TmSyjSqYgOoQcOTuFxpGmY1FIgJ4awsH5d8iEj8RIqlPc6JfJQF+UT/WR96PyxfM/jvBE" +
	"XigP5kXyrmFSD4C178e//f/tnX2IVXUaxz/PvZabsVJE29oby9bSm0Vho1JYWKn0sk1uRe+RDUUWxeBEGul4NKEMEsFalbIh" +
	"cDcjXUIDtQihf3rxTH84DcW0u0kvaiFUBmNkc5/+OGfwzLnnnHuu2Ewv3w8c7p37m3vPmd898+H5Pb/n/E5QYVtQHcEjeAv8" +
	"XqAFZy1u/Q1vae+NKhuTOa60tApM4TmhhxeFOJ4f0VBCNkWzglkTq1kRVZ1sPHU5j2Xvj1SeL2tOpO7v8n7M1wItwL1UeEva" +
	"kLCGE+fQVm86DHt+0rBH+7F5n2APhzjPAh1gz+DWmzuGsTLDuHTSPWuUlhoDWc54yJrIUZERiJUdYXrJfFi6aDTLiM0EkFm5" +
	"qrrf9944R9WB+bPMt5BO+4RO62eR8lQS1nAxNXCmBrWRGRbOG/ovWp3zDpX2Vewf04Hb82BvAB8De/MFVbbYtFEOq2i8ltfe" +
	"zJrvDSKqsjmupgpJvXhitPGcxF6MjzHeAH+e0fs7mFtZxaPVd4bsc6HyVBLW75kxbT9QvX85dt90oDVaDSLvWkIozjaXXSCq" +
	"2SBhsO4rL+/W3Ec1vhSHEkWi6detfJdl7/NFoJV2m05HdTkPjflBJ6eEJYq/kj6wp6OciV8E1nXwq0quXpeVVS6wgpWpH8iL" +
	"qBqVVKTeWzTozg3+PD/gyxvOUZB/yq9GT7+nixoXxTmqpzH6dA5KWKJ09HHPANa2G5sVYrPeBlYC84BFYC8De+rtZF4/O1hC" +
	"Yg0vkqbEELLEjGCzQ8BDLTS1Oqd7aj+GsQfj5ag/mQesZLa9zWwLecB286AN6CSUsMQhC+yO7dhtS7GbA/DHwV4C6wVCYCfY" +
	"9xm3laFcXVbaGod4YXTRulilc1JWIJ+sX/PGBfhRkef3UT8RYvRivAQ8zl0W0GZLuce26ySTsMTPIq+berEb5mD/GI9d1wLM" +
	"jcWVM5OY+Lnw1l2e2oos0Ng1hZERKeE0+nhPHZOX3MfBIXCIM5ebrIVbbDy32Rzu1DrqEpYYCbYAbXH+pQX8bvCtQ8XjqX/g" +
	"vIXXy6yuV5C3ahSBJQ8pmYPyouGe19+oKG3J+htLbAXuPtgntOFs0akiYYkRj7iu3Ydd3YddGWIzQvhxPbAsjrwWAQtwW42z" +
	"HRho7v7saallia7o5hUlC0wLKzasaIWEAWA7sBpjAbAIYy6wDGc9rRYy00Kutz5utn06WSQs8YsT2FXfYZe/jk19Crs0wKYs" +
	"4UB1Pm4ria5/exfsfbBuYAfYp8C+7EWkMsZ77s0n1evk1KBud2jQ59Hx8SmwA/NuzN+P/g424azkR+ZzmS1hmgXMsKe4yl7n" +
	"WvtOJ4OEJX6NjJ60l+qkLmziTGzCZOz8CfDVJOifAXQCm8E/y4+eyi42lZaTZQ8HmxGY8xnOZpxOaszggE1icmUCF9tkLrGZ" +
	"TLUuptlefckSlvhNR2JXDGAT9wCvEk3tX5PI+bQAFwIt1GjFvR18Be4bwbvBd4EPFEdROcGaM4CzC+gG34izghrt1GqtQ/Z7" +
	"cLsmPr5XmWh7uFglBxKW+B2L6+xvsbN2Ymf0YKeH2F9D7C8hdko3dlLIHV9soubrwJ/DfTnuT4B3Ao8AC4nyZGW3hfH7OsGf" +
	"iD6P5xioreOR9k2cZiF/s27OtJCzLeQcCznPerjAdjIhvtuMkLDUBSKXf1/ojPrzl9ifeqgev43qcRuoHLMG++MybMxi7A8B" +
	"dmSAjQqwSkDVAo6wgNEWcJQFHG0BYy3gWAs4zhZzvC3jhMoaxlU3cHJ1G6daD6eN+pINz+jaPCFhCSEkLCGEkLCEEELCEoeD" +
	"14AvgP2p11uBXuADoAf4e6LtGKLK8x1EVfljE20LgI+AKepaIWGJw80K4AIgfRfj1cCNwHjghvjnpJTeBM6LH+cn2u4HLgde" +
	"UNcKCUscbrYCX2W83hdHUoMR1X8TbVcC/4qfrwWuTrQdAI4GjlDXCglLDBe3A+uILp/5DzAr0XYSsCt+vhsYl2hbCGwEHlMX" +
	"CglLDBf/JKpGPxWYA6wq+b4u4MxEBCaEhCV+dqYAr8TP1xNdXjPILuDE+Pm4OMoSQsISI8b/iJLnAFcA/0+0bQFuTQwdN6u7" +
	"hIQlhoPP421s/DjIfcCTwIfAUmB2om0xMJ2o3GEasETdKCQsMRycHG+V+HGQ94DzgbPix/cSbV/Hojo3Ftc36kYhYQkhJCwh" +
	"hJCwhBBCwhJCSFhCCCFhCSGEhCWEkLCEEELCEkIICUsI8dvhJ7l1VoL/ETyXAAAAAElFTkSuQmCC";
	
	
	
	
	
	
	private static class MouseWheelListener1 implements MouseWheelListener
	{
		private JDialog dialog;
		
		private JLabel label;
		
		private ImageIcon imageicon;
		
		private int width, height;
		
		private boolean resized = false;
		
		private int freq = 16; // 16 x per sec
		
		public MouseWheelListener1(JDialog dialog, JLabel label)
		{
			this.dialog = dialog;
			
			this.label = label;
			
			//  Store the original image icon so the image
			//  doesn't become distorted from each scaling
			
			this.imageicon = (ImageIcon) label.getIcon();
			
			//  Read the width and height
			
			int width  = imageicon.getIconWidth();
			int height = imageicon.getIconHeight();
			
			this.width  = width;
			this.height = height;
		}
		
		
		public void mouseWheelMoved(MouseWheelEvent e)
		{
			if (resized) return;
			
			else resized = true;
			
			new Thread(() ->
			{
				try { Thread.sleep(1000 / freq); }
				
				catch (InterruptedException ex) {  };
				
				resized = false;
			
			}).start();
			
			
			//  Increase or decrease the size of the image
			//
			//  If the rotation is positive, increase the size
			//  If the rotation is negative, decrease the size
			//
			//  This is intuitive for the user because moving the wheel down
			//  moves the image down as it expands from the upper left corner,
			//  and moving the wheel up moves the image up as it contracts.
			
			int rotation = e.getWheelRotation();
			
			if (rotation > 0) changeImageSize(+2);
			if (rotation < 0) changeImageSize(-2);
		}
		
		
		public void changeImageSize(double m)
		{
			//  magnifies or minifies the image by m
			
			//  Read the original icon and the current size
			
			ImageIcon imageicon = this.imageicon;
			
			//  Read the screen size
			
			Toolkit tk = Toolkit.getDefaultToolkit();
			
			Dimension d = tk.getScreenSize();
			
			float m1 = d.width / this.width;
			
			if (m1 > 8) m1 = 8;
			
			//  Calculate the new width
			
			int width = this.width, height = this.height;
			
			if (m > 0) width = (int) (width * (1 + m1*0.0125f*+m) + 1);
			if (m < 0) width = (int) (width / (1 + m1*0.0125f*-m) + 1);
			
			int maxsize = Math.min(d.width, d.height);
			
			if (width > maxsize) width = maxsize;
			
			if (width <= 0) width = 1; // zero width is illegal
			
			//  If the user spins the mouse wheel at high speed and
			//  the width is at the maximum size, return without re-
			//  painting the image so the program doesn't hang or
			//  become unresponsive.
			
			if (width == this.width) return;
			
			this.width = width; this.height = height;
			
			height = -1; int hints = Image.SCALE_DEFAULT;
			
			//  Scale the original image to the new size
			
			Image image = imageicon.getImage();
			
			image = image.getScaledInstance(width, height, hints);
			
			//  Create a new image icon and set the label icon
			
			imageicon = new ImageIcon(image);
			
			label.setIcon(imageicon);
			
			label.repaint();
			
			dialog.setSize(dialog
			
			    .getPreferredSize());
		}
	}
	
	
	
	private static ArrayList<byte[]>   images = new ArrayList<byte[]>();
	private static ArrayList<JDialog> dialogs = new ArrayList<JDialog>();
	
	public static void display(Window window, String title, byte[] imagedata)
	{
		//  Displays an image in a JDialog frame
		//
		//  The window can be set to null so the attached files appear
		//  in the upper left corner of the user's screen instead of
		//  on top of the user's email frame which would obstruct the
		//  view of the email messages.
		
		
		//  Test if the byte[] list already contains a reference
		//  to the image data to be displayed so the user doesn't
		//  open multiple copies of the same attached file
		
		//  This test can use the == operator instead of the
		//  Arrays.equals(array1, array2) method but the Docu-
		//  ments display method has to use the equals method
		
		for (byte[] array : images)
		
		    if (array == imagedata)
		
			{ delete(imagedata); return; }
		
		
		JDialog dialog = new JDialog(window);
		
		ImageIcon imageicon = new ImageIcon(imagedata, "");
		
		Image image = imageicon.getImage();
		
		JLabel label = new JLabel();
		
		label.setIcon(imageicon);
		
		MouseWheelListener1 mwl1 = new
		MouseWheelListener1(dialog, label);
		
		label.addMouseWheelListener(mwl1);
		
		dialog.addKeyListener(new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				int c = e.getKeyChar();
				int d = e.getKeyCode();
				
				if ((c == '=') || (d == KeyEvent.VK_RIGHT)) mwl1.changeImageSize(+1);
				if ((c == '-') || (d == KeyEvent.VK_LEFT))  mwl1.changeImageSize(-1);
				
				//  The up / down keys use a 1.3 magnification instead of 1.0 to
				//  compensate for the slower speed compared to left / right keys
				//  (The magnification also increases the increment size)
				
				if (d == KeyEvent.VK_DOWN) mwl1.changeImageSize(+1.3);
				if (d == KeyEvent.VK_UP)   mwl1.changeImageSize(-1.3);
				
				//  The user can close the dialog by pressing escape or enter
				
				if ((d == KeyEvent.VK_ESCAPE)
				 || (d == KeyEvent.VK_ENTER))
				{
					delete(imagedata);
				}
			}
		});
		
		dialog.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				delete(imagedata);
			}
		});
		
		
		dialog.add(new JPanel().add(label));
		
		int xpos = 0, ypos = 0;
		
		if (window != null)
		{
			xpos = window.getX();
			ypos = window.getY();
		}
		
		dialog.setLocation(xpos, ypos);
		
		//  set resizable is set to true or else on some
		//  versions of Linux the location of the window
		//  will move down as the user enlarges the image 
		
		dialog.setResizable(true);
		
		dialog.setTitle(title);
		
		dialog.setSize(dialog
		
		    .getPreferredSize());
		
		dialog.setVisible(true);
		
		
		Toolkit tk = Toolkit.getDefaultToolkit();
		
		Dimension screensize = tk.getScreenSize();
		
		int width, height;
		
		do
		{	width  = label.getIcon().getIconWidth();
			height = imageicon.getIconHeight();
			
			mwl1.changeImageSize(-1.5);
		}
		
		while (width > screensize.width / 3.3);
		
		dialogs.add(dialog);
		
		images.add(imagedata);
	}
	
	
	
	private static void delete(byte[] imagedata)
	{
		for (int i = 0; i < images.size(); i++)
		
		if (images.get(i) == imagedata)
		{
			images.remove(i);
			
			JDialog dialog = dialogs.remove(i);
			
			dialog.dispose();
		}
	}
}


//  End class Icons










class ListFiles
{

	//  Returns a list of all files in a directory
	//  using recursion. Java listFiles only returns
	//  the files in the directory, not the files in
	//  the sub-directories. Listing all files is re-
	//  quired for directory encryption and deletion.
	
	public static File[] listFiles(File directory)
	{
		ArrayList<File> filelist = new ArrayList<File>();
		
		listFiles(new File[] { directory }, filelist);
		
		File[] files = new File[filelist.size()];
		
		return filelist.toArray(files);
	}
	
	private static void listFiles(
	
		File[] filearray, ArrayList<File> filelist)
	{
		if ((filearray == null) || (filearray.length == 0)) return;
		
		for (File file : filearray)
		{
			//  Test before recursion
			
			if (file.isDirectory()) listFiles(
			
			    file.listFiles(), filelist);
			
			//  Add the file to the list
			
			filelist.add(file);
		}
	}
}








class DataStream
{



	//  This class opens a file, reads or writes data, and then
	//  closes the file using only one read or write statement.
	//  These methods are inefficient for large numbers of read
	//  and write operations because the file has to be opened
	//  and closed for each read and write operation, but one
	//  read or write operation can transfer up to 2 GB of data.
	
	//  The Editor program reads and writes binary data because the
	//  data is usually encrypted. The random data is not encoded
	//  because encoding in base 64 would expand the file size by
	//  one-third.
	
	
	//  These methods can only read and write files up to 2 GB
	//  because of the array size limit, except for the append(
	//  String) method. For larger file sizes the methods should
	//  use a RandomAccessFile or FileChannel object which is
	//  safe for use by multiple concurrent threads.
	//
	//  If the file contains text separated by a delimiters such
	//  as newlines and space chars, then a Scanner object can be
	//  used to read the file such as Scanner in = new Scanner(
	//  new BufferedReader(new FileReader(file)));
	
	
	
	
	public static byte[] read(File file) throws IOException
	{
		//  opens a file, reads binary data from
		//  the file, and then closes the file
		
		if (file.length() >= 2L*1024*1024*1024)
		
		    throw new IllegalArgumentException();
		
		try (DataInputStream in =
		
		    new DataInputStream(
		
		       new BufferedInputStream(
		
		          new FileInputStream(file))))
		{
			byte[] input = new byte[(int) file.length()];
			
			in.readFully(input);
			
			return input;
		}
	}
	
	
	
	public static void write(File file, byte[] data) throws IOException
	{
		//  opens a file, writes binary data to
		//  the file, and then closes the file
		
		try (DataOutputStream out =
		
		      new DataOutputStream(
		
		         new BufferedOutputStream(
		
		            new FileOutputStream(file))))
		{
			out.write(data, 0, data.length);
			
			out.flush();
		}
	}
	
	
	public static void write(File file, String text) throws IOException
	{
		//  opens a file, writes text data to
		//  the file, and then closes the file
		
		try (PrintWriter out =
		
		      new PrintWriter(
		
		         new BufferedWriter(
		
		            new FileWriter(file, false))))
		{
			out.print(text);
			
			out.flush();
		}
	}
	
	
	public static void append(File file, String text) throws IOException
	{
		//  opens a file, appends text data to
		//  the file, and then closes the file
		
		try (PrintWriter out =
		
		      new PrintWriter(
		
		         new BufferedWriter(
		
		            new FileWriter(file, true))))
		{
			out.print(text);
			
			out.flush();
		}
	}
	
	
	public static void appendLine(File file, String text) throws IOException
	{
		//  opens a file, appends text data to
		//  the file, and then closes the file
		
		try (PrintWriter out =
		
		     new PrintWriter(
		
		        new BufferedWriter(
		
		           new FileWriter(file, true))))
		{
			out.println(text);
			
			out.flush();
		}
	}
}


//  End class DataStream












class FileChannel1
{


	private FileChannel fc;
	
	private String filepath;
	
	public FileChannel1(String filepath, OpenOption openoption) throws IOException
	{
		this.filepath = filepath;
		
		Path path = FileSystems.getDefault().getPath(filepath);
		
		fc = FileChannel.open(path, openoption);
	}
	
	public FileChannel1(String filepath, OpenOption openoption1,
	
		OpenOption openoption2) throws IOException
	{
		this.filepath = filepath;
		
		Path path = FileSystems.getDefault().getPath(filepath);
		
		fc = FileChannel.open(path, openoption1, openoption2);
	}
	
	
	public void close() throws IOException
	{
		//  closes the file channel
		
		fc.close();
	}
	
	public void force(boolean metadata) throws IOException
	{
		//  forces any updates to this channel's file to be
		//  written to the storage device that contains it
		
		fc.force(metadata);
	}
	
	public long position() throws IOException
	{
		//  returns this channel's file position
		
		return fc.position();
	}
	
	public void position(long p) throws IOException
	{
		//  sets this channel's file position
		
		fc.position(p);
	}
	
	
	public int read(ByteBuffer bytebuffer) throws IOException
	{
		//  reads a sequence of bytes into the given buffer starting at
		//  the channel's current file position and then updates the
		//  file position with the number of bytes actually read
		
		return fc.read(bytebuffer);
	}
	
	public int read(ByteBuffer bytebuffer, long position) throws IOException
	{
		//  reads a sequence of bytes from this channel into
		//  the buffer starting at the given file position
		
		return fc.read(bytebuffer, position);
	}
	
	public long size() throws IOException
	{
		//  returns the current size of this channel's file
		
		return fc.size();
	}
	
	public FileChannel truncate(long size) throws IOException
	{
		//  truncates this channel's file to the given size.
		//
		//  If the given size is less than the file's current size then the file
		//  is truncated, discarding any bytes beyond the new end of the file.
		//  If the given size is greater than or equal to the file's current size
		//  then the file is not modified. In either case, if this channel's file
		//  position is greater than the given size then it is set to that size.
		
		return fc.truncate(size);
	}
	
	public int write(ByteBuffer bytebuffer) throws IOException
	{
		//  writes a sequence of bytes starting at the current
		//  channel position and then updates the file position
		//  with the number of bytes actually written
		
		return fc.write(bytebuffer);
	}
	
	public int write(ByteBuffer bytebuffer, long position) throws IOException
	{
		//  writes a sequence of bytes to this channel from
		//  the buffer starting at the given file position
		
		return fc.write(bytebuffer, position);
	}
}


//  End class FileChannel1





class FileChannelReader extends FileChannel1
{
	public FileChannelReader(String filepath) throws IOException
	{
		super(filepath, StandardOpenOption.READ);
	}
	
	//  public void close()
	
	//  public void position()
	
	//  public void position(long p)
	
	//  public int read(ByteBuffer bytebuffer)
	
	//  public int read(ByteBuffer bytebuffer, long position)
	
	//  public long size()
}


class FileChannelWriter extends FileChannel1
{
	public FileChannelWriter(String filepath) throws IOException
	{
		super(filepath, StandardOpenOption.WRITE);
	}
	
	public FileChannelWriter(String filepath,
	
		StandardOpenOption option) throws IOException
	{
		super(filepath, option);
	}
	
	//  public void close()
	
	//  public void force(boolean metadata)
	
	//  public void position()
	
	//  public void position(long p)
	
	//  public long size()
	
	//  public FileChannel truncate(long size)
	
	//  public int write(ByteBuffer bytebuffer)
	
	//  public int write(ByteBuffer bytebuffer, long position)
}







class BigByteArray
{

	//  A class for creating large byte arrays
	
	private byte[][] arrays;
	
	private int arraysize = 256*1024*1024;
	
	private long elements;
	
	public BigByteArray(long elements)
	{
		int size1 = (int) (elements + arraysize-1) / arraysize;
		
		int r = (int) (elements % arraysize);
		
		arrays = new byte[size1][];
		
		for (int i = 0; i < size1; i++)
		{
			if (i == size1 - 1)
			
			     arrays[i] = new byte[r];
			
			else arrays[i] = new byte[arraysize];
		}
	}
	
	public BigByteArray(byte[][] arrays)
	{
		int size1 = arrays.length;
		
		this.arrays = new byte[size1][];
		
		for (int i = 0; i < size1; i++)
		
		    this.arrays[i] = new byte[
		
			 arrays[i].length];
		
		int elements = 0;
		
		for (int i = 0; i < arrays.length; i++)
		
		    elements += arrays[i].length;
		
		this.elements = elements;
	}
	
	
	public byte get(long index)
	{
		int div = (int) (index / arraysize);
		int mod = (int) (index % arraysize);
		
		return arrays[div][mod];
	}
	
	public void set(long index, byte b)
	{
		int div = (int) (index / arraysize);
		int mod = (int) (index % arraysize);
		
		arrays[div][mod] = b;
	}
	
	public long size()
	{
		return elements;
	}
}







class Gbc extends GridBagConstraints
{

	//  The Gbc class is a collection of mutator and accessor
	//  methods for the GridBagConstraints class
	
	private static final long serialVersionUID = 1L;
	
	//  GridBagConstraint anchors
	
	public static final int right  = GridBagConstraints.EAST;
	public static final int left   = GridBagConstraints.WEST;
	public static final int top    = GridBagConstraints.NORTH;
	public static final int bottom = GridBagConstraints.SOUTH;
	
	public static final int center = GridBagConstraints.CENTER;
	
	public static final int horizontal = GridBagConstraints.HORIZONTAL;
	public static final int vertical   = GridBagConstraints.VERTICAL;
	
	public static final int both = GridBagConstraints.BOTH;
	public static final int none = GridBagConstraints.NONE;
	
	
	//  Methods to set the variables of the GridBagConstraints class
	
	public void setPosition(int gridx, int gridy)
	{
		this.gridx = gridx;
		this.gridy = gridy;
	}
	
	public void setSize(int gridwidth, int gridheight)
	{
		this.gridwidth  = gridwidth;
		this.gridheight = gridheight;
	}
	
	public void setWeight(double weightx, double weighty)
	{
		this.weightx = weightx;
		this.weighty = weighty;
	}
	
	public void setAnchor(int anchor)
	{
		this.anchor = anchor;
	}
	
	public void setFill(int fill)
	{
		this.fill = fill;
	}
	
	public void setInsets(int i, int j, int k, int l)
	{
		//  top, left, bottom, right
		
		this.insets = new Insets(i, j, k, l);
	}
	
	public void setIpad(int ipadx, int ipady)
	{
		this.ipadx = ipadx;
		this.ipady = ipady;
	}
	
	
	
	//  Methods to get the variables of the GridBagConstraints class
	
	public int[] getPosition()
	{
		return new int[] { this.gridx, this.gridy };
	}
	
	public int[] getSize()
	{
		return new int[] { this.gridwidth, this.gridheight };
	}
	
	public double[] getWeight()
	{
		return new double[] { this.weightx, this.weighty };
	}
	
	public int getAnchor()
	{
		return this.anchor;
	}
	
	public int getFill()
	{
		return this.fill;
	}
	
	public Insets getInsets()
	{
		//  top, left, bottom, right
		
		return this.insets;
	}
	
	public int[] getIpad()
	{
		return new int[] { this.ipadx, this.ipady };
	}
}


//  End class Gbc















class Keyboard
{


	//                     Virtual Keyboard
	//    __________________________________________________
	//   |                                                  |
	//   |  `~  1! 2@ 3# 4$ 5% 6^ 7& 8* 9( 0)  -_  +=  <<   |
	//   |                                                  |
	//   |   >> Q  W  E  R  T  Y  U  I  O  P  {[  ]} |\     |
	//   |                                                  |
	//   | Caps  A  S  D  F  G  H  J  K  L  :;  "' <Enter>  |
	//   |                                                  |
	//   | Shift Z  X  C  V  B  N  M  <, >. ?/  Shift       |
	//   |               ____________________               |
	//   |              |____________________|              |
	//   |__________________________________________________|
	
	
	
	
	private JTextComponent textcomp;
	
	private JPanel panel;
	
	private JFrame frame;
	
	private JButton[][] buttons;
	
	private float maxfontsize = 40;
	
	public void setTextComponent(JTextComponent textcomp)
	{
		this.textcomp = textcomp;
	}
	
	public void setForeground(Color foreground)
	{
		for (int i = 0; i < buttons   .length; i++)
		for (int j = 0; j < buttons[i].length; j++)
		
		    buttons[i][j].setForeground(foreground);
	}
	
	public void setBackground(Color background)
	{
		for (int i = 0; i < buttons   .length; i++)
		for (int j = 0; j < buttons[i].length; j++)
		
		    buttons[i][j].setBackground(background);
	}
	
	public void setKeyboardBackground(Color color)
	{
		panel.setBackground(color);
	}
	
	public void setFont(Font font)
	{
		if (font.getSize() > maxfontsize)
		
		    font = font.deriveFont(maxfontsize);
		
		for (int i = 0; i < buttons   .length; i++)
		for (int j = 0; j < buttons[i].length; j++)
		
		    buttons[i][j].setFont(font);
	}
	
	
	
	public Keyboard()
	{
	
		Gbc gbc;
		
		panel = new JPanel();
		
		panel.setLayout(new GridBagLayout());
		
		
		JButton
		
		accentbutton = new JButton(),  onebutton   = new JButton(),
		twobutton    = new JButton(),  threebutton = new JButton(),
		fourbutton   = new JButton(),  fivebutton  = new JButton(),
		sixbutton    = new JButton(),  sevenbutton = new JButton(),
		eightbutton  = new JButton(),  ninebutton  = new JButton(),
		zerobutton   = new JButton(),  minusbutton = new JButton(),
		equalsbutton = new JButton(),  backbutton  = new JButton(),
		delbutton    = new JButton(),
		
		
		tabbutton = new JButton(),  capsbutton = new JButton(),
		
		qbutton = new JButton(),  wbutton = new JButton(),
		ebutton = new JButton(),  rbutton = new JButton(),
		tbutton = new JButton(),  ybutton = new JButton(),
		ubutton = new JButton(),  ibutton = new JButton(),
		obutton = new JButton(),  pbutton = new JButton(),
		
		lbracketbutton  = new JButton(),
		rbracketbutton  = new JButton(),
		backslashbutton = new JButton(),
		
		abutton = new JButton(),  sbutton = new JButton(),
		dbutton = new JButton(),  fbutton = new JButton(),
		gbutton = new JButton(),  hbutton = new JButton(),
		jbutton = new JButton(),  kbutton = new JButton(),
		lbutton = new JButton(),
		
		semicolonbutton = new JButton(),
		apostrophebutton = new JButton(),
		enterbutton = new JButton(),
		
		zbutton = new JButton(),  xbutton = new JButton(),
		cbutton = new JButton(),  vbutton = new JButton(),
		bbutton = new JButton(),  nbutton = new JButton(),
		mbutton = new JButton(),
		
		shiftlbutton = new JButton(),  shiftrbutton = new JButton(),
		commabutton  = new JButton(),  periodbutton = new JButton(),
		slashbutton  = new JButton(),  spacebutton  = new JButton(),
		
		leftbutton = new JButton(),  rightbutton = new JButton();
		
		
		buttons = new JButton[][]
		{
			{ accentbutton, onebutton, twobutton, threebutton, fourbutton,
			fivebutton, sixbutton, sevenbutton, eightbutton, ninebutton,
			zerobutton, minusbutton, equalsbutton, backbutton, },
			
			
			{ tabbutton, qbutton, wbutton, ebutton, rbutton, tbutton,
			ybutton, ubutton, ibutton, obutton, pbutton, lbracketbutton,
			rbracketbutton, backslashbutton, },
			
			
			{ capsbutton, abutton, sbutton, dbutton, fbutton, gbutton,
			hbutton, jbutton, kbutton, lbutton, semicolonbutton,
			apostrophebutton, enterbutton, },
			
			
			{ shiftlbutton, zbutton, xbutton, cbutton, vbutton, bbutton,
			nbutton, mbutton, commabutton, periodbutton, slashbutton,
			shiftrbutton, },
			
			
			{ spacebutton, leftbutton, rightbutton },
		};
		
		
		String[][] buttonnames = new String[][]
		{
			{ "' ~", "1 !", "2 @", "3 #", "4 $", "5 %", "6 ^",
			"7 &", "8 *", "9 (", "0 )", "- _", "= +", "<<", },
			
			{ ">>", "Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P",
			"[ {", "] }", "\\ |", },
			
			{ "Caps","A", "S", "D", "F", "G", "H", "J", "K", "L", "; :",
			"' \"", "Enter", },
			
			{ "Shift", "Z", "X", "C", "V", "B", "N", "M", ", <", ". >",
			"/ ?", "Shift", "", },
			
			{ "", "<", ">", "^", "v" },
		};
		
		
		char[][] charray = new char[][]
		{
			{ '`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=',
			KeyEvent.VK_BACK_SPACE, },
			
			{ KeyEvent.VK_TAB, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p',
			'[', ']', '\\', },
			
			{ KeyEvent.VK_CAPS_LOCK, 'a','s', 'd', 'f', 'g', 'h', 'j', 'k', 'l',
			';', '\'', KeyEvent.VK_ENTER, },
			
			{ KeyEvent.VK_SHIFT, 'z', 'x', 'c', 'v', 'b', 'n', 'm',
			',', '.', '/', KeyEvent.VK_SHIFT, },
			
			{ ' ', '<', '>', '^', 'v', },
		};
		
		
		char[][] charray2 = new char[][]
		{
			{ '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
			KeyEvent.VK_BACK_SPACE, },
			
			{ KeyEvent.VK_TAB, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P',
			'{', '}', '|', },
			
			{ KeyEvent.VK_CAPS_LOCK, 'A','S', 'D', 'F', 'G', 'H', 'J', 'K', 'L',
			':', '\"', KeyEvent.VK_ENTER, },
			
			{ KeyEvent.VK_SHIFT, 'Z', 'X', 'C', 'V', 'B', 'N', 'M',
			'<', '>', '?', KeyEvent.VK_SHIFT, },
			
			{ ' ', '<', '>'  },
		};
		
		
		for (int i = 0; i < buttons.length -1; i++)
		for (int j = 0; j < buttons[i].length; j++)
		{
			buttons[i][j].setText(buttonnames[i][j]);
			
			gbc = new Gbc();
			
			gbc.setPosition(j,i);
			gbc.setSize(1,1);
			gbc.setFill(Gbc.both);
			gbc.setInsets(0,0,0,0);
			gbc.setIpad(0, 0);
			gbc.setWeight(80, 100);
			
			if (buttons[i][j].equals(spacebutton))
			{
				gbc.setSize(10, 1);
				gbc.setIpad(200, 15);
			}
			
			panel.add(buttons[i][j], gbc);
		}
		
		for (int i = buttons.length -1; i < buttons   .length; i++)
		for (int j = 0;                 j < buttons[i].length; j++)
		{
			buttons[i][j].setText(buttonnames[i][j]);
			
			gbc = new Gbc();  int k = 0;
			
			if (buttons[i][j].equals(spacebutton))
			{
				k += 5;
				
				gbc.setPosition(j+k,i);
				gbc.setSize(5, 1);
				gbc.setFill(Gbc.both);
				gbc.setInsets(0, 0, 0, 0);
				gbc.setIpad(200, 15);
				gbc.setWeight(80, 100);
			}
			
			else
			{	gbc.setPosition(j+k,i);
				gbc.setSize(1,1);
				gbc.setFill(Gbc.both);
				gbc.setInsets(0, 0, 0, 0);
				gbc.setWeight(80, 100);
			}
			
			panel.add(buttons[i][j], gbc);
		}
		
		
		
		class ButtonListener implements ActionListener
		{
			private boolean shift;
			
			private boolean caps;
			
			public void actionPerformed(ActionEvent e)
			{
				if (textcomp == null) return;
				
				if (!textcomp.isEditable()) return;
				
				for (int i = 0; i < buttons   .length; i++)
				for (int j = 0; j < buttons[i].length; j++)
				{
					int     cp = textcomp.getCaretPosition();
					int length = textcomp.getText().length();
					
					if (e.getSource() == capsbutton)
					{
						caps = !caps;
						
						return;
					}
					
					else if ((e.getSource() == shiftlbutton)
					      || (e.getSource() == shiftrbutton))
					{
						shift = !shift;
						
						return;
					}
					
					else if (e.getSource() == delbutton)
					{
						if (cp == length) return;
						
						StringBuilder sb = new StringBuilder(
						
						    textcomp.getText());
						
						sb.deleteCharAt(cp);
						
						textcomp.setText(sb.toString());
						
						textcomp.setCaretPosition(cp);
						
						textcomp.requestFocusInWindow();
						
						return;
					}
					
					else if (e.getSource() == backbutton)
					{
						if (cp == 0) return;
						
						StringBuilder sb = new StringBuilder(
						
						    textcomp.getText());
						
						sb.deleteCharAt(cp-1);
						
						textcomp.setText(sb.toString());
						
						textcomp.setCaretPosition(cp-1);
						
						textcomp.requestFocusInWindow();
						
						return;
					}
					
					else if ((e.getSource() == leftbutton)
					      || (e.getSource() == rightbutton))
					{
						if (e.getSource() == leftbutton)
						
						    textcomp.setCaretPosition(
						
							cp - 1 >= 0 ? cp - 1 : 0);
						
						else if (e.getSource() == rightbutton)
						
						    textcomp.setCaretPosition(
						
							cp + 1 <= length ? cp + 1 : cp);
						
						cp = textcomp.getCaretPosition();
						
						textcomp.requestFocusInWindow();
						
						return;
					}
					
					else if (e.getSource() == buttons[i][j])
					{
						//  Read the text before and after the caret position
						
						String s1 = textcomp.getText().substring(0, cp);
						String s2 = textcomp.getText().substring(cp, length);
						
						if (!shift && !caps)
						{
							String s3 = s1 + charray[i][j] + s2;
							
							textcomp.setText(s3);
							textcomp.setCaretPosition(cp + 1);
						}
						
						else // if (shift || caps)
						{
							String str;
							
							if (shift) str = String.valueOf(charray2[i][j]);
							
							else // if (caps)
							
							    str = String.valueOf(charray[i][j]).toUpperCase();
							
							String s3 = s1 + str + s2;
							
							textcomp.setText(s3);
							textcomp.setCaretPosition(cp + 1);
						}
						
						shift = false;
						
						textcomp.requestFocusInWindow();
						
						return;
					}
				}
			}
		}
		
		ButtonListener buttonlistener = new ButtonListener();
		
		for (int i = 0; i < buttons   .length; i++)
		for (int j = 0; j < buttons[i].length; j++)
		
		    buttons[i][j].addActionListener(buttonlistener);
	}
	
	
	public JPanel getPanel()
	{
	
		return panel;
	}
	
	
	public JFrame getFrame()
	{
	
		frame = new JFrame();
		
		frame.add(panel);
		
		frame.setDefaultCloseOperation(
		
		    JFrame.DISPOSE_ON_CLOSE);
		
		frame.setResizable(false);
		
		frame.toFront();
		
		String title = "";
		
		frame.setTitle(title);
		
		frame.setVisible(true);
		
		return frame;
	}
}


//  End class Keyboard














//  The PublicKey, PublicKeyDialog, and PassphraseDialog classes
//
//  PublicKey[] PublicKey .generatePublicKey(secretkey, numberofciphers)
//
//  String PublicKeyDialog .generatePublicKey(component, font, color, color, [email address])
//
//  String PassphraseDialog .readPassphrase() or .readDialogInput()
//
//
//  For a client / server key, use the PublicKey[] PublicKey .generatePublicKey(secretkey,
//  numberofciphers) method instead of the dialog classes (because a client / server key
//  doesn't require a dialog box, a passphrase, an email address, or a partition size).
//  This is a static factory method that calls the public key constructor multiple times
//  using different key sizes to generate the composite public key.
//
//  For the user's public key, use the String PublicKeyDialog .generatePublicKey(...)
//  instead of the PassphraseDialog class because it prompts the user for a passphrase,
//  email address, and number of ciphers, and it converts the public key to a partitioned
//  string that can be copied and pasted.
//
//  If the user only has to enter a passphrase, use the PassphraseDialog readPassphrase()
//  or readDialogInput()






class PublicKeyDialog
{


	//  This class displays a public key dialog and generates a public key.
	//
	//  The PublicKeyDialog class is used instead of PassphraseDialog for users' public keys.
	
	//  The PublicKey generatePublicKey method only requires the secret / private key and
	//  the number of ciphers because it is used to generate client and server keys.
	
	
	
	//  These two methods create a dialog box that enables the user to enter a passphrase,
	//  email address (optional), and number of ciphers. Then the methods call the PublicKey
	//  generatePublicKey(passphrase, email, numberofciphers) method and return a formatted
	//  / partitioned / printable public key document.
	
	
	private Window window;
	
	private Font font;
	
	private Color foreground;
	private Color background;
	
	private String passphrase0;
	private String passphrase1;
	
	private String address;
	
	
	
	public PublicKeyDialog(Window window) { this.window = window; }
	
	public void setFont(Font font) { this.font = font; }
	
	public void setForeground(Color foreground) { this.foreground = foreground; }
	public void setBackground(Color background) { this.background = background; }
	
	public void setPassphrase0(String passphrase0) { this.passphrase0 = passphrase0; }
	public void setPassphrase1(String passphrase1) { this.passphrase1 = passphrase1; }
	
	public void setEmailAddress(String address)  { this.address = address; }
	
	
	public String[] generatePublicKey()
	{
		//  The mail program knows the user's email address and fills in the address field
		
		//  This method displays a passphrase dialog and returns the saved passphrase,
		//  the typed passphrase, and the formatted / partitioned public key
		
		
		//  partition size
		
		int linewidth = 40;
		
		int keyformat = 0;
		
		
		//  Get the passphrase, email address,
		//  number of ciphers, and partition size
		
		PassphraseDialog pd = new PassphraseDialog(
		
		   window, PassphraseDialog.passphrase_email_encrypt);
		
		if (foreground != null) pd.setForeground1(foreground);
		if (background != null) pd.setBackground1(background);
		
		if (font != null) pd.setFont1(font);
		
		if (passphrase0 != null) pd.setPassphrase0(passphrase0);
		if (passphrase1 != null) pd.setPassphrase1(passphrase1);
		
		//  Fill in the address field
		
		if (address != null) pd.setEmailAddress(address);
		
		String[] input = pd.readDialogInput();
		
		//  System.out.println("input == " + Arrays.toString(input));
		
		if (input == null) return null;
		
		String[] keys = null;
		
		String passphrase0 = null;
		String passphrase1 = null;
		String passphrase = null;
		String emailaddress = null;
		
		passphrase0  = input[0];
		passphrase1  = input[1];
		emailaddress = input[2];
		
		passphrase = passphrase0 + passphrase1;
		
		int numberofciphers = 4;
		
		try
		{	if ((input[3] != null) && !input[3].isEmpty())
			
			    numberofciphers = Integer.parseInt(input[3]);
			
			if (numberofciphers > PublicKey.size.length)
			    numberofciphers = PublicKey.size.length;
			
			if (input.length > 4)
			
			    if ((input[4] != null) && !input[4].isEmpty())
			
				linewidth = Integer.parseInt(input[4]);
		}
		
		catch (NumberFormatException ex)
		{
			ex.printStackTrace();
		}
		
		System.out.println("saved passphrase == " + passphrase0);
		//  System.out.println("typed passphrase == " + passphrase1);
		System.out.println("email address == " + emailaddress);
		System.out.println("no of ciphers == " + numberofciphers);
		
		if (numberofciphers > PublicKey.numberofciphers)
		    System.out.println("number of ciphers " +
			numberofciphers + " > " + PublicKey.numberofciphers);
		
		//  System.out.println("line width == " + linewidth);
		
		keys = PublicKey.generatePublicKey(
		
		    passphrase, emailaddress, numberofciphers);
		
		String title = ((emailaddress != null)
		             && !emailaddress.isBlank()) ? "" : __.publickey;
		
		String publickey = PublicKey.printPublicKey(
		
		    keys, emailaddress, title, linewidth, keyformat);
		
		return new String[] { passphrase0, passphrase1, publickey };
	}
}

//  End class PublicKeyDialog












class PassphraseDialog extends JDialog implements AncestorListener
{


	private static final long serialVersionUID = 1L;
	
	public static final int PASSPHRASE_ONLY = 0;
	public static final int PASSPHRASE_EMAIL_ENCRYPT = 1;
	public static final int PASSPHRASE_EMAIL_DECRYPT = 2;
	public static final int PASSPHRASE_MAILSERVER = 3;
	
	public static final int passphrase_only = PASSPHRASE_ONLY;
	public static final int passphrase_email_encrypt = PASSPHRASE_EMAIL_ENCRYPT;
	public static final int passphrase_email_decrypt = PASSPHRASE_EMAIL_DECRYPT;
	public static final int passphrase_mailserver = PASSPHRASE_MAILSERVER;
	
	
	
	//  mail passphrase file name
	
	private String mailpassphrasefilename;
	
	//  The email passphrase requires more security than the
	//  file encryption passphrase because email is sent over
	//  the internet and email uses public keys which can be
	//  compared to a list of pre-computed public keys that
	//  use weak passwords.
	//
	//  Files require less security than email because files
	//  use secret keys instead of public keys and files are
	//  protected by the user's computer.
	
	
	
	private JDialog dialog;
	
	private JTextField passphrasefield;
	
	private JTextField emailfield;
	
	
	private JTextArea passphrasearea;
	
	private JTextArea textarealabel;
	
	private JTextField hashfield;
	
	
	private JCheckBox randcheckbox;
	
	
	private JRadioButton singlebutton;
	private JRadioButton doublebutton;
	private JRadioButton quadbutton;
	private JRadioButton octbutton;
	private JRadioButton maxbutton;
	
	private JCheckBox maxcheckbox;
	
	private JComboBox<Integer> linewidthbox;
	
	
	private JLabel passphraselabel;
	private JLabel emaillabel;
	private JLabel passphrasehashlabel;
	private JLabel numberofcipherslabel;
	private JLabel numberofcipherslabel1;
	private JLabel keywidthlabel;
	
	private JLabel incomingmailserverlabel = new JLabel(__.incomingmailserver);
	private JLabel outgoingmailserverlabel = new JLabel(__.outgoingmailserver);
	private JLabel maildirectorylabel      = new JLabel(__.maildirectory);
	private JLabel numberofmessageslabel   = new JLabel(__.numberofmessages);
	
	private JComboBox<String> incomingmailserverbox;
	private JComboBox<String> outgoingmailserverbox;
	private JComboBox<Integer>  numberofmessagesbox;
	private JComboBox<String>          ascensionbox;
	private JTextField           maildirectoryfield;
	
	
	private String title = "";
	
	//  The label "My email address" is used instead of "Email address"
	//  so that some users don't enter a recipient's email address to
	//  try to generate the recipient's public key.
	
	private String passphraselabelstring0 = __.Passphrase;
	private String emaillabelstring = __.myemailaddress;
	private String numberofciphersstring = __.numberofciphers;
	
	
	private Window window;
	
	private int dialogtype;
	
	private JButton okbutton;
	
	private int maxfontsize = 40;
	
	private int maxlabelsize = 28;
	private int maxradiobuttonsize = 32;
	private int maxboxsize = 32;
	
	private Font font = new Font(
	
	    "monospaced", Font.BOLD, 18);
	
	
	
	
	
	//  the minimum length of the passphrase
	
	private int minlength = 16;
	
	
	//  Passphrase length for public key passphrase
	//
	//  20 digits x 3.32 bits / base-10 digit ~ 66.4 bits.
	//
	//  (3.32 == log2(10) == log(10) / log(2))
	
	
	//  There is no minimum passphrase length for the secret file key
	
	
	private Component[] components, components1;
	
	private KeyboardListener keyboardlistener;
	
	private KeyListener keylistener = new KeyListener();
	
	private MouseListener mouselistener1;
	
	private JPanel keyboardpanel;
	
	private boolean showkeyboard;
	
	
	
	//  These are public variables that are selected / entered by the user.
	//  They can also be initialized / changed by setMailServers(...), set
	//  MessagesPerScreen(...), setMailDirectory(...), setAscension(...), ...
	
	
	private String SP;
	private String email;
	private int numberofciphers;
	private int linewidth;
	
	private String incomingmailserver;
	private String outgoingmailserver;
	private String maildirectory;
	private boolean ascending = true;
	private int messagesperscreen = 50;
	
	private boolean validpassphrase;
	
	private boolean closed;
	
	
	
	public PassphraseDialog(Window window, int dialogtype)
	{
	
		//	passphrase_only
		//	
		//	passphrase_email_encrypt
		//	
		//	passphrase_email_decrypt
		//	
		//	passphrase_mailserver
		
		
		
		//           ______________________________
		//          |______________________________|
		//          |                              |
		//          |                              |
		//          |______________________________|
		//          | 0123 4567 89ab cdef          |
		//          |______________________________|
		//          |            O K               |
		//          |______________________________|
		
		
		
		//    _____________________________________________________
		//   |                                                     |
		//   |                   __________________________________|
		//   |    passphrase    |__________________________________|
		//   |                  |                                  |
		//   |                  |__________________________________|
		//   | My email address |__________________________________|
		//   |                   0123 4567 89ab cdef               |
		//   |                                                  __ |
		//   | number of ciphers 4 o quad  o oct  o max  width |56||
		//   |_____________________________________________________|
		//   |                         O K                         |
		//   |_____________________________________________________|
		
		
		
		//    _____________________________________________________
		//   |                                                     |
		//   |                   __________________________________|
		//   |    passphrase    |__________________________________|
		//   |                  |                                  |
		//   |                  |__________________________________|
		//   | My email address |__________________________________|
		//   |                   0123 4567 89ab cdef               |
		//   |_____________________________________________________|
		//   |                         O K                         |
		//   |_____________________________________________________|
		
		
		
		//    _____________________________________________________
		//   |                      _______________________________|
		//   |                     |_______________________________|
		//   |    passphrase       |                               |
		//   |                     |_______________________________|
		//   |                      0123 4567 89ab cdef            |
		//   |                                                     |
		//   |                      _______________________________|
		//   | Incoming mail server|_____________________________|_|
		//   | Outgoing mail server|_____________________________|_|
		//   | Mail directory      |_____________________________|_|
		//   | Number of messages  |__________|_|________________|_|
		//   |_____________________________________________________|
		//   |                         O K                         |
		//   |_____________________________________________________|
		
		
		
		
		
		super(window);
		
		this.window = window;
		
		this.dialogtype = dialogtype;
		
		dialog = this;
		
		okbutton = new JButton(__.OK);
		
		Gbc gbc;  int y = 0;
		
		
		//  the number of chars in the passphrase field
		
		final int textlength = 30;
		
		
		//  the number of rows in the passphrase area
		
		int rows = 2;
		
		this.setLayout(new GridBagLayout());
		
		
		if (dialogtype == PASSPHRASE_ONLY)
		{
			//   ________________________________
			//  |________________________________|
			//  |                                |
			//  |                                |
			//  |________________________________|
			//  |      0123 4567 89ab cdef       |
			//  |________________________________|
			//  |              O K               |
			//  |________________________________|
			
			
			passphrasehashlabel = new JLabel("");
			
			passphrasefield = new JTextField(textlength);
			passphrasearea = new JTextArea(rows, textlength);
			passphrasearea.setLineWrap(true);
			
			JScrollPane scrollpane1 = new JScrollPane(passphrasearea);
			
			hashfield = new JTextField(24);
			hashfield.setBorder(null);
			hashfield.setEditable(false);
			hashfield.setForeground(Color.gray);
			hashfield.setBackground(this.getBackground());
			
			randcheckbox = new JCheckBox();
			randcheckbox.setVisible(false);
			randcheckbox.setToolTipText(__.rng);
			
			textarealabel = new JTextArea(rows, 16);
			
			textarealabel.setLineWrap(true);
			textarealabel.setWrapStyleWord(true);
			
			textarealabel.setText(passphraselabelstring0);
			
			textarealabel.setBackground(this.getBackground());
			
			mouselistener1 = new MouseListener1(passphrasearea);
			passphrasearea.addMouseListener(mouselistener1);
			
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, 0);
			gbc.setSize(1, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(scrollpane1, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, 1);
			gbc.setSize(1, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(hashfield, gbc);
			
			//  Set the value of y so the constructor can ap-
			//  pend the virtual keyboard and the ok button
			
			y = 2;
		}
		
		
		
		
		else if ((dialogtype == PASSPHRASE_EMAIL_ENCRYPT)
		      || (dialogtype == PASSPHRASE_EMAIL_DECRYPT))
		{
		
			//    _____________________________________________________
			//   |                                                     |
			//   |                   __________________________________|
			//   |    passphrase    |__________________________________|
			//   |                  |                                  |
			//   |                  |__________________________________|
			//   | My email address |__________________________________|
			//   |                   0123 4567 89ab cdef               |
			//   |                                                  __ |
			//   | number of ciphers 4 o quad  o oct  o max  width |56||
			//   |_____________________________________________________|
			//   |                         O K                         |
			//   |_____________________________________________________|
			
			
			passphraselabel = new JLabel(passphraselabelstring0);
			     emaillabel = new JLabel(emaillabelstring);
			numberofcipherslabel  = new JLabel(numberofciphersstring);
			numberofcipherslabel1 = new JLabel();
			keywidthlabel = new JLabel(__.keywidth);
			
			
			passphrasehashlabel = new JLabel("");
			
			passphrasefield = new JTextField(textlength);
			passphrasearea  = new JTextArea(rows, textlength);
			
			JScrollPane scrollpane1 = new JScrollPane(passphrasearea);
			
			emailfield = new JTextField(textlength);
			
			
			hashfield = new JTextField(textlength);
			
			hashfield.setBorder(null);
			hashfield.setEditable(false);
			hashfield.setForeground(Color.gray);
			hashfield.setBackground(this.getBackground());
			
			randcheckbox = new JCheckBox();
			randcheckbox.setVisible(true);
			randcheckbox.setToolTipText(__.rng);
			
			randcheckbox.setVisible(passphrasefield.getText().isBlank());
			
			passphrasefield.setToolTipText(__.savedpassphrase);
			passphrasearea .setToolTipText(__.typedpassphrase);
			hashfield      .setToolTipText(__.passphraseandemailhash);
			
			//  The number of chars on the last line is the sum of
			//  the key sizes plus the number of hyphens (which is
			//  n-1) modulo the line width. The number of chars per
			//  line could change in future versions of the program.
			
			Integer[] linewidths = new Integer[] { 40, 48, 56, 64 };
			
			linewidthbox = new JComboBox<Integer>(linewidths);
			
			linewidthbox.setSelectedIndex(0);
			
			linewidthbox.setToolTipText(__.publickeywidth);
			
			
			//  Number of ciphers to be used
			
			singlebutton = new JRadioButton(__.single);
			doublebutton = new JRadioButton(__.double1);
			quadbutton   = new JRadioButton(__.quad);
			octbutton    = new JRadioButton(__.oct);
			maxbutton    = new JRadioButton(__.max);
			
			maxcheckbox = new JCheckBox();
			
			maxcheckbox.setEnabled(false);
			
			doublebutton.setToolTipText(__.numberofciphers);
			quadbutton  .setToolTipText(__.numberofciphers);
			octbutton   .setToolTipText(__.numberofciphers);
			maxbutton   .setToolTipText(__.numberofciphers);
			maxcheckbox .setToolTipText(__.includelargeciphers);
			
			
			
			//  Count the number of ciphers
			//  >= 256 chars / 1 K bits
			
			int largesize = (4+1)*1024;
			
			int n = PublicKey.numberofciphers;
			
			int numberoflargekeys = 0;
			
			for (int size : PublicKey.size)
			
			    if (size > largesize) numberoflargekeys++;
			
			int n1 = numberoflargekeys;
			
			maxcheckbox.setEnabled(n1 > 0);
			maxcheckbox.setVisible(n1 > 0);
			
			
			singlebutton.setVisible(false);
			doublebutton.setVisible(false);
			
			quadbutton.setVisible(n - n1 >  4);
			 octbutton.setVisible(n - n1 >= 8);
			
			maxbutton.setVisible(quadbutton.isVisible());
			
			maxcheckbox.setEnabled(false);
			maxcheckbox.setSelected(false);
			
			
			ButtonGroup buttongroup = new ButtonGroup();
			
			buttongroup.add(singlebutton);
			buttongroup.add(doublebutton);
			buttongroup.add(quadbutton);
			buttongroup.add(octbutton);
			buttongroup.add(maxbutton);
			
			
			JPanel buttonpanel = new JPanel();
			
			buttonpanel.add(singlebutton);
			buttonpanel.add(doublebutton);
			buttonpanel.add(quadbutton);
			buttonpanel.add(octbutton);
			buttonpanel.add(maxbutton);
			buttonpanel.add(maxcheckbox);
			
			Component strut1;
			
			strut1 = Box.createHorizontalStrut(10);
			
			buttonpanel.add(strut1);
			buttonpanel.add(keywidthlabel);
			buttonpanel.add(linewidthbox);
			
			
			//  Set the default number of ciphers
			
			numberofciphers = Math.min(8, n);
			
			octbutton.setSelected(true);
			
			
			//  Show the selected number as a digit string
			
			String numberstr = String.valueOf(numberofciphers);
			
			if (numberstr.length() == 1) numberstr = " " + numberstr;
			
			numberofcipherslabel1 .setText(numberstr);
			
			
			//  Set the line width box
			
			int index = 0;
			
			if (numberofciphers >= 4)  index = 1;
			if (numberofciphers >= 8)  index = 2;
			if (numberofciphers >= 16) index = 3;
			
			linewidthbox.setSelectedIndex(index);
			
			
			passphrasearea.setLineWrap(true);
			
			
			mouselistener1 = new MouseListener1(passphrasearea);
			passphrasearea.addMouseListener(mouselistener1);
			
			
			
			int labelsize = 8;
			int fieldsize = 8;
			
			int pos0 = 0;
			int pos1 = labelsize + 1;
			
			int sp_rows = passphrasearea.getRows();
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, y = 0);
			gbc.setSize(labelsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(passphraselabel, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(labelsize, y);
			gbc.setSize(1, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(randcheckbox, gbc);
			
			
			
			gbc = new Gbc();
			
			gbc.setPosition(pos1, y = 0);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(passphrasefield, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, sp_rows);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(scrollpane1, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, y += sp_rows);
			gbc.setSize(labelsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(emaillabel, gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(pos1, y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(emailfield, gbc);
			
			
			
			gbc = new Gbc();
			
			gbc.setPosition(0, ++y);
			gbc.setSize(labelsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(new JLabel(), gbc);
			
			
			gbc = new Gbc();
			
			gbc.setPosition(pos1, y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.both);
			gbc.setWeight(100, 100);
			
			this.add(hashfield, gbc);
			
			
			
			if (dialogtype == PASSPHRASE_EMAIL_ENCRYPT)
			{
				gbc = new Gbc();
				
				gbc.setPosition(0, ++y);
				gbc.setSize(labelsize, 1);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(numberofcipherslabel, gbc);
				
				
				gbc = new Gbc();
				
				gbc.setPosition(labelsize, y);
				gbc.setSize(1, 1);
				gbc.setInsets(0, 15, 0, 10);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(numberofcipherslabel1, gbc);
				
				
				gbc = new Gbc();
				
				gbc.setPosition(pos1, y);
				gbc.setSize(fieldsize, 1);
				gbc.setFill(Gbc.both);
				gbc.setWeight(100, 100);
				
				this.add(buttonpanel, gbc);
			}
			
			
			
			
			class ButtonListener implements ActionListener
			{
			
				public void actionPerformed(ActionEvent e)
				{
				
					//  auto size the line widths
					//
					//    0      1      2    (index)
					//
					//  size0  size1  size2  (digits)
					
					
					int index = 0;
					
					Object obj = e.getSource();
					
					if (obj instanceof JRadioButton)
					{
						JRadioButton b = (JRadioButton) obj;
						
						if      (b == singlebutton)  numberofciphers = 1;
						else if (b == doublebutton)  numberofciphers = 2;
						else if (b ==   quadbutton)  numberofciphers = 4;
						else if (b ==    octbutton)  numberofciphers = 8;
						else if (b ==    maxbutton)  numberofciphers = n - n1;
						
						maxcheckbox.setEnabled((n1 > 0) && (b == maxbutton));
						
						if (!maxcheckbox.isEnabled())
						     maxcheckbox.setSelected(false);
						
						if (maxcheckbox.isSelected())
						
						    numberofciphers += n1;
						
						if (numberofciphers >=  4) index = 1;
						if (numberofciphers >=  8) index = 2;
						if (numberofciphers >= 16) index = 3;
					}
					
					if (obj instanceof JCheckBox)
					{
						if (maxcheckbox.isSelected())
						
						     numberofciphers += n1;
						else numberofciphers -= n1;
						
						//  Set the line width index
						
						if ((numberofciphers == n)
						 || (numberofciphers == n - n1))
						
						     index = linewidths.length - 1;
						else index = linewidths.length - 2;
					}
					
					if (index >= linewidths.length)
					    index =  linewidths.length - 1;
					
					linewidthbox.setSelectedIndex(index);
					
					String numberstr = String.valueOf(numberofciphers);
					
					if (numberstr.length() == 1) numberstr = " " + numberstr;
					
					numberofcipherslabel1 .setText(numberstr);
					
					Dimension newsize = dialog.getPreferredSize();
					
					dialog.setSize(newsize.width, newsize.height);
				}
			}
			
			
			ButtonListener buttonlistener = new ButtonListener();
			
			singlebutton .addActionListener(buttonlistener);
			doublebutton .addActionListener(buttonlistener);
			quadbutton   .addActionListener(buttonlistener);
			octbutton    .addActionListener(buttonlistener);
			maxbutton    .addActionListener(buttonlistener);
			maxcheckbox  .addActionListener(buttonlistener);
		}
		
		
		
		
		
		else if (dialogtype == PASSPHRASE_MAILSERVER)
		{
		
			//    _____________________________________________________
			//   |                      _______________________________|
			//   |     passphrase      |_______________________________|
			//   |                     |                               |
			//   |                     |_______________________________|
			//   |                      0123 4567 89ab cdef            |
			//   |                                                     |
			//   |                      _______________________________|
			//   | Incoming mail server|_____________________________|_|
			//   | Outgoing mail server|_____________________________|_|
			//   | Number of messages  |__________|_|________________|_|
			//   | Mail directory      |_____________________________|_|
			//   |_____________________________________________________|
			//   |                         O K                         |
			//   |_____________________________________________________|
			
			
			passphraselabel = new JLabel(passphraselabelstring0);
			
			passphrasefield = new JTextField(textlength);
			passphrasearea  = new JTextArea(rows, textlength);
			
			JScrollPane scrollpane1 = new JScrollPane(passphrasearea);
			
			hashfield = new JTextField(textlength);
			hashfield.setBorder(null);
			hashfield.setEditable(false);
			hashfield.setForeground(Color.gray);
			hashfield.setBackground(this.getBackground());
			
			emailfield = new JTextField(textlength);
			
			randcheckbox = new JCheckBox();
			randcheckbox.setVisible(true);
			randcheckbox.setToolTipText(__.rng);
			
			
			//  incoming mail server, outgoing mail server, and mail directory
			
			incomingmailserverbox = new JComboBox<String>(__.incomingmailservers);
			outgoingmailserverbox = new JComboBox<String>(__.outgoingmailservers);
			
			maildirectoryfield = new JTextField();
			
			randcheckbox.setVisible(passphrasefield.getText().isBlank());
			
			
			passphrasefield.setToolTipText(__.savedpassphrase);
			passphrasearea .setToolTipText(__.typedpassphrase);
			hashfield      .setToolTipText(__.passphrasehash);
			
			
			String homedir    = System.getProperty("user.home");
			String workingdir = System.getProperty("user.dir");
			String classpath  = System.getProperty("java.class.path");
			
			
			String directory = homedir + File.separator + __.Mail;
			
			maildirectoryfield.setText(directory);
			
			numberofmessagesbox = new JComboBox<Integer>(__.messagenumbers);
			
			ascensionbox = new JComboBox<String>(
			
			    new String[] { __.ascending, __.descending });
			
			ascensionbox.setBackground(Color.white);
			
			incomingmailserverbox.setEditable(true);
			outgoingmailserverbox.setEditable(true);
			   maildirectoryfield.setEditable(false);
			  numberofmessagesbox.setEditable(true);
			         ascensionbox.setEditable(false);
			
			passphrasearea.setLineWrap(true);
			
			
			if (incomingmailserver != null)
			
			    incomingmailserverbox.setSelectedItem(incomingmailserver);
			
			if (outgoingmailserver != null)
			
			    outgoingmailserverbox.setSelectedItem(outgoingmailserver);
			
			numberofmessagesbox.setSelectedItem(this.messagesperscreen);
			
			if (ascending) ascensionbox.setSelectedItem(__. ascending);
			else           ascensionbox.setSelectedItem(__.descending);
			
			
			mouselistener1 = new MouseListener1(passphrasearea);
			passphrasearea.addMouseListener(mouselistener1);
			
			
			
			int fieldsize = 8;
			
			int sp_rows = passphrasearea.getRows();
			
			gbc = new Gbc();
			gbc.setPosition(0, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setWeight(100, 100);
			
			this.add(passphraselabel, gbc);
			
			
			gbc = new Gbc();
			gbc.setPosition(0, y += 2 + sp_rows);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(incomingmailserverlabel, gbc);
			
			gbc = new Gbc();
			gbc.setPosition(0, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(outgoingmailserverlabel, gbc);
			
			gbc = new Gbc();
			gbc.setPosition(0, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(numberofmessageslabel, gbc);
			
			gbc = new Gbc();
			gbc.setPosition(0, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setInsets(10,0,0,0);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(maildirectorylabel, gbc);
			
			
			
			y = 0;
			
			int pos1 = 10;
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(passphrasefield, gbc);
			
			gbc.setPosition(9, y);
			gbc.setSize(1, 1);
			gbc.setAnchor(Gbc.right);
			gbc.setWeight(100, 100);
			
			this.add(randcheckbox, gbc);
			
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, sp_rows);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(scrollpane1, gbc);
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, y += sp_rows);
			gbc.setSize(fieldsize, 1);
			gbc.setInsets(1, 0, 0, 0);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(hashfield, gbc);
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(incomingmailserverbox, gbc);
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(outgoingmailserverbox, gbc);
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(4, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(numberofmessagesbox, gbc);
			
			gbc = new Gbc();
			gbc.setPosition(pos1+4, y);
			gbc.setSize(4, 1);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(ascensionbox, gbc);
			
			
			gbc = new Gbc();
			gbc.setPosition(pos1, ++y);
			gbc.setSize(fieldsize, 1);
			gbc.setInsets(10,0,0,0);
			gbc.setFill(Gbc.horizontal);
			gbc.setWeight(100, 100);
			
			this.add(maildirectoryfield, gbc);
			
			
			
			incomingmailserverbox.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent e)
				{
					//  Sets the outgoing mail server to the same domain as the incoming server
					
					String selection = incomingmailserverbox.getSelectedItem().toString();
					
					String str = selection.substring(selection.indexOf("@") + 1);
					
					if (!str.contains(" ")) return;
					
					String domain = str.substring(0, str.indexOf(" "));
					
					String[] tokens = domain.split("[.]");
					
					if (tokens.length > 1) domain =
					
					    tokens[tokens.length -2] + "." + tokens[tokens.length -1];
					
					//  Set the outgoing server box to the same domain name
					
					for (int i = 0; i < outgoingmailserverbox.getItemCount(); i++)
					
					    if (outgoingmailserverbox.getItemAt(i).contains(domain))
					
						outgoingmailserverbox.setSelectedIndex(i);
				}
			});
			
			
			
			maildirectoryfield.addMouseListener(new MouseAdapter()
			{
				public void mouseClicked(MouseEvent e)
				{
					String filename;
					
					filename = maildirectoryfield.getText();
					
					File selectedfile = null;
					
					JFileChooser fc;
					
					fc = new FileChooser();
					
					fc.setFont(font);
					
					int mode = JFileChooser.DIRECTORIES_ONLY;
					
					fc.setFileSelectionMode(mode);
					
					fc.setDialogTitle(__.setmaildirectory);
					
					int choice = fc.showOpenDialog(window);
					
					if (choice == JFileChooser.APPROVE_OPTION)
					
					    selectedfile = fc.getSelectedFile();
					
					else return;
					
					if (selectedfile != null)
					{
						filename = selectedfile.getPath();
						
						maildirectoryfield.setText(filename);
					}
					
					String maildirectory = maildirectoryfield.getText();
					
					if ((mailpassphrasefilename != null)
					 || !mailpassphrasefilename.isEmpty())
					{
						filename = maildirectory + File.separator + __.mailpassphrase;
						
						File file = new File(filename);
						
						if (file.exists())
						{
							//  Read and display the saved passphrase
							
							byte[] input;
							
							try { input = DataStream.read(file); }
							
							catch (IOException ex)
							{
								System.out.println(ex);
								
								return;
							}
							
							String SP0 = new String(input);
							
							passphrasefield.setText(SP0);
						}
					}
				}
			});
		}
		
		
		passphrasefield.addKeyListener(keylistener);
		passphrasearea .addKeyListener(keylistener);
		
		passphrasearea.addAncestorListener(this);
		
		if (emailfield != null) emailfield
		
		    .addKeyListener(keylistener);
		
		
		randcheckbox.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				if (randcheckbox.isSelected())
				    randcheckbox.setSelected(false);
				
				int radix = 16;
				
				String randstr = generateRandomString(minlength + 4, radix);
				
				randstr = Convert.partition(randstr, " ", 4);
				
				passphrasefield.setText(randstr);
				
				setPassphraseHash();
			}
		});
		
		
		
		components = new Component[]
		{
			passphraselabel, emaillabel, passphrasehashlabel,
			numberofcipherslabel, numberofcipherslabel1, keywidthlabel,
			
			incomingmailserverlabel, outgoingmailserverlabel,
			maildirectorylabel, numberofmessageslabel,
			
			passphrasefield, passphrasearea, emailfield, hashfield,
			
			singlebutton, doublebutton, quadbutton, octbutton, maxbutton,
			
			linewidthbox, incomingmailserverbox, outgoingmailserverbox,
			maildirectoryfield, numberofmessagesbox, ascensionbox, okbutton,
		};
		
		
		components1 = new Component[]
		{
			//  this array is used to set the colors
			
			passphrasefield, passphrasearea, emailfield,
			
			linewidthbox, incomingmailserverbox, outgoingmailserverbox,
			maildirectoryfield, numberofmessagesbox, ascensionbox, okbutton,
		};
		
		
		//  Add a mouse listener to the passphrase label to show/hide the passphrase
		
		if (passphraselabel != null)
		
		passphraselabel.addMouseListener(new MouseAdapter()
		{
			Color foreground;
			
			public void mouseClicked(MouseEvent e)
			{
				//  Show / hide the keyboard
				
				keyboardpanel.setVisible(!keyboardpanel.isVisible());
				
				//  Window.java says that pack() is deprecated
				//  but the warning is suppressed so we use
				//  d.setSize(d.getPreferredSize()) instead
				
				Dimension newsize = dialog.getPreferredSize();
				dialog.setSize(newsize.width, newsize.height);
			}
		});
		
		if (passphraselabel != null) passphraselabel
		
		    .setToolTipText(__.clicktoshowhidekeyboard);
		
		
		//  Set the passphrase hash
		
		setPassphraseHash();
		
		
		keyboardlistener = new KeyboardListener();
		
		keyboardpanel = keyboardlistener.keyboardpanel;
		
		int length = textlength;
		
		
		//  Add a virtual keyboard
		
		gbc = new Gbc();
		gbc.setPosition(0, ++y);
		gbc.setSize(length, 1);
		gbc.setFill(Gbc.horizontal);
		gbc.setAnchor(Gbc.center);
		gbc.setInsets(15, 0, 15, 0);
		gbc.setWeight(100, 100);
		
		this.add(keyboardpanel, gbc);
		
		
		
		//  Add the ok button
		
		gbc = new Gbc();
		gbc.setPosition(0, ++y);
		gbc.setSize(length, 1);
		gbc.setFill(Gbc.both);
		gbc.setWeight(100, 100);
		
		this.add(okbutton, gbc);
		
		
		
		
		keyboardpanel.setVisible(showkeyboard);
		
		
		this.setDefaultCloseOperation(
		
		    JDialog.DO_NOTHING_ON_CLOSE);
		
		this.addWindowListener(new WindowAdapter()
		{
			public void windowClosing(WindowEvent e)
			{
				closed = true;
				
				dialog.setVisible(false);
			}
		});
		
		this.setTitle(title);
		
		this.setResizable(true);
		
		passphrasearea.requestFocusInWindow();
		
		
		//  Set the window size
		
		Dimension newsize = this.getPreferredSize();
		this.setSize(newsize.width, newsize.height);
		
		
		//  Center the dialog box
		
		centerDialogBox();
		
		
		//  Add the ok button action
		
		okbutton.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent e)
			{
				validpassphrase = validatePassphrase();
				
				//  Hide the dialog to unblock the read passphrase methods
				
				if (validpassphrase) dialog.setVisible(false);
			}
		});
	}
	
	
	//  End PassphraseDialog constructor
	
	
	
	
	private void centerDialogBox()
	{
		//  Center the dialog in the parent frame
		
		Point p = window.getLocation();
		
		int xpos = p.x, ypos = p.y;
		
		int  width = window.getWidth();
		int height = window.getHeight();
		
		int  width1 = dialog.getWidth();
		int height1 = dialog.getHeight();
		
		int x2pos = xpos +  width/2 -  width1/2;
		int y2pos = ypos + height/2 - height1/2;
		
		this.setLocation(x2pos, y2pos);
	}
		
	
	
	//  The PassphraseDialog KeyboardListener
	
	
	private class KeyboardListener implements ActionListener
	{
	
		private Keyboard keyboard;
		
		private JPanel keyboardpanel;
		
		private class FocusListener extends FocusAdapter
		{
			public void focusGained(FocusEvent e)
			{
				if (e.getSource() instanceof JTextComponent)
				{
					if (e.getSource() == passphrasefield)
					    keyboard.setTextComponent(passphrasefield);
					
					else if (e.getSource() == passphrasearea)
					    keyboard.setTextComponent(passphrasearea);
					
					else if (e.getSource() == emailfield)
					    keyboard.setTextComponent(emailfield);
				}
			}
		}
		
		private class DocumentListener1 implements DocumentListener
		{
			public void changedUpdate(DocumentEvent e) {   }
			public void  insertUpdate(DocumentEvent e) { setPassphraseHash(); }
			public void  removeUpdate(DocumentEvent e) { setPassphraseHash(); }
		}
		
		public KeyboardListener()
		{
			keyboard = new Keyboard();
			
			if (passphrasearea != null)
			
			     keyboard.setTextComponent(passphrasearea);
			else keyboard.setTextComponent(passphrasefield);
			
			keyboardpanel = keyboard.getPanel();
			
			keyboardpanel.setVisible(false);
			
			FocusListener focuslistener = new FocusListener();
			
			passphrasefield.addFocusListener(focuslistener);
			
			if (passphrasearea != null) passphrasearea.addFocusListener(focuslistener);
			if (    emailfield != null)     emailfield.addFocusListener(focuslistener);
			
			DocumentListener1 documentlistener1 = new DocumentListener1();
			
			if (passphrasefield != null) passphrasefield
			    .getDocument().addDocumentListener(documentlistener1);
			
			if (passphrasearea != null) passphrasearea
			    .getDocument().addDocumentListener(documentlistener1);
			
			if (emailfield != null) emailfield
			    .getDocument().addDocumentListener(documentlistener1);
		}
		
		public void setTextComponent(JTextComponent textcomp)
		{
			keyboard.setTextComponent(textcomp);
		}
		
		public void actionPerformed(ActionEvent e)
		{
			keyboardpanel.setVisible(true);
		}
	}
	
	
	
	
	private class KeyListener extends KeyAdapter
	{
	
		private boolean control;
		
		public void keyPressed(KeyEvent e)
		{
			if (e.getSource() == passphrasefield)
			{
				if (e.getKeyChar() == '\n')
				
				    passphrasefield.transferFocus();
				
				Dimension newsize = dialog.getPreferredSize();
				dialog.setSize(newsize.width, newsize.height);
			}
			
			if (e.getSource() == passphrasearea)
			{
				if (e.getKeyChar() == '\t')
				
				    if (emailfield != null)
				
					passphrasearea.transferFocus();
				
				Dimension newsize = dialog.getPreferredSize();
				dialog.setSize(newsize.width, newsize.height);
			}
			
			if (e.getKeyCode() == KeyEvent.VK_CONTROL)
			
			    control = true;
			
			if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				closed = true;
				
				dialog.dispose();
			}
		}
		
		
		public void keyReleased(KeyEvent e)
		{
			if (e.getSource() == passphrasefield)
			
			    if (passphrasefield.getText().isEmpty())
			
				randcheckbox.setVisible(true);
			
			if (e.getKeyCode() == KeyEvent.VK_CONTROL)
			
			    control = false;
			
			setPassphraseHash();
			
			Dimension newsize = dialog.getPreferredSize();
			dialog.setSize(newsize.width, newsize.height);
		}
	}
	
	
	
	private void setPassphraseHash()
	{
		String passphrase =
		
		    passphrasefield.getText() + passphrasearea.getText() +
		
			(emailfield != null ? emailfield.getText() : "" );
		
		passphrase = passphrase.toLowerCase();
		
		String passphrasehash = Cipher.hash2(passphrase) .substring(0, 16);
		
		passphrasehash = Convert.partition(passphrasehash, " ", 4);
		
		hashfield.setText(passphrasehash);
	}
	
	
	private void showHidePassphrase()
	{
		Color foreground = passphrasearea.getForeground();
		
		if (!passphrasearea.getForeground().equals(
		     passphrasearea.getBackground()))
		{
			passphrasearea.setForeground(
			passphrasearea.getBackground());
			
			passphrasefield.setForeground(
			passphrasefield.getBackground());
		}
		
		else
		{	passphrasearea .setForeground(foreground);
			passphrasefield.setForeground(foreground);
		}
	}
	
	
	//  AncestorListener is required because a component must be
	//  displayable, focusable, and visible, and all of its ancestors
	//  (except for the top-level window) must also be displayable,
	//  focusable, and visible, for the focus request to be granted.
	
	public void ancestorAdded(AncestorEvent e)
	{
		//  Transfer the focus from the passphrase field
		//  to the passphrase area if the saved passphrase
		//  was previously entered
		
		if (!passphrasefield.getText().isBlank())
		
		     passphrasefield.transferFocus();
	}
	
	public void ancestorMoved(AncestorEvent e) {  }
	
	public void ancestorRemoved(AncestorEvent e) {  }
	
	
	
	
	public PassphraseDialog setPassphrase0(String passphrase0)
	{
		if (passphrase0 != null)
		{
			if (Number.isDigitString(passphrase0, 16))
			
			    passphrase0 = Convert.partition(passphrase0, " ", 4);
			
			passphrasefield.setText(passphrase0);
		}
		
		passphrasefield.setCaretPosition(0);
		
		return this;
	}
	
	
	public PassphraseDialog setPassphrase1(String passphrase1)
	{
		if (passphrase1 != null)
		{
			if (Number.isDigitString(passphrase1, 16))
			
			    passphrase1 = Convert.partition(passphrase1, " ", 4);
			
			passphrasearea.setText(passphrase1);
		}
		
		passphrasearea.setCaretPosition(0);
		
		return this;
	}
	
	
	private String generateRandomString(int digits, int radix)
	{
		Number random = Number.random(digits, radix);
		
		String str = random .toString(digits, radix);
		
		while (str.length() < digits)  str = "0" + str;
		
		return str;
	}
	
	
	private String getPassphrase0()
	{
		return passphrasefield.getText();
	}
	
	
	
	
	
	//  public methods
	
	
	public PassphraseDialog setMinimumLength(int length)
	{
		this.minlength = length;
		
		return this;
	}
	
	
	public PassphraseDialog setEmailAddress(String address)
	{
		emailfield.setText(address);
		
		return this;
	}
	
	
	
	public PassphraseDialog setForeground1(Color color)
	{
		//  Set the foreground color of JTextComponents
		
		for (Component component1 : components1)
		{
			if (component1 == null) continue;
			
			component1.setForeground(color);
			
			if ((component1 instanceof JTextField)
			 || (component1 instanceof JTextArea))
			
			     ((JTextComponent) component1)
			
				.setCaretColor(color);
		}
		
		keyboardlistener.keyboard.setForeground(color);
		
		return this;
	}
	
	
	public PassphraseDialog setBackground1(Color color)
	{
		//  Set the background color of JTextComponents
		
		for (Component component1 : components1)
		{
			if (component1 == null) continue;
			
			component1 .setBackground(color);
		}
		
		keyboardlistener.keyboard.setBackground(color);
	  	
		return this;
	}
	
	
	
	public PassphraseDialog setFont1(Font font)
	{
	
		if (font == null)  return this;
		
		String fontname = this.font.getName();
		int fontstyle = this.font.getStyle();
		
		float fontsize = font.getSize();
		
		if (fontsize > maxfontsize)
		    fontsize = maxfontsize;
		
		this.font = this.font.deriveFont(fontsize);
		
		for (Component component : components)
		{
			if (component != null)
			
			    component.setFont(new Font(
			
				fontname, fontstyle, (int) fontsize));
			
			
			if ((fontsize > maxlabelsize) && component instanceof JLabel)
			
			    component.setFont(new Font(fontname, fontstyle, maxlabelsize));
			
			else if ((fontsize > maxradiobuttonsize) && component instanceof JRadioButton)
			
			    component.setFont(new Font(fontname, fontstyle, maxradiobuttonsize));
			
			else if ((fontsize > maxboxsize) && component instanceof JComboBox)
			
			    component.setFont(new Font(fontname, fontstyle, maxboxsize));
		}
		
		//  Set the keyboard font
		
		float minfontsize = 8, maxfontsize = 17;
		
		float keyboardfontsize = font.getSize();
		
		if (keyboardfontsize > maxfontsize) keyboardfontsize = maxfontsize;
		if (keyboardfontsize < minfontsize) keyboardfontsize = minfontsize;
		
		keyboardlistener.keyboard.setFont(font.deriveFont(keyboardfontsize));
		
		//  Pack the frame so the text area doesn't collapse
		
		this.pack();
		
		return this;
	}
	
	
	
	public PassphraseDialog setMailDirectory(String maildirectory)
	{
		this.maildirectory = maildirectory;
		
		if (maildirectoryfield != null)
		
		    maildirectoryfield.setText(maildirectory);
		
		return this;
	}
	
	
	public PassphraseDialog setMailPassphraseFileName(String filename)
	{
		this.mailpassphrasefilename = filename;
		
		return this;
	}
	
	
	
	public PassphraseDialog setMailServers(
	
		String incomingmailserver,
		String outgoingmailserver)
	{
		this.incomingmailserver = incomingmailserver;
		this.outgoingmailserver = outgoingmailserver;
		
		if (incomingmailserver != null)
		
		    incomingmailserverbox.setSelectedItem(
		    incomingmailserver);
		
		if (outgoingmailserver != null)
		
		    outgoingmailserverbox.setSelectedItem(
		    outgoingmailserver);
		
		return this;
	}
	
	
	
	public PassphraseDialog setAscension(boolean ascending)
	{
		//  Set the ascent / descent (ascension / descension)
		
		//  Some email service providers list the newest emails first / oldest last
		//   while other email providers list the oldest emails first / newest last
		
		this.ascending = ascending;
		
		if (ascending) ascensionbox.setSelectedItem(__. ascending);
		else           ascensionbox.setSelectedItem(__.descending);
		
		return this;
	}
	
	
	public PassphraseDialog setMessagesPerScreen(int messagesperscreen)
	{
		if (messagesperscreen == 0) return this;
		
		this.messagesperscreen = messagesperscreen;
		
		numberofmessagesbox.setSelectedItem(this.messagesperscreen);
		
		return this;
	}
	
	
	public PassphraseDialog showKeyboard(boolean bool)
	{
		//  Show the keyboard
		
		keyboardpanel.setVisible(bool);
		
		return this;
	}
	
	
	
	
	public String readPassphrase()
	{
		//  Set modal to true so that the setVisible method
		//  will block until the user enters a passphrase
		//  and the okbutton listener sets visible to false
		
		this.setModal(true);
		
		if ((passphrasefield == null) || passphrasefield.isVisible())
		
		     passphrasearea.requestFocusInWindow();
		
		//  The frame visibility has to be set to false
		//  and then to true to force the method to block
		
		this.setVisible(false);
		this.setVisible(true);
		
		if (!validpassphrase || closed)  return null;
		
		String SP = passphrasefield.getText()
		
		    + passphrasearea.getText();
		
		SP = SP .replaceAll("[ \n\t]", "");
		
		SP = SP .toLowerCase();
		
		this.SP = SP;
		
		return this.SP;
	}
	
	
	
	public String[] readDialogInput()
	{
		//  Set modal to true so that the setVisible method
		//  will block until the user enters a passphrase
		//  and the okbutton listener sets visible to false
		
		this.setModal(true);
		
		//  The frame visibility has to be set to false
		//  and then to true to force the method to block
		
		this.setVisible(false);
		this.setVisible(true);
		
		if (!validpassphrase || closed) return null;
		
		if ((passphrasefield.getText() + passphrasearea.getText())
		
			.replaceAll("[ \t\n]", "") .length() < minlength)
		{
			passphrasefield.setText("");
			passphrasearea .setText("");
		}
		
		
		if ((dialogtype == passphrase_email_encrypt)
		 || (dialogtype == passphrase_email_decrypt))
		{
			if (this == null) return null;
			
			String[] input = new String[4];
			
			String SP0 = passphrasefield.getText().trim();
			String SP1 = passphrasearea .getText().trim();
			
			String SP = SP0 + SP1;
			
			SP = SP .replaceAll("[ \n\t]", "");
			
			SP = SP .toLowerCase();
			
			if (SP.length() < minlength) return null;
			
			
			String email = emailfield.getText()
			
			    .replaceAll(" ", "");
			
			email = email.toLowerCase();
			
			
			this.SP = SP;
			
			this.email = email;
			
			
			int linewidth = (Integer)
			
			    linewidthbox.getSelectedItem();
			
			this.linewidth = linewidth;
			
			return new String[] { SP0, SP1, email, String
			
			   .valueOf(numberofciphers), String.valueOf(linewidth) };
		}
		
		
		else if (dialogtype == passphrase_mailserver)
		{
			String SP0 = passphrasefield.getText().trim();
			String SP1 = passphrasearea .getText().trim();
			
			String SP = SP0 + SP1;
			
			SP = SP.replaceAll("[ \n\t]", "");
			
			SP = SP.toLowerCase();
			
			if (SP.length() < minlength) SP = null;
			
			
			String[] input = new String[5];
			
			this.SP = SP;
			
			this.incomingmailserver = incomingmailserverbox .getSelectedItem().toString().trim();
			this.outgoingmailserver = outgoingmailserverbox .getSelectedItem().toString().trim();
			this.maildirectory      =    maildirectoryfield .getText().trim();
			
			String ascension = ascensionbox.getSelectedItem().toString().trim();
			
			Integer prevnumber = this.messagesperscreen;
			
			try { messagesperscreen = Integer.parseInt(
			
			    numberofmessagesbox.getSelectedItem().toString().trim()); }
			
			catch (NumberFormatException ex) { messagesperscreen = prevnumber; }
			
			return new String[] { SP0, SP1, incomingmailserver, outgoingmailserver,
			
			    maildirectory, String.valueOf(messagesperscreen), ascension };
		}
		
		else return null;
	}
	
	
	
	private int emailwarning = 0;
	
	private boolean validatePassphrase()
	{
		boolean selectedvalue = false;
		
		while (true)
		{
			String text = passphrasefield.getText()
			
			    + passphrasearea.getText();
			
			if (!text.isBlank())
			{
				//  passphrase < minlength
				
				String text1 = text.replaceAll("[ \n\t]", "");
				
				if (dialogtype != PASSPHRASE_ONLY)
				{
					if (text1.length() < minlength)
					{
						String warning_message = __.passphrasewarning;
						
						JOptionPane.showMessageDialog(
						
						    dialog, warning_message, "",
						
							JOptionPane.WARNING_MESSAGE);
						
						return false;
					}
				}
			}
			
			else // if (text.isBlank())
			{
				break;
			}
			
			
			if ((dialogtype != PASSPHRASE_ONLY) && !text.isBlank())
			{
				//  Validate the email field
				
				if ( (dialogtype == passphrase_email_encrypt)
				 ||  (dialogtype == passphrase_email_decrypt) )
				{
					if ( emailfield.getText().isEmpty() ) // no trim
					{
						//  user forgot to enter an email address
						
						if (emailwarning++ > 0) break;
						
						String message = __.enteranemailaddress;
						
						JOptionPane.showMessageDialog(dialog,
						    message, "", JOptionPane.ERROR_MESSAGE);
						
						return false;
					}
					
					else if ( !emailfield.getText().isBlank()
					       && !emailfield.getText().contains("@") )
					{
						//  invalid email address
						
						String message = __.invalidemailaddress;
						
						JOptionPane.showMessageDialog(dialog,
						    message, "", JOptionPane.ERROR_MESSAGE);
						
						return false;
					}
				}
			}
			
			break;
		}
		
		return true;
	}
	
	
	
	
	private class MouseListener1 extends MouseAdapter
	{
		private JPopupMenu popupmenu;
		
		private JTextComponent comp;
		
		public MouseListener1(JTextComponent comp)
		{
			this.comp = comp;
			
			popupmenu = new JPopupMenu();
			
			JMenuItem menuitem = new JMenuItem(__.copy);
			
			menuitem.addActionListener(new CopyListener(comp));
			
			popupmenu.add(menuitem);
			
			popupmenu.addSeparator();
			
			menuitem = new JMenuItem(__.paste);
			
			menuitem.addActionListener(new PasteListener(comp));
			
			popupmenu.add(menuitem);
			
			//  ...
		}
		
		public void mousePressed(MouseEvent e)
		{
			if (e.getButton() != MouseEvent.BUTTON1)
			{
				popupmenu.show(comp, e.getX(), e.getY());
			}
		}
	}
	
	
	private class CopyListener implements ActionListener
	{
		private JTextComponent comp;
		
		public CopyListener(JTextComponent comp)
		
		    { this.comp = comp; }
		
		public void actionPerformed(ActionEvent e)
		{
			comp.copy();
		}
	}
	
	
	private class PasteListener implements ActionListener
	{
		private JTextComponent comp;
		
		public PasteListener(JTextComponent comp)
		
		    { this.comp = comp; }
		
		public void actionPerformed(ActionEvent e)
		{
			comp.paste();
		}
	}
}

//  End class PassphraseDialog

















class PublicKey
{



	//  Public key exchange / key agreement
	//
	//
	//  Public key generation
	//
	//  Each entity A that wants to receive encrypted messages chooses
	//  an array of private keys x[] and computes a composite public key
	//
	//  y[] = f[](a[], x[])
	//
	//  where f[] is an array of one-way functions
	//  and a[] is an array of public parameters.
	//
	//
	//  Public key encryption
	//
	//  An entity B can encrypt a message m which only A can decrypt.
	//
	//  To send A an encrypted message, B does the following.
	//
	//  0. Obtain a copy of A's public key y[].
	//
	//  1. For each public key cipher in y[]
	//
	//     compute a one-time public key z[i] = f[i](a[i], k[i])
	//       and the one-time secret key e[i] = f[i](y[i], k[i])
	//
	//     where a[i] is the blank public key or public key parameter.
	//
	//  2. Calculate the composite key agreement e = xor(e[]).
	//
	//  3. Compute the encrypted message
	//
	//     c = E(e, m) == H(e + i) (+) m[i].
	//
	//  4. Send A the composite one-time public
	//     key z[] and the ciphertext c = E(k, m).
	//
	//
	//
	//  Public key decryption
	//
	//  A can decrypt any ciphertext c that was encrypted using A's public key.
	//
	//  To decrypt a message, A does the following.
	//
	//  0. Read the one-time composite public key z[] attached to the message.
	//
	//  1. For each public key cipher in z[]
	//
	//     compute the one-time secret key agreement
	//
	//     e[i] = f[i](z[i], x[i]).
	//
	//  2. Calculate the composite key agreement e = xor( e[] ).
	//
	//  3. Compute the decrypted message
	//
	//     m = D(e, c) == H(e + i) (+) c[i].
	//
	//
	//
	//  Sending an encrypted message
	//
	//  The sender generates a set of one-time private keys k[] and a set of
	//  one-time public keys z[] == f[](a[], k[]) to match the recipient's
	//  public key ciphers y[] == f[](a[], x[]).
	//
	//  The sender also computes the one-time secret keys e[] == f[](y[], k[])
	//  and the ciphertext c = E(e, m).
	//
	//  Then the sender concatenates the one-time public keys z[] and
	//  the ciphertext using newline chars as separators or delimiters.
	//
	//
	//  one-time public key z1
	//
	//  one-time public key z2
	//
	//  one-time public key z3
	//
	//  one-time public key z4
	//
	//    ...    ...    ...
	//
	//  one-time public key zn
	//
	//  k' = k (+) e[]  (optional)
	//
	//  C = E(e[], P) or E(k, P)
	
	
	//  The encrypted encryption key k' is optional because the sender can use
	//  the public key agreement or shared secret key as the encryption key.
	//
	//  The default setting uses the public key agreement as the encryption key
	//  because the one-time public key z[] uses a one-time private key k[] which
	//  is a function of the message hash and the time in nanoseconds. The random
	//  number generator is initialized using the system nano time.
	
	
	
	//  Decrypting an encrypted message
	//
	//  For each one-time public key z[i] the recipient computes the public key
	//  agreement e[i], and then xors the secret keys e[i] to get the composite
	//  key agreement e[]. (If an encrypted encryption key k' = k (+) e[] is ap-
	//  pended, then the composite key agreement e[] is xor-ed with k' to recover
	//  the one-time encryption key k.)
	//
	//  The composite public key agreement e[] or the encryption key k is then
	//  used to decrypt the ciphertext c and recover the plaintext m = D(k, c).
	
	//  The (+) symbol denotes the xor operator, binary addition or addition modulo 2.
	
	
	
	//  The public key class follows the examples in the Handbook of Applied Cryptography which also
	//  use the letters A, B, C, ... as in "Each entity A does the following to create a public key",
	//  or "To send A an encrypted message, B does the following ..." Other reference books and many
	//  cryptography papers use this notation as well.
	//
	//  If you create an instance of each class name such as client A and server B, or entity C, then
	//  you only have to use the class names once to instantiate the member variables A, B, C. It is
	//  redundant to repeat the class name for a variable that has already been instantiated.
	//
	//  Some examples can use class names without instantiation if there is only one instance of each
	//  class. For instance, the transport protocol example in the SendMail class uses the class names
	//  client and server to illustrate the communication or message exchange between two computers
	//  for sending email. The PublicKey and Signature classes also use class names in the examples.
	//
	//  Satoshi uses generic class names in the Bitcoin white paper such as the public key or account
	//  owner, the payee, the sender, the receiver and the recipient. He also creates instances of clas-
	//  ses by enumerating the class name. For instance, he uses owner0, owner1, and owner2 for the bit-
	//  coin account holders, and he uses owner1's public key and owner0's signature to illustrate a
	//  bitcoin transaction.
	
	
	
	
	
	//  Public key cipher notes
	
	
	//  All ciphers in the public key class except for subset sum ciphers are based on hypercomplex numbers.
	//  Hypercomplex numbers are multi-dimensional arrays of numbers that include vectors, quaternions, ma-
	//  trices, cubes, and tesseracts.
	//
	//  The matrix ciphers are based on the multivariate functions X1 A X2, X^-1 A^x X, A^-x B^x1 A^x, and
	//  A^x1 B^x2. The vector ciphers are based on the vector cross product problem Y = A (x) X, and the
	//  vector dot product problem Y = A * X. The quaternion and polynomial discrete log problem are based
	//  on the function X^-1 A^x X. (Matrix and linear algebra books use different letters for these func-
	//  tions such as P^-1 D P and C = A (x) B or W = U (x) V instead of X^-1 A X and Y = A (x) X.)
	//
	//  The vector ciphers and non-exponential matrix ciphers can be modular or non-modular, and the matrix,
	//  vector, and quaternion ciphers can use one or multiple equations. Unlike integer ciphers such as the
	//  Rabin / factorization cipher, there are no sub-exponential, polynomial, or quantum algorithms for
	//  solving non-linear matrix, vector, or hypercomplex equations or for breaking these ciphers.
	//
	//  The only difference between the public key ciphers and the ordinary matrix discrete log cipher Y =
	//  A^x (mod p) or the linear matrix cipher Y = A X is that the ciphers are multiplied by X and X^-1 or
	//  A^x1 and A^-x1. The vector cipher Y = A (x) X is the same form as the linear Diffie-Hellman cipher
	//  y = a x or Y = A X, but the matrix cipher Y = X A X is different because it has two X's or private
	//  variables instead of one to make the cipher non-linear.
	//
	//  Matrix ciphers are a generalization of integer ciphers because all numbers are 1x1 matrices. The in-
	//  teger cipher y = a^x (mod p) is a special case of the matrix discrete log cipher Y = A^x (mod p) in
	//  which A is an integer or a 1 x 1 matrix. The matrix discrete log cipher Y = A^x (mod p) is a special
	//  case of the X^-1 A^x X cipher where X is the identity or unit matrix, and the linear multiplication
	//  cipher Y = A X is a special case of the non-linear cipher Y = X1 A^x X2 in which X1 is the unit ma-
	//  trix and the exponent equals 1.
	//
	//  The words block and matrix are synonymous because a matrix is a rectangular block of numbers. Before
	//  they were called matrices, rectangular arrays of numbers were referred to as blocks. A block is a
	//  quantity, number, or section of things dealt with as a unit, such as a block of plaintext or cipher-
	//  text. (J.J. Sylvester used the term matrix in 1850 to refer to a rectangular block of numbers because
	//  a determinant is formed from a matrix, and a matrix is something from which something else origin-
	//  ates, develops, or takes form.)
	//
	//  All the commutative one-way functions or symmetric public key ciphers used in the public key class
	//  derive from the general matrix function X1 A^x X2 (or B^x1 A^x B^x2) including A^x, A^x X, A X,
	//  X1 A X2, and X^-1 A^x X (mod p). (The cipher a^x mod n is really X^-1 A^x X mod n where a and x are
	//  1x1 matrices or Latin squares, but the X matrices annihilate each other because integer multiplica-
	//  tion is commutative.) The side matrices X1 and X2 have to be private Latin squares, cubes or tesser-
	//  acts, powers of a public matrix, cube or tesseract, or inverses of each other or else there would be
	//  no constraint on the function or the function would be non-commutative.
	//
	//  Matrix ciphers are more complicated than integer ciphers because matrix multiplication is non-commu-
	//  tative unless the matrices are Latin squares. A Latin square is a matrix in which each row contains
	//  the same elements except that the elements are permuted or arranged in a different order. If the row
	//  elements are rotated, then the Latin square is also a circulant matrix. Latin square, cube, or tes-
	//  seract multiplication is commutative if the elements are circulant in the right or positive direc-
	//  tion so that the diagonal elements are all equal. Integer multiplication is commutative because all
	//  numbers are 1x1 Latin squares or circulant matrices and the diagonal elements are equal because there
	//  is only one element.
	//
	//  All circulant matrices are also Latin squares but all Latin squares are not circulant matrices be-
	//  cause the row elements can be permutated instead of rotated. This means that there are O(n!) Latin
	//  squares that can be formed from a row of n elements whereas there are only O(n) circulant matrices
	//  that can be formed from the same elements. While many of the matrices used in the public key class
	//  are both Latin squares and circulant matrices, some of them are only Latin squares because the rows
	//  rotate alternately in different directions and the elements can also be written boustrophedonically
	//  or by alternating the rows from left to right and right to left.
	// 
	//  Matrix public key generation uses block matrices whereas secret key generation uses block arrays.
	//  Public key generation reduces an n x n block matrix to an n x 1 column vector or block array, and
	//  then secret key generation reduces the n x 1 block array to a 1x1 block. (For a single-equation /
	//  1x1 block matrix cipher, the 1x1 block matrix is reduced to a 1x1 column vector / block array, and
	//  then the 1x1 block array is reduced to a 1x1 block or matrix.)
	//
	//  The vector cross product cipher uses arrays of integers, polynomials, commutative Latin squares,
	//  cubes or tesseracts, or powers of a matrix, cube, or tesseract for public key generation Y = A (x) X
	//  where the public key vector Y represents the area of a parallelogram formed by the two sides A and X.
	//  Then it uses the dot product instead of the cross product to compute the secret key number E = Y * K
	//  which represents the volume of the parallelepiped formed by the product of the public vector Y and
	//  the private vector K. (The implementation of the vector cross product cipher is asymmetrical because
	//  it requires different public key generation and public key agreement methods, but unlike the Merkle-
	//  Hellman cipher it uses two commutative functions instead of an invertible / one-way function.)
	//
	//  A secret matrix, vector, or hypercomplex number can be reduced to a secret key or number by concaten-
	//  ating the elements or removing the commas or delimiters. For example, the array { 1, 2, 3, 4 } or the
	//  matrix { { 1, 2 }, { 3, 4 } } can be reduced to the secret key or number 1234. The numbers are padded
	//  or prepended with zeros so that the elements have the same number of digits.
	//
	//  Any symmetric n x n matrix in which the elements are integers, vectors, quaternions, polynomials, ma-
	//  trices, cubes, or tesseracts can be used to construct a non-linear n-equation public key vector or
	//  array.
	//
	//  If the totient or exponent modulus is computable and contains only small prime powers q[] then the
	//  discrete log problem y = a ^ x (mod p) can be reduced to a set of smaller discrete log problems, ex-
	//  cept for products of matrices that are non-commutative such as Y = A^x1 B^x2 (mod p). The reduced log
	//  problems can be solved separately and then the composite logarithm can be computed using Gauss's re-
	//  mainder algorithm. This method for solving the discrete log problem is called the Pohlig-Hellman
	//  method.
	//
	//  If q[] = fact(p-1), each x[i] = x mod q[i] is computed by solving the reduced discrete log problem
	//  y[i] = a[i] ^ x[i] (mod p) where the reduced base a[i] = g ^ ((p-1)/q[i]) (mod p) and the reduced
	//  residue y[i] = y ^ ((p-1)/q[i]) (mod p). Since 0 <= x[i] < q[i], the discrete logs can be solved by
	//  trying all the combinations for x[i] or by finding sqrt collisions using a1 x[i] + b1 == a2 x[i] +
	//  b2 and then solving for x[i] == (b2 - b1) / (a1 - a2) (mod q[i]). The composite logarithm is the
	//  least common remainder x = lcr(x mod q[], q[]) where x mod q[] is the set of solutions to the re-
	//  duced discrete log problems.
	//
	//  Elliptic curves, lattices, polynomial factorization, and error-correcting codes are not used in the
	//  public key class because ciphers based on these math problems are susceptible to classical and quan-
	//  tum computing and are completely broken for all key sizes and parameters.
	//
	//
	//
	//  The Merkle-Hellman / knapsack cipher
	//
	//  The Merkle-Hellman cipher c[] = s0 a[] + r[][]^T s[] (mod n), b = c[] (m[] + e[]), b1 = r[][] (m[]
	//  + e[]), where c[] is the static public key and b is the one-time public key is included in the public
	//  key class. The static key is unbreakable because it uses secret keys s0, s[] and a private modulus n.
	//  Moreover, the one-time public key is also unbreakable because it includes small errors so that even
	//  if the subset sum problem is solved, the solution will not be the correct key because the solution is
	//  ambiguous and the solution set is too large to try all the combinations. But the recipient can always
	//  solve for the correct key by using the knowledge of the secret keys s, s[], and private modulus n to
	//  reduce the general subset sum problem to the superincreasing subset sum problem to find the correct
	//  solution or secret key m[]. The solution to the superincreasing subset sum problem is unambiguous be-
	//  cause the errors are added to the smaller elements of the superincreasing sequence.
	//
	//  The Merkle-Hellman cipher was the world's first public key cryptosystem and also the first quantum-
	//  resistant cipher. The cipher was never broken but it has to be implemented correctly or else it
	//  doesn't work. For example, if r[][] equals zero or no errors are added to the static key, then the
	//  vector c[] = s0 a[] (mod n) can be solved for the multiplier s0 and modulus n because a[] is a super-
	//  increasing sequence. If r[][] == 0, a cryptanalyst could find the value of s0 because for one of the
	//  elements c[0], a[0] == a^0 == 1; then the value of n can be solved from c[1] = a^1 s0 - k n which
	//  only contains two variables k and n, and k can only be a small value such as 0, 1, or 2 if a[1] = 2.
	//  Since the elements of c[] are permutated, it would require O(n^2) tries where n is the number of ele-
	//  ments to find the indexes of a[0] and a[1].
	
	
	
	
	
	
	
	
	
	
	
	
	//  Public key variables
	
	
	//  A is a public parameter or blank public key
	//
	//  X is the static private key
	//  Y is the static public key
	//
	//  K is the one-time private key
	//  Z is the one-time public key
	//
	//  E is the secret key agreement
	
	
	
	//  The public key ciphers are based on the matrix-theoretic problems
	//
	//       -1  x              -x2  x1  x2           x
	//  Y = X  A  X ,   Y = x  A   B   A ,   Y = A  X ,   Y = X1 A X2 ,
	//
	//  Y1  ==  x ( M1^x1 [ A ] M2^x1 + M1^x2 [ B ] M2^x2 )
	//  Y2  ==  x ( M1^x1 [ B ] M2^x1 + M1^x2 [ C ] M2^x2 ) ,
	//
	//  and the matrix- or polynomial- theoretic problem
	//
	//           x1   x2   |            k1 x1   k1 x2
	//  Y1  =  A    B      |   E1  =  A       B
	//                     |
	//           x1   x2   |            k2 x1   k2 x2
	//  Y2  =  B    C      |   E2  =  B       C
	//
	//  where A, B, C, X, X1, and X2 are matrices, Latin squares,
	//  quaternions, cubes, tesseracts, or polynomials
	//
	//  The vector ciphers are based on the vector dot product,
	//  the vector cross product, and the cross product determinant
	//  problems.
	
	
	
	
	
	//  Integer-matrix and polynomial-matrix ciphers
	
	
	
	//  Latin square discrete log (LSDL) cipher
	
	
	//         -1   x
	//  Y  =  X   A   X
	//
	//         -1   k
	//  Z  =  K   A   K
	//
	//         -1   x
	//  E  =  X   Z   X
	
	
	
	//  Matrix discrete log (MDL) ciphers
	
	
	//         -x' -1   x   1   x'
	//  Y  =  B   C   A   C   B
	//
	//         -k' -1   k   1   k'
	//  Z  =  B   C   A   C   B
	//
	//         -x'  x   x'
	//  E  =  B   Z   B
	
	
	//         -x'  x   x'
	//  Y  =  B   A   B
	//
	//         -k'  k   k'
	//  Z  =  B   A   B
	//
	//         -x'  x   x'
	//  E  =  B   Z   B
	
	
	
	
	//  Matrix discrete log, Latin square discrete log,
	//
	//  and Latin square discrete cipher (no logarithm)
	//
	//  MDL, LSDL, and LSD ciphers
	
	
	//  (no cross exponentiation for E
	//  only cross multiplication)
	
	
	//  Matrix discrete log multiplication cipher
	//
	//              x1      x2
	//  Y  =  x0  A    C  B
	//
	//              k1      k2
	//  Z  =  k0  A    C  B
	//
	//              x1      x2
	//  E  =  x0  A    Z  B
	
	
	
	
	//  Matrix discrete log Latin square
	//  multiplication cipher
	//
	//             x
	//  Y  =  X  A
	//             k
	//  Z  =  K  A
	//                x
	//  E  =  X  Z  A
	
	
	
	
	//  Latin square discrete (LSD) cipher
	//
	//  (modular or non-modular)
	//
	//  Y  =  X1  A  X2
	//
	//  Z  =  K1  A  K2
	//
	//  E  =  X1  Z  X2
	
	
	
	
	//  Quaternion discrete log (QDL) ciphers
	
	
	//  Quaternion discrete log cipher
	//
	//         -x1   x   x1
	//  Y  =  A    B   A
	//
	//         -k1   k   k1
	//  Z  =  A    B   A
	//
	//         -x1   x   x1
	//  E  =  A    Z   A
	
	
	
	//  Quaternion discrete log multiplication cipher
	//
	//  (no cross exponentiation for E
	//  only cross multiplication)
	//
	//          x1      x2
	//  Y  =  A    B  C
	//
	//          k1      k2
	//  Z  =  A    B  C
	//
	//          x1      x2
	//  E  =  A    Z  C
	
	
	
	//  Asymmetric quaternion /
	//  matrix discrete log cipher
	//
	//         -1
	//  Y  =  X   A  X
	//
	//              k
	//  M  =  k1  A
	//
	//              k          -1   k         -1
	//  Z  =  k1  Y   ==  k1  X   A   X  ==  X   M  X
	//
	//               -1
	//  E  =  X  Z  X   ==  M
	
	
	
	
	
	
	
	//  The vector dot product cipher
	//
	//  (asymmetrical or invertible / one-way function)
	//
	//  The recipient's static public key A[] is
	//
	//  an array of real or complex numbers;
	//
	//  the sender's private key X[] is an array
	//
	//  of real or complex numbers;
	//
	//  the one-time public key b is the dot product
	//
	//  of A[] and X[] or b = A[] * X[];
	//
	//  the secret key x is the sum of X[].
	
	
	
	
	//  The vector cross product determinant cipher
	//
	//  The static and one-time public keys Y and Z
	//  are the cross products of the private keys
	//  X1, X2, and K1, K2. The secret key agreement
	//  E is the determinant of the public key Y and
	//  the private keys K or the public key Z and
	//  the private keys X.
	//
	//                    |  i   j   k  |
	//  Y = X1 (x) X2  == | x11 x12 x13 |
	//                    | x21 x22 x23 |
	//
	//                    |  i   j   k  |
	//  Z = K1 (x) K2  == | k11 k12 k13 |
	//                    | k21 k22 k23 |
	//
	//         | y1  y2  y3  | __ |  z1  z2  z3 |
	//  E  ==  | k11 k12 k13 | __ | x11 x12 x13 |
	//         | k21 k22 k23 |    | x21 x22 x23 |
	
	
	
	
	
	//  The vector cross product cipher
	//
	//  (Vector, parallelogram, parallelepiped cipher)
	//
	//  for vectors of integers, Latin squares, polynomials,
	//  or powers of a matrix (cube or tesseract) such as
	//  { A^x1, A^x2, A^x3 }.
	//
	//  A, K, X are vectors where A is a public parameter
	//  and K and X are the private keys
	//
	//  The static and one-time public keys are the areas
	//  of the parallelograms
	//
	//  Y  =  A (x) X   and   Z  =  A (x) K
	//
	//  where the cross product of A = { a1, a2, a3 } and
	//  B = { b1, b2, b3 } is the determinant or vector
	//
	//  |   i   j   k  |          (a2 b3 - a3 b2) i
	//  |              |   __
	//  |  a1  a2  a3  |   __   + (a3 b1 - a1 b3) j
	//  |              |
	//  |  b1  b2  b3  |        + (a1 b2 - a2 b1) k
	//
	//  The secret key is the volume of the parallelepiped
	//
	//  E  = Y * K == - Z * X
	//
	//  The volume of a parallelepiped is also defined by
	//  the determinant
	//
	//            |  a1  a2  a3  |
	//       __   |              |
	//   V   __   |  b1  b2  b3  |
	//            |              |
	//            |  c1  c2  c3  |
	//
	//  where the vectors { a1, a2, a3 }, { b1, b2, b3 },
	//  and { c1, c2, c3 } are any three sides.
	
	
	
	
	
	//  Vector cross product cipher
	//
	//  Y1 = A (x) X1 + B (x) X2
	//
	//  Y2 = B (x) X1 + C (x) X2
	//  ________________________
	//
	//  Z1 = A (x) K1 + B (x) K2
	//
	//  Z2 = B (x) K1 + C (x) K2
	//  ________________________
	//
	//  E  =   Y1 * K1 + Y2 * K2
	//
	//    == - Z1 * X1 - Z2 * X2
	
	
	
	
	//  Matrix, quaternion, or polynomial polynomial discrete log cipher
	//
	//         x     x     x-1    x-1    x-2    x-2            0     0
	//  Y  =  A  B  C  +  A   B  C   +  A   B  C   +  ...  +  A  B  C
	//
	//         k+x     k+x     k+x-1    k+x-1             0     0
	//  E  =  A    B  C    +  A     B  C      +  ...  +  A  B  C
	
	
	
	
	
	//  A four-equation discrete log cipher example
	//
	//  Compute the public key array or column vector Y [] =
	//
	//      x1   x2   x3   x4                             x1
	//  | M1   M1   M1   M1   |  |  A   B   C   D  |  | M2   |
	//  |   x1   x2   x3   x4 |  |                 |  |   x2 |
	//  | M1   M1   M1   M1   |  |  B   E   F   G  |  | M2   |
	//  |   x1   x2   x3   x4 |  |                 |  |   x3 |
	//  | M1   M1   M1   M1   |  |  C   F   H   I  |  | M2   |
	//  |   x1   x2   x3   x4 |  |                 |  |   x4 |
	//  | M1   M1   M1   M1   |  |  D   G   I   J  |  | M2   |
	//
	//            x1      x1              x4      x4
	//  Y1  ==  M1   A  M2   +  ...  +  M1   D  M2
	//            x1      x1              x4      x4
	//  Y2  ==  M1   B  M2   +  ...  +  M1   G  M2
	//            x1      x1              x4      x4
	//  Y1  ==  M1   C  M2   +  ...  +  M1   I  M2
	//            x1      x1              x4      x4
	//  Y2  ==  M1   D  M2   +  ...  +  M1   J  M2
	//
	//
	//  where M1, M2, A, B, C, D, E, F, G, H, I, J are public
	//
	//  matrices, cubes, tesseracts, or polynomials, and
	//  x1, x2, x3, x4 are private integer exponents.
	//
	//
	//  (Block array exponentiation, multiplication, and addition)
	//
	//  Compute the block vector E [] =
	//
	//                x1                x1
	//  | E1 |    | M1   |  | Z1 |  | M2   |
	//  |    |    |   x2 |  |    |  |   x2 |
	//  | E2 | __ | M1   |  | Z2 |  | M2   |
	//  |    | __ |   x3 |  |    |  |   x3 |
	//  | E3 |    | M1   |  | Z3 |  | M2   |
	//  |    |    |   x4 |  |    |  |   x4 |
	//  | E4 |    | M1   |  | Z4 |  | M2   |
	//
	//  and then compute the secret key / matrix
	//
	//    E  ==  E1 + E2 + E3 + E4
	
	
	
	
	
	
	
	//  Matrix discrete log (mdl) ciphers
	
	private static final int size64 = 4*16; // 64 digits
	private static final int size72 = 8*9;  // 72 digits
	private static final int size96 = 16*6; // 96 digits
	private static final int size76 = 4*19; // 76 digits
	
	private static final int size108 = 12*9; //  108 digits
	
	private static final int size112 = 2*2*2*14; // 112 digits
	
	
	//  Real / fractional number / non-integer matrix cipher
	
	private static final int size90 = 10*3*3; // 90 digits
	
	
	//  Matrix polynomial discrete log (mpdl) cipher
	
	private static final int size60 = 4*15; // 60 digits
	
	
	//  Polynomial matrix discrete log cipher
	
	private static final int size56 = 224 / 4; // 56 digits
	
	
	//  Latin square discrete log (lsdl) cipher
	
	private static final int size84 = 6*14; // 84 digits
	
	
	//  Quaternion discrete log (qdl) cipher
	
	private static final int size80 = 4*20; // 80 digits
	
	
	//  Non-exponential modular and non-modular ciphers
	
	//  circulant matrix / lsd cipher
	
	private static final int size144 = 576/4; // 144 digits
	private static final int size88  = 4*22; // 88 digits
	
	
	//  Vector cross product (vcp) cipher
	
	private static final int size120 = 3*40; // 120 digits
	
	
	//  Vector cross product determinant (vcpd) cipher
	
	private static final int size192 = 3*64; // 192 digits
	
	
	//  Polynomial matrix X A X cipher
	
	private static final int size150 = 50*3; // 150 digits
	
	
	
	//  Large ciphers
	
	//  Asymmetrical public keys or invertible one-way functions
	
	
	//  The integer Merkle-Hellman / knapsack ciphers
	
	private static final int sizeknapsack1 = (4*16)*(4*16+1); // 4k*(4k+1)
	
	
	//  Vector dot product (vdp) cipher
	
	private static final int size768 = 6*128; // 768 digits
	
	
	
	
	
	//  Public keys can be static / receiver or one-time / sender keys
	//
	//  The type of key is only important for asymmetric public key ciphers
	//  such as the Merkle-Hellman / knapsack cipher, the parallelogram /
	//  parallelepiped or vector / cross product ciphers, and the vector
	//  dot product ciphers.
	//
	//  Symmetric public keys or Diffie-Hellman ciphers ignore this variable
	//
	//  Note that only the generate secret key method requires the type of
	//  key as an argument; the generate public key methods don't require
	//  the type because they know from the publickey member variable what
	//  type of key is required; if the publickey == null then the construc-
	//  tor has to generate the recipient's static public key, and if the
	//  publickey != null then the constructor has to generate the sender's
	//  onetime public key. This is why there is no boolean type member var-
	//  iable and PublicKey setType(type) method in the PublicKey class.
	
	final static int receive_decrypt = 1; // receiver / static key
	final static int    send_encrypt = 2; //  sender / one-time key
	
	
	
	
	//  This array determines the number and order
	//  of the ciphers in the public key class
	
	
	public static int[] size = new int[]
	{
	
		size120, //  Y = A (x) X  vector cross product / vcp
		
		size144, //  X1 A X2 (64 x 64)  non-modular lsd
		
		size88,  //  rotate( A X1 ) X2  2-D multiplication
		
		size72,  //  x A1^x1 B A2^x2  cube-dl / c-dl
		
		
		size150, //  X1 A X2  polynomial matrix lsd
		
		size90,  //  X1 A X2  real / fractional number matrix
		
		size96,  //  x A1^x1 B A2^x2  tesseract-dl / t-dl
		
		size112, //  x (M1^x1 [ A ] M2^x1 + M1^x2 [ B ] M2^x2)
		         //  x (M1^x1 [ B ] M2^x1 + M1^x2 [ C ] M2^x2)
		
		
		size64,  //  x A1^x1 B A2^x2  m-dl
		
		size56,  //  A^x1 B^x2, B^x1 C^x2  polynomial m-dl
		
		size60,  //  A^x C B^x + ... + A^0 C B^0  m-pdl
		
		size84,  //  X^-1 A^x X (4 x 4)  boustrophedonic lsdl
		
		size108, //  A^x X (3 x 3)  matrix latin square
		
		size80,  //  A^-x1 B^x A^x1  quaternion / q-dl
		
		size76,  //  A^-x' C^-1  B^x  C^1  A^x'  m-dl
		
		size192, //  Y = X1 (x) X2, E = det(Z, X1, X2)
		
		
		//  vector dot product / vdp
		
		size768, //  y = a[],  z = a[] * x[]
		
		
		sizeknapsack1, //  knapsack cipher
		
		//  c[] = s0 a[] + r[][] s[] (mod n),
		//
		//  b = c[] (m[] + e[]), b1 = r[][]^T (m[] + e[])
		
		
		
		
		//  cipher abbreviations
		//
		//  m-dl = matrix discrete log
		//  p-dl = polynomial discrete log
		//  q-dl = quaternion discrete log
		//  c-dl = cube discrete log
		//  t-dl = tesseract discrete log
		//
		//  mpdl = matrix polynomial discrete log
		//  lsdl = Latin square discrete log  X^-1 A^x X
		//  lsd  = Latin square discrete cipher X A X
		//  vcp  = vector cross product cipher A (x) X
		//  vcpd = vector cross product determinant cipher
		//  vdp  = vector dot product cipher A * X
		//
		//  ....   ....
		
		
		//  The public key class may include a few more real
		//  / fractional number / non-integer / non-discrete
		//  ciphers in future versions
	};
	
	
	//  public key compute time (ms) ==
	//
	//  [11, 5, 5, 30, 7, 7, 77, 19, 21, 53, 112, 53, 28, 83, 36]
	//  [12, 5, 4, 25, 4, 7, 73, 34, 25, 63, 123, 42, 22, 117, 20]
	//
	//  These numbers are not accurate because the threads are interrupted,
	//  but they show that the integer vector cross product, the 2-dimen-
	//  sional matrix product, the real / fractional number matrix product,
	//  the polynomial matrix lsd, and the Merkle-Hellman / knapsack ciphers
	//  are the fastest public key ciphers.
	//
	//  (Smart cards or credit cards could use these ciphers because they
	//  require only a few million processor operations. The other ciphers
	//  require tens of millions of operations.)
	
	
	
	
	
	
	public static final int numberofciphers = size.length;
	
	
	
	//  No two public keys can have the same size
	//
	//  In future versions an identifier could be prepended
	//  or appended to the public key strings so the public
	//  key class could distinguish between different keys
	//  that have the same sizes
	
	
	//  The following code is inside a code block so it
	//  can be executed outside of a function or method.
	//  The code block is declared static since it only
	//  has to be executed once for all instances.
	
	static
	{
		//  Verify that no two public keys have the same size
		
		int[] sizes = Arrays.copyOf(size, size.length);
		
		//  System.out.println(Arrays.toString(sizes));
		
		int[][] int_freq = Math.sortAndCollate(sizes);
		
		for (int i = 0; i < int_freq.length; i++)
		{
			//  System.out.print(int_freq[i][0]
			//           + " " + int_freq[i][1] + ", ");
			
			if (int_freq[i][1] != 1) throw
			
			    new IllegalArgumentException();
		}
	}
	
	
	
	
	
	//  PublicKey members
	
	
	//  public key string, modulus, and private key
	
	private String publickey;
	
	private byte[] privatekey;
	
	private Number[] x;
	
	private Number p;
	
	
	
	
	
	//  Random digits for public key parameters or blank public keys
	//
	//  The digits of pi are used as random numbers because pi is an ir-
	//  rational and transcendental number and the digits are perfectly
	//  random, disordered or chaotic.
	
	
	//  Number pi = Number.pi(5*1024);
	//
	//  String str = pi.toString(16).replace(".", "");
	//
	//  System.out.println(str);
	//
	//  Click Edit -> Convert Text / Document -> String -> OK
	//
	//  and then press Ctrl + a or click Edit -> Select All
	//  and press the right-arrow key to indent the text
	
	
	final private static String pi2 =
	
	"1100100100001111110110101010001000100001011010001100001000110100" +
	"1100010011000110011000101000101110000000110111000001110011010001" +
	"0010100100000010010011100000100010001010011001111100110001110100" +
	"0000001000001011101111101010011000111011000100111001101100100010" +
	"0101000101001010000010000111100110001110001101000000010011011110";
	
	
	final private static String pi16 =
	
	"3243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c89452821e638d0137" +
	"7be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b54709179216d5d98979fb1bd1310ba698dfb5a" +
	"c2ffd72dbd01adfb7b8e1afed6a267e96ba7c9045f12c7f9924a19947b3916cf70801f2e2858efc1" +
	"6636920d871574e69a458fea3f4933d7e0d95748f728eb658718bcd5882154aee7b54a41dc25a59b" +
	"59c30d5392af26013c5d1b023286085f0ca417918b8db38ef8e79dcb0603a180e6c9e0e8bb01e8a3" +
	"ed71577c1bd314b2778af2fda55605c60e65525f3aa55ab945748986263e8144055ca396a2aab10b" +
	"6b4cc5c341141e8cea15486af7c72e993b3ee1411636fbc2a2ba9c55d741831f6ce5c3e169b87931" +
	"eafd6ba336c24cf5c7a325381289586773b8f48986b4bb9afc4bfe81b6628219361d809ccfb21a99" +
	"1487cac605dec8032ef845d5de98575b1dc262302eb651b8823893e81d396acc50f6d6ff383f4423" +
	"92e0b4482a484200469c8f04a9e1f9b5e21c66842f6e96c9a670c9c61abd388f06a51a0d2d8542f6" +
	"8960fa728ab5133a36eef0b6c137a3be4ba3bf0507efb2a98a1f1651d39af017666ca593e82430e8" +
	"88cee8619456f9fb47d84a5c33b8b5ebee06f75d885c12073401a449f56c16aa64ed3aa62363f770" +
	"61bfedf72429b023d37d0d724d00a1248db0fead349f1c09b075372c980991b7b25d479d8f6e8def" +
	"7e3fe501ab6794c3b976ce0bd04c006bac1a94fb6409f60c45e5c9ec2196a246368fb6faf3e6c53b" +
	"51339b2eb3b52ec6f6dfc511f9b30952ccc814544af5ebd09bee3d004de334afd660f2807192e4bb" +
	"3c0cba85745c8740fd20b5f39b9d3fbdb5579c0bd1a60320ad6a100c6402c7279679f25fefb1fa3c" +
	
	"c8ea5e9f8db3222f83c7516dffd616b152f501ec8ad0552ab323db5fafd23876053317b483e00df8" +
	"29e5c57bbca6f8ca01a87562edf1769dbd542a8f6287effc3ac6732c68c4f5573695b27b0bbca58c" +
	"8e1ffa35db8f011a010fa3d98fd2183b84afcb56c2dd1d35b9a53e479b6f84565d28e49bc4bfb979" +
	"0e1ddf2daa4cb7e3362fb1341cee4c6e8ef20cada36774c01d07e9efe2bf11fb495dbda4dae90919" +
	"8eaad8e716b93d5a0d08ed1d0afc725e08e3c5b2f8e7594b78ff6e2fbf2122b648888b812900df01" +
	"c4fad5ea0688fc31cd1cff191b3a8c1ad2f2f2218be0e1777ea752dfe8b021fa1e5a0cc0fb56f74e" +
	"818acf3d6ce89e299b4a84fe0fd13e0b77cc43b81d2ada8d9165fa2668095770593cc7314211a147" +
	"7e6ad206577b5fa86c75442f5fb9d35cfebcdaf0c7b3e89a0d6411bd3ae1e7e4900250e2d2071b35" +
	"e226800bb57b8e0af2464369bf009b91e5563911d59dfa6aa78c14389d95a537f207d5ba202e5b9c" +
	"5832603766295cfa911c819684e734a41b3472dca7b14a94a1b5100529a532915d60f573fbc9bc6e" +
	"42b60a47681e6740008ba6fb5571be91ff296ec6b2a0dd915b6636521e7b9f9b6ff34052ec585566" +
	"453b02d5da99f8fa108ba47996e85076a4b7a70e9b5b32944db75092ec4192623ad6ea6b049a7df7" +
	"d9cee60b88fedb266ecaa8c71699a17ff5664526cc2b19ee1193602a575094c29a0591340e4183a3" +
	"e3f54989a5b429d656b8fe4d699f73fd6a1d29c07efe830f54d2d38e6f0255dc14cdd20868470eb2" +
	"66382e9c6021ecc5e09686b3f3ebaefc93c9718146b6a70a1687f358452a0e286b79c5305aa50073" +
	"73e07841c7fdeae5c8e7d44ec5716f2b8b03ada37f0500c0df01c1f040200b3ffae0cf51a3cb574b" +
	
	"225837a58dc0921bdd19113f97ca92ff69432477322f547013ae5e58137c2dadcc8b576349af3dda" +
	"7a94461460fd0030eecc8c73ea4751e41e238cd993bea0e2f3280bba1183eb3314e548b384f6db90" +
	"86f420d03f60a04bf2cb8129024977c795679b072bcaf89afde9a771fd9930810b38bae12dccf3f2" +
	"e5512721f2e6b7124501adde69f84cd877a5847187408da17bc9f9abce94b7d8cec7aec3adb851df" +
	"a63094366c464c3d2ef1c18473215d908dd433b3724c2ba1612a14d432a65c45150940002133ae4d" +
	"d71dff89e10314e5581ac77d65f11199b043556f1d7a3c76b3c11183b5924a509f28fe6ed97f1fbf" +
	"a9ebabf2c1e153c6e86e34570eae96fb1860e5e0a5a3e2ab3771fe71c4e3d06fa2965dcb999e71d0" +
	"f803e89d65266c8252e4cc9789c10b36ac6150eba94e2ea78a5fc3c531e0a2df4f2f74ea7361d2b3" +
	"d1939260f19c279605223a708f71312b6ebadfe6eeac31f66e3bc4595a67bc883b17f37d1018cff2" +
	"8c332ddefbe6c5aa56558218568ab9802eecea50fdb2f953b2aef7dad5b6e2f841521b6282907617" +
	"0ecdd4775619f151013cca830eb61bd960334fe1eaa0363cfb5735c904c70a239d59e9e0bcbaade1" +
	"4eecc86bc60622ca79cab5cabb2f3846e648b1eaf19bdf0caa02369b9655abb5040685a323c2ab4b" +
	"3319ee9d5c021b8f79b540b19875fa09995f7997e623d7da8f837889a97e32d7711ed935f1668128" +
	"10e358829c7e61fd696dedfa17858ba9957f584a51b2272639b83c3ff1ac24696cdb30aeb532e305" +
	"48fd948e46dbc312858ebf2ef34c6ffeafe28ed61ee7c3c735d4a14d9e864b7e342105d14203e13e" +
	"045eee2b6a3aaabeadb6c4f15facb4fd0c742f442ef6abbb5654f3b1d41cd2105d81e799e86854dc" +
	
	"7e44b476a3d816250cf62a1f25b8d2646fc8883a0c1c7b6a37f1524c369cb749247848a0b5692b28" +
	"5095bbf00ad19489d1462b17423820e0058428d2a0c55f5ea1dadf43e233f70613372f0928d937e4" +
	"1d65fecf16c223bdb7cde3759cbee74604085f2a7ce77326ea607808419f8509ee8efd85561d9973" +
	"5a969a7aac50c06c25a04abfc800bcadc9e447a2ec3453484fdd567050e1e9ec9db73dbd3105588c" +
	"d675fda79e3674340c5c43465713e38d83d28f89ef16dff20153e21e78fb03d4ae6e39f2bdb83adf" +
	"7e93d5a68948140f7f64c261c94692934411520f77602d4f7bcf46b2ed4a20068d40824713320f46" +
	"a43b7d4b7500061af1e39f62e9724454614214f74bf8b88404d95fc1d96b591af70f4ddd366a02f4" +
	"5bfbc09ec03bd97857fac6dd031cb850496eb27b355fd3941da2547e6abca0a9a28507825530429f" +
	"40a2c86dae9b66dfb68dc1462d7486900680ec0a427a18dee4f3ffea2e887ad8cb58ce0067af4d6b" +
	"6aace1e7cd3375fecce78a399406b2a4220fe9e35d9f385b9ee39d7ab3b124e8b1dc9faf74b6d185" +
	"626a36631eae397b23a6efa74dd5b43326841e7f7ca7820fbfb0af54ed8feb397454056acba48952" +
	"755533a3a20838d87fe6ba9b7d096954b55a867bca1159a58cca9296399e1db33a62a4a563f3125f" +
	"95ef47e1c9029317cfdf8e80204272f7080bb155c05282ce395c11548e4c66d2248c1133fc70f86d" +
	"c07f9c9ee41041f0f404779a45d886e17325f51ebd59bc0d1f2bcc18f41113564257b7834602a9c6" +
	"0dff8e8a31f636c1b0e12b4c202e1329eaf664fd1cad181156b2395e0333e92e13b240b62eebeb92" +
	"285b2a20ee6ba0d99de720c8c2da2f728d012784595b794fd647d0862e7ccf5f05449a36f877d48f";
	
	
	
	
	
	
	//  The PublicKey constructor is private
	//
	//  No instantiation from outside the PublicKey class
	//
	//
	//  See the two public static generatePublicKey() methods
	//
	//  generatePublicKey(String passphrase, String email, int numberofciphers)
	//
	//  generatePublicKey(int[] secretkey, int numberofciphers)
	
	
	
	//  The constructor does not require the static public key to generate
	//  the one-time public key if the public key cipher is symmetrical.
	//
	//  For asymmetrical public key ciphers, the constructor requires the
	//  static public key to generate the one-time public key, and null to
	//  generate the static public key. The generateSecretKey method deter-
	//  mines which method to use from the public key type which is either
	//  receive / decrypt or send / encrypt.
	//
	//  If the public key member is set to null, it gets replaced by the
	//  computed static public key. If the public key member is not null,
	//  then the static public key member gets used by the method to compute
	//  the one-time public key which replaces the static public key member.
	
	
	//  A public key cipher is symmetrical if it uses the same function but
	//  different variables to generate the static and one-time public keys,
	//  such as y = f(a, x) and z = f(a, k).
	//
	//  A public key cipher is asymmetrical if it uses different functions
	//  to generate the static and one-time public keys, such as y = f(x) and
	//  z = f(y, k) where k or f(k) is the shared secret. (The functions can
	//  have the same name because they use a different number of parameters.)
	//
	//  For asymmetrical ciphers the sender or encryptor uses the recipient's
	//  static public key y to encrypt the secret key k, and then the recipient
	//  inverts or decrypts the one-time public key z (or c) to recover k.
	// 
	//  For example, the sender can compute the one-time public key c = m ^ 2
	//  (mod n) using the recipient's public key n and then the recipient can
	//  invert or decrypt c to recover m == c ^ (1/2) == sqrt(c) (mod n).
	
	
	
	//  A public key is valid if it contains at least a few valid or enabled ci-
	//  phers in the public key class. Some sender's or recipient's keys may con-
	//  tain newer or additional ciphers that are not recognized by the user's
	//  program.
	//
	//  If a cipher or key size is unknown, the generateMatchingPublicKeys method
	//  will return a PublicKey array that includes an empty public key object so
	//  that the number of ciphers in the user's one-time public key matches the
	//  recipient's static public key.
	//
	//  If the user's key is a one-time public key for encrypting to a recipient's
	//  static public key z, and the one-time public key includes one or more empty
	//  strings, then for each empty public key the generateSecretKey(z, type) method
	//  will return a value of zero to be xor-ed with the composite key agreement be-
	//  cause if the one-time public key contains an empty string, then the corre-
	//  sponding static public key contains an unknown cipher, key size or z.length().
	
	
	
	//  The private static and one-time public key constructor
	
	
	private PublicKey(byte[] privatekey, String publickey, int size)
	{
	
	
		//  If the recipient is generating a static public key then the
		//  public key parameter is null or empty.
		//
		//  If the public key cipher is symmetrical then the public key
		//  string is ignored by the constructor (because a symmetric
		//  public key cipher does not require the static public key
		//  y = f(x) to generate the one-time public key z = f(k)).
		//
		//  If the public key cipher is asymmetrical, then the public key
		//  constructor requires the recipient's static public key y = f(x)
		//  to generate the sender's one-time public key z = f(y, k).
		
		
		//  For public key / encryption ciphers, the private key is hashed
		//  with the size of the public key, not the cipher modulus, because
		//  encryption ciphers are allowed to use the same moduli.
		//
		//  For signature ciphers the private key is hashed with the cipher
		//  modulus, not the cipher size, because signature ciphers are
		//  allowed to use the same size, but not the same modulus.
		
		
		
		
		//  Define the private keys
		
		
		//  Hash the private key and the size or number of digits
		
		//  x is the 256-bit secret key == hash(passphrase + cipher size)
		
		//  Hash the private key with the size of the public key to
		//  make the private key different for each encryption cipher
		
		this.privatekey = Cipher.hash( new Number(
		
		    privatekey) .add(size) .toByteArray(32) );
		
		this.publickey = publickey;
		
		
		x = new Number[8];
		
		x[0] = new Number(Cipher.hash(this.privatekey));
		
		for (int i = 1; i < x.length; i++)
		
		    x[i] = new Number(Cipher.hash(
		
			x[i-1].toByteArray(32)));
		
		
		
		
		//  Example  Find a safe prime modulus
		//
		//  int radix = 16, sign = -1;
		//
		//  for (int digits = 8; digits <= 48; digits++)
		//  {
		//	Number n = new Number(radix) .pow(digits);
		//	
		//	while (!n.isPrime() || !n.subtract(1).divide(2).isPrime())
		//	{
		//		if      (sign == +1) n = n.add(1);
		//		else if (sign == -1) n = n.subtract(1);
		//		else return;
		//	}
		//	
		//	int diff = n .subtract(new Number(radix)
		//	    .pow(digits)).abs() .intValue();
		//	
		//	System.out.print(radix + "^");
		//	System.out.println(digits +
		//	  (sign == 1 ? " + " : " - ") + diff);
		//  }
		
		
		
		Number p6  = new Number(16).pow(6)  .subtract(317);
		Number p7  = new Number(16).pow(7)  .subtract(437);
		Number p8  = new Number(16).pow(8)  .subtract(209);
		Number p9  = new Number(16).pow(9)  .subtract(137);
		Number p10 = new Number(16).pow(10) .subtract(437);
		Number p12 = new Number(16).pow(12) .subtract(5297);
		Number p14 = new Number(16).pow(14) .subtract(2249);
		Number p15 = new Number(16).pow(15) .subtract(3677);
		Number p16 = new Number(16).pow(16) .subtract(1469);
		Number p17 = new Number(16).pow(17) .subtract(149);
		Number p19 = new Number(16).pow(19) .subtract(557);
		Number p20 = new Number(16).pow(20) .subtract(5837);
		Number p22 = new Number(16).pow(22) .subtract(797);
		Number p24 = new Number(16).pow(24) .subtract(3449);
		Number p25 = new Number(16).pow(25) .subtract(12389);
		Number p28 = new Number(16).pow(28) .subtract(3989);
		Number p32 = new Number(16).pow(32) .subtract(15449);
		Number p40 = new Number(16).pow(40) .subtract(13709);
		
		
		
		this.publickey = "";
		
		
		if (size == -1) {  }
		
		
		else if (size == size90)
		{
			this.p = null;
			
			generate3x3Key(size);
		}
		
		
		else if (size == size64)
		{
			this.p = p16;
			
			generate2x2Key(size);
		}
		
		
		else if (size == size88)
		{
			this.p = p22;
			
			generate2x2Key(size);
		}
		
		
		else if (size == size72)
		{
			this.p = p9;
			
			generate2x2Key(size);
		}
		
		
		else if (size == size96)
		{
			this.p = p6;
			
			generate2x2Key(size);
		}
		
		
		else if (size == size76)
		{
			this.p = p19;
			
			generate2x2Key(size);
		}
		
		
		else if ( size == size108 )
		{
			this.p = p12;
			
			generate3x3Key(size);
		}
		
		
		else if (size == size120)
		{
			this.p = p40;
			
			generateVectorKey(size);
		}
		
		
		else if (size == size112)
		{
			this.p = p14;
			
			generate2x2x2Key(size);
		}
		
		
		else if (size == size144)
		{
			this.p = null;
			
			generate64x64Key(size);
		}
		
		
		else if (size == size60)
		{
			this.p = p15;
			
			generateMPDLKey(size);
		}
		
		
		else if (size == size56)
		{
			this.p = null;
			
			generatePolynomialKey(size);
		}
		
		
		else if (size == size84)
		{
			this.p = p14;
			
			generate4x4Key(size);
		}
		
		
		else if (size == size150)
		{
			this.p = null;
			
			generatePolynomialKey(size);
		}
		
		
		else if (size == size80)
		{
			this.p = p20;
			
			generateQuaternionKey(size);
		}
		
		
		
		else if (size == size192)
		{
			this.p = null;
			
			generateVectorKey(size);
		}
		
		
		
		
		else if (size == sizeknapsack1)
		{
			this.p = null;
			
			generateMerkleHellmanKey(publickey, size);
		}
		
		
		else if (size == size768)
		{
			this.p = null;
			
			generateVectorDotProductKey(publickey, size);
		}
		
		
		
		
		//  else if (size == size...)
		//  {
		//	
		//  }
		
		
		//  If p is not null, verify that p is prime
		
		if ((this.p != null) && !this.p.isPrime())
		
		    throw new IllegalArgumentException();
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//  Public methods
	
	
	
	public String toString()
	{
	
		return publickey;
	}
	
	
	public static int countNumberOfCiphers(String str)
	{
		//  counts the number of ciphers in
		//  a public key or encrypted message
		//
		//  duplicate keys and keys that are empty
		//  or invalid are not counted
		//
		//  Note that this method returns the number of valid
		//  or enabled ciphers, but the number of keys used
		//  to generate the secret key agreement could be
		//  higher because the encrypt methods will try to
		//  generate a matching public key even for ciphers
		//  that are commented or disabled
		
		
		//  Verify that the string is a valid pub-
		//  lic key or a valid encrypted message
		
		str = str.trim();
		
		String delimiter = "-";
		
		if (str.contains(Convert.base16Separator))
		
		    delimiter = Convert.base16Separator;
		
		else if (str.contains("\n\n")) delimiter = "\n\n";
		
		if (!isValidKey(str) && !isEncrypted(str)) return 0;
		
		String[] tokens = str.split(delimiter);
		
		if (tokens.length > 64) return 0;
		
		int t = tokens.length;
		
		int numberofciphers = 0;
		
		ArrayList<String> publickeys
		
		    = new ArrayList<String>();
		
		for (String token : tokens)
		{
			token = token.trim();
			
			if (isValidKeySize(token.length()))
			
			if (!publickeys.contains(token))
			{
				publickeys.add(token);
				
				numberofciphers++;
			}
		}
		
		return numberofciphers;
	}
	
	
	
	
	public static boolean isEncrypted(String document)
	{
	
		//  verifies that a message
		//  is encrypted in the form
		//
		//  one-time public key z1
		//
		//  one-time public key z2
		//
		//  one-time public key z3
		//
		//  one-time public key z4
		//
		//    ...    ...    ...
		//
		//  one-time public key zn
		//
		//  k' = k (+) e[]  (optional)
		//
		//  C = E(e[], P) or E(k, P)
		
		
		
		//  The lines are separated by two or more newlines
		
		String str = document.trim();
		
		String[] lines;
		
		if (str.contains(Convert.base16Separator))
		
		     lines = str.split(Convert.base16Separator);
		
		else lines = str.split("\n{2,}");
		
		
		//  Remove any partitioning
		
		for (int i = 0; i < lines.length; i++)
		
		    lines[i] = lines[i] .replaceAll("\n", "");
		
		
		if (lines.length < 2) return false;
		
		for (int i = 0; i < lines.length -1; i++)
		
		    if (!Number.isDigitString(lines[i].trim(), 16))
		
			return false;
		
		
		//  The last line must be in base 64 (not base 16)
		
		String lastline = lines[lines.length -1].trim();
		
		
		//  The last line has to be a multiple of 4 6-bit chars or 24 bits
		//
		//  Truncate the last line for partial ciphertext decryption
		
		while ((lastline.length() % 4) != 0) lastline =
		
		    lastline.substring(0, lastline.length() -1);
		
		
		if (!Number.isBase64(lastline)
		  || Number.isBase16(lastline))
		
			return false;
		
		//  Verify that the cipherdata is random
		
		byte[] cipherdata = Convert
		
		    .base64ToByteArray(lastline);
		
		if (!Cipher.isRandom(cipherdata))
		
		    return false;
		
		return true;
	}
	
	
	
	
	public static String hashPublicKey(PublicKey[] publickeys)
	{
		//  computes the hash of each public key and xors the hashes
		
		//  Convert the PublicKey array to a String array
		
		String[] keys = new String[publickeys.length];
		
		for (int i = 0; i < keys.length; i++)
		
		    keys[i] = publickeys[i].toString();
		
		return hashPublicKey(keys);
	}
	
	
	
	public static String hashPublicKey(String[] keys)
	{
		//  computes the hash of each public key and xors the hashes
		
		byte[] hash = new byte[32];
		
		for (String key : keys)
		{
			byte[] bytes = key.trim().getBytes();
			
			byte[] hash1 = Cipher.hash(bytes);
			
			hash = Math.xor(hash, hash1);
		}
		
		return new String(Convert
		
		    .byte256ArrayToByte16Array(hash))
		
			.substring(0, 40);
	}
	
	
	
	public static String hashPublicKey(String text)
	{
		//  computes the hash of each public key and xors the hashes
		
		text = text.trim() .replaceAll("[ \t]", "");
		
		//  Split the text into tokens separated by \n\n
		
		String[] tokens = text.split("\n{2,}");
		
		for (String token : tokens)
		{
			if (token.contains("----")) continue;
			if (token.contains("@")) continue;
			
			if (token.contains(keydelimiter)
			 || token.contains(Convert.base16Separator)
			
			 || Number.isBase16(token.replaceAll("\n", "")))
			
			    text = token;
		}
		
		String delimiter = keydelimiter;
		
		if (text.contains(Convert.base16Separator))
		
		    delimiter = Convert.base16Separator;
		
		
		//  Use the delimiter to split the text
		
		tokens = text .split(delimiter);
		
		
		//  For each token remove the single newlines \n
		
		for (int i = 0; i < tokens.length; i++)
		
		    tokens[i] = tokens[i] .replaceAll("\n", "");
		
		
		//  Save the tokens that are hex strings
		
		ArrayList<String> keylist = new ArrayList<String>();
		
		for (String token : tokens)
		
		    if (Number.isBase16(token))
		
			keylist.add(token);
		
		String[] keys = new String[keylist.size()];
		
		keylist.toArray(keys);
		
		return hashPublicKey(keys);
	}
	
	
	
	public static boolean isPublicKeyDocument(String publickey)
	{
		if ((publickey == null) || publickey.isEmpty()) return false;
		
		publickey = publickey .replaceAll("\t", "") .trim();
		
		String[] tokens = publickey.split("\n{2,}");
		
		if (!tokens[0]               .contains("----")
		 || !tokens[tokens.length-1] .contains("----"))
		
		    return false;
		
		if ((tokens.length < 3) || (tokens.length > 4))
		
		    return false;
		
		//  Read the composite public key
		
		String compositekey = tokens[tokens.length -2];
		
		compositekey = compositekey.replaceAll("\n", "");
		
		//  Split the composite key into public keys
		
		String delimiter = "-";
		
		String[] publickeys = compositekey.split(delimiter);
		
		int len = publickeys.length;
		
		return isValidKey(publickeys);
	}
	
	
	
	public static boolean isValidKey(String publickey)
	{
		//  verifies that the composite public key is valid
		
		publickey = publickey.replaceAll("[\n\t ]", "");
		
		if (!Number.isDigitString(publickey, 16)) return false;
		
		String[] publickeys = splitKeys(publickey);
		
		return isValidKey(publickeys);
	}
	
	
	
	private static boolean isValidKey(String[] publickeys)
	{
		//  verifies that at least a few keys are valid
		
		//  the number of public keys in another user's public key
		//  could exceed the number of public keys in the public key
		//  class because other users may enable a large cipher or
		//  may have a newer version of the software that contains
		//  additional ciphers.
		
		final int minkeys = 4;
		
		int validkeys = 0;
		
		for (String publickey : publickeys)
		{
			int length = publickey.length();
			
			if (isValidKeySize(length)) validkeys++;
		}
		
		if (validkeys < minkeys) return false;
		
		//  Verify that no two public keys have the same size
		
		int[] array = new int[publickeys.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = publickeys[i].trim().length();
		
		int[][] int_freq = Math.sortAndCollate(array);
		
		for (int i = 0; i < int_freq.length; i++)
		
		    if (int_freq[i][1] != 1) return false;
		
		return true;
	}
	
	
	public static boolean isValidKeySize(int size)
	{
		//  verifies that a public key size is valid
		
		for (int size1 : PublicKey.size)
		
		     if (size1 == size) return true;
		
		return false;
	}
	
	
	public static String[] parseKey(String str)
	{
	
		//  parses public key documents and client / server public keys
		
		//  Public key documents are delimited by newline chars and client
		//  / server public keys are delimited by the base-16 separator.
		
		if (str == null)  return null;
		
		Scanner sc = new Scanner(str);
		
		for (int i = 0, n = 0;  ; i++)
		{
			if (!sc.hasNextLine()) break;
			
			if (sc.nextLine().contains("------")) n++;
			
			if (n > 2) return null;
		}
		
		
		str = str.trim().replaceAll("[\t ]", "");
		
		String publickey = "", email = "";
		
		
		//  Create an array of strings
		
		//  Each string can have multiple lines separated by new-
		//  line chars or the base-16 separator 0123456789abcdef
		
		
		//  Remove single newlines but not double newlines
		
		str = str .replaceAll("\n\n", "  ")
		
		   .replaceAll("\n", "") .replaceAll("  ", "\n\n");
		
		String[] array;
		
		if (str.contains(Convert.base16Separator))
		
		      array = str.split(Convert.base16Separator);
		else  array = str.split("\n{2,}");
		
		
		int count = 0;
		
		
		for (String lines : array)
		{
			sc = new Scanner(lines);
			
			ArrayList<String> list = new ArrayList<String>();
			
			while (sc.hasNext())
			{
				String token = sc.nextLine().trim();
				
				if (token.isEmpty()) continue;
				
				if (token.contains("@"))
				{
					email = token;
					
					list = new ArrayList<String>();
				}
				
				else
				{	String[] tokens = token.split(keydelimiter);
					
					for (String token1 : tokens)
					
					    if (Number.isDigitString(token1, 16))
					
						list.add(token1);
				}
				
				if ((list.size() > 0) &&
				
				    token.contains("----"))  break;
			}
			
			for (int i = 0; i < list.size(); i++)
			
			    if (isValidKeySize(list.get(i).length()))
			
				publickey += (list.get(i) + Convert.base16Separator);
		}
		
		if (publickey.endsWith(Convert.base16Separator))
		
		    publickey = publickey .substring(0, publickey.length()
		
			- Convert.base16Separator.length());
		
		if (publickey.isEmpty()) return null;
		
		if (email.isEmpty())  email = hashPublicKey(
		
		    publickey).substring(0, 16);
		
		return new String[] { email, publickey };
	}
	
	
	
	public static String joinKeys(PublicKey[] publickeys)
	{
		//  joins an array of public keys
		
		String[] keys = new String[publickeys.length];
		
		for (int i = 0; i < keys.length; i++)
		
		    keys[i] = publickeys[i].toString();
		
		return joinKeys(keys);
	}
	
	
	public static String joinKeys(String[] publickeys)
	{
		//  joins an array of key strings
		
		return joinKeys(publickeys, Convert.base16Separator);
	}
	
	
	public static String joinKeys(String[] publickeys, String delimiter)
	{
		//  joins an array of key strings
		
		String str = "";
		
		for (int i = 0; i < publickeys.length; i++)
		{
			str += publickeys[i].toString();
			
			if (i < publickeys.length -1)
			
			    str += delimiter;
		}
		
		return str;
	}
	
	
	public static String[] splitKeys(String publickey)
	{
		//  splits a composite key into an array of strings
		
		//  Public keys can be concatenated
		//  using newlines or base-16 separators
		
		publickey = publickey.trim();
		
		if (!Number.isDigitString(publickey
		
		    .replaceAll("[-\n\t ]", ""), 16))
		
			throw new IllegalArgumentException(
			
			    "public key == " + publickey);
		
		String[] publickeys;  String delimiter;
		
		if (publickey.contains(Convert.base16Separator))
		
		    delimiter = Convert.base16Separator;
		
		else if (publickey.contains("\n\n"))
		
		    delimiter = "\n{2,}";
		
		else delimiter = "-";
		
		publickeys = publickey.split(delimiter);
		
		return publickeys;
	}
	
	
	
	
	
	//  The encryptMessage and decryptMessage methods
	//
	//  create a new thread for each public key cipher
	
	
	
	public static String decrypt(String str, String passphrase)
	{
		//  decrypts an encrypted message block
		
		byte[] SK = Cipher.passphraseToKey(passphrase);
		
		return decrypt(str, SK);
	}
	
	
	
	public static String decrypt(String str, byte[] SK)
	{
	
		//  decrypts an encrypted message block
		
		//  returns null if there is nothing to decrypt, or returns
		//  an empty string if the ciphertext does not decrypt
		
		
		//  Remove the tabs
		
		str = str.trim().replaceAll("\t", "");
		
		
		//  Parse the message
		
		String[] tokens = null;
		
		if (str.contains("-")) tokens = str.split("-");
		
		else if (str.contains("\n\n")) tokens = str.split("\n\n");
		
		else if (str.contains(Convert.base16Separator))
		
		    tokens = str.split(Convert.base16Separator);
		
		else return null;
		
		
		//  Remove any partitioning
		
		for (int i = 0; i < tokens.length; i++)
		
		    tokens[i] = tokens[i].replaceAll("\n", "");
		
		
		//  Read the ciphertext
		
		String ciphertext = tokens[tokens.length -1] .trim();
		
		if ((ciphertext == null) || ciphertext.isEmpty()) return null;
		
		
		//  Verify that the ciphertext is in base 64
		//
		//  If the ciphertext length is not a multiple of 4,
		//  truncate the text to make it a multiple of 4 so
		//  the message can be partially decrypted
		
		if (!Number.isBase64(ciphertext))
		
		    while ((ciphertext.length() % 4) != 0)
		
			ciphertext = ciphertext.substring(
			
			    0, ciphertext.length() - 1);
		
		if (!Number.isBase64(ciphertext)) return null;
		
		
		//  Decrypt the auto / message key k = H(m)
		
		byte[] messagekey = decryptMessageKey(str, SK);
		
		if (messagekey == null) return "";
		
		
		//  Make sure the ciphertext is at least 32 bytes
		
		if (ciphertext.length() < 32) return "";
		
		
		//  Convert the base-64 ciphertext to cipherdata
		
		byte[] cipherdata = Convert.base64ToByteArray(ciphertext);
		
		
		//  Truncate the cipherdata if not a multiple of 32
		
		if ((cipherdata.length % 32) != 0)
		
		     cipherdata = Arrays.copyOfRange(cipherdata,
		
			0, cipherdata.length - (cipherdata.length % 32));
		
		
		//  Use the decrypted message key to decrypt the ciphertext
		
		byte[] plaindata = Cipher.decrypt(cipherdata, messagekey);
		
		
		//  Verify that the message decrypted correctly
		
		if (plaindata == null) return "";
		
		
		//  Convert the plaindata to plaintext
		
		String plaintext = new String(plaindata);
		
		
		//  Verify that the text is valid
		
		String teststr = new String(plaindata);
		
		char[] charray = teststr.toCharArray();
		
		boolean size8  = false;
		boolean size16 = false;
		
		for (char c : charray)
		{
			if (((int) c) >  0xff) size16 = true;
			if (((int) c) <= 0xff) size8  = true;
		}
		
		if (size8 && size16) return "";
		
		
		if (!Cipher.isEncrypted(plaintext.getBytes()))
		
		     return plaintext;
		
		else return new String("");
	}
	
	
	
	
	
	//  These PublicKey methods can decrypt the message key, use the key
	//  to decrypt the partial ciphertext to read the subject, from address,
	//  and first few lines of the message, and then save the message key so
	//  the caller can reuse the key to decrypt the message if the user clicks
	//  on the message / subject line to read the message.
	
	
	//  The decryptMessageKey() method is the first half of the decrypt()
	//  method. Programs can use the following code to decrypt partial
	//  ciphertext messages.
	//
	//  byte[] staticprivatekey = ...
	//
	//  byte[] messagekey = PublicKey
	//
	//     .decryptMessageKey(ciphertext, staticprivatekey);
	//
	//  if (messagekey != null) plaintext = PublicKey
	//
	//     .decryptCiphertext(ciphertext, messagekey);
	
	
	
	
	public static byte[] decryptMessageKey(String str, byte[] SK)
	{
	
		//  Public key decryption
		
		//  This method decrypts the auto key k = H(m) or any
		//  key used to encrypt the plaintext / ciphertext
		
		//  This method returns null if the key is not decryptable
		
		
		//  Remove the tabs
		
		str = str.trim().replaceAll("\t", "");
		
		
		//  Parse the message
		
		String[] tokens = null;
		
		if (str.contains("-")) tokens = str.split("-");
		
		else if (str.contains("\n\n")) tokens = str.split("\n\n");
		
		else if (str.contains(Convert.base16Separator))
		
		   tokens = str.split(Convert.base16Separator);
		
		else return null;
		
		
		//  Remove any partitioning
		
		for (int i = 0; i < tokens.length; i++)
		
		    tokens[i] = tokens[i].replaceAll("\n", "");
		
		
		//  Read the ciphertext and verify that text is in base 64
		
		String ciphertext = tokens[tokens.length -1] .trim();
		
		//  Verify that the ciphertext is in base 64
		
		//  If the ciphertext length is not a multiple of 4,
		//  truncate the text to make it a multiple of 4 so
		//  the message can be partially decrypted
		
		if (!Number.isBase64(ciphertext))
		
		    while ((ciphertext.length() % 4) != 0)
		
			ciphertext = ciphertext.substring(
			
			    0, ciphertext.length() - 1);
		
		if (!Number.isBase64(ciphertext)) return null;
		
		
		//  Read the last prepended key and test if the key
		//  is an encrypted message key
		//
		//  The encrypted message key should have a pattern
		//  such as repeating the first 16 digits at the end
		//  of the encrypted message key so that if the size
		//  of the last cipher has the same number of digits,
		//  the method doesn't read the cipher as an encrypted
		//  encryption key because then the message will not
		//  decrypt correctly. Other patterns and tests could
		//  be added in future versions of the software.
		
		String encryptedmessagekey = null;
		
		String lastkey = tokens[tokens.length -2];
		
		if ((lastkey.length() >= 64) && Number.isBase16(lastkey))
		{
			int l = lastkey.length();
			
			String substr1 = lastkey.substring(0, 16);
			String substr2 = lastkey.substring(l -16);
			
			if (substr1.equals(substr2))
			
			    encryptedmessagekey =
			
				lastkey.substring(0, l-16);
		}
		
		//  Verify the one-time public keys
		
		int numberofkeys;
		
		if (encryptedmessagekey != null)
		
		     numberofkeys = tokens.length -2;
		else numberofkeys = tokens.length -1;
		
		
		byte[] messagekey = null;
		
		ArrayList<String> onetimepublickeylist = new ArrayList<String>();
		
		for (int i = 0; i < numberofkeys; i++)
		
		    if (isValidKeySize(tokens[i].length()))
		
		        onetimepublickeylist.add(tokens[i]);
		
		if (onetimepublickeylist.isEmpty()) return null;
		
		
		//  =============================================
		
		
		//  Compute the one-time composite secret key
		//
		//  e[] == the sum of all secret keys
		
		//  Use a thread array to generate the public and secret keys
		
		int numberofciphers = onetimepublickeylist.size();
		
		Number[] e = new Number[numberofciphers];
		
		Thread[] tarray = new Thread[numberofciphers];
		
		for (int i = 0; i < tarray.length; i++)
		{
			int i1 = i;
			
			int size = onetimepublickeylist.get(i).length();
			
			int type = receive_decrypt; // recipient / decryption
			
			String onetimepublickey = onetimepublickeylist.get(i);
			
			byte[] SK1 = SK;
			
			tarray[i] = new Thread(() ->
			{
				PublicKey publickey = new PublicKey(
				
				    SK1, onetimepublickey, size);
				
				Number secretkey = publickey
				
				    .generateSecretKey(onetimepublickey, type);
				
				e[i1] = secretkey;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		//  Add the secret keys to create the composite secret key
		
		Number compositekey = new Number(e[0]);
		
		for (int i = 1; i < tarray.length; i++)
		
		    compositekey = compositekey .xor(e[i]);
		
		
		//  =============================================
		
		
		//  Use the one-time secret e[] to decrypt the encrypted message key
		
		//  the encrypted messagekey == the messagekey + the compositekey
		//  the messagekey == the encrypted messagekey - the compositekey
		
		if (encryptedmessagekey != null) //  use the decrypted key k = H(m) or rand256
		
		    messagekey = new Number(encryptedmessagekey, 16)
		
			.xor(compositekey) .toByteArray(32);
		
		else // if (encryptedmessagekey == null) use the composite secret key
		
		    messagekey = compositekey .toByteArray(32);
		
		//  Return the decrypted message key or the composite key
		
		return messagekey;
	}
	
	
	
	//  This method is faster for decrypting multiple messages
	//  because the user's public key only has to be computed once
	
	public static byte[] decryptMessageKey(String str, PublicKey[] publickeys)
	{
	
		//  Public key decryption
		
		//  This method decrypts the auto key k = H(m) or any random
		//  key that was used to encrypt the plaintext / ciphertext
		
		//  This method returns null if the message key is not decryptable
		
		
		//  Remove the tabs
		
		str = str.trim().replaceAll("\t", "");
		
		
		//  Parse the message
		
		String[] tokens = null;
		
		if (str.contains("-")) tokens = str.split("-");
		
		else if (str.contains("\n\n")) tokens = str.split("\n\n");
		
		else if (str.contains(Convert.base16Separator))
		
		   tokens = str.split(Convert.base16Separator);
		
		else return null;
		
		
		//  Remove any partitioning
		
		for (int i = 0; i < tokens.length; i++)
		
		    tokens[i] = tokens[i].replaceAll("\n", "");
		
		
		//  Read the ciphertext and verify that text is in base 64
		
		String ciphertext = tokens[tokens.length -1] .trim();
		
		if (!Number.isBase64(ciphertext))
		
		    while ((ciphertext.length() % 4) != 0)
		
			ciphertext = ciphertext.substring(
			
			    0, ciphertext.length() - 1);
		
		if (!Number.isBase64(ciphertext)) return null;
		
		
		//  Read the last prepended key and test if the key
		//  is an encrypted message key
		//
		//  The encrypted message key should have a pattern
		//  such as repeating the first 16 digits at the end
		//  of the encrypted message key so that if the size
		//  of the last cipher has the same number of digits,
		//  the method doesn't read the cipher as an encrypted
		//  encryption key because then the message will not
		//  decrypt correctly. Other patterns and tests could
		//  be added in future versions of the software.
		
		String encryptedmessagekey = null;
		
		String lastkey = tokens[tokens.length -2];
		
		if ((lastkey.length() >= 64) && Number.isBase16(lastkey))
		{
			int l = lastkey.length();
			
			String substr1 = lastkey.substring(0, 16);
			String substr2 = lastkey.substring(l -16);
			
			if (substr1.equals(substr2))
			
			    encryptedmessagekey =
			
				lastkey.substring(0, l-16);
		}
		
		
		//  Verify the one-time public keys
		
		int numberofkeys;
		
		if (encryptedmessagekey != null)
		
		     numberofkeys = tokens.length -2;
		else numberofkeys = tokens.length -1;
		
		
		byte[] messagekey = null;
		
		ArrayList<String> onetimepublickeylist = new ArrayList<String>();
		
		for (int i = 0; i < numberofkeys; i++)
		
		    if (isValidKeySize(tokens[i].length()))
		
			onetimepublickeylist.add(tokens[i]);
		
		if (onetimepublickeylist.isEmpty()) return null;
		
		
		//  =============================================
		
		
		//  Compute the one-time composite secret key
		//
		//  e[] == the sum of all secret keys
		
		//  Use a thread array to generate the public and secret keys
		
		int numberofciphers = onetimepublickeylist.size();
		
		Number[] e = new Number[numberofciphers];
		
		Thread[] tarray = new Thread[numberofciphers];
		
		for (int i = 0; i < tarray.length; i++)
		{
			int i1 = i;
			
			int size = onetimepublickeylist.get(i).length();
			
			int type = receive_decrypt; // recipient / decryption
			
			String onetimepublickey = onetimepublickeylist.get(i);
			
			tarray[i] = new Thread(() ->
			{
				//  Find the user's corresponding public key
				
				PublicKey publickey = null;
				
				for (PublicKey publickey1 : publickeys)
				
				    if (publickey1.toString().length() == size)
				
					publickey = publickey1;
				
				Number secretkey = publickey
				
				   .generateSecretKey(onetimepublickey, type);
				
				e[i1] = secretkey;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		//  Add the secret keys to create the composite secret key
		
		Number compositekey = new Number(e[0]);
		
		for (int i = 1; i < tarray.length; i++)
		
		    compositekey = compositekey .xor(e[i]);
		
		
		//  =============================================
		
		
		//  Use the one-time secret e[] to decrypt the encrypted message key
		
		//  the encrypted messagekey == the messagekey + the compositekey
		//  the messagekey == the encrypted messagekey - the compositekey
		
		if (encryptedmessagekey != null) //  use the decrypted key k = H(m) or rand256
		
		    messagekey = new Number(encryptedmessagekey, 16)
		
			.xor(compositekey) .toByteArray(32);
		
		else // if (encryptedmessagekey == null) use the composite secret key
		
		    messagekey = compositekey .toByteArray(32);
		
		//  Return the decrypted message key or the composite key
		
		return messagekey;
	}
	
	
	
	
	public static String decryptCiphertext(String str, byte[] messagekey)
	{
	
		//  Public key decryption
		
		//  This method decrypts an encrypted message using the decrypted messagekey
		
		//  This method returns null if there is nothing to decrypt, or
		//  it returns an empty string if the ciphertext does not decrypt.
		
		
		str = new String(str).trim();
		
		str = str.replaceAll("\t", "");
		
		
		//  Parse the message
		
		String[] tokens = null;
		
		if (str.contains("-")) tokens = str.split("-");
		
		else if (str.contains("\n\n")) tokens = str.split("\n\n");
		
		else if (str.contains(Convert.base16Separator))
		
		    tokens = str.split(Convert.base16Separator);
		
		else return null;
		
		
		for (int i = 0; i < tokens.length; i++)
		
		    tokens[i] = tokens[i].replaceAll("\n", "");
		
		
		//  Read the ciphertext and verify that text is in base 64
		
		String ciphertext = tokens[tokens.length -1] .trim();
		
		if (!Number.isBase64(ciphertext))
		
		    while ((ciphertext.length() % 4) != 0)
		
			ciphertext = ciphertext.substring(
			
			    0, ciphertext.length() - 1);
		
		if (!Number.isBase64(ciphertext)) return null;
		
		
		//  Use the message key to decrypt the ciphertext
		
		
		//  Make sure the ciphertext is at least 32 bytes
		
		if (ciphertext.length() < 32) return "";
		
		
		//  Convert the base-64 ciphertext to cipherdata
		
		byte[] cipherdata = Convert.base64ToByteArray(ciphertext);
		
		
		//  Truncate the cipherdata if not a multiple of 32
		
		if ((cipherdata.length % 32) != 0)
		
		     cipherdata = Arrays.copyOfRange(cipherdata,
		
			0, cipherdata.length - (cipherdata.length % 32));
		
		
		//  Use the decrypted message key to decrypt the ciphertext
		
		byte[] plaindata = Cipher.decrypt(cipherdata, messagekey);
		
		
		//  Verify that the message decrypted correctly
		
		if (plaindata == null)  return "";
		
		
		//  Convert the plaindata to plaintext
		
		String plaintext = new String(plaindata);
		
		
		//  Verify that the text is valid after decrypting
		
		String teststr = plaintext;
		
		char[] charray = teststr.toCharArray();
		
		boolean size8  = false;
		boolean size16 = false;
		
		for (char c : charray)
		{
			if (((int) c) >  0xff) size16 = true;
			if (((int) c) <= 0xff) size8  = true;
		}
		
		if (size8 && size16) return "";
		
		if (plaintext.isEmpty()) return "";
		
		
		if (!Cipher.isEncrypted(plaintext.getBytes()))
		
		     return plaintext;
		
		else return new String("");
	}
	
	
	
	public static String encrypt(String message, String publickey)
	{
		if (!isValidKey(publickey)) throw
		
		    new IllegalArgumentException();
		
		String[] publickeys = splitKeys(publickey);
		
		return encrypt(message, publickeys);
	}
	
	
	public static String encrypt(String message, String[] y)
	{
		return encrypt(message, y, null);
	}
	
	
	
	
	//  The public key encrypt method can use a random key + H(M) or the public key agreement e
	//  for message encryption. The default setting uses the public key agreement or composite
	//  secret key instead of a random key to parametrize the private key cipher. A one-time
	//  random encryption key would be redundant because the public key encrypt method chooses
	//  a random number + H(M) for the one-time private key to generate the matching one-time
	//  public key which generates the random composite secret key. The plaintext is padded
	//  with several bytes to verify that the secret key or public key agreement is correct.
	
	
	public static String encrypt(String message, String[] y, PublicKey[] onetimepublickeys)
	{
		return encrypt(message, y, onetimepublickeys, false);
	}
	
	
	public static String encrypt(
	
	    String message, String[] y, PublicKey[] onetimepublickeys, boolean randkey)
	{
		//  encrypts a message to the recipient's public key y and appends
		//  a random number of digits to hide the size of the message
		
		//  String[] y is the recipient's array of public keys
		
		//  PublicKey[] onetimepublickeys is the sender's one-time public key
		
		//  if (randkey == true)  the method generates a random encryption key and
		//  appends the encrypted encryption key to the document; this option is used
		//  if the sender is using a static public key instead of a one-time public
		//  key. The only reason for a sender to use a static public key is if the
		//  receiver has to verify the sender's key or if the key agreement is used
		//  as a password to log in to an account.
		//
		//  if (randkey == false) the method uses the public key agreement as the
		//  encryption key; this option is used if the sender is using a random one-
		//  time public key. It would be redundant for the method to create and ap-
		//  pend a random encryption key for a one-time public key since the public
		//  key agreement can be used as a one-time encryption key.
		
		
		
		//  Generate a matching one-time public key if the caller doesn't provide one
		
		if (onetimepublickeys == null)
		{
			//  Choose a one-time private key k = hash(x, m, r, ...)
			
			String randstr = Number.random(64, 16) .toString(16);
			
			byte[] onetimeprivatekey = Cipher.hash(
			
			    (message + randstr) .getBytes());
			
			//  Generate a matching one-time public key
			
			onetimepublickeys = generateMatchingPublicKeys(
			
			    onetimeprivatekey, y);
		}
		
		
		
		//  Compute an array of one-time public keys
		//  and a composite one-time secret key
		
		String[] z = new String[y.length];
		Number[] e = new Number[y.length];
		
		Thread[] tarray = new Thread[y.length];
		
		for (int i = 0; i < tarray.length; i++)
		{
			int j = i;
			
			int size = y[j].trim().length();
			
			int type = send_encrypt; // sender / encryption
			
			PublicKey onetimepublickey = onetimepublickeys[j];
			
			tarray[i] = new Thread(() ->
			{
				z[j] = onetimepublickey.toString();
				
				e[j] = onetimepublickey
				
				   .generateSecretKey(y[j], type);
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		//  Add the secret keys to create the composite secret key
		
		Number compositekey = new Number(e[0]);
		
		for (int i = 1; i < tarray.length; i++)
		
		    compositekey = compositekey .xor(e[i]);
		
		
		//  If the sender's public key is a one-time public key that uses a random
		//  private key, then the method can use the secret composite key agreement
		//  to encrypt the message instead of generating a one-time / random encryp-
		//  tion key, encrypting the encryption key by adding the composite key, and
		//  appending the encrypted encryption key to the one-time public keys.
		
		
		//  Use the composite public key agreement as the secret encryption key
		
		byte[] messagekey = compositekey.toByteArray(32);
		
		String plaintext = new String(message);
		
		
		//  Convert the plaintext to plaindata
		
		byte[] plaindata = Convert.charArrayToByteArray(
		
			plaintext.toCharArray());
		
		
		
		//  Pad the front of the plaindata to a multiple of 32 bytes or else
		//  the Cipher encrypt method will pad the front or back of the data
		//  depending on the implementation which could change. The Cipher en-
		//  crypt method only pads the data if the data is not already padded.
		
		
		//  The plaindata is padded to a multiple of 32 bytes or 256 bits so
		//  that any private key cipher can encrypt and decrypt the message.
		//
		//  The length of the padding is random so that if the same message is
		//  sent twice or sent to more than one recipient it will not encrypt
		//  to the same size.
		
		//  Use the System nano time to initialize the Math rng
		
		Math.initRng(System.nanoTime());
		
		double multiplier = 0;
		
		if      (plaintext.length() < (128*1024)) multiplier = 0.75; // < 2 x
		else if (plaintext.length() < (512*1024)) multiplier = 0.50; // < 3/2
		else                                      multiplier = 0.33; // < 4/3
		
		//  Use a random pad length < the size of the
		//  multiplier to hide the size of the message
		
		int textlength = plaintext.length();
		
		int padlength = 16 + (int) (textlength
		
		    * Math.random(1.0D) * multiplier);
		
		while (((textlength + padlength)
		
		    % 32) != 0) padlength++;
		
		
		
		//  Pad the plaindata using the random
		//  length to hide the size of the file
		
		boolean front = true;
		
		plaindata = Cipher.addPadding(
		
		    plaindata, front);
		
		
		
		if (randkey) // if randkey == true
		{
			//  If a random key is used instead of the secret composite key
			//  then the method will compute the encrypted encyption key k'
			//  = k (+) e[] where e[] is the secret composite key or public
			//  key agreement and append the encrypted key k' to the one-time
			//  public keys.
			//
			//  (A random key is not used because the public key agreement or
			//  shared secret key can be used as the one-time encryption key.
			//  If some programs require static public keys instead of one-time
			//  public keys because the key agreement is used to log in to an
			//  account or to verify the sender, then the sender would set rand-
			//  key = true and the method would append the encrypted encryption
			//  key k' = k (+) e[] so the static key agreement doesn't get used
			//  for encryption.)
			
			String randstr = Number.random(16, 16) .toString(16);
			
			//  Compute the message key = hash(plaintext);
			
			messagekey = Cipher.hash((plaintext + randstr) .getBytes());
		}
		
		
		//  Encrypt the plaindata using a private key cipher
		//  and verify that the cipherdata is decryptable
		
		int method = Cipher.encrypt_method_3;
		
		byte[] cipherdata = Cipher.encrypt(plaindata, messagekey, method);
		
		byte[] plaindata1 = Cipher.decrypt(cipherdata, messagekey);
		
		if (!Arrays.equals(plaindata1, Cipher.removePadding(plaindata)))
		
		try { throw new ArithmeticException(); }
		
		catch (ArithmeticException ex)
		{
			ex.printStackTrace();
			
			System.out.println(Arrays.toString(plaindata1));
			System.out.println(Arrays.toString(
			    Cipher.removePadding(plaindata)));
			
			return null;
		}
		
		
		//  Convert the cipherdata to ciphertext
		
		String ciphertext = Convert.byteArrayToBase64(cipherdata);
		
		
		
		//  Encrypt the message key k = H(m)
		//
		//  by xor-ing the composite key
		
		//  The encrypted message key is not used because the encrypt
		//  method uses a random / one-time public key for each message.
		//
		//  If no encrypted message key is appended, then the recipient
		//  uses the public key agreement or composite key as the message
		//  key to decrypt the message.
		
		String encryptedmessagekey = new Number(messagekey)
		
		    .xor(compositekey) .toString(64, 16);
		
		//  Append the first 16 digits to the end of the encrypted key
		//  so the decrypt method can identify the key as an encrypted
		//  message key instead of a prepended one-time public key
		
		String substr1 = encryptedmessagekey.substring(0, 16);
		
		encryptedmessagekey += substr1;
		
		
		//  Prepend the one-time public key and the encrypted message key
		//
		//  (Discard the message key k == hash(m) and the one-time secret
		//  key array e[] that was used to encrypt the message key)
		
		
		//  one-time public key z1
		//
		//  one-time public key z2
		//
		//  one-time public key z3
		//
		//  one-time public key z4
		//
		//    ...    ...    ...
		//
		//  one-time public key zn
		//
		//  k' = k (+) e[]  (optional)
		//
		//  C = E(e[], P) or E(k, P)
		
		
		StringBuilder sb = new StringBuilder();
		
		for (int i = 0; i < y.length; i++)
		{
			String s = z[i];
			
			if ((s != null) && !s.isEmpty())
			
			    sb.append(s);
			
			if (i < y.length -1)
			
			    sb.append("\n\n");
		}
		
		return sb.toString() + "\n\n" +
		
		    (!new Number(messagekey) .equals(compositekey) ?
		
		        (encryptedmessagekey + "\n\n") : "") + ciphertext;
	}
	
	
	
	
	
	public static PublicKey[] generateMatchingPublicKeys(
	
		byte[] privatekey, String[] receivedkey)
	{
		//  creates a matching one-time, transient or ephemeral
		//  public key using the ciphers in the static public key,
		//  even if some of the ciphers are commented or disabled;
		//
		//  for public key sizes that are not valid, the method will
		//  create a public key element that contains the empty string
		//  so that the generate secret key method will ignore the key.
		//
		//  This method is used by the encrypt method and by the SSL
		//  Socket class.
		//
		//  Because this method is used to generate a matching one-time
		//  public key (instead of generating a static public key), the
		//  PublicKey constructor requires the corresponding static key.
		//
		//  Note that the static key variable is only required for asym-
		//  metric public key ciphers such as the vector / cross product
		//  cipher, the Merkle-Hellman / knapsack cipher, and the factor-
		//  ization cipher. The other public key ciphers ignore the stat-
		//  ic key because the public keys are symmetrical or use commu-
		//  tative one-way functions instead of an invertible / one-way
		//  function.
		
		
		
		//  Make a list of the received key sizes
		
		int[] sizes = new int[receivedkey.length];
		
		for (int i = 0; i < sizes.length; i++)
		
		    sizes[i] = receivedkey[i].length();
		
		
		//  Create a thread for each cipher
		
		Thread[] tarray = new Thread[sizes.length];
		
		PublicKey[] publickeys = new PublicKey[sizes.length];
		
		for (int i = 0; i < tarray.length; i++)
		{
			int i1 = i;
			
			int size = sizes[i];
			
			String statickey = receivedkey[i];
			
			tarray[i] = new Thread(() ->
			{
				PublicKey publickey = new PublicKey(
				
				    privatekey, statickey, size); // static key required
				
				publickeys[i1] = publickey;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		return publickeys;
	}
	
	
	
	public static String[] generatePublicKey(
	
		String passphrase, String email, int numberofciphers)
	{
		//  converts a passphrase, email address, and number
		//  of ciphers to a static public key string array;
		
		if (numberofciphers > PublicKey.numberofciphers)
		    numberofciphers = PublicKey.numberofciphers;
		
		//  Hash the passphrase and address to generate the private key
		
		byte[] SK = Cipher.passphraseToKey(
		
		    passphrase.trim() + email.trim());
		
		//  Create a thread for each cipher
		
		Thread[] tarray = new Thread[numberofciphers];
		
		long[] computetime = new long[numberofciphers];
		
		String[] publickeys = new String[numberofciphers];
		
		for (int i = 0; i < tarray.length && i < PublicKey.size.length; i++)
		{
			int i1 = i;
			
			int size = PublicKey.size[i];
			
			tarray[i] = new Thread(() ->
			{
				long time1 = System.currentTimeMillis();
				
				PublicKey key = new PublicKey(SK, null, size);
				
				long time2 = System.currentTimeMillis();
				
				if ((key == null) || (key.toString() == null))
				
				    throw new ArithmeticException();
				
				publickeys[i1] = key.toString();
				
				computetime[i1] = time2 - time1;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		//  System.out.println("public key compute time (ms) == "
		//
		//      + Arrays.toString(computetime));
		
		return publickeys;
	}
	
	
	
	public static PublicKey[] generatePublicKey(byte[] secretkey, int numberofciphers)
	{
	
		//  converts a secret key and number of ciphers
		//  to an array of static public keys
		//
		//  (This method is used by the SSLServerSocket and SSLSocket classes.)
		
		if (numberofciphers > PublicKey.size.length)
		
		    throw new IllegalArgumentException();
		
		//  Create a thread for each cipher
		
		Thread[] tarray = new Thread[numberofciphers];
		
		PublicKey[] publickeys = new PublicKey[numberofciphers];
		
		for (int i = 0; i < tarray.length && i < PublicKey.size.length; i++)
		{
			int i1 = i;
			
			int size = PublicKey.size[i];
			
			tarray[i] = new Thread(() ->
			{
				PublicKey publickey = new PublicKey(secretkey, null, size);
				
				publickeys[i1] = publickey;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		return publickeys;
	}
	
	
	
	
	
	
	
	
	
	private static String keydelimiter = "-";
	
	
	public static String printPublicKey(
	
		String[] keys, String email, String title, int linewidth, int keyformat)
	{
		//  converts an array of public key strings and a
		//  partition size to a public key document that
		//  can be printed, copied, and pasted
		
		
		if (numberofciphers < 1)  return null;
		
		if (linewidth <= 0)  linewidth = 48;
		
		
		//  Partition the public key string
		
		String str = new String();
		
		if (keyformat == 0) // keydelimiter
		{
			for (int i = 0; i < keys.length; i++)
			{
				str += keys[i];
				
				if (i < keys.length - 1)
				
				    str += keydelimiter;
			}
			
			str = Convert.partition(str, "\n\t", linewidth);
			
			str += "\n\t\n\t";
		}
		
		if (keyformat == 1)
		{
			//  \n\n separator (no encoding)
			
			for (int i = 0; i < keys.length; i++)
			{
				str += Convert.partition(keys[i], "\n\t", linewidth);
				
				str += "\n\t\n\t";
			}
		}
		
		
		//  It may be redundant to label a public key if it already
		//  has an email address (and it makes the key look cluttered).
		//  If there is no address for the key then it can be labeled
		//  as a public key.
		
		
		String s;
		
		if ((email == null) || email.isBlank())
		{
			//  ---------------- Public Key ----------------
			
			s = "";  s += "\n\n\n";  s += "\t";
			
			int t = (linewidth - title.length()) / 2;
			
			for (int i = 1; i < t; i++)  s += '-';
			
			if ((title != null) && !title.isBlank())
			
			    s += " " + title + " ";
			
			else s += "--";
			
			for (int i = 1; i < t; i++)  s += '-';
			
			s += "\n\t\n\t";  // + s;
			
			//  --------------------------------------------
		}
		
		else
		{	//  -------------------------------------------
			//
			//  emailaddress@example.com
			
			s = "";  s += "\n\n\n";  s += "\t";
			
			for (int i = 0; i < linewidth; i++) s += '-';
			
			s += "\n\t\n\t";  // + s;
			
			//  --------------------------------------------
		}
		
		
		String emailaddress;
		
		if (((emailaddress = email) != null)
		
		   && !emailaddress.isBlank())
		{
			emailaddress = emailaddress.trim();
			
			s += emailaddress += "\n\t\n\t";
		}
		
		s += str;
		
		for (int i = 0; i < linewidth; i++) s += '-';
		
		s += "\n\n";
		
		return s;
	}
	
	
	
	
	
	
	
	
	
	
	
	//  Public key generation methods
	
	
	
	
	private void generate2x2Key(int digits)
	{
	
		if (digits == size64)
		{
		
			//  Matrix Diffie-Hellman cipher
			//
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			int matrices = 3, rows = 2, cols = rows;
			
			if ((digits % (rows*cols)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + rows*cols);
			
			int s = digits / rows / cols / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			
			//  Define the matrices
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*cols*s + (j+0)*s,
				k*rows*cols*s + i*cols*s + (j+1)*s), radix);
			
			Matrix A1 = new Matrix(elements[0]);
			Matrix A2 = new Matrix(elements[1]);
			Matrix B  = new Matrix(elements[2]);
			
			
			//  Reduce the size of x1, x2 to 2 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and( new Number(2).pow(p.bitCount()*2) .subtract(1) );
			x2 = x2 .and( new Number(2).pow(p.bitCount()*2) .subtract(1) );
			
			
			//  Compute A1^x1, A2^x2
			
			Matrix A1x1 = A1 .modPow(x1, p);
			Matrix A2x2 = A2 .modPow(x2, p);
			
			
			//  Compute the public key
			
			Matrix Y = A1x1 .multiply(B) .mod(p) .multiply(
			
			    A2x2 ) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y.toIntegerString(s, radix);
			
			this.publickey = y;
		}
		
		
		
		if (digits == size88)
		{
		
			//  Matrix Diffie-Hellman cipher (2-D multiplication)
			//
			//          A---X1           A---K1           Y---K1     Z---X1
			//   Y  =   |     ,   Z  =   |     ,   E  =   |      ==  |
			//          X2               K2               K2         X2
			
			
			int matrices = 1, rows = 2, cols = rows;
			
			if ((digits % (rows*cols)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + rows*cols);
			
			int s = digits / rows / cols / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			
			//  Define the matrices
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*cols*s + (j+0)*s,
				k*rows*cols*s + i*cols*s + (j+1)*s), radix);
			
			Matrix A = new Matrix(elements[0]);
			
			
			//  Define the private matrices
			
			Matrix X1 = new Matrix( new Number[][]
			
			    { { x[0], x[1] }, { x[1], x[0] } } ) .mod(p);
			
			Matrix X2 = new Matrix( new Number[][]
			
			    { { x[2], x[3] }, { x[3], x[2] } } ) .mod(p);
			
			
			//  Compute the static public key
			
			Matrix AX1 = A.multiply(X1) .mod(p);
			
			Matrix AX2 = A.rotate(1).multiply(X2).rotate(-1) .mod(p);
			
			//  Matrix Y1 = AX1.rotate(1).multiply(X2) .mod(p);
			
			Matrix Y2 = AX2.multiply(X1) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y2.toIntegerString(s, radix);
			
			this.publickey = y;
		}
		
		
		
		if (digits == size72)
		{
		
			//  Cube Diffie-Hellman cipher
			//
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			int cubes = 3, r1, r2, r3;
			
			r1 = r2 = r3 = 2;
			
			if ((digits % (r1*r2*r3)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + r1*r2*r3);
			
			int s = digits / r1 / r2 / r3 / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			
			//  Define the cubes
			
			Number[][][][] elements;
			
			elements = new Number[cubes][r1][r2][r3];
			
			for (int m = 0; m < cubes; m++)
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    elements[m][i][j][k] = new Number( pi16.substring(
			
				m*r1*r2*r3*s + i*r2*r3*s + j*r3*s + (k+0)*s,
				m*r1*r2*r3*s + i*r2*r3*s + j*r3*s + (k+1)*s), radix);
			
			Cube A1 = new Cube(elements[0]);
			Cube A2 = new Cube(elements[1]);
			Cube B  = new Cube(elements[2]);
			
			
			//  Reduce the size of x1, x2 to 4 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			x2 = x2 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			
			
			//  Compute A1^x1, A2^x2
			
			Cube A1x1 = A1 .modPow(x1, p);
			Cube A2x2 = A2 .modPow(x2, p);
			
			
			//  Compute the public key cube
			
			Cube Y = A1x1 .multiply(B) .mod(p)
			
			   .multiply( A2x2 ) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y .toIntegerString(s, radix);
			
			this.publickey = y;
		}
		
		
		
		
		if (digits == size96)
		{
		
			//  Tesseract Diffie-Hellman cipher
			//
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			int tesseracts = 3, r1, r2, r3, r4;
			
			r1 = r2 = r3 = r4 = 2;
			
			if ((digits % (r1*r2*r3*r4)) != 0)
			
			   System.out.println("Key size" +
			
			      " must be divisible by " + r1*r2*r3*r4);
			
			int s = digits / r1 / r2 / r3 / r4 / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			
			//  Define the tesseracts
			
			Number[][][][][] elements;
			
			elements = new Number[tesseracts][r1][r2][r3][r4];
			
			for (int m = 0; m < tesseracts; m++)
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    elements[m][i][j][k][l] = new Number( pi16.substring(
			
				m*r1*r2*r3*r4*s + i*r2*r3*r4*s + j*r3*r4*s + k*r4*s + (l+0)*s,
				m*r1*r2*r3*r4*s + i*r2*r3*r4*s + j*r3*r4*s + k*r4*s + (l+1)*s), radix);
			
			
			Tesseract A1 = new Tesseract(elements[0]);
			Tesseract A2 = new Tesseract(elements[1]);
			Tesseract B  = new Tesseract(elements[2]);
			
			
			//  Reduce the size of x1, x2 to 4 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			x2 = x2 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			
			
			//  Compute A1^x1, A2^x2
			
			Tesseract A1x1 = A1 .modPow(x1, p);
			Tesseract A2x2 = A2 .modPow(x2, p);
			
			
			//  Compute the public key tesseract
			
			Tesseract Y = A1x1 .multiply(B) .mod(p)
			
			   .multiply( A2x2 ) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y .toIntegerString(s, radix);
			
			this.publickey = y;
		}
		
		
		
		if (digits == size76)
		{
		
			//  Multivariate matrix discrete log cipher
			//
			//         -x' -1   x   1   x'
			//  Y  =  A   C   B   C   A
			//
			//  A, B, C are public matrices and
			//
			//  x and x' are private exponents
			
			
			int rows = 2, cols = rows, matrices = 3;
			
			int s = digits / rows / cols, radix = 16;
			
			
			//  Define the matrices
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*rows*s + (j+0)*s,
				k*rows*cols*s + i*rows*s + (j+1)*s), radix);
			
			Matrix A = new Matrix(elements[0]);
			Matrix B = new Matrix(elements[1]);
			Matrix C = new Matrix(elements[2]);
			
			//  System.out.println(A .modInverse(p) .toMatrixString(16));
			//  System.out.println(B .modInverse(p) .toMatrixString(16));
			
			
			//  Reduce the size of the private key to 2 log2 p
			
			for (int i = 0; i < x.length; i++)
			
			    x[i] = x[i] .and( new Number(2)
			
				.pow(p.bitCount() * 2) .subtract(1) );
			
			
			//  Compute the public key
			//
			//         -x' -1   x   1   x'
			//  Y  =  A   C   B   C   A
			
			Matrix Ax1 = A.modPow(x[1], p);
			Matrix Bx0 = B.modPow(x[0], p);
			
			Matrix invAx1 = Ax1.modInverse(p);
			Matrix invC   =   C.modInverse(p);
			
			
			Matrix Y = invAx1
			
			  .multiply( invC ) .mod(p)
			
			     .multiply( Bx0 ) .mod(p)
			
			        .multiply( C ) .mod(p)
			
			           .multiply( Ax1 ) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y.toIntegerString(s, radix);
			
			this.publickey = y;
		}
	}
	
	
	
	
	private void generate2x2x2Key(int digits)
	{
	
		if (digits == size112)
		{
		
			//  Multi-equation multivariate discrete log cipher
			//
			//               x1    x2                 x1
			//           | M1    M1   | | A   B | | M2   |
			//  Y  ==  x |   x1    x2 | |       | |   x2 |
			//           | M1    M1   | | B   C | | M2   |
			//
			//                 x1         x1      x2         x2
			//  Y1  ==  x0 ( M1  [ A ]  M2   +  M1  [ B ]  M2 )
			//
			//                 x1         x1      x2         x2
			//  Y2  ==  x0 ( M1  [ B ]  M2   +  M1  [ C ]  M2 )
			
			
			int rows = 2, cols = rows, equations = 2, matrices = 5;
			
			int s = digits / rows / cols / equations, radix = 16;
			
			
			//  Define the matrices A, B, C, M1, M2
			
			Number[][] a = new Number[matrices][rows*cols];
			
			for (int k = 0; k < matrices;  k++)
			for (int i = 0; i < rows*cols; i++)
			
			    a[k][i] = new Number( pi16.substring(
			
				k*rows*cols*s + s*(i+0),
				k*rows*cols*s + s*(i+1)), radix );
			
			Matrix A, B, C, M1, M2;
			
			A  = new Matrix(new Number[][] { { a[0][0], a[0][1] }, { a[0][2], a[0][3] } });
			B  = new Matrix(new Number[][] { { a[1][0], a[1][1] }, { a[1][2], a[1][3] } });
			C  = new Matrix(new Number[][] { { a[2][0], a[2][1] }, { a[2][2], a[2][3] } });
			M1 = new Matrix(new Number[][] { { a[3][0], a[3][1] }, { a[3][2], a[3][3] } });
			M2 = new Matrix(new Number[][] { { a[4][0], a[4][1] }, { a[4][2], a[4][3] } });
			
			
			//  Reduce the size of the private key to 2 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			x2 = x2 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			
			
			//  Compute the public key
			//
			//  Y1 = M1^x1 A M2^x1 + M1^x2 B M2^x2
			//  Y2 = M1^x1 B M2^x1 + M1^x2 C M2^x2
			
			Matrix M11 = M1 .modPow(x1, p),  M12 = M1 .modPow(x2, p);
			Matrix M21 = M2 .modPow(x1, p),  M22 = M2 .modPow(x2, p);
			
			Matrix Y1 = M11 .multiply(A) .multiply(M21) .add(
			            M12 .multiply(B) .multiply(M22) ) .multiply(x0) .mod(p);
			Matrix Y2 = M11 .multiply(B) .multiply(M21) .add(
				    M12 .multiply(C) .multiply(M22) ) .multiply(x0) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y1.toIntegerString(s, radix)
			         + Y2.toIntegerString(s, radix);
			
			this.publickey = y;
		}
	}
	
	
	
	
	private void generate3x3Key(int digits)
	{
	
		if (digits == size90)
		{
		
			//  Real / fractional number cipher
			//
			//  Y  =  X1  A  X2
			
			//  Fractional number ciphers don't use integer errors but
			//  they are inexact because the fractional digits greater
			//  than the number precision are discarded. This is the only
			//  non-discrete / non-integer cipher in the public key class.
			
			int matrices = 1, rows = 3, cols = rows, p = 10;
			
			if ((digits % (rows*cols)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + rows*cols);
			
			int s = digits / rows / cols / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			Number d = new Number(16).pow(s) .multiply(2);
			
			
			//  Define the matrix A
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*cols*s + (j+0)*s,
				k*rows*cols*s + i*cols*s + (j+1)*s), radix);
			
			Matrix A = new Matrix(elements[0]);
			
			
			//  Define the private matrices
			
			Number x0 = x[0], x1 = x[1];
			Number x2 = x[2], x3 = x[3];
			
			Number[] array_x1 = new Number[cols];
			Number[] array_x2 = new Number[cols];
			
			for (int i = 0; i < cols; i++)
			{
				array_x1[i] = x1.getDigits(i*s, (i+1)*s, 16);
				array_x2[i] = x2.getDigits(i*s, (i+1)*s, 16);
			}
			
			Matrix X1 = new Matrix(array_x1, 1);
			Matrix X2 = new Matrix(array_x2, 1);
			
			//  System.out.println(X1.toMatrixString(16));
			//  System.out.println(X2.toMatrixString(16));
			
			//  Convert the integers to fractional numbers
			
			A  = A  .setPrecision(p) .divide(d);
			X1 = X1 .setPrecision(p) .divide(d);
			X2 = X2 .setPrecision(p) .divide(d);
			
			
			//  Compute the public key
			//
			//  Y  =  X1  A  X2
			
			
			Matrix Y = X1 .multiply(A) .multiply(X2);
			
			//  System.out.println("Y == \n\n" + Y.toMatrixString(16));
			
			
			//  Remove the integer / fraction points
			//  (or hexadecimal points)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    Y.set( new Number( Y.get(i, j).toString(16)
			
				.replace(".", ""), 16), i, j);
			
			
			//  Convert the public key matrix to string
			
			String y = Y.toIntegerString(s, 16);
			
			//  System.out.println(y);
			
			this.publickey = y;
		}
		
		
		
		if (digits == size108)
		{
		
			//  Matrix Latin square cipher
			//
			//            x
			//   Y  =   A   X
			//            k
			//   Z  =   A   K
			//            k   x
			//   E  =   A   A   K  X
			
			
			int rows = 3, cols = rows;
			
			if ((digits % (rows*cols)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + rows*cols);
			
			int s = digits / rows / cols, radix = 16;
			
			
			//  Define the matrix A
			
			Number[][] elements = new Number[rows][cols];
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[i][j] = new Number( pi16.substring(
			
				i*rows*s + s*(j+0), i*rows*s + s*(j+1)), radix);
			
			Matrix A = new Matrix(elements);
			
			
			//  Define the private Latin square X and
			//                               x
			//  compute the public key Y = A   X
			
			Number n = new Number(radix).pow(s);
			
			for (int i = 1; i < x.length; i++) x[i] = x[i] .mod(n);
			
			Matrix X = new Matrix(new Number[] { x[1], x[2], x[3] }, 1) .mod(p);
			
			Matrix Y = A.modPow(x[0], p) .multiply(X) .mod(p);
			
			
			//  Convert the public key matrix to string
			
			String y = Y.toIntegerString(s,radix);
			
			this.publickey = y;
		}
	}
	
	
	
	private void generate64x64Key(int digits)
	{
	
		if (digits == size144)
		{
		
			//  Latin square discrete cipher
			//
			//  Y = X1 A X2
			//
			//  A is a public Latin square and X1
			//  and X2 are private Latin squares.
			//
			//  (non-exponential, non-linear, and non-modular)
			
			
			int rows = 64, cols = rows;
			
			int t = rows, bits = 9, radix = 16;
			
			String pidigits = pi2 .substring(0*rows, 1*rows);
			
			
			//  Define the matrix A
			
			Number[] array0 = new Number(pidigits, 2) .toArray(1, 2);
			
			Matrix A = new Matrix(array0, -1);
			
			
			//  Define the private Latin squares
			
			Number[] array1 = Arrays.copyOfRange(x[0].toArray(256, 2), 0, t);
			Number[] array2 = Arrays.copyOfRange(x[1].toArray(256, 2), 0, t);
			
			int[] x1 = new int[t], x2 = new int[t];
			
			for (int i = 0; i < t; i++) x1[i] = array1[i].intValue();
			for (int i = 0; i < t; i++) x2[i] = array2[i].intValue();
			
			//  Flip the private key bits until the key contains
			//  an equal number of 0 and 1 bits so the size of the
			//  elements does not exceed 10 bits.
			
			for (int i = 0; i < t; i++) if (Math.countOneBits(x1) != t/2) x1[i] ^= 1; else break;
			for (int i = 0; i < t; i++) if (Math.countOneBits(x2) != t/2) x2[i] ^= 1; else break;
			
			Matrix X1 = new Matrix(x1, +1);
			Matrix X2 = new Matrix(x2, +1);
			
			
			//  Compute the public key
			//
			//  Y  =  X1  A  X2
			
			//  Multiply the top row
			
			Matrix temp1 = X1 .multiply(A, 1);
			
			temp1 = new Matrix(temp1.getRow(0), -1);
			
			//  Multiply the top row
			
			Matrix temp2 = temp1 .multiply(X2, 1);
			
			temp2 = new Matrix(temp2.getRow(0), -1);
			
			Matrix Y = new Matrix(temp2);
			
			array0 = Y.getRow(0);
			
			
			//  Convert the public key matrix to string
			
			Number[] array = Y.getRow(0);
			
			Number r = new Number(2).pow(bits);
			
			String y = new Number(array, r).toString(16);
			
			
			//  Pad the string with zeros
			
			while (y.length() < digits)  y = "0" + y;
			
			this.publickey = y;
		}
	}
	
	
	
	private void generateMPDLKey(int digits)
	{
	
		//  Matrix polynomial discrete log cipher
		
		
		if (digits == size60)
		{
		
			if ((digits % 4) != 0) System.out.println(
			
			    "Key size must be divisible by 4");
			
			int s = digits / 4, radix = 16;
			
			int rows = 2, cols = rows, matrices = 3;
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*rows*s + (j+0)*s,
				k*rows*cols*s + i*rows*s + (j+1)*s), radix);
			
			Matrix A0 = new Matrix(elements[0]);
			Matrix B0 = new Matrix(elements[1]);
			Matrix C0 = new Matrix(elements[2]);
			
			Number x0 = new Number(x[0]).and(new Number(2)
			
			    .pow(128).subtract(1)); x0.setBit(127);
			
			//  Compute the public key matrix
			
			Matrix Y = Polynomial.modPow(A0, B0, C0, null, x0, p);
			
			//  Convert the public key matrix to a number string
			
			String y = Y.toIntegerString(s, radix);
			
			this.publickey = y;
		}
	}
	
	
	
	
	
	
	//  Polynomial matrix ciphers
	
	
	
	private void generatePolynomialKey(int digits)
	{
	
		if (digits == size56)
		{
		
			//  Polynomial matrix discrete log cipher
			//
			//           x1   x2   |           k1 x1   k1 x2
			//  Y1  =  A    B      |  E1  =  A       B
			//                     |
			//           x1   x2   |           k2 x1   k2 x2
			//  Y2  =  B    C      |  E2  =  B       C
			
			
			//  Define the public coefficients and exponents
			
			int p = 23, q = p - 1, t = q, s = 3, radix = 16;
			
			//  5 bits / term x 22 terms / equation x 2 equations
			//
			//  == 5 x 22 x 2 bits == 220 bits == 55 chars
			
			
			String pidigits = pi16 .substring(0, 256);
			
			int d = Math.log2(p) / 4; // digits per term
			
			int[][] a = new int[s][t];
			
			for (int i = 0; i < s; i++)
			for (int j = 0; j < t; j++)
			{
				String substring = pidigits .substring(
				
				    d*i*t + (j+0)*d, d*i*t + (j+1)*d);
				
				a[i][j] = new Number(substring, 16) .intValue();
			}
			
			
			//  Define the polynomials A, B, C
			
			int[][] A1 = new int[t][2];
			int[][] B1 = new int[t][2];
			int[][] C1 = new int[t][2];
			
			for (int i = 0; i < t; i++) { A1[i][0] = a[0][i];  A1[i][1] = i; }
			for (int i = 0; i < t; i++) { B1[i][0] = a[1][i];  B1[i][1] = i; }
			for (int i = 0; i < t; i++) { C1[i][0] = a[2][i];  C1[i][1] = i; }
			
			Polynomial A = new Polynomial(A1, p, q, t);
			Polynomial B = new Polynomial(B1, p, q, t);
			Polynomial C = new Polynomial(C1, p, q, t);
			
			//  Reduce the size of the private key
			
			x[0] = x[0] .and(new Number(2).pow(digits*2).subtract(1));
			x[1] = x[1] .and(new Number(2).pow(digits*2).subtract(1));
			
			int[] x1 = x[0].toIntArray();
			int[] x2 = x[1].toIntArray();
			
			
			//  Compute the public key
			
			Polynomial A2x1 = A.modPow(x1);
			Polynomial B2x2 = B.modPow(x2);
			Polynomial B2x1 = B.modPow(x1);
			Polynomial C2x2 = C.modPow(x2);
			
			Polynomial Y1 = A2x1.multiply(B2x2).add();
			Polynomial Y2 = B2x1.multiply(C2x2).add();
			
			
			//  Extract the coefficients and exponents
			
			int[] values = new int[2*t];
			
			for (int i = 0; i < t; i++)
			{
				int coefficient1 = Y1.get(i,0), exponent1 = Y1.get(i,1);
				int coefficient2 = Y2.get(i,0), exponent2 = Y2.get(i,1);
				
				if (exponent1 != i) throw new ArithmeticException();
				if (exponent2 != i) throw new ArithmeticException();
				
				int value1 = coefficient1;
				int value2 = coefficient2;
				
				values[0*t + i] = value1;
				values[1*t + i] = value2;
			}
			
			
			//  Pack the 5-bit coefficients into a number
			
			final int bits = 5;
			
			Number number = new Number(0);
			
			for (int i = 0; i < values.length; i++)
			
			    number = number .shiftLeft(32, bits) .add(values[i]) .trim();
			
			
			//  Verify that the values were stored correctly
			
			Number number1 = number;
			
			int[] values1 = new int[values.length];
			
			for (int i = 0; i < values1.length; i++)
			{
				values1[values1.length -1 -i] = number1 .and(
				
				    new Number(2).pow(bits).subtract(1) ) .intValue();
				
				number1 = number1 .shiftRight(bits) .trim();
			}
			
			if (!Arrays.equals(values, values1))
			{
				System.out.println(Arrays.toString(values));
				System.out.println(Arrays.toString(values1));
				
				throw new ArithmeticException();
			}
			
			//  Convert the number to string
			
			String y = number.toString(16);
			
			
			//  Pad the string with zeros
			
			while (y.length() < digits)  y = "0" + y;
			
			this.publickey = y;
		}
		
		
		
		if (digits == size150)
		{
		
			//  Polynomial matrix X1 A X2 cipher
			//
			//  | x1[i] u^[i]  x2[i] u^[i] | | a1[i] u^[i]  a2[i] u^[i] | | x3[i] u^[i]  x4[i] u^[i] |
			//  |                          | |                          | |                          |
			//  | x2[i] u^[i]  x1[i] u^[i] | | a3[i] u^[i]  a4[i] u^[i] | | x4[i] u^[i]  x3[i] u^[i] |
			
			//  30 terms / element x 4 elements x 5 bits / term x 1 digit / 4 bits == 150 digits
			
			
			//  Define the public coefficients and exponents
			
			int p = 31, q = p - 1, t = q, radix = 16;
			
			int[][] a = new int[2*2][t];
			
			for (int i = 0; i < 4; i++)
			for (int j = 0; j < t; j++)
			{
				//  Copy 2 hex digits == 8 bits
				
				int value = new Number(pi16 .substring(
				
				    2*(i*t + j), 2*(i*t + (j+1))), radix) .intValue();
				
				a[i][j] = value % p;
			}
			
			
			//  Define the matrix A
			
			int[][][][] A = new int[2][2][t][2];
			
			for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			
			    { A[i][j][k][0] = a[2*i+j][k];  A[i][j][k][1] = k; }
			
			
			//  Define the private coefficients
			
			String xstr = "";
			
			for (int i = 0; i < x.length; i++)
			
			    xstr += x[i].toString(16);
			
			
			int[][] c = new int[4][t];
			
			for (int i = 0; i < 4; i++)
			for (int j = 0; j < t; j++)
			{
				//  Copy 2 hex digits == 8 bits
				
				int value = new Number(xstr .substring(
				
				    2*(i*t + j), 2*(i*t + (j+1))), radix) .intValue();
				
				c[i][j] = value % p;
			}
			
			
			//  Define the matrix X1
			
			int[][][][] X1 = new int[2][2][t][2];
			
			for (int i = 0; i < 1; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X1[i][j][k][0] = c[2*(i+0)+j][k];
			     X1[i][j][k][1] = k;
			}
			
			for (int i = 1; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X1[i][j][k][0] = X1[i-1][(j+1)%2][k][0];
			     X1[i][j][k][1] = k;
			}
			
			//  Define the matrix X2
			
			int[][][][] X2 = new int[2][2][t][2];
			
			for (int i = 0; i < 1; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X2[i][j][k][0] = c[2*(i+1)+j][k];
			     X2[i][j][k][1] = k;
			}
			
			for (int i = 1; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X2[i][j][k][0] = X2[i-1][(j+1)%2][k][0];
			     X2[i][j][k][1] = k;
			}
			
			//  These statements were used for debugging
			//
			//  for (int i = 0; i < c.length; i++)
			//
			//      System.out.println(Arrays.toString(c[i]));
			//
			//  System.out.println();
			//
			//  print(X1); System.out.println();
			//  print(X2); System.out.println();
			
			
			//  Compute the public key
			//
			//  Y  =  X1  A  X2
			
			int[][][][] AX2 = Polynomial.multiply( A,  X2, p, q);
			int[][][][]   Y = Polynomial.multiply(X1, AX2, p, q);
			
			
			//  Extract the coefficients and exponents
			
			int[] values = new int[2*2*t];
			
			for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
				int coefficient = Y[i][j][k][0];
				int    exponent = Y[i][j][k][1];
				
				//  int value = (coefficient << 5) + exponent;
				
				if (exponent != k) throw new ArithmeticException();
				
				int value = coefficient;
				
				values[(2*i+j)*t + k] = value;
			}
			
			
			//  Pack the 5-bit coefficients into a number
			
			final int bits = 5;
			
			Number n = new Number(0);
			
			for (int i = 0; i < values.length; i++)
			
			    n = n .shiftLeft(32, bits) .add(values[i]) .trim();
			
			
			//  Verify that the values were stored correctly
			
			Number n1 = n;
			
			int[] values1 = new int[values.length];
			
			for (int i = 0; i < values1.length; i++)
			{
				values1[values1.length -1 -i] = n1 .and(
				
				    new Number(2).pow(bits).subtract(1) ) .intValue();
				
				n1 = n1 .shiftRight(bits) .trim();
			}
			
			if (!Arrays.equals(values, values1))
			{
				System.out.println(Arrays.toString(values));
				System.out.println(Arrays.toString(values1));
				
				throw new ArithmeticException();
			}
			
			//  Convert the number to string
			
			String y = n .toString(16);
			
			
			//  Pad the string with zeros
			
			while (y.length() < digits)  y = "0" + y;
			
			this.publickey = y;
		}
	}
	
	
	
	
	//  Quaternion discrete log ciphers
	
	
	private void generateQuaternionKey(int digits)
	{
	
		if (digits == size80)
		{
		
			//  Quaternion matrix discrete log cipher
			//
			//         -x1   x   x1
			//  Y  =  A    B   A
			//
			//  A and B are public quaternions
			//  and x, x1 are private variables
			
			//  Define the public quaternions
			
			final int t = 4, s = digits / t, radix = 16;
			
			Number[] a = new Number[2*t];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = new Number(pi16.substring(s*i, s*(i+1)), 16);
			
			Quaternion A, B;
			
			A = new Quaternion(new Number[] {a[0],a[1],a[2],a[3]});
			B = new Quaternion(new Number[] {a[4],a[5],a[6],a[7]});
			
			Quaternion invA = A.modInverse(p);
			
			
			//  Define the private variables
			
			Number x0 = x[0], x1 = x[1];
			
			Number n = new Number(radix).pow(s*t);
			
			x0 = x0 .mod(n);  x1 = x1 .mod(n);
			
			
			//  Compute the static public key
			
			Quaternion B2x0 = B.modPow(x0, p);
			Quaternion A2x1 = A.modPow(x1, p);
			
			Quaternion invA2x1 = A2x1.modInverse(p);
			
			Quaternion Y = invA2x1 .multiply(B2x0) .mod(p)
			
			    .multiply(A2x1) .mod(p);
			
			
			//  Convert the vector to string
			
			String y = Y.toIntegerString(s, 16);
			
			this.publickey = y;
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	//  Vector cross product ciphers
	
	
	private void generateVectorKey(int digits)
	{
	
		//  Vector cross product cipher
		//
		//  (for integer or Latin square vectors)
		//
		//  A, K, X are vectors of numbers or Latin squares
		//
		//  where A is a public parameter and K and X are
		//  the private keys
		//
		//  The static and one-time public keys are the
		//  areas of the parallelograms
		//
		//  Y  =  A (x) X   and   Z  =  A (x) K
		//
		//  The secret key is the volume of the parallelepiped
		//
		//  E  =  Y * K  == - Z * X
		
		
		//  Vector cross product cipher
		//
		//  Y1 = A (x) X1 + B (x) X2
		//
		//  Y2 = B (x) X1 + C (x) X2
		//  ________________________
		//
		//  Z1 = A (x) K1 + B (x) K2
		//
		//  Z2 = B (x) K1 + C (x) K2
		//  ________________________
		//
		//  E  =   Y1 * K1 + Y2 * K2
		//
		//    == - Z1 * X1 - Z2 * X2
		
		
		
		if (digits == size120)
		{
		
			//  Compute the static or one-time public key
			//
			//  Y  =  A (x) X   or   Z  =  A (x) K
			
			int s = digits / 3, radix = 16;
			
			
			//  Define the public vector A
			
			String[] pidigits = new String[3];
			
			final int s1 = s * 3/4;
			
			for (int i = 0; i < pidigits.length; i++)
			
			    pidigits[i] = pi16.substring(i*s1, (i+1)*s1);
			
			Number a1 = new Number(pidigits[0],radix);
			Number a2 = new Number(pidigits[1],radix);
			Number a3 = new Number(pidigits[2],radix);
			
			Vector A = new Vector( new Number[] { a1, a2, a3 } );
			
			
			//  Define the private vector X and compute the recip-
			//  ient's static public key vector / parallelogram Y
			
			Number n = new Number(radix) .pow(s);
			
			for (int i = 0; i < x.length; i++) x[i] = x[i] .mod(n);
			
			Vector X = new Vector( new Number[] { x[0], x[1], x[2] } );
			
			Vector Y = A .cross(X) .mod(p);
			
			
			//  Either the sender or the receiver can negate
			//  the value of the secret key, but not both
			//
			//  (This code is not used because the negation
			//  is done in the secret key agreement method)
			
			if ((publickey == null) || publickey.isEmpty()) {  }
			
			else if ((publickey != null) && !publickey.isEmpty()) {  }
			
			
			//  Convert the public key vector to string
			
			String y = Y.toIntegerString(s, radix);
			
			this.publickey = y;
		}
		
		
		
		if (digits == size192)
		{
		
			//  Compute the static or one-time public key
			//
			//  Y  =  X1 (x) X2   or   Z  =  K1 (x) K2
			
			
			//  Define the private vectors X1, X2 (or K1, K2)
			
			final int t = 3, bits = 128, s = digits / t / 1, radix = 16;
			
			Number d = new Number(2).pow(bits);
			
			Number ones = d.subtract(1);
			
			Number[] numbers1 = new Number[t];
			Number[] numbers2 = new Number[t];
			
			for (int i = 0; i < t; i++)
			{
				//  Extract the upper and lower halves of x[0] to x[t-1]
				
				numbers1[i] = new Number(x[i]).divide(d).and(ones);
				numbers2[i] = new Number(x[i]).divide(1).and(ones);
				
				numbers1[i].clearBit(bits-1);
				numbers2[i].clearBit(bits-1);
				
				numbers1[i].setBit(bits-2);
				numbers2[i].setBit(bits-2);
			}
			
			Vector X1 = new Vector(new Number[] { numbers1[0], numbers1[1], numbers1[2] });
			Vector X2 = new Vector(new Number[] { numbers2[0], numbers2[1], numbers2[2] });
			
			
			//  Compute the cross product of X1 and X2
			
			Vector Y = X1 .cross(X2);
			
			
			//  Convert the public key vector to string
			
			String y = Y.toIntegerString(s, radix);
			
			this.publickey = y;
		}
	}
	
	
	
	
	private void generate4x4Key(int digits)
	{
	
		if (digits == size84)
		{
		
			//                                 x
			//  Boustrophedonic Latin square X  cipher
			//
			//          -1   x
			//  Y  =   X   A   X   (mod p)
			//
			//          -1       x
			//    == ( X   A  X )  (mod p)
			//
			//
			//  A and X are defined as
			//
			//  | a1  a2  a3  a4 |  | x1  x2  x3  x4 |
			//  | a4  a1  a2  a3 |  | x2  x1  x4  x3 |
			//  | a3  a4  a1  a2 |  | x3  x4  x1  x2 |
			//  | a2  a3  a4  a1 |  | x4  x3  x2  x1 |
			//
			//  X is a boustrophedonic Latin square
			//  because X is written boustrophedonically
			//
			//  The X^x cipher is a re-dl (root extraction
			//  discrete log) version of the lsdl cipher
			//  B^-x A^x B^x
			
			
			int s = digits / 6, radix = 16;
			
			
			//  Define the public matrix A
			
			String[] pidigits = new String[4];
			
			for (int i = 0; i < pidigits.length; i++)
			
			    pidigits[i] = pi16.substring(i*s, (i+1)*s);
			
			Number a1 = new Number(pidigits[0],radix);
			Number a2 = new Number(pidigits[1],radix);
			Number a3 = new Number(pidigits[2],radix);
			Number a4 = new Number(pidigits[3],radix);
			
			Matrix A = new Matrix(new Number[] { a1, a2, a3, a4 }, 1);
			
			
			//  Define the private matrix X
			
			Number n = new Number(radix) .pow(s);
			
			for (int i = 0; i < x.length; i++) x[i] = x[i] .mod(n);
			
			Matrix X = new Matrix( new Number[][]
			{
				{ x[1], x[2], x[3], x[4] },
				{ x[2], x[1], x[4], x[3] },
			        { x[3], x[4], x[1], x[2] },
				{ x[4], x[3], x[2], x[1] },
			} );
			
			
			//  Compute the public key
			
			Matrix Y = X .modInverse(p)
			
			  .multiply(A.modPow(x[0], p)) .mod(p)
			
			      .multiply(X) .mod(p);
			
			
			//  Convert the matrix to a number string
			//  (Note that there are only 6 elements)
			//
			//
			//        |  1   2   3   4  |
			//        |                 |
			//        |  4   5   2   6  |
			//        |                 |
			//        |  3   4   1   2  |
			//        |                 |
			//        |  2   6   4   5  |
			
			
			String[] strarray = new String[6];
			
			strarray[0] = Y.get(0,0).toString(s,radix);
			strarray[1] = Y.get(0,1).toString(s,radix);
			strarray[2] = Y.get(0,2).toString(s,radix);
			strarray[3] = Y.get(0,3).toString(s,radix);
			
			strarray[4] = Y.get(1,1).toString(s,radix);
			strarray[5] = Y.get(1,3).toString(s,radix);
			
			//  Prepend zeros if necessary so the code won't
			//  break if the toString method is modified
			
			for (int i = 0; i < strarray.length; i++)
			
			    while (strarray[i].length() != s)
			
			        strarray[i] = "0" + strarray[i];
			
			//  Concatenate the strings
			
			String y = "";
			
			for (String str : strarray)
			
			    y += str;
			
			this.publickey = y;
		}
	}
	
	
	
	
	
	
	//  The vector, cube, tesseract, quaternion, and polynomial
	//  classes could be moved outside of the PublicKey class be-
	//  cause they don't use any of the PublicKey members or methods.
	
	
	
	private class Vector
	{
	
		private Number[] array;
		
		
		public Vector(Number[] array)
		{
			//  vector constructor
			
			this.array = new Number[array.length];
			
			for (int i = 0; i < array.length; i++)
			
			    this.array[i] = array[i];
		}
		
		
		public Vector add(Vector v)
		{
			//  adds two vectors
			
			Number[] a = this.array;
			Number[] b =    v.array;
			
			Number[] c = new Number[a.length];
			
			for (int i = 0; i < c.length; i++)
			
			    c[i] = a[i] .add(b[i]);
			
			return new Vector(c);
		}
		
		
		public Vector subtract(Vector v)
		{
			//  subtracts two vectors
			
			Number[] a = this.array;
			Number[] b =    v.array;
			
			Number[] c = new Number[a.length];
			
			for (int i = 0; i < a.length; i++)
			
			    c[i] = a[i] .subtract(b[i]);
			
			return new Vector(c);
		}
		
		
		public Number dot(Vector v)
		{
			//  computes the inner or dot product
			//  of two vectors A * B == a[i] b[i]
			
			Number[] a = this.array;
			Number[] b =    v.array;
			
			Number c = new Number(0);
			
			for (int i = 0; i < a.length; i++)
			
			    c = c .add(a[i].multiply(b[i]));
			
			return c;
		}
		
		
		public Vector cross(Vector v)
		{
			//  computes the outer or cross product of two vectors
			//
			//  The cross product A (x) B where A = { a1, a2, a3 }
			//  and B = { b1, b2, b3 } is the determinant or vector
			//
			//  |   i   j   k  |          (a2 b3 - a3 b2) i
			//  |              |   __
			//  |  a1  a2  a3  |   __   + (a3 b1 - a1 b3) j
			//  |              |
			//  |  b1  b2  b3  |        + (a1 b2 - a2 b1) k
			
			
			Number[] a = this.array;
			Number[] b =    v.array;
			
			Number a1 = a[0], a2 = a[1], a3 = a[2];
			Number b1 = b[0], b2 = b[1], b3 = b[2];
			
			Number c1 = a2.multiply(b3) .subtract(a3.multiply(b2));
			Number c2 = a3.multiply(b1) .subtract(a1.multiply(b3));
			Number c3 = a1.multiply(b2) .subtract(a2.multiply(b1));
			
			Number[] c = new Number[] { c1, c2, c3 };
			
			return new Vector(c);
		}
		
		
		public Vector mod(Number n)
		{
			//  reduces the vector modulo n
			
			Number[] a = this.array;
			
			Number[] b = new Number[a.length];
			
			for (int i = 0; i < a.length; i++)
			
			    b[i] = a[i] .mod(n);
			
			return new Vector(b);
		}
		
		
		public Number[] toArray()
		{
			//  converts a vector to a number array
			
			Number[] a = new Number[this.array.length];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = this.array[i];
			
			return a;
		}
		
		
		public String toIntegerString(int digits, int radix)
		{
			//  converts a vector to an integer string
			
			Number mod = new Number(radix).pow(digits);
			
			Number[] Y = this.array;
			
			String[] y = new String[Y.length];
			
			for (int i = 0; i < y.length; i++)
			{
				if (Y[i].signum() == -1)
				
				    Y[i] = mod.subtract(Y[i].abs());
				
				y[i] = Y[i] .toString(radix) .trim();
			}
			
			for (int i = 0; i < y.length; i++)
			
			    while (y[i].length() < digits)
			
				y[i] = "0" + y[i];
			
			
			String str = "";
			
			for (int i = 0; i < y.length; i++)
			
			    str += y[i];
			
			return str;
		}
		
		public String toString()
		{
			return Arrays.toString(array);
		}
	}
	
	
	//  End class Vector
	
	
	
	
	
	
	
	
	
	class Cube
	{
	
		//  A tesseract is a 4-dimensional array (w, x, y, z)
		//
		//  A cube is a 3-dimensional array (x, y, z)
		//
		//  A matrix is a 2-D or rectangular array (x, y)
		//
		//  A vector is a 1-D or linear array x
		//
		//  A number is a 0-D, non-dimensional array or point
		
		
		
		public void main(String[] args)
		{
			//  This method was used to test the Cube class
			
			int[][][] array1, array2, array3;
			
			Cube cube1, cube2, cube3, product1, product2;
			
			array1 = new int[][][]
			
			    { { { 1, 2 }, { 3, 4 } },
			      { { 5, 6 }, { 7, 8 } } };
			
			array2 = new int[][][]
			
			    { { { 3, 1 }, { 4, 1 } },
			      { { 5, 9 }, { 2, 6 } } };
			
			array3 = new int[][][]
			
			    { { { 5, 3 }, { 5, 8 } },
			      { { 9, 7 }, { 9, 3 } } };
			
			cube1 = new Cube(array1);
			cube2 = new Cube(array2);
			cube3 = new Cube(array3);
			
			//  Verify the associative property for cube multiplication
			
			product1 = (cube1.multiply(cube2)).multiply(cube3);
			product2 = cube1.multiply((cube2.multiply(cube3)));
			
			System.out.println(product1.equals(product2));
			
			
			//  Verify the commutative property for Latin cube multiplication
			//  where the cubes are circulant in the right or diagonal direction
			
			array1 = new int[][][]
			
			    { { { 1, 2, 3 }, { 3, 1, 2 }, { 2, 3, 1 } },
			      { { 3, 1, 2 }, { 2, 3, 1 }, { 1, 2, 3 } },
			      { { 2, 3, 1 }, { 1, 2, 3 }, { 3, 1, 2 } } };
			
			array2 = new int[][][]
			
			    { { { 4, 5, 6 }, { 6, 4, 5 }, { 5, 6, 4 } },
			      { { 6, 4, 5 }, { 5, 6, 4 }, { 4, 5, 6 } },
			      { { 5, 6, 4 }, { 4, 5, 6 }, { 6, 4, 5 } } };
			
			cube1 = new Cube(array1);
			cube2 = new Cube(array2);
			
			System.out.println(
			
			    cube1.multiply(cube2).equals(
			    cube2.multiply(cube1)));
		}
		
		
		
		//  Instance member
		
		private Number[][][] cube;
		
		
		
		//  Cube constructors
		
		
		public Cube(int[][][] cube)
		{
			this.cube = new Number[
			
			    cube.length][cube[0].length][cube[0].length];
			
			for (int i = 0; i < cube   .length; i++)
			for (int j = 0; j < cube[i].length; j++)
			for (int k = 0; k < cube[j].length; k++)
			
			    this.cube[i][j][k] = new Number(cube[i][j][k]);
		}
		
		
		public Cube(Number[][][] cube)
		{
			this.cube = new Number[
			
			    cube.length][cube[0].length][cube[0].length];
			
			for (int i = 0; i < cube   .length; i++)
			for (int j = 0; j < cube[i].length; j++)
			for (int k = 0; k < cube[j].length; k++)
			
			    this.cube[i][j][k] = cube[i][j][k];
		}
		
		
		public Cube(int r1, int r2, int r3)
		{
			//  creates an empty cube
			
			this.cube = new Number[r1][r2][r3];
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    this.cube[i][j][k] = new Number(0);
		}
		
		
		public Cube(Cube cube)
		{
			//  the cube copy constructor
			
			this.cube = new Number[cube.cube.length]
			
			    [cube.cube[0].length][cube.cube[0][0].length];
			
			for (int i = 0; i < cube.cube   .length; i++)
			for (int j = 0; j < cube.cube[i].length; j++)
			
				this.cube[i][j] = cube.cube[i][j];
		}
		
		
		public boolean equals(Cube cube)
		{
			//  returns true if two cubes are equal
			
			int r1 = cube.cube.length;
			int r2 = cube.cube[0].length;
			int r3 = cube.cube[0][0].length;
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    if (!this.cube[i][j][k] .equals(
			         cube.cube[i][j][k]))
			
				return false;
			
			return true;
		}
		
		
		private Matrix getHorizontalMatrix(int row)
		{
			int r1 = cube.length;
			int r2 = cube[0].length;
			int r3 = cube[0][0].length;
			
			Matrix matrix = new Matrix(r2, r3);
			
			for (int i = 0; i < r2; i++)
			for (int j = 0; j < r3; j++)
			
			    matrix.set(cube[row][i][j], i, j);
			
			return matrix;
		}
		
		
		private Matrix getVerticalMatrix(int col)
		{
			int r1 = cube.length;
			int r2 = cube[0].length;
			int r3 = cube[0][0].length;
			
			Matrix matrix = new Matrix(r1, r3);
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r3; j++)
			
			    matrix.set(cube[i][col][j], i, j);
			
			return matrix;
		}
		
		
		public Cube mod(Number n)
		{
			//  returns the value of this mod n
			
			Cube cube = new Cube(this);
			
			int r1 = cube.cube.length;
			int r2 = cube.cube[0].length;
			int r3 = cube.cube[0][0].length;
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    cube.cube[i][j][k] =
			    cube.cube[i][j][k] .mod(n);
			
			return cube;
		}
		
		
		public Cube modPow(int exp, int n)
		{
			return modPow(new Number(exp), new Number(n));
		}
		
		public Cube modPow(int exp, Number n)
		{
			return modPow(new Number(exp), n);
		}
		
		public Cube modPow(Number exp, int n)
		{
			return modPow(exp, new Number(n));
		}
		
		public Cube modPow(Number exp, Number n)
		{
			//  returns the modular power A^x (mod n)
			
			Cube a = new Cube(this).mod(n);
			Cube y = new Cube(this).mod(n);
			
			Number x = new Number(exp);
			
			//  Subtract 1 from the exponent
			//  because y is initialized to a
			
			x = x .subtract(1);
			
			//  Use the square and multiply method
			
			while (!x.equals(0))
			{
				if (x.testBit(0))
				
				    y = a .multiply(y) .mod(n);
				
				a = a .multiply(a). mod(n);
				
				
				//  Shift the exponent to the next bit
				
				x = x .shiftRight(1);
			}
			
			return y;
		}
		
		
		public Cube multiply(int val)
		{
			//  multiplies a cube by an int
			
			return multiply(new Number(val));
		}
		
		public Cube multiply(Number number)
		{
			//  multiplies a cube by a number
			
			Cube cube = new Cube(this);
			
			for (int i = 0; i < cube.cube   .length; i++)
			for (int j = 0; j < cube.cube[i].length; j++)
			for (int k = 0; k < cube.cube[j].length; k++)
			
			    cube.cube[i][j][k] =
			    cube.cube[i][j][k] .multiply(number);
			
			return cube;
		}
		
		public Cube multiply(Cube cube)
		{
			//  multiplies a cube by a cube
			
			int r1 = cube.cube.length;
			int r2 = cube.cube[0].length;
			int r3 = cube.cube[0][0].length;
			
			Cube product = new Cube(r1, r2, r3);
			
			if (this.cube[0].length != cube.cube.length)
			
			    throw new IllegalArgumentException();
			
			for (int row = 0; row < r1; row++)
			{
				Matrix h_matrix = this.getHorizontalMatrix(row);
				
				for (int col = 0; col < r2; col++)
				{
					Matrix v_matrix = cube.getVerticalMatrix(col);
					
					Matrix m_product = h_matrix.multiply(v_matrix);
					
					Number[] vector = new Number[r3];
					
					for (int i = 0; i < vector.length; i++)
					
					    vector[i] = Number.add(m_product.getColumn(i));
					
					product.set(vector, row, col);
				}
			}
			
			return product;
		}
		
		
		private void set(Number n, int i, int j, int k)
		{
			//  sets an element of a cube
			
			this.cube[i][j][k] = n;
		}
		
		
		private void set(Number[] vector, int row, int col)
		{
			//  sets a vector of a cube at the point (row, col)
			
			for (int k = 0; k < cube.length; k++)
			
			    cube[row][col][k] = vector[k];
		}
		
		
		public String toIntegerString(int digits, int radix)
		{
		
			//  converts a cube to an integer string by padding
			//  and concatenating the elements
			
			//  This method is used for cryptography to convert a
			//  public key / cube to a public key string.
			
			//  The digits variable is the minimum number of digits.
			//  The left side will be padded with zeros if necessary.
			
			
			Cube cube = new Cube(this);
			
			int r1 = this.cube.length;
			int r2 = this.cube[0].length;
			int r3 = this.cube[0][0].length;
			
			String[][][] y = new String[r1][r2][r3];
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			{
				Number n = cube.cube[i][j][k];
				
				if (n.isComplex())
				{
					Number real = n.toReal();
					Number imag = n.toImag();
					
					y[i][j][k]
					
					  = real.toString(digits, radix) .replaceAll(" ", "")
					  + imag.toString(digits, radix) .replaceAll(" ", "");
				}
				
				else // if (!n.isComplex())
				{
					y[i][j][k] = cube.cube[i][j][k].toString(
					
					    digits, radix) .replaceAll(" ", "");
				}
				
				//  the toString method is guaranteed to prepend zeros
				//  if radix == 16 unless the implementation changes
				
				//  Replace spaces with zeros
				
				if (digits == 0) continue;
				
				while (y[i][j][k].length() < digits)
				
				       y[i][j][k] = "0" + y[i][j][k];
			}
			
			String numberstr = "";
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    numberstr += y[i][j][k];
			
			return numberstr;
		}
		
		
		public String toString()
		{
			//  converts the cube to string
			
			Number[][][] cube = this.cube;
			
			StringBuilder sb = new StringBuilder();
			
			for (int i = 0; i < cube   .length; i++)
			for (int j = 0; j < cube[0].length; j++)
			for (int k = 0; k < cube[0].length; k++)
			
			    sb.append(cube[i][j][k] + " ");
			
			return sb.toString();
		}
	}
	
	//  End class Cube
	
	
	
	
	
	
	
	class Tesseract
	{
	
		//  A tesseract is a 4-dimensional array
		//
		//  A cube is a 3-dimensional array
		//
		//  A matrix is a 2-D or rectangular array
		//
		//  A vector is a 1-D or linear array
		//
		//  A number is a 0-D array or a point
		
		
		
		public void main(String[] args)
		{
			//  This method was used to test the Tesseract class
			
			int[][][][] array1 = new int[][][][]
			
			    { { { { 1, 2 }, { 3, 4 } }, { { 5, 6 }, { 7, 8 } } },
			      { { { 9, 0 }, { 1, 2 } }, { { 3, 4 }, { 5, 6 } } } };
			
			int[][][][] array2 = new int[][][][]
			
			    { { { { 3, 1 }, { 4, 1 } }, { { 5, 9 }, { 2, 6 } } },
			      { { { 5, 3 }, { 5, 8 } }, { { 9, 7 }, { 9, 3 } } } };
			
			int[][][][] array3 = new int[][][][]
			
			    { { { { 2, 3 }, { 8, 4 } }, { { 6, 2 }, { 6, 4 } } },
			      { { { 3, 3 }, { 8, 3 } }, { { 2, 7 }, { 9, 5 } } } };
			
			Tesseract t1 = new Tesseract(array1);
			Tesseract t2 = new Tesseract(array2);
			Tesseract t3 = new Tesseract(array3);
			
			//  Verify the associative property for tesseract multiplication
			
			Tesseract product1 = (t1.multiply(t2)).multiply(t3);
			Tesseract product2 = t1.multiply((t2.multiply(t3)));
			
			boolean bool = product1.equals(product2);
			
			System.out.println(bool);
		}
		
		
		//  Instance member
		
		private Number[][][][] tesseract;
		
		
		
		//  Tesseract constructors
		
		
		public Tesseract(int[][][][] t)
		{
			this.tesseract = new Number[
			
			    t.length][t[0].length][t[0].length][t[0].length];
			
			for (int i = 0; i < t   .length; i++)
			for (int j = 0; j < t[i].length; j++)
			for (int k = 0; k < t[j].length; k++)
			for (int l = 0; l < t[k].length; l++)
			
			    this.tesseract[i][j][k][l] = new Number(t[i][j][k][l]);
		}
		
		
		public Tesseract(Number[][][][] t)
		{
			this.tesseract = new Number[
			
			    t.length][t[0].length][t[0].length][t[0].length];
			
			for (int i = 0; i < t   .length; i++)
			for (int j = 0; j < t[i].length; j++)
			for (int k = 0; k < t[j].length; k++)
			for (int l = 0; l < t[k].length; l++)
			
			    this.tesseract[i][j][k][l] = t[i][j][k][l];
		}
		
		
		public Tesseract(int r1, int r2, int r3, int r4)
		{
			//  creates an empty tesseract
			
			this.tesseract = new Number[r1][r2][r3][4];
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    this.tesseract[i][j][k][l] = new Number(0);
		}
		
		
		public Tesseract(Tesseract t)
		{
			//  the tesseract copy constructor
			
			this.tesseract = new Number
			
			[t.tesseract.length][t.tesseract[0].length]
			[t.tesseract[0][0].length][t.tesseract[0][0][0].length];
			
			for (int i = 0; i < t.tesseract   .length; i++)
			for (int j = 0; j < t.tesseract[i].length; j++)
			for (int k = 0; k < t.tesseract[j].length; k++)
			
				this.tesseract[i][j][k] =
				   t.tesseract[i][j][k];
		}
		
		
		public boolean equals(Tesseract t)
		{
			//  returns true if two tesseracts are equal
			
			int r1 = t.tesseract.length;
			int r2 = t.tesseract[0].length;
			int r3 = t.tesseract[0][0].length;
			int r4 = t.tesseract[0][0][0].length;
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    if (!this.tesseract[i][j][k][l] .equals(
			            t.tesseract[i][j][k][l]))
			
				return false;
			
			return true;
		}
		
		
		private Cube getHorizontalCube(int row)
		{
			int r1 = tesseract.length;
			int r2 = tesseract[0].length;
			int r3 = tesseract[0][0].length;
			int r4 = tesseract[0][0][0].length;
			
			Cube cube = new Cube(r2, r3, r4);
			
			for (int i = 0; i < r2; i++)
			for (int j = 0; j < r3; j++)
			for (int k = 0; k < r4; k++)
			
			    cube.set(tesseract[row][i][j][k], i, j, k);
			
			return cube;
		}
		
		
		private Cube getVerticalCube(int col)
		{
			int r1 = tesseract.length;
			int r2 = tesseract[0].length;
			int r3 = tesseract[0][0].length;
			int r4 = tesseract[0][0][0].length;
			
			Cube cube = new Cube(r1, r3, r4);
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r3; j++)
			for (int k = 0; k < r4; k++)
			
			    cube.set(tesseract[i][col][j][k], i, j, k);
			
			return cube;
		}
		
		
		public Tesseract mod(Number n)
		{
			//  returns the value of this mod n
			
			Tesseract t = new Tesseract(this);
			
			int r1 = t.tesseract.length;
			int r2 = t.tesseract[0].length;
			int r3 = t.tesseract[0][0].length;
			int r4 = t.tesseract[0][0][0].length;
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    t.tesseract[i][j][k][l] =
			    t.tesseract[i][j][k][l] .mod(n);
			
			return t;
		}
		
		
		public Tesseract modPow(int exp, int n)
		{
			return modPow(new Number(exp), new Number(n));
		}
		
		public Tesseract modPow(int exp, Number n)
		{
			return modPow(new Number(exp), n);
		}
		
		public Tesseract modPow(Number exp, int n)
		{
			return modPow(exp, new Number(n));
		}
		
		public Tesseract modPow(Number exp, Number n)
		{
			//  computes the modular power A^x (mod n)
			
			Tesseract a = new Tesseract(this).mod(n);
			Tesseract y = new Tesseract(this).mod(n);
			
			Number x = new Number(exp);
			
			//  Subtract 1 from the exponent
			//  because y is initialized to a
			
			x = x .subtract(1);
			
			
			//  Use the square and multiply method
			
			while (!x.equals(0))
			{
				if (x.testBit(0))
				
				    y = a .multiply(y) .mod(n);
				
				a = a .multiply(a). mod(n);
				
				
				//  Shift the exponent to the next bit
				
				x = x .shiftRight(1);
			}
			
			return y;
		}
		
		
		
		public Tesseract multiply(int val)
		{
			//  multiplies a tesseract by an int
			
			return multiply(new Number(val));
		}
		
		public Tesseract multiply(Number number)
		{
			//  multiplies a tesseract by a number
			
			Tesseract t = new Tesseract(this);
			
			for (int i = 0; i < t.tesseract   .length; i++)
			for (int j = 0; j < t.tesseract[i].length; j++)
			for (int k = 0; k < t.tesseract[j].length; k++)
			for (int l = 0; l < t.tesseract[k].length; l++)
			
			    t.tesseract[i][j][k][l] =
			    t.tesseract[i][j][k][l] .multiply(number);
			
			return t;
		}
		
		public Tesseract multiply(Tesseract t)
		{
			//  multiplies a tesseract by a tesseract
			
			int r1 = t.tesseract.length;
			int r2 = t.tesseract[0].length;
			int r3 = t.tesseract[0][0].length;
			int r4 = t.tesseract[0][0][0].length;
			
			Tesseract product = new Tesseract(r1, r2, r3, r4);
			
			if (this.tesseract[0].length != t.tesseract.length)
			
			    throw new IllegalArgumentException();
			
			for (int row = 0; row < r1; row++)
			{
				Cube h_cube = this.getHorizontalCube(row);
				
				for (int col = 0; col < r2; col++)
				{
					Cube v_cube = t.getVerticalCube(col);
					
					Cube c_product = h_cube.multiply(v_cube);
					
					Matrix matrix = new Matrix(r3, r4);
					
					for (int i = 0; i < matrix.rowCount(); i++)
					for (int j = 0; j < matrix.columnCount(); j++)
					
					    matrix.set(new Number(0), i, j);
					
					for (int i = 0; i < matrix.rowCount(); i++)
					
					    matrix = matrix.add(c_product.getHorizontalMatrix(i));
					
					product.set(matrix, row, col);
				}
			}
			
			return product;
		}
		
		
		private void set(Matrix matrix, int row, int col)
		{
			//  sets a matrix of a tesseract
			
			tesseract[row][col] = matrix.toNumberArray();
		}
		
		
		public String toIntegerString(int digits, int radix)
		{
			//  converts a tesseract to an integer string
			//  by padding and concatenating the elements
			
			//  This method is used for cryptography to convert
			//  a public key / tesseract to a public key string.
			
			//  The digits variable is the minimum number of digits.
			//  The left side will be padded with zeros if necessary.
			
			
			Tesseract t = new Tesseract(this);
			
			int r1 = this.tesseract.length;
			int r2 = this.tesseract[0].length;
			int r3 = this.tesseract[0][0].length;
			int r4 = this.tesseract[0][0][0].length;
			
			String[][][][] y = new String[r1][r2][r3][4];
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			{
				Number n = t.tesseract[i][j][k][l];
				
				if (n.isComplex())
				{
					Number real = n.toReal();
					Number imag = n.toImag();
					
					y[i][j][k][l]
					
					  = real.toString(digits, radix) .replaceAll(" ", "")
					  + imag.toString(digits, radix) .replaceAll(" ", "");
				}
				
				else // if (!n.isComplex())
				{
					y[i][j][k][l] = t.tesseract[i][j][k][l].toString(
					
					    digits, radix) .replaceAll(" ", "");
				}
				
				//  the toString method is guaranteed to prepend zeros
				//  if radix == 16 unless the implementation changes
				
				//  Replace spaces with zeros
				
				if (digits == 0) continue;
				
				while (y[i][j][k][l].length() < digits)
				
				       y[i][j][k][l] = "0" + y[i][j][k][l];
			}
			
			String numberstr = "";
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    numberstr += y[i][j][k][l];
			
			return numberstr;
		}
		
		
		public String toString()
		{
			//  converts a tesseract to string
			
			Number[][][][] t = this.tesseract;
			
			StringBuilder sb = new StringBuilder();
			
			for (int i = 0; i < t   .length; i++)
			for (int j = 0; j < t[0].length; j++)
			for (int k = 0; k < t[0][0].length; k++)
			for (int l = 0; l < t[0][0][0].length; l++)
			
			    sb.append(t[i][j][k] + " ");
			
			return sb.toString();
		}
	}
	
	//  End class Tesseract
	
	
	
	
	
	
	
	
	
	
	private class Quaternion
	{
	
		//  Quaternion Algebra / The Algebra of Quaternions / Four-dimensional algebra (1843)
		//
		//  A quaternion is a four-element hypercomplex number a0 + a1 i + a2 j + a3 k.
		//
		//  Multiplication of the basis or set of unit vectors { i, j, k } is defined by
		//
		//  i j ==  k,  j k ==  i,  k i ==  j,  j i == - k,  k j == - i,  i k == - j, and
		//
		//  i i == j j == k k == - 1. The unit or identity vector is I = { 1, 0, 0, 0 }.
		//
		//
		//  Quaternion addition  C = A + B
		//
		//  where C[i] = A[i] + B[i]
		//
		//
		//  Quaternion multiplication  C = A * B
		//
		//  Let A = [ a1 + a2 i + a3 j + a4 k ]  and
		//      B = [ b1 + b2 i + b3 j + b4 k ]; then
		//
		//  C = A B == [ a1 + a2 i + a3 j + a4 k ]
		//           * [ b1 + b2 i + b3 j + b4 k ]
		//
		//   == [ a1 b1    + a1 b2 i   + a1 b3 j   + a1 b4 k
		//      + a2 b1 i  + a2 b2 ii  + a2 b3 ij  + a2 b4 ik
		//      + a3 b1 j  + a3 b2 ji  + a3 b3 jj  + a3 b4 jk
		//      + a4 b1 k  + a4 b2 ki  + a4 b3 kj  + a4 b4 kk ]
		//
		//   == [ a1 b1    + a1 b2 i   + a1 b3 j   + a1 b4 k
		//      + a2 b1 i  - a2 b2     + a2 b3 k   - a2 b4 j
		//      + a3 b1 j  - a3 b2 k   - a3 b3     + a3 b4 i
		//      + a4 b1 k  + a4 b2 j   - a4 b3 i   - a4 b4 ]
		//
		//   == [ a1 b1 - a2 b2 - a3 b3 - a4 b4,
		//      ( a1 b2 + a2 b1 + a3 b4 - a4 b3 ) i,
		//      ( a1 b3 + a3 b1 - a2 b4 + a4 b2 ) j,
		//      ( a1 b4 + a4 b1 + a2 b3 - a3 b2 ) k ].
		//
		//
		//  Quaternion inversion  A X == I
		//
		//  A  =  a1 + a2 i + a3 j + a4 k;
		//  X  =  x1 + x2 i + x3 j + x4 k;
		//  I  =   1 +  0 i +  0 j +  0 k;
		//
		//  Multiply the two quaternions / vectors
		//
		//  A X == a1 + a2 i + a3 j + a4 k
		//         x1 + x2 i + x3 j + x4 k ==
		//
		//  ( a1 x1 - a2 x2 - a3 x3 - a4 x4 ),
		//  ( a1 x2 + a2 x1 + a3 x4 - a4 x3 ) i,
		//  ( a1 x3 + a3 x1 - a2 x4 + a4 x2 ) j,
		//  ( a1 x4 + a4 x1 + a2 x3 - a3 x2 ) k.
		//
		//  Set the product equal to the unit vector { 1, 0, 0, 0 }
		//
		//  a1 x1 - a2 x2 - a3 x3 - a4 x4 == 1;
		//  a1 x2 + a2 x1 + a3 x4 - a4 x3 == 0;
		//  a1 x3 + a3 x1 - a2 x4 + a4 x2 == 0;
		//  a1 x4 + a4 x1 + a2 x3 - a3 x2 == 0;
		//
		//  Rearrange the terms
		//
		//  a1 x1 - a2 x2 - a3 x3 - a4 x4 == 1;
		//  a2 x1 + a1 x2 - a4 x3 + a3 x4 == 0;
		//  a3 x1 + a4 x2 + a1 x3 - a2 x4 == 0;
		//  a4 x1 - a3 x2 + a2 x3 + a1 x4 == 0;
		//
		//  Extract the coefficients to form the augmented matrix
		//
		//  | a1  - a2  - a3  - a4  | | x1 |    | 1 |
		//  | a2  + a1  - a4  + a3  | | x2 | __ | 0 |
		//  | a3  + a4  + a1  - a2  | | x3 | __ | 0 |
		//  | a4  - a3  + a2  + a1  | | x4 |    | 0 |
		//
		//  | a1  - a2  - a3  - a4  | 1 |
		//  | a2  + a1  - a4  + a3  | 0 |
		//  | a3  + a4  + a1  - a2  | 0 |
		//  | a4  - a3  + a2  + a1  | 0 |
		//
		//  Solve the system of simultaneous linear equations by
		//  reducing the matrix to echelon and row canonical form
		
		
		
		//  Quaternion Latin square multiplication
		//
		//  | a1     a2 i   a3 j   a4 k | | b1   | b2 i | b3 j | b4 k |    | C1 | C2 | C3 | C4 |
		//  | ------------------------- | |      |      |      |      |    | ---+----+----+--- |
		//  | a4 k   a1     a2 i   a3 j | | b4 k | b1   | b2 i | b3 j | __ | C4 | C1 | C2 | C3 |
		//  | ------------------------- | |      |      |      |      | __ | ---+----+----+--- |
		//  | a3 j   a4 k   a1     a2 i | | b3 j | b4 k | b1   | b2 i |    | C3 | C4 | C1 | C2 |
		//  | ------------------------- | |      |      |      |      |    | ---+----+----+--- |
		//  | a2 i   a3 j   a4 k   a1   | | b2 i | b3 j | b4 k | b1   |    | C2 | C3 | C4 | C1 |
		//
		//
		//  where  C1 = { a1 b1,   a2 b4 i k, a3 b3 j j, a4 b2 k i },
		//         C2 = { a1 b2 i, a2 b1 i,   a3 b4 j k, a4 b3 k j } i,
		//         C3 = { a1 b3 j, a2 b2 i i, a3 b1 j,   a4 b4 k k } j,
		//         C4 = { a1 b4 k, a2 b3 i j, a3 b2 j,i, a4 b1 k   } k,
		//
		//   or    C1 = { a1 b1,   - a2 b4 j, - a3 b3,     a4 b2 j },
		//         C2 = { a1 b2 i,   a2 b1 i,   a3 b4 i, - a4 b3   } i,
		//         C3 = { a1 b3 j, - a2 b2,     a3 b1 j, - a4 b4   } j,
		//         C4 = { a1 b4 k,   a2 b3 k, - a3 b2 k,   a4 b1 k } k.
		
		
		
		
		private Number[] array;
		
		
		//  Quaternion constructors
		
		
		public Quaternion(Number[] array)
		{
			this.array = new Number[array.length];
			
			for (int i = 0; i < array.length; i++)
			
			    this.array[i] = array[i];
		}
		
		public Quaternion(Quaternion A)
		{
			this.array = new Number[A.array.length];
			
			for (int i = 0; i < array.length; i++)
			
			    this.array[i] = A.array[i];
		}
		
		
		
		//  Quaternion methods
		
		
		public Quaternion add(Quaternion A)
		{
			//  adds two quaternions
			
			Number[] C = new Number[4];
			
			Number[] B = this.array;
			
			C[0] = A.array[0] .add( B[0] );
			C[1] = A.array[1] .add( B[1] );
			C[2] = A.array[2] .add( B[2] );
			C[3] = A.array[3] .add( B[3] );
			
			return new Quaternion(C);
		}
		
		
		public Quaternion mod(Number n)
		{
			//  returns the value of this mod n
			
			Quaternion A = new Quaternion(this);
			
			for (int i = 0; i < A.array.length; i++)
			
			    A.array[i] = A.array[i] .mod(n);
			
			return A;
		}
		
		
		public Quaternion modInverse(Number p)
		{
			//  computes the modular inverse of a quaternion
			
			//  It would be faster to use the modPow method
			//  if the exponent modulus is known.
			
			//  A   =  a0 + a1 i + a2 j + a3 k;
			//  X   =  x0 + x1 i + x2 j + x3 k;
			//  A X =   1 +  0 i +  0 j +  0 k;
			//
			//  Multiply the two quaternions / vectors
			//
			//  A X == a0 + a1 i + a2 j + a3 k
			//         x0 + x1 i + x2 j + x3 k ==
			//
			//  ( a0 x0 - a1 x1 - a2 x2 - a3 x3 ),
			//  ( a0 x1 + a1 x0 + a2 x3 - a3 x2 ) i,
			//  ( a0 x2 + a2 x0 - a1 x3 + a3 x1 ) j,
			//  ( a0 x3 + a3 x0 + a1 x2 - a2 x1 ) k.
			//
			//  Set the product equal to the unit vector
			//
			//  a0 x0 - a1 x1 - a2 x2 - a3 x3 == 1;
			//  a0 x1 + a1 x0 + a2 x3 - a3 x2 == 0;
			//  a0 x2 + a2 x0 - a1 x3 + a3 x1 == 0;
			//  a0 x3 + a3 x0 + a1 x2 - a2 x1 == 0;
			//
			//  Rearrange the terms
			//
			//  a0 x0 - a1 x1 - a2 x2 - a3 x3 == 1;
			//  a1 x0 + a0 x1 - a3 x2 + a2 x3 == 0;
			//  a2 x0 + a3 x1 + a0 x2 - a1 x3 == 0;
			//  a3 x0 - a2 x1 + a1 x2 + a0 x3 == 0;
			//
			//  Extract the coefficients and solve for x
			//
			//  | a0  - a1  - a2  - a3  | | x1 |    | 1 |
			//  | a1  + a0  - a3  + a2  | | x2 | __ | 0 |
			//  | a2  + a3  + a0  - a1  | | x3 | __ | 0 |
			//  | a3  - a2  + a1  + a0  | | x4 |    | 0 |
			
			//  Initialize the augmented matrix [ A | B ]
			
			Number[] array = this.array;
			
			Number a0 = array[0], a1 = array[1];
			Number a2 = array[2], a3 = array[3];
			
			Number a1_ = a1.negate(p);
			Number a2_ = a2.negate(p);
			Number a3_ = a3.negate(p);
			
			Matrix A = new Matrix( new Number[][]
			{
				{ a0,  a1_, a2_, a3_ },
				{ a1,  a0,  a3_, a2  },
				{ a2,  a3,  a0,  a1_ },
				{ a3,  a2_, a1,  a0  },
			});
			
			Matrix B = new Matrix(Convert.intArrayToNumberArray(
			
			    new int[] { 1, 0, 0, 0 })).transpose();
			
			Matrix A_B = A.augment(B);
			
			
			//  Solve the augmented matrix [ A | B ]
			//
			//  for the inverse vector X == A^-1 B
			
			Number[] x;
			
			if (p.isLessThan(2*1024*1024))
			
			    x = A_B .solve(p.intValue());
			
			else x = A_B .solve(p);
			
			
			//  Verify the solution
			
			Matrix A_X = A.multiply(new
			
			   Matrix(x).transpose()).mod(p);
			
			Quaternion Q = new Quaternion(x);
			
			Quaternion I = this.multiply(Q);
			
			return Q;
		}
		
		
		
		public Quaternion modPow(Number x1, Number p)
		{
			//  computes the modular power of a quaternion
			
			Quaternion A = new Quaternion(this);
			
			Number x = new Number(x1);
			
			Number[] y = new Number[]
			
			    { new Number(1), new Number(0),
			      new Number(0), new Number(0) };
			
			Quaternion Y = new Quaternion(y);
			
			//  Use the square and multiply method
			
			while (x.bitCount() != 0)
			{
				//  Accumulate squares for each 1 bit
				
				if (x.testBit(0))
				
				    Y = A.multiply(Y) .mod(p);
				
				//  Square the square
				
				A = A.multiply(A) .mod(p);
				
				//  Shift the exponent to the next bit
				
				x = x.shiftRight(1);
			}
			
			return Y;
		}
		
		
		
		public Quaternion multiply(Quaternion A1)
		{
			//  multiplies two quaternions
			
			//  A  =  a0 + a1 i + a2 j + a3 k;
			//  B  =  b0 + b1 i + b2 j + b3 k; C =
			//
			//  ( a0 b0 - a1 b1 - a2 b2 - a3 b3 ),
			//  ( a0 b1 + a1 b0 + a2 b3 - a3 b2 ) i,
			//  ( a0 b2 + a2 b0 - a1 b3 + a3 b1 ) j,
			//  ( a0 b3 + a3 b0 + a1 b2 - a2 b1 ) k.
			
			Number[] C = new Number[4];
			
			Number[] A =   A1.array;
			Number[] B = this.array;
			
			Number a0b0 = A[0].multiply(B[0]), a0b1 = A[0].multiply(B[1]);
			Number a0b2 = A[0].multiply(B[2]), a0b3 = A[0].multiply(B[3]);
			
			Number a1b0 = A[1].multiply(B[0]), a1b1 = A[1].multiply(B[1]);
			Number a1b2 = A[1].multiply(B[2]), a1b3 = A[1].multiply(B[3]);
			
			Number a2b0 = A[2].multiply(B[0]), a2b1 = A[2].multiply(B[1]);
			Number a2b2 = A[2].multiply(B[2]), a2b3 = A[2].multiply(B[3]);
			
			Number a3b0 = A[3].multiply(B[0]), a3b1 = A[3].multiply(B[1]);
			Number a3b2 = A[3].multiply(B[2]), a3b3 = A[3].multiply(B[3]);
			
			C[0] = a0b0 .subtract(a1b1.add(a2b2).add(a3b3));
			C[1] = a0b1 .add(a1b0).add(a2b3).subtract(a3b2);
			C[2] = a0b2 .add(a2b0).subtract(a1b3).add(a3b1);
			C[3] = a0b3 .add(a3b0).add(a1b2).subtract(a2b1);
			
			return new Quaternion(C);
		}
		
		
		public Number[] toArray()
		{
			//  converts a quaternion to a number array
			
			Number[] a = new Number[this.array.length];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = this.array[i];
			
			return a;
		}
		
		
		public String toIntegerString(int digits, int radix)
		{
			//  converts a quaternion to an integer string
			
			Number[] Y = this.array;
			
			String[] y = new String[Y.length];
			
			for (int i = 0; i < y.length; i++)
			
			    y[i] = Y[i] .toString(radix) .trim();
			
			for (int i = 0; i < y.length; i++)
			
			    while (y[i].length() < digits)
			
				y[i] = "0" + y[i];
			
			String str = "";
			
			for (int i = 0; i < y.length; i++)
			
			    str += y[i];
			
			return str;
		}
		
		public String toString()
		{
			//  converts a quaternion / vector to string
			
			return Arrays.toString(array);
		}
	}
	
	
	//  End class Quaternion
	
	
	
	
	
	
	
	private class Polynomial
	{
	
		//  Polynomial methods
		
		//  The polynomial methods require two moduli, one for the base and
		//  another for the exponent. The exponent modulus q equals p-1 only
		//  if the base modulus p is prime.
		//
		//  If the base modulus p is a power of 2, then the exponent modulus
		//  equals the base modulus. (More precisely, if p is a power of 2
		//  greater than 2^2, then q = p / 4 because the order of a^x mod 8 is
		//  8/4 == 2. To verify this, 3^2, 5^2, and 7^2 == 1 modulo 8;  3^4, 5^4,
		//  7^4, 9^4, ..., 15^4 == 1 modulo 16;  3^8, 5^8, 7^8, ..., 31^8 == 1
		//  modulo 32; ...)
		//
		//  For any prime power p = a^k where a != 2, q = lambda(a^k) = phi(a^k) ==
		//  (a-1) a^(k-1). (For example, if p = 3^3 == 27, then q == 2 3^2 == 18.)
		//  For any power p = 2^k where k > 2, q = lambda(2^k) == 2^(k-2) ==
		//  phi(2^k) / 2. (For example, lambda(8) == 2 because 3^2 == 1 (mod 8),
		//  5^2 == 1 (mod 8), and 7^2 == 1 (mod 8))
		
		
		
		//  member variables
		
		private int p, q, t;
		
		private int[][] m1;
		
		
		//  member methods
		
		public Polynomial(int[][] a, int p, int q, int t)
		{
			//  Polynomial constructor
			
			this.m1 = new int[a.length][a[0].length];
			
			for (int i = 0; i < a   .length; i++)
			for (int j = 0; j < a[i].length; j++)
			
			    this.m1[i][j] = a[i][j];
			
			this.p = p; this.q = q; this.t = t;
		}
		
		
		public Polynomial add()
		{
			//  compares the exponents in a polynomial and adds the
			//  coefficients of terms that have the same exponent
			//
			//  This reduces the size of the polynomial from O(q^2) to O(q).
			//
			//  This method is used only by the polynomial modPow method
			
			int[][] m1 = this.m1;
			
			int[][] terms = new int[t][2];
			
			for (int i = 0; i < terms.length; i++)
			
			    { terms[i][0] = 0; terms[i][1] = i; }
			
			for (int i = 0; i < m1.length; i++)
			{
				int coefficient = m1[i][0] % p;
				int    exponent = m1[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			return new Polynomial(terms, p, q, t);
		}
		
		
		
		private int[][] add(int[][] m1)
		{
			//  compares the exponents in a polynomial and adds the
			//  coefficients of terms that have the same exponent
			//
			//  This reduces the size of the polynomial from O(q^2) to O(q).
			//
			//  This method is used only by the polynomial modPow method
			
			int[][] terms = new int[t][2];
			
			for (int i = 0; i < terms.length; i++)
			
			    { terms[i][0] = 0; terms[i][1] = i; }
			
			for (int i = 0; i < m1.length; i++)
			{
				int coefficient = m1[i][0] % p;
				int    exponent = m1[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			return terms;
		}
		
		
		public Polynomial add(Polynomial poly)
		{
			//  compares the exponents in two polynomials and adds
			//  the coefficients of terms that have the same exponents
			
			int[][] m1 = this.m1;
			int[][] m2 = poly.m1;
			
			int[][] terms = new int[t][2];
			
			for (int i = 0; i < terms.length; i++)
			
			    { terms[i][0] = 0; terms[i][1] = i; }
			
			for (int i = 0; i < m1.length; i++)
			{
				int coefficient = m1[i][0] % p;
				int    exponent = m1[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			for (int i = 0; i < m2.length; i++)
			{
				int coefficient = m2[i][0] % p;
				int    exponent = m2[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			return new Polynomial(terms, p, q, t);
		}
		
		
		public int get(int i, int j)
		{
			return m1[i][j];
		}
		
		
		public Polynomial modPow(int[] x1)
		{
			//  computes the modular power of a polynomial
			
			int[][] m1 = this.m1;
			
			int[][] a = new int[m1.length][m1[0].length];
			
			for (int i = 0; i < a   .length; i++)
			for (int j = 0; j < a[0].length; j++)
			
			    a[i][j] = m1[i][j];
			
			int[] x = Arrays.copyOf(x1, x1.length);
			
			int[][] y = new int[][] { { 1, 0 } };
			
			//  Use the square and multiply method
			
			while (Math.bitCount(x) != 0)
			{
				//  Accumulate squares for each 1 bit
				
				if (Math.testBit(x, 0))
				
				    y = add( multiply(a, y) );
				
				//  Square the square
				
				a = add( multiply(a, a) );
				
				//  Shift the exponent to the next bit
				
				x = Math.shiftRight(x, 1);
			}
			
			return new Polynomial(y, p, q, t);
		}
		
		
		
		public Polynomial multiply(Polynomial poly)
		{
			//  computes the modular product of two polynomials
			
			int[][] m1 = this.m1;
			int[][] m2 = poly.m1;
			
			int t = m1.length * m2.length;
			
			int[][] m3 = new int[t][2];
			
			//  For each term in m1[i] and m2[j], multiply the coefficient
			//  of m2[j] by the coefficient of m1[i] modulo p and add the
			//  exponents m1[i] and m2[j] modulo q.
			
			for (int i = 0; i < m1.length; i++)
			for (int j = 0; j < m2.length; j++)
			{
				m3[m2.length*i + j][0] = (((m1[i][0] * m2[j][0]) % p) + p) % p;
				m3[m2.length*i + j][1] = (((m1[i][1] + m2[j][1]) % q) + q) % q;
			}
			
			return new Polynomial(m3, p, q, t);
		}
		
		
		private int[][] multiply(int[][] m1, int[][] m2)
		{
			//  computes the modular product of two polynomials
			
			int t = m1.length * m2.length;
			
			int[][] m3 = new int[t][2];
			
			//  For each term in m1[i] and m2[j], multiply the coefficient
			//  of m2[j] by the coefficient of m1[i] modulo p and add the
			//  exponents m1[i] and m2[j] modulo q.
			
			for (int i = 0; i < m1.length; i++)
			for (int j = 0; j < m2.length; j++)
			{
				m3[m2.length*i + j][0] = (((m1[i][0] * m2[j][0]) % p) + p) % p;
				m3[m2.length*i + j][1] = (((m1[i][1] + m2[j][1]) % q) + q) % q;
			}
			
			return m3;
		}
	
	
	
	
		//  static methods for polynomials
		
		
		private static int[][] add(int[][] m1, int[][] m2, int p, int q)
		{
			//  compares the exponents in two polynomials and adds
			//  the coefficients of terms that have the same exponents
			
			final int t = q;
			
			int[][] terms = new int[t][2];
			
			for (int i = 0; i < terms.length; i++)
			
			    { terms[i][0] = 0; terms[i][1] = i; }
			
			for (int i = 0; i < m1.length; i++)
			{
				int coefficient = m1[i][0] % p;
				int    exponent = m1[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			for (int i = 0; i < m2.length; i++)
			{
				int coefficient = m2[i][0] % p;
				int    exponent = m2[i][1] % q;
				
				 terms[exponent][0] =
				(terms[exponent][0] + coefficient) % p;
			}
			
			return terms;
		}
		
		
		private static int[][] multiply(int[][] m1, int[][] m2, int p, int q)
		{
			//  computes the modular product of two polynomials
			
			int t = m1.length * m2.length;
			
			int[][] m3 = new int[t][2];
			
			//  For each term in m1[i] and m2[j], multiply the coefficient of
			//  m2[j] by the coefficient of m1[i] modulo p and add the exponents
			//  m1[i] and m2[j] modulo q.
			
			for (int i = 0; i < m1.length; i++)
			for (int j = 0; j < m2.length; j++)
			{
				m3[m2.length*i + j][0] = (((m1[i][0] * m2[j][0]) % p) + p) % p;
				m3[m2.length*i + j][1] = (((m1[i][1] + m2[j][1]) % q) + q) % q;
			}
			
			return m3;
		}
		
		
		//  static methods for matrix polynomials
		
		private static int[][][][] multiply(int[][][][] m1, int[][][][] m2, int p, int q)
		{
			//  multiplies two matrices of polynomials (mod p)
			
			//  int[rows][cols][terms][0 or 1]  0 = coef, 1 = exp
			
			int rows = m1.length, cols = m2[0].length;
			
			int t = m1[0][0].length;
			
			int[][][][] m3 = new int[rows][cols][t][2];
			
			for (int i = 0; i < m3   .length; i++)
			for (int j = 0; j < m3[i].length; j++)
			for (int k = 0; k < m1[i].length; k++)
			
			    { m3[i][j][k][0] = 0; m3[i][j][k][1] = k; }
			
			for (int i = 0; i < m3   .length; i++)
			for (int j = 0; j < m3[i].length; j++)
			for (int k = 0; k < m1[i].length; k++)
			
			    m3[i][j] = add( m3[i][j], multiply(
			
				m1[i][k], m2[k][j], p , p-1), p, q );
			
			return m3;
		}
		
		
		private static void print(int[][][][] m)
		{
			//  prints an int array matrix
			
			int rows = m.length, cols = m[0].length;
			
			for (int i = 0; i < rows; i++, System.out.println())
			for (int j = 0; j < cols; j++)
			{
				int[][] p = m[i][j];
				
				System.out.print(" { ");
				
				for (int s = 0; s < p   .length; s++, System.out.print(" "))
				for (int t = 0; t < p[0].length; t++)
				
				    System.out.print(p[s][t] + " ");
				
				System.out.println(" } ");
			}
		}
		
		
		
		
		private static Matrix modPow(Matrix A0, Matrix B0, Matrix C0, Matrix A1, Number x, Number p)
		{
			//  The matrix polynomial discrete log modPow method
			//
			//  A^x C B^x + ... + A^0 C B^0
			
			final int t = (int) x.bitCount();
			
			final int rows = A0.rowCount();
			
			final Matrix[]  A = new Matrix[t];
			final Matrix[]  B = new Matrix[t];
			final Matrix[] CC = new Matrix[t];
			
			A[0] = Matrix.identityMatrix(rows);
			B[0] = Matrix.identityMatrix(rows);
			
			A[1] = new Matrix(A0);
			B[1] = new Matrix(B0);
			
			CC[0] = Matrix.identityMatrix(rows);
			
			for (int i = 2; i < A.length; i++)
			
			    A[i] = A[i-1] .square() .mod(p);
			
			for (int i = 2; i < B.length; i++)
			
			    B[i] = B[i-1] .square() .mod(p);
			
			for (int i = 1; i < t; i++)
			
			   CC[i] = A[i] .multiply(CC[i-1])
			
			      .multiply(B[i]) .mod(p)
			
				  .add(CC[i-1]) .mod(p);
			
			Matrix Y = (A1 == null) ? C0 : A1;
			
			for (int i = t - 1; i >= 1; i--)
			
			   if (x.testBit(i)) // multiply and add
			
			      Y = A[i] .multiply(Y) .multiply(B[i])
			
			         .add(CC[i-1]) .mod(p);
			
			return Y;
		}
	}
	
	
	//  End class Polynomial
	
	
	
	
	
	
	//  The linear cipher y = a x (mod n) and the quadratic cipher c = m ^ 2 (mod n)
	//  are proofs of public key cryptography or the existence of trapdoor one-way
	//  functions. The linear cipher y = a x (mod n) is a commutative one-way function
	//  and the quadratic cipher c = m^2 (mod n) is an invertible / one-way function.
	//  Just like Merkle's puzzles, these ciphers have no practical use except for
	//  teaching the introduction to public key cryptography and Diffie-Hellman key
	//  exchange or key agreement because the key sizes are too large.
	//
	//  The Merkle-Hellman / knapsack cryptosystem was the world's first practical
	//  and quantum-resistant public key cipher, and also the only cipher to use a
	//  secret, private or nonpublic modulus.
	
	
	
	//  The linear cipher y = a x (mod n)
	//
	//  The public parameters are a, n where
	//
	//  n is a random number or a power of 2;
	//
	//  the static private key is x;
	//
	//  the one-time private key is k;
	//
	//  the static public key is y = a x (mod n);
	//
	//  the one-time public key is z = a k (mod n);
	//
	//  the secret key agreement is e = y k == z x (mod n).
	//
	//  The size of a and n has to > 10^12 or 1 terabit because a cryptanalyst can compute a^-1 (mod n)
	//  to invert the function and solve for x == a^-1 y (mod n). This requires O(n^2 log n) operations
	//  where n is the number of bits or size of the modulus. Computing the public key only requires a
	//  multiplication or O(n log n) operations because modular reduction is a division, multiplication,
	//  and subtraction. This cipher only works for modular arithmetic or integers not for real numbers
	//  because a non-modular inversion requires only about ten multiplications using short division or
	//  Newton's method for inversion u = u (2 - v u).
	//
	//  A cryptanalyst doesn't have to factor or know how to factor the modulus n because the modular in-
	//  version method can use the extended Euclidean algorithm to invert a instead of Fermat's little
	//  theorem a^p == a, a^(p-1) == a^0 == 1, a^(p-2) == 1/a (mod p) which requires the factorization of
	//  the modulus into primes and then the reconstruction of the composite inverse using a least common
	//  remainder method such as Gauss's remainder algorithm or Garner's formula.
	
	
	
	
	//  The quadratic cipher c = m ^ 2 ^ k (mod n)
	//
	//  The Rabin / factorization / square root or co-composite root extraction cipher
	//
	//  A commutative or invertible function such as the Rabin cipher doesn't have to be based on a refractory
	//  problem to be a public key cipher. It only has to be harder to invert than to compute either because of
	//  the time complexity or because of the space requirements of the algorithm. Some functions such as the
	//  factorial function a! (mod p) are neither computable nor invertible in polynomial time. If a! (mod n)
	//  were computable it would solve the factorization problem for n.
	//
	//  The Rabin cipher c = m ^ e (mod n) where (e, phi(n)) != 1 (e and phi are co-composite such as e = 2^k)
	//  is equivalent to factorization because there is a many-to-one mapping of m to c. If m1 is chosen and
	//  c = m1^2 (mod n) is solved for m2 = sqrt(c) (mod n), then the number can be factored using the differ-
	//  ence of squares m2^2 - m1^2 == 0 (mod n) or (m2 + m1) (m2 - m1) - k n == 0. This implies that f1 =
	//  (m2 + m1) and f2 = (m2 - m1) each contains a prime or composite factor of n. By dividing n by f1 and
	//  f2 and then recursively using the factorization algorithm for the reduced modulus, the modulus can be
	//  completely factored. If the sqrt algorithm returns the same value m2 == m1, then m1 has to be re-chosen
	//  to be a different value until the algorithm returns a different value for m2, but this will only happen
	//  once in every 2^k times where k is the number of prime factors in the modulus or number being factored.
	//
	//  Solving the coprime root extraction problem c = m ^ e (mod n) where (e, phi(n)) == 1 is not equivalent
	//  to factorization because there is no difference of squares for the roots of c = m ^ e (mod n) if the
	//  sqrt(c) always gives the same value of m. The problem with coprime root extraction is that the function
	//  is invertible without factoring or unmultiplying the modulus n, and the function can be inverted as fast
	//  as it can be computed. (Michael Rabin had thought of using coprime root extraction as a public key ci-
	//  pher but he knew that it wasn't equivalent to factorization.)
	//
	//  The Rabin cipher can use any exponent e > 1 by choosing a prime factor that has the same number in the
	//  totient whereas the RSA / coprime root extraction cipher can only use exponents e > 2 that are co-prime
	//  with the totient. If the message m is a perfect square < n, then the message can be encrypted and de-
	//  crypted by squaring and unsquaring m modulo n. Similarly, if m is a perfect cube and phi(n) is divisible
	//  by 3, then the message can be encrypted and decrypted by cubing and uncubing m modulo n. The root of c =
	//  m ^ e (mod n) still has e ^ k solutions where k is the number of factors (or prime powers) in the mod-
	//  ulus, but the recipient can extract the message by inverting e modulo phi(n)/e instead of modulo phi be-
	//  cause the message is a perfect square or cube in addition to a quadratic or cubic residue modulo n.
	//
	//  The key generation could be made faster by choosing a large random number for the modulus n and then
	//  multiplying n by a 512-bit prime. The encryption method was made faster by choosing a secret key m ~
	//  sqrt(n) and log2(n) = 2^k - 1024; then computing c = m^2 mod n only requires one large multiplication
	//  but no large division. The modular reduction is several times faster because the divide method calls
	//  the quadratic divider instead of the inverter if the dividend is only slightly larger than the divisor.
	//  If the message were chosen such that m ~ n, then the modulus and inverse would have to be stored in a
	//  static class member to avoid doing inversions for each decryption because division is ten to twenty
	//  times more expensive than multiplication.
	//
	//  Note that the terms Rabin cipher and RSA refer to the ciphers whereas quadratic residue, square root ex-
	//  traction, and coprime root extraction refer to the math problems on which the ciphers are based. The math
	//  problems of root extraction modulo a prime or composite number existed before they were discovered or
	//  used as ciphers, just as the discrete log problem existed and was studied long before it was used as a
	//  cipher. Math books would not refer to co-composite or square root extraction, coprime root extraction,
	//  or discrete logarithms as Rabin, RSA, or Diffie-Hellman problems.
	//
	//  The Rabin / factorization cipher is susceptible to quantum and classical computing because there are sub-
	//  exponential, quantum, and polynomial-time algorithms for factoring integers. Factorization can be solved
	//  in O(1) exponentiations, O(n) multi-precision multiplications, or O(n^2 log n) operations for large num-
	//  bers which is the time required to compute a ^ (lamdba(n)/2) (mod n) or to solve for the factors f1 =
	//  (a ^ (lambda(n)/2) + 1, n) and f2 = (a ^ (lambda(n)/2) - 1, n) where a is a quadratic non-residue.
	//
	//  For example, if n = 77, a quantum computer would compute the order of a^x (mod n) or lambda(n) = lcm(
	//  phi(7), phi(11)) == lcm(7-1, 11-1) == 30; and then a classical computer would compute 2 ^ (lambda/2)
	//  (mod 77) == 43; f1 = (77, 44) == 11 and f2 = (77, 42) == 7. The exponentiation requires O(n) multiplica-
	//  tions or O(n^2 log n) operations, and the gcd function only requires O(n) multi-precision subtractions
	//  or O(n^2) operations.
	//
	//  The sub-exponential method for solving the integer discrete log problem (modulo a prime) is called the
	//  index-calculus algorithm. The Handbook of Applied Cryptography says that "...the basic ideas behind the
	//  index-calculus algorithm first appeared in the work of Kraitchik (circa 1922-1924) and of Cunningham
	//  and was rediscovered by several authors ... Pomerance credits the idea of multiplying congruences to
	//  produce a solution to x^2 == y^2 (mod n) for the purpose of factoring n to some old work of Kraitchik
	//  circa 1926-1929."
	//
	//  Kraitchik's method can only solve the discrete log / factorization problem up to ~ 256 bits because it
	//  has to find round numbers or numbers that contain only small factors. By using a linear sieve, quadra-
	//  tic sieve, or number field sieve to reduce the size of the numbers by half to two-thirds, Kraitchik's
	//  method can solve the discrete log / factorization problem up to ~ 512 to ~ 768 bits which is on the or-
	//  der of a thousand bits. A polynomial-time algorithm can factor numbers up to 1 to 10 M bits.
	
	
	
	
	
	
	//  The Rabin / factorization / co-composite root extraction cipher
	//
	//  This cipher works with any exponent 2, 3, 4, 5, 6, ...
	//  that is co-composite with the totient of the modulus
	//
	//  the size of the public key is 10^7 or ~ 10 M bits
	//
	//  For the exponent 2
	//
	//  the static private key p[] is an array of primes congruent to 3 modulo 4;
	//
	//  the static public key n is the product of the primes array p[];
	//
	//  the one-time public key is c = m1 ^ (2 k) mod n
	//
	//  where sqrt(n) < m1^(1 k) < n  and k is a power of 2;
	//
	//  the secret key is the perfect square
	//
	//  m2 == lcr( c[]^(1/k) mod(fact n), fact n ) or
	//  m2 == lcr( c[]^(1/k) mod(p[]), p[] ) where
	//
	//      1/k        1/k (mod (p[i]-1)/2)
	//  c[i]   ==  c[i]                     mod p[i]
	//
	//  and lcr(r[], p[]) is the least common remainder,
	//  least Chinese remainder, least common residue,
	//  or least composite residue.
	//
	//  If m1 < p[i] for any i, then the secret key is
	//
	//               1/(2 k)
	//  m1  ==  c[i]         mod p[i] for any index i.
	
	
	
	
	
	
	
	
	
	//  The Merkle-Hellman / knapsack cipher
	//
	//  Generating the recipient's static key
	//
	//  Choose a superincreasing vector
	//
	//  a[] = (a[1], a[2], ..., a[k]).
	//
	//  Choose a secret modulus n greater than the sum of the
	//  array elements multiplied by the multiplier modulus p.
	//
	//  Choose a public table r[][] and a random vector s[].
	//
	//  Convert the private superincreasing vector a[] to
	//  the nonincreasing public vector
	//
	//  c[] = (c[1], c[2], ..., c[k]) where
	//
	//                          T
	//  c[i] = s0 a[i] + r[i][j] s[j] (mod n)  or
	//
	//                             T
	//  C[i] = R1 A[i] R2 + R[i][j] S[j] (mod n)
	//
	//  for the matrix version.
	//
	//
	//  Permutate the elements of c[] using a secret key.
	//
	//  The modulus n and vectors a[], s[] are the private key.
	//
	//  The vector c[] is the static public key.
	//
	//
	//  Generating the sender's one-time public key
	//
	//  Choose a secret key m[] and then calculate the sum
	//
	//  b = c[] (m[] + e[]) (mod p) or
	//
	//  B = C[] (m[] + e[]) (mod p)  and
	//
	//  b1 = r[][] (m[] + e[])
	//
	//  where p is a modulus < a[i+1] / a[i]
	//
	//  and e[] are random errors.
	//
	//
	//
	//  Recovering the secret key m[]
	//
	//  Use the subset sums
	//
	//  b0 = c[] (m[] + e[]) (mod p) and
	//
	//  b1 = r[][] (m[] + e[]) to solve for m[];
	//                            T
	//  since b0 = (s0 a[] + r[][] s[] mod n) (m[] + e[])
	//
	//  multiply b0 by s0 ^-1 (mod n) to get
	//
	//  b' = a[] m[] + (r[][] (m[] + e[])) s[] s0^-1 (mod n);
	//
	//  compute and subtract (r[][] (m[] + e[])) s[] s0^-1 (mod n)
	//
	//  to obtain the superincreasing sum b2 = a[] m[]
	//
	//  and then solve for the permuted secret key m'[];
	//
	//  unpermutate m'[] or discard the lower permuted
	//
	//  (m[] + e[]) elements to recover m[].
	//
	//
	//  The first implementation of the cipher used a single large error added to
	//  m[0] but then this was changed to use multiple small errors greater than
	//  the quotient of the base of the superincreasing sequence a[].
	//
	//  Note that the cipher could also include small random errors added to the
	//  static public key. Although the recipient would have to solve the super-
	//  increasing subset sum problem hundreds of times to find the correct key,
	//  this would not increase the decryption time because the ssss or solve
	//  superincreasing subset sum method would compensate by testing the last two
	//  elements of m for 1 so that the cipher could be decrypted 16^2 or 256 times
	//  faster if the base of the sequence is 16.
	//
	//  Also the sender would have to include a non-random pattern in the message
	//  such as non-consecutive repeating digits so the decryptor would know which
	//  solution is the correct key. For example, for 64 elements, the average num-
	//  ber of ones for a random base-16, 64-digit number would be 1/16 / element *
	//  64 elements == 4, but the probability of getting 24 ones would be Poisson(
	//  u = 4, x = 24) ~ 10^-11 or one in a hundred billion, and 28 ones would be
	//  P(u = 4, x = 28) ~ 10^15 or 1 in a quadrillion. If the number of elements is
	//  64, the size of m[i] is four bits or 16, and the lower 20 elements are dis-
	//  carded because they contain errors, then the number of solutions is 10^15 *
	//  16 ^ (64-20-28) ~ 2^50 * 2^(4*16) == 2 ^ 114. For 60 elements there would be
	//  ~ 2 ^ 100 or 1 nonillion solutions.
	//
	//  If the knapsack cipher could be shown to be breakable, then the cipher in the
	//  public key class would have to be modified to include small random errors in
	//  the static public key. The one-time public key is already unbreakable because
	//  it include random errors in the message m[].
	
	
	
	
	
	
	
	
	
	
	private void generateVectorDotProductKey(String publickey, int digits)
	{
	
		//  Computes the recipient's static public key if null
		//  or else computes the sender's one-time public key
		
		final int s, t, radix, bits; Number ones, d;
		
		if (digits == size768)
		{
			t = 6; s = digits / t; radix = 16; bits = 128;
			
			d = new Number(2).pow(bits);
			
			ones = d.subtract(1);
		}
		
		else return;
		
		if ((s % 4) != 0) throw new
		
		    IllegalArgumentException();
		
		
		if ((publickey == null) || publickey.isEmpty())
		{
		
			//  Choose the recipient's static public key A[]
			
			Number[] A = new Number[t];
			
			
			//  Choose a random 128-bit radix or base B
			//  xor the upper and lower halves of x[0]
			//  because only 128 bits are required for B
			
			Number upper = new Number(x[0]).divide(d).and(ones);
			Number lower = new Number(x[0]).divide(1).and(ones);
			
			Number B = upper.xor(lower); B.setBit(bits-1);
			
			
			//  Choose 2 x 6 secret 128-bit numbers
			
			Number[] numbers1 = new Number[t];
			Number[] numbers2 = new Number[t];
			
			for (int i = 0; i < t; i++)
			{
				//  Extract the upper and lower halves of x[1] to x[6]
				
				numbers1[i] = new Number(x[1+i]).divide(d).and(ones);
				numbers2[i] = new Number(x[1+i]).divide(1).and(ones);
				
				numbers1[i].clearBit(bits-1);
				numbers2[i].clearBit(bits-1);
			}
			
			for (int i = 0; i < t; i++)
			{
				Number[] coefficients = new Number[]
				
				    { numbers1[i], new Number(1), new Number(0), numbers2[i] };
				
				A[i] = new Number(coefficients, B);
			}
			
			
			//  Convert the public key vector to string
			
			StringBuilder sb = new StringBuilder();
			
			for (Number number : A)
			
			    sb.append(number.toString(s, radix));
			
			this.publickey = sb.toString();
		}
		
		
		else // if (publickey != null)
		{
		
			//  Generate the sender's one-time public key
			//
			//  B  =  A[] * X[]  from the recipient's
			//
			//  static public key A[]
			
			
			//  Choose a random secret key X[] =
			//
			//  f(static public key y, one-time private key k)
			
			
			//  Choose the secret key X
			
			Number[] X = new Number[t];
			
			for (int i = 0; i < t; i++)
			
			    X[i] = new Number(x[i]) .and(ones);
			
			for (int i = 0; i < t; i++)
			{
				X[i] .clearBit(bits-1);
				X[i] .clearBit(bits-2);
				X[i] .clearBit(bits-3);
				X[i] .clearBit(bits-4);
				X[i]   .setBit(bits-5);
			}
			
			
			Number[] A = new Number[t];
			
			for (int i = 0; i < t; i++)
			
			    A[i] = new Number(publickey.substring(
			
				digits/t * i, digits/t * (i+1)), 16);
			
			
			Number b = new Number(0);
			
			for (int i = 0; i < t; i++)
			
			    b = b .add(A[i].multiply(X[i]));
			
			String ystr = b .toString(s + s/4, 16);
			
			
			//  Append random digits to make the one-time public
			//  key size equal to the static public key size
			//
			//  While the random numbers can be probabilistic
			//  they should be deterministic so that a program
			//  can test if a public key is being reused by
			//  hashing the key and comparing the hashes.
			
			StringBuilder sb = new StringBuilder(ystr);
			
			for (int i = 0; sb.length() < digits; i++)
			
			     sb.append(pi16.charAt(i));
			
			this.publickey = sb.toString();
		}
	}
	
	
	
	
	private byte[] hash2(byte[] array, int bits)
	{
		if (bits <= 256) return Cipher.hash(array);
		
		//  returns a 512-bit hash using a 256-bit algorithm
		//  (a 256-bit hash will work if the number of terms
		//  times the number of multiplier bits is < 256, or
		//  if the number of terms is < 64 for a 4-bit cipher)
		
		byte[] hash0 = array;
		
		byte[] hash1 = Cipher.hash(hash0);
		byte[] hash2 = Cipher.hash(hash1);
		
		int len = hash1.length + hash2.length;
		
		byte[] hash12 = new byte[len];
		
		for (int i = 0; i < hash1.length; i++) hash12[        i] = hash1[i];
		for (int i = 0; i < hash2.length; i++) hash12[len/2 + i] = hash2[i];
		
		return hash12;
	}
	
	
	
	private void generateMerkleHellmanKey(String publickey, int digits)
	{
		//  Computes the recipient's static public key if null
		//  or else computes the sender's one-time public key
		
		int pbits = -1, nbits = -1;
		
		int k = new Number(digits)
		
		    .sqrt() .round() .intValue();
		
		while ((k % 4) != 0) k--;
		
		pbits = 4; nbits = pbits*k + 4*1;
		
		final int offset = 16;
		final int k1 = offset*2;
		final int bits = k*pbits;
		
		
		//  The knapsack density can be defined as k log2 p / log2 A where k is
		//  the number of terms in the sequence a[], log2 p is the size of each
		//  multiplier m[], and log2 A is the size of the largest element in a[].
		//
		//  If k = 48, pbits = 4, and the elements are (log2 p) ^ i == 16 ^ 0,
		//  16 ^ 1, 16 ^ 2, ... == 2 ^ (4 i), then log2 A[48] == log2 (2 ^ (4 x 48))
		//  == 4 x 48, and the density is 48 x 4 / (48 x 4) == 1.
		
		
		if ((publickey == null) || publickey.isEmpty())
		{
		
			//  Compute the recipient's static public key
			//
			//  c[] = (c[1], c[2], ..., c[k])
			//
			//  where c[i] = s0 a[i] + r[][] s[] (mod n)
			
			
			//  Define the multiplier modulus
			
			Number p = new Number(2).pow(pbits);
			
			
			//  Define the superincreasing sequence
			
			Number[] a = new Number[k];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = new Number(2).pow(pbits*i);
			
			if (!isSuperincreasingSequence(a, p))
			{
				System.out.println("a == " + Arrays.toString(a));
				
				throw new ArithmeticException();
			}
			
			
			//  Choose a secret modulus n greater than the sum of the
			//  array elements multiplied by the multiplier modulus p
			//  (n doesn't have to be prime but has to be coprime with r)
			
			Number n = x[0] .mod(
			
			    new Number(2).pow(nbits));
			
			n .setBit(nbits -1);
			
			n = n .nextPrime();
			
			if ((n.bitCount() % 4) != 0)
			
			    throw new ArithmeticException();
			
			int c_digits = k + 1;
			
			
			//  Choose a public number r0 and secret number s[]
			
			//  The number r0 would be public without r[][] s[] because a crypt-
			//  analyst knows that a[0] starts with 1 or a small value and can
			//  run an algorithm a[0] k times to find the value of a[0] r0. Also
			//  although the number r0 is secret it doesn't have to be because
			//  the array s[] and the modulus n are secret.
			//
			//  If a[0] were a large secret number such as 2^32, then the density
			//  of the knapsack would be k log2 p / log2 A == (28 * 8) / (28 * 8
			//  + 32) == 0.875 == 7/8 instead of (28 * 8) / (28 * 8 + 0) == 1.
			
			
			//  Define the array multiplier r
			
			Number r  = new Number(x[1]) .mod(n);
			Number s0 = new Number(x[2]) .mod(n);
			
			//  Set the highest bit of r to ensure that
			//  a[] r is reduced modulo n for all values
			//  of a[i] = 2 ^ i except for i = 0
			
			r.setBit(nbits -1);
			
			
			if (!r.isCoprimeWith(n)) throw
			
			    new ArithmeticException();
			
			Number[] s1 = new Number[k1];
			
			s1[0] = new Number( hash2(
			
			    s0.toByteArray(32), bits) );
			
			for (int i = 1; i < s1.length; i++)
			
			    s1[i] = new Number( hash2(s1[i-1]
			
				.toByteArray(32), bits) );
			
			for (int i = 0; i < s1.length; i++)
			
			    s1[i] = s1[i] .mod(n);
			
			
			//  Define the public table r1
			
			final int d = nbits / 4;
			
			Number[][] r1 = new Number[k1][k];
			
			for (int i1 = 0; i1 < k1; i1++)
			
			    r1[i1][0] = new Number(0);
			
			Number temp = new Number(0);
			
			for (int i1 = 0; i1 < k1; i1++)
			for (int i  = 0; i  < k;  i ++)
			{
				temp = new Number( hash2(
				
				    temp.toByteArray(32), bits) );
				
				r1[i1][i] = temp .mod(
				
				    new Number(16).pow(d));
			}
			
			
			//  Convert the vector a[] to the public vector
			//
			//  c[] = (c[1], c[2], ..., c[k]) where
			//
			//  c[i] = s0 a[i] + r[][] s[] (mod n)
			
			Number[] c = new Number[a.length];
			
			for (int i = 0; i < c.length; i++)
			
			    c[i] = a[i] .multiply(r) .mod(n);
			
			
			//  the c[] elements below the offset value can be permutated without
			//  unpermutating the solved m[] values because the lower values of
			//  m[] are discarded; permutating the higher values of c[] might re-
			//  quire permutating the rows or columns of the public matrix r[][],
			//  but then for each static public key, r[][] would have to use a se-
			//  quence of random numbers instead of the digits of pi or else there
			//  would be no point to permutating the rows, and that would expand
			//  the size of the static public key.
			
			
			//  System.out.println();
			//
			//  for (Number c1 : c) System.out
			//    .print(c1.mod(256).toString(16));
			
			Number key = x[3];
			
			permutateLower(c, key, offset);
			
			//  System.out.println();
			//
			//  for (Number c1 : c) System.out
			//    .print(c1.mod(256).toString(16));
			
			
			
			//  Compute t1 = r1[][]^T s[]
			
			Number[] t1 = new Number[k];
			
			for (int i = 0; i < k; i++)
			
			    t1[i] = new Number(0);
			
			for (int i  = 0; i  < k;  i ++)
			for (int i1 = 0; i1 < k1; i1++)
			
			    t1[i] = t1[i] .add(r1[i1][i]
			
				.multiply(s1[i1])) .mod(n);
			
			
			//  Add t1[] to c[]
			
			for (int i = 0; i < k; i++)
			
			    c[i] = c[i] .add(t1[i]) .mod(n);
			
			
			
			
			/********************************
			
			
			//  The Merkle-Hellman / knapsack ciphers could include
			//  small random errors added to the static public key
			
			
			//  Create a list of small random errors
			
			Number[] rand = new Number[k];
			
			//  0, 0, 1, -1, 2, -2, 3, -3, ...
			
			for (int i = 0; i < k; i++)
			
			    rand[i] = ((i % 2) == 0) ?
			
				new Number(+i/4) :
				new Number(-i/4);
			
			
			//  Multiply the random errors by t modulo n
			
			Number t = new Number(x[3]) .mod(n);
			
			for (int i = 0; i < k; i++)
			
			    rand[i] = rand[i] .multiply(t) .mod(n);
			
			
			//  Permutate the list of random errors
			
			//  Any value can be used to permutate the random errors
			//  but a private key should be used so the recipient's
			//  public key hash doesn't change every time the public
			//  key is generated
			
			Number key = x[2];
			
			permutate(rand, key);
			
			
			//  Add the random errors t rand[i] to c[i]
			
			if (pbits <= 6) for (int i = 1; i < k; i++)
			
			    c[i] = c[i] .add(rand[i]) .mod(n);
			
			
			********************************/
			
			
			
			//  for (Number c1 : c) System.out.print(
			//
			//      c1.toString(16).length() + "  ");
			
			
			//  Convert the vector c[] to string
			
			StringBuilder sb = new StringBuilder();
			
			for (int i = 0; i < c.length; i++)
			{
				String cstr = c[i] .toString(16);
				
				if (cstr.length() > c_digits)
				
				    throw new ArithmeticException();
				
				while (cstr.length() < c_digits)
				
				    cstr = "0" + cstr;
				
				sb.append(cstr);
			}
			
			String ystr = sb.toString();
			
			this.publickey = ystr;
		}
		
		
		
		else // if (publickey != null)
		{
		
			//  Generate the sender's one-time public key
			//
			//  b = c[] (m[] + e[]),  b1 = r[][] ^ T (m[] + e[])
			//
			//  from the recipient's static public key c[]
			
			//  Choose a random secret key m =
			//
			//  f(static public key y, one-time private key k)
			
			
			Number[] m = new Number[k];
			
			
			//  Define the values for m[]
			
			m[0] = new Number( hash2( new Number(publickey, 16)
			
			    .add(x[0]) .toByteArray(32), bits ) );
			
			for (int i = 1; i < m.length; i++)
			
			    m[i] = new Number( hash2(
			
				m[i-1] .toByteArray(32), bits ) );
			
			
			//  Reduce m[] modulo (2 ^ pbits)
			
			Number p = new Number(2).pow(1*pbits);
			
			for (int i = 0; i < m.length; i++)
			
			    m[i] = m[i] .mod(p);
			
			
			//  Set the last m[i] to 1
			
			m[m.length - 1] = new Number(1);
			
			
			
			/********************************
			
			
			//  If the Merkle-Hellman ciphers includes small
			//  random errors added to the static public key
			//
			//  Set the second-to-last m[i] element to 1 if small
			//  random errors are included in the static public key;
			//  this will make the decryption 256 times faster
			//
			//  m[m.length - 2] = new Number(1);
			
			
			//  Set a number of non-consecutive repeating digits so the
			//  decryption method knows which solution is the correct key
			//  (if small random errors are added to the static key)
			//
			//  Create an array of k - offset elements; set a consecutive
			//  number of repeating elements equal to 1 and permutate the
			//  elements so that the 1's and 0's are random; then for each
			//  array[i] that equals 1 set the corresponding m[i] element
			//  equal to 1.
			
			final int rep = 28, digit = 1;
			
			Number[] ones_zeros = new Number[m.length - offset];
			
			for (int i = rep; i < ones_zeros.length; i++)
			
			    ones_zeros[i] = new Number((i < rep) ? digit : 0);
			
			Number key = x[1];
			
			permutate(ones_zeros, key);
			
			for (int i = offset; i < m.length; i++)
			
			    if (ones_zeros[i].equals(digit))
			
				m[i] = new Number(digit);
			
			
			********************************/
			
			
			
			//  Initialize the vector cstr[] from
			//  the recipient's static public key
			
			String[] cstr = new String[k];
			
			if (((publickey.length()) % k) != 0)
			
			    throw new IllegalArgumentException();
			
			
			final int c_digits = (publickey.length()) / k;
			
			for (int i = 0; i < cstr.length; i++)
			
			    cstr[i] = publickey .substring(
			
				c_digits*(i), c_digits*(i+1));
			
			
			
			//  Add random errors to m[] before computing the subset sum
			
			int maxindex = offset;
			
			//  System.out.println(Arrays.toString(m));
			
			for (int i = 1, mod = 16*15; i < maxindex; i++)
			{
				//  if (m[i].equals(1)) continue;
				
				Math.initRng(i*System.nanoTime());
				
				int rand = 16 + Math.random(mod);
				
				m[i] = new Number(rand);
			}
			
			
			
			//  Convert cstr[] to a number vector c[]
			
			Number[] c = new Number[cstr.length];
			
			for (int i = 0; i < c.length; i++)
			
			    c[i] = new Number(cstr[i], 16);
			
			
			//  System.out.println("c string == \n\n");
			//
			//  for (int i = 0; i < cstr.length; i++)
			//
			//      System.out.println(cstr[i]);
			
			
			//  Compute the subset sum b = c[] m[]
			//
			//  This will expand the size of c by pbits + log2(k)
			
			Number b = new Number(0);
			
			for (int i = 0; i < c.length; i++)
			
			    b = b .add(c[i].multiply(m[i]));
			
			
			//  Convert the subset sum to a public key string
			
			String ystr = b .toString(16);
			
			int ylen = (nbits + pbits + Math.log2(k) + 3) / 4;
			
			
			//  Prepend one or two zeros until the length equals ylen
			
			while (ystr.length() < ylen) ystr = "0" + ystr;
			
			
			//  Define the public coefficients
			
			final int d = nbits / 4;
			
			Number[][] r1 = new Number[k1][k];
			
			for (int i1 = 0; i1 < k1; i1++)
			
			    r1[i1][0] = new Number(0);
			
			Number temp = new Number(0);
			
			for (int i1 = 0; i1 < k1; i1++)
			for (int i  = 0; i  < k;  i ++)
			{
				temp = new Number( hash2(
				
				    temp.toByteArray(32), bits ) );
				
				r1[i1][i] = temp.mod(new Number(16).pow(d));
			}
			
			
			//  Compute the vector products r[][] m[]
			
			Number[] r_m = new Number[k1];
			
			for (int i1 = 0; i1 < k1; i1++)
			
			    r_m[i1] = new Number(0);
			
			for (int i1 = 0; i1 < k1; i1++)
			for (int i  = 0; i  < k;  i ++)
			
			    r_m[i1] = r_m[i1] .add(
			
				r1[i1][i].multiply(m[i]));
			
			
			//  Append the vector products r[][] m[]
			
			String[] r_m_str = new String[k1];
			
			for (int i1 = 0; i1 < k1; i1++)
			
			    r_m_str[i1] = r_m[i1] .toString(16);
			
			for (String str : r_m_str)
			
			    if (str.length() > ylen)
			
				throw new ArithmeticException();
			
			for (int i1 = 0; i1 < k1; i1++)
			{
				while (r_m_str[i1].length() < ylen)
				
				    r_m_str[i1] = "0" + r_m_str[i1];
				
				ystr = ystr + r_m_str[i1];
			}
			
			
			//  Append random digits to make the one-time public
			//  key size equal to the static public key size
			//
			//  While the random numbers can be probabilistic
			//  they should be deterministic so that a program
			//  can test if a public key is being reused by
			//  hashing the key and comparing the hashes.
			
			StringBuilder sb = new StringBuilder(ystr);
			
			for (int i = 0; sb.length() < digits; i++)
			
			     sb.append(pi16.charAt(i));
			
			this.publickey = sb.toString();
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	//  Secret key generation
	
	
	//  The generateSecretKey method requires the static public key y (for
	//  receiving or decrypting) or the one-time public key z (for sending
	//  or encrypting) to generate the secret key e.
	//
	//  The sender uses the recipient's static public key y = f(a, x), and
	//  the recipient uses the sender's one-time public key z = f(a, k).
	//
	//  For a symmetrical public key cipher, the sender and receiver generate
	//  the same secret key e = f(y, k) == f(f(a, x), k) or e = f(z, x) ==
	//  f(f(a, k), x) using their private keys k or x.
	//
	//  For an asymmetrical public key cipher, the sender chooses a shared
	//  secret key m and encrypts the key using the recipient's static public
	//  key to generate the one-time public key. The recipient then inverts or
	//  decrypts the sender's one-time public key to recover the secret key m.
	
	
	
	
	//  These are public static methods for generating the secret key from a
	//  composite static public key and a matching composite one-time public key.
	//
	//  To generate a matching composite one-time public key, use the generate
	//  MatchingPublicKeys(byte[] privatekey, String[] statickey) method.
	
	
	
	
	//  These two public static methods are used by the SSLServerSocket class
	
	
	public static Number generateSecretKey(String receivedkey, PublicKey[] y, int type)
	{
		//  Split the received key string into z[]
		
		String[] tokens = splitKeys(receivedkey);
		
		if (tokens == null) throw new NullPointerException();
		
		String[] z = new String[tokens.length];
		
		for (int i = 0; i < z.length; i++) z[i] = tokens[i];
		
		return generateSecretKey(z, y, type);
	}
	
	
	
	public static Number generateSecretKey(String[] receivedkey, PublicKey[] y, int type)
	{
	
		//  PublicKey[] is used instead of the private key so the caller doesn't
		//  have to keep generating the public key to compute the secret key for
		//  each message. This makes decryption twice as fast because the recipi-
		//  ent only has to compute the secret key instead of computing the static
		//  public key y = a ^ x which isn't used for decryption.
		
		
		//  Verify that the received public key is valid
		
		String[] z = receivedkey;
		
		if (!isValidKey(z))
		{
			System.out.println("Public key is invalid");
			
			return null;
		}
		
		//  Verify that the public key ciphers match each other
		
		if (z.length != y.length) throw
		
		    new IllegalArgumentException();
		
		for (int i = 0; i < y.length; i++)
		
		    if (y[i].toString().length() != z[i].length())
		
			if (!y[i].toString().isEmpty())
		
			    throw new IllegalArgumentException();
		
		
		//  Compute the one-time composite secret key
		//
		//  e[] == the sum of all secret keys
		
		//  Use multiple threads to generate the public and secret keys
		
		int numberofciphers = z.length;
		
		Number[] e = new Number[numberofciphers];
		
		Thread[] tarray = new Thread[numberofciphers];
		
		for (int i = 0; i < tarray.length; i++)
		{
			int i1 = i;
			
			int size = z[i].length();
			
			String onetimepublickey = z[i];
			
			PublicKey staticpublickey = y[i];
			
			tarray[i] = new Thread(() ->
			{
				Number secretkey = staticpublickey
				
				    .generateSecretKey(onetimepublickey, type);
				
				e[i1] = secretkey;
			});
		}
		
		
		//  Start the threads
		
		for (Thread thread : tarray)
		
		     thread.start();
		
		
		//  Wait for the threads to expire
		
		for (Thread thread : tarray)
		
		     while (thread.isAlive()) ;
		
		
		//  Add the secret keys to create the composite secret key
		
		Number compositekey = new Number(e[0]);
		
		for (int i = 1; i < tarray.length; i++)
		
		    compositekey = compositekey .xor(e[i]);
		
		return compositekey;
	}
	
	
	
	
	
	
	//  These are private methods for generating the secret key agreement from the
	//  user's private key or member variables x[] and the sender's or recipient's
	//  static or one-time public key.
	//
	//  The parameter z is either the recipient's static public key (for sending or
	//  encrypting) or the sender's one-time public key (for receiving or decrypting).
	
	
	
	//  This is the private, non-static or instance method for generating the secret
	//  key agreement from the user's static or one-time public key. If the user's
	//  key is a static public key, then the argument key z is the sender's one-time
	//  public key, and if the user's key is a one-time public key, then z is the
	//  recipient's static public key.
	
	
	private Number generateSecretKey(String z, int type)
	{
	
		//  This method is used for symmetric and asymmetric keys
		//
		//  If the public key is symmetric or symmetrical, then the type is ignored
		
		//  type 1 = recipient / decryption
		//  type 2 =    sender / encryption
		//
		//  If the public key is asymmetrical, then
		//
		//  if (type == 1 recipient / decryption) m is computed from z
		//  if (type == 2    sender / encryption) m is chosen and z is ignored
		//
		//  The method knows whether a public key cipher is asymmetric or symmetric
		//  from the size of z because no two ciphers are allowed to have the same size.
		
		
		
		
		if (z.trim().length() == -1)  return null;
		
		
		else if ( z.trim().length() == size90 )
		{
		
			//   Y  =  X1  A  X2
			//
			//   Z  =  K1  A  K2
			//
			//   E  =  X1  Z  X2
			
			
			int digits = z.trim().length();
			
			int matrices = 1, rows = 3, cols = rows, p = 10;
			
			if ((digits % (rows*cols)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + rows*cols);
			
			int s = digits / rows / cols / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			Number d = new Number(16).pow(s) .multiply(2);
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[rows*cols];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(
			
				i*s, (i+1)*s), radix);
			
			Matrix Z = new Matrix(zn, rows, cols);
			
			//  System.out.println("Z == \n" + Z.toMatrixString(16));
			
			
			//  Define the private matrices
			
			Number x0 = x[0], x1 = x[1];
			Number x2 = x[2], x3 = x[3];
			
			Number[] array_x1 = new Number[cols];
			Number[] array_x2 = new Number[cols];
			
			for (int i = 0; i < cols; i++)
			{
				array_x1[i] = x1.getDigits(i*s, (i+1)*s, 16);
				array_x2[i] = x2.getDigits(i*s, (i+1)*s, 16);
			}
			
			Matrix X1 = new Matrix(array_x1, 1);
			Matrix X2 = new Matrix(array_x2, 1);
			
			//  System.out.println(X1.toMatrixString(16));
			//  System.out.println(X2.toMatrixString(16));
			
			
			//  Convert the integers to fractional numbers
			
			Z  = Z  .setPrecision(p) .divide(d);
			X1 = X1 .setPrecision(p) .divide(d);
			X2 = X2 .setPrecision(p) .divide(d);
			
			
			//  Compute the secret key
			
			Matrix E = X1 .multiply(Z) .multiply(X2);
			
			
			//  Reduce the precision of the public
			//  key agreement or shared secret key
			
			int p1 = 2;
			
			E = E .setPrecision(p - p1);
			
			
			//  Remove the integer / fraction points
			//  (or hexadecimal points)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    E.set( new Number( E.get(i, j).toString(16)
			
				.replace(".", ""), 16), i, j);
			
			//  System.out.println("E == \n\n" + E.toMatrixString(16));
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s - p1, radix), radix)
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size64 )
		{
		
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			//  Initialize the matrix A
			
			int matrices = 3, rows = 2, cols = rows, radix = 16;
			
			int s = z.trim().length() / rows / cols / 1;
			
			//  for complex divide by 2 instead of 1
			
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*rows*s + (j+0)*s,
				k*rows*cols*s + i*rows*s + (j+1)*s), radix);
			
			Matrix A1 = new Matrix(elements[0]);
			Matrix A2 = new Matrix(elements[1]);
			Matrix B  = new Matrix(elements[2]);
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[rows*cols];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(i*s, (i+1)*s), radix);
			
			Matrix Z = new Matrix(new Number[][]
			
			    { { zn[0], zn[1] }, { zn[2], zn[3] } });
			
			
			//  Reduce the size of x1, x2 to 2 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			x2 = x2 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			
			
			//  Compute A1 ^ x1,  A2 ^ x2
			
			Matrix A1x1 = A1.modPow(x1, p);
			Matrix A2x2 = A2.modPow(x2, p);
			
			
			//  Compute the secret key
			
			Matrix E = A1x1 .multiply(Z) .mod(p)
			
			   .multiply(A2x2) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix)
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size88 )
		{
		
			//          A---X1           A---K1           Y---K1     Z---X1
			//   Y  =   |     ,   Z  =   |     ,   E  =   |      ==  |
			//          X2               K2               K2         X2
			
			
			int matrices = 1, rows = 2, cols = rows, radix = 16;
			
			int s = z.trim().length() / rows / cols / 1;
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[rows*cols];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(i*s, (i+1)*s), radix);
			
			Matrix Z = new Matrix(new Number[][]
			
			    { { zn[0], zn[1] }, { zn[2], zn[3] } });
			
			
			//  Define the private matrices
			
			Matrix X1 = new Matrix( new Number[][]
			
			    { { x[0], x[1] }, { x[1], x[0] } } );
			
			Matrix X2 = new Matrix( new Number[][]
			
			    { { x[2], x[3] }, { x[3], x[2] } } );
			
			
			//  Compute the secret key
			
			//  Matrix Temp1 = Z.multiply(X1) .mod(p);
			Matrix Temp2 = Z.rotate(1).multiply(X2).rotate(-1) .mod(p);
			
			//  Matrix E1 = Temp1.rotate(1).multiply(X2) .mod(p);
			Matrix E2 = Temp2.multiply(X1) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E2.toIntegerString(s, radix), radix)
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size72 )
		{
		
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			int digits = z.trim().length();
			
			int cubes = 3, r1 = 2, r2 = r1, r3 = r2;
			
			int s = digits / r1 / r2 / r3 / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			if ((digits % (r1*r2*r3)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + r1*r2*r3);
			
			
			//  Initialize the cubes
			
			Number[][][][] elements;
			
			elements = new Number[cubes][r1][r2][r3];
			
			for (int m = 0; m < cubes; m++)
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			
			    elements[m][i][j][k] = new Number( pi16.substring(
			
				m*r1*r2*r3*s + i*r2*r3*s + j*r3*s + (k+0)*s,
				m*r1*r2*r3*s + i*r2*r3*s + j*r3*s + (k+1)*s), radix);
			
			Cube A1 = new Cube(elements[0]);
			Cube A2 = new Cube(elements[1]);
			Cube B  = new Cube(elements[2]);
			
			
			//  Reduce the size of x1, x2 to 4 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			x2 = x2 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[r1*r2*r3];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(i*s, (i+1)*s), radix);
			
			Cube Z = new Cube( new Number[][][]
			
			    { { { zn[0], zn[1] }, { zn[2], zn[3] } },
			      { { zn[4], zn[5] }, { zn[6], zn[7] } } } );
			
			
			//  Compute A1^x1, A2^x2
			
			Cube A1x1 = A1.modPow(x1, p);
			Cube A2x2 = A2.modPow(x2, p);
			
			
			//  Compute the secret cube
			
			Cube E = A1x1 .multiply(Z) .mod(p)
			
			    .multiply(A2x2) .mod(p)
			
				.multiply(x0) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size96 )
		{
		
			//              x1      x2
			//   Y  =  x  A1   B  A2
			//
			//              k1      k2
			//   Z  =  k  A1   B  A2
			//
			//              x1      x2
			//   E  =  x  A1   Z  A2
			
			
			int digits = z.trim().length();
			
			int tesseracts = 3, r1 = 2, r2 = r1, r3 = r2, r4 = r3;
			
			int s = digits / r1 / r2 / r3 / r4 / 1, radix = 16;
			
			//  for complex divide by 2 instead of 1
			
			if ((digits % (r1*r2*r3*r4)) != 0)
			
			    System.out.println("Key size" +
			
			        " must be divisible by " + r1*r2*r3*r4);
			
			
			//  Initialize the tesseracts
			
			Number[][][][][] elements;
			
			elements = new Number[tesseracts][r1][r2][r3][r4];
			
			for (int m = 0; m < tesseracts; m++)
			
			for (int i = 0; i < r1; i++)
			for (int j = 0; j < r2; j++)
			for (int k = 0; k < r3; k++)
			for (int l = 0; l < r4; l++)
			
			    elements[m][i][j][k][l] = new Number( pi16.substring(
			
				m*r1*r2*r3*r4*s + i*r2*r3*r4*s + j*r3*r4*s + k*r4*s + (l+0)*s,
				m*r1*r2*r3*r4*s + i*r2*r3*r4*s + j*r3*r4*s + k*r4*s + (l+1)*s), radix);
			
			
			Tesseract A1 = new Tesseract(elements[0]);
			Tesseract A2 = new Tesseract(elements[1]);
			Tesseract B  = new Tesseract(elements[2]);
			
			
			//  Reduce the size of x1, x2 to 4 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			x2 = x2 .and( new Number(2).pow(p.bitCount()*4) .subtract(1) );
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[r1*r2*r3*r4];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(i*s, (i+1)*s), radix);
			
			Tesseract Z = new Tesseract( new Number[][][][]
			
			    { { { { zn[0],  zn[1]  }, { zn[2],  zn[3]  } },
			        { { zn[4],  zn[5]  }, { zn[6],  zn[7]  } } },
			      { { { zn[8],  zn[9]  }, { zn[10], zn[11] } },
			        { { zn[12], zn[13] }, { zn[14], zn[15] } } } } );
			
			
			//  Compute A1^x1, A2^x2
			
			Tesseract A1x1 = A1.modPow(x1, p);
			Tesseract A2x2 = A2.modPow(x2, p);
			
			
			//  Compute the secret tesseract
			
			Tesseract E = A1x1 .multiply(Z) .mod(p)
			
			    .multiply(A2x2) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size76 )
		{
		
			//         -x'  x   x'     -k'-x' -1   k x      k'+ x'
			//  E  =  A   Z   A   ==  A      B    C    B   A
			
			//  Initialize the matrix A
			
			int rows = 2, cols = rows, matrices = 3, radix = 16;
			
			int s = z.trim().length() / rows / cols;
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*rows*s + (j+0)*s,
				k*rows*cols*s + i*rows*s + (j+1)*s), radix);
			
			
			    Matrix A = new Matrix(elements[0]);
			//  Matrix B = new Matrix(elements[1]);
			//  Matrix C = new Matrix(elements[2]);
			
			
			//  Initialize the matrix Z
			
			String str = z.trim();
			
			Number[] zn = new Number[rows*cols];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(str.substring(i*s, (i+1)*s), radix);
			
			Matrix Z = new Matrix(new Number[][]
			
			    { { zn[0], zn[1] }, { zn[2], zn[3] } });
			
			
			//  Reduce the size of the private keys to 2 log2 p
			
			for (int i = 0; i < x.length; i++)
			
			    x[i] = x[i] .and( new Number(2)
			
				.pow(p.bitCount() * 2).subtract(1) );
			
			
			//  Compute the secret matrix
			
			Matrix    Ax1 = A  .modPow(x[1], p);
			Matrix invAx1 = Ax1.modInverse(p);
			
			Matrix E = invAx1 .multiply(Z.modPow(x[0], p))
			
			    .mod(p) .multiply(Ax1) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size120 )
		{
		
			//  Y = A (x) X   Z = A (x) K   E = Y * K == - Z * X   or
			//  Y = A (x) X   Z = K (x) A   E = Y * K ==   Z * X
			
			
			int digits = z.length();
			
			int s = digits / 3, radix = 16;
			
			
			//  Initialize the public vector Z
			
			Number[] elements = new Number[3];
			
			for (int i = 0; i < 3; i++)
			
			    elements[i] = new Number(
			
				z.substring(i*s, (i+1)*s), 16);
			
			Vector Z = new Vector(elements);
			
			
			//  Define the private vector X
			
			Number n = new Number(radix) .pow(s);
			
			for (int i = 0; i < x.length; i++) x[i] = x[i] .mod(n);
			
			Vector X = new Vector( new Number[] { x[0], x[1], x[2] } );
			
			
			//  Compute the secret volume of the parallelepiped
			//
			//  == the parallelogram Z times the private vector X
			//  or the parallelogram Y times the private vector K
			//
			//  E  =  Z * X  ==  - Y * K
			
			Number E = Z .dot(X) .mod(p);
			
			
			
			////////////////////////////////////////////////////////////////
			
			
			if (false)
			{
				//  Test if a cryptanalyst can compute the same volume as E1 =
				//  Y1 * K1 == - Z1 * X1 without using X1 or K1 by forming a
				//  matrix M1 containing the public vectors A1, Y1, and Z1 and
				//  then computing the determinant.
				
				//  Define a public vector A1
				
				String[] pidigits = new String[3];
				
				final int s1 = s * 3/4;
				
				for (int i = 0; i < pidigits.length; i++)
				
				    pidigits[i] = pi16.substring(i*s1, (i+1)*s1);
				
				Number a1 = new Number(pidigits[0],radix);
				Number a2 = new Number(pidigits[1],radix);
				Number a3 = new Number(pidigits[2],radix);
				
				Vector A1 = new Vector( new Number[] { a1, a2, a3 } );
				
				
				//  Define two private vectors X1 and K1
				
				//  Number n = new Number(radix) .pow(s);
				
				Number[] x1 = new Number[3];
				Number[] k1 = new Number[3];
				
				for (int i = 0; i < x1.length; i++) x1[i] = new Number(Math.random(0xffffffffL));
				for (int i = 0; i < k1.length; i++) k1[i] = new Number(Math.random(0xffffffffL));
				
				Vector X1 = new Vector( new Number[] { x1[0], x1[1], x1[2] } );
				Vector K1 = new Vector( new Number[] { k1[0], k1[1], k1[2] } );
				
				
				//  Compute the public key vectors / parallelograms
				
				Vector Y1 = A1 .cross(X1) .mod(p);
				Vector Z1 = A1 .cross(K1) .mod(p);
				
				//  Compute the volume E1 = Y * K == - Z * X
				
				Number E0 = Y1 .dot(K1) .mod(p);
				Number E1 = Z1 .dot(X1) .mod(p) .negate(p);
				
				if (!E0.equals(E1)) throw new ArithmeticException();
				
				
				//  Form the matrix of the vectors A1, Y1, and Z1
				//  to try to find the volume E1 = Y * K == - Z * X
				//  without using X1 or K1
				
				Matrix M1 = new Matrix(3, 3);
				
				Number[] vec_a1 = A1.toArray();
				Number[] vec_y1 = Y1.toArray();
				Number[] vec_z1 = Z1.toArray();
				
				M1.setRow(vec_a1, 0);
				M1.setRow(vec_y1, 1);
				M1.setRow(vec_z1, 2);
				
				Number D1 = M1 .determinant(p);
				Number D2 = M1 .determinant(p).negate(p);
				
				System.out.println("E1 == " + E1);
				System.out.println("D1 == " + D1);
				System.out.println("D2 == " + D2);
			}
			
			
			////////////////////////////////////////////////////////////////
			
			
			
			//  Either the sender or the receiver can negate
			//  the value of the secret key, but not both
			
			if (type == send_encrypt) E = E .negate(p);
			
			//  else if (type == receive_decrypt) {  } // do nothing
			
			if ((type != send_encrypt) && (type != receive_decrypt))
			
			    throw new IllegalArgumentException();
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return E .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		
		else if ( z.trim().length() == size192 )
		{
		
			//  Y = X1 (x) X2   Z = K1 (x) K2
			//
			//  E = det(Z, X1, X2) == det(Y, K1, K2) 
			
			
			int digits = z.length();
			
			final int t = 3, bits = 128, s = digits / t / 1, radix = 16;
			
			
			//  Initialize the public vector Z
			
			Number[] Z = new Number[3];
			
			for (int i = 0; i < 3; i++)
			
			    Z[i] = new Number(z.substring(i*s, (i+1)*s), 16);
			
			
			Number mod = new Number(radix).pow(s);
			
			for (int i = 0; i < Z.length; i++)
			
			    if (Z[i].isGreaterThan(mod.divide(2)))
			
				Z[i] = mod.subtract(Z[i]) .multiply(-1);
			
			
			//  Define the private vectors X1, X2 (or K1, K2)
			
			Number d = new Number(2).pow(bits);
			
			Number ones = d.subtract(1);
			
			Number[] numbers1 = new Number[t];
			Number[] numbers2 = new Number[t];
			
			for (int i = 0; i < t; i++)
			{
				//  Extract the upper and lower halves of x[0] to x[t-1]
				
				numbers1[i] = new Number(x[i]).divide(d).and(ones);
				numbers2[i] = new Number(x[i]).divide(1).and(ones);
				
				numbers1[i].clearBit(bits-1);
				numbers2[i].clearBit(bits-1);
				
				numbers1[i].setBit(bits-2);
				numbers2[i].setBit(bits-2);
			}
			
			Number[] X1 = new Number[] { numbers1[0], numbers1[1], numbers1[2] };
			Number[] X2 = new Number[] { numbers2[0], numbers2[1], numbers2[2] };
			
			
			//  Compute the determinant of { Z, X1, X2 }  or  { Y, K1, K2 }
			
			Matrix matrix = new Matrix(new Number[][] { Z, X1, X2 });
			
			//  Determinant1() and determinant() give the same answer but
			//  determinant1 uses integers whereas determinant() uses frac-
			//  tions, inverses and divisions to reduce the matrix to echelon
			//  form. Determinant() also returns an integer if the fractional
			//  part of the result is zero or if the elements of the original
			//  matrix are all zero. For matrices larger than 3 x 3 or 4 x 4,
			//  determinant() would have to be used because determinant1() has
			//  an exponential running time.
			
			Number E1 = matrix.determinant1();
			Number E  = matrix.determinant ();
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return E .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		
		else if ( z.trim().length() == size112 )
		{
		
			//                x1              x1
			//  | E1 |    | M1   | | Z1 | | M2   |
			//  |    | -- |      | |    | |      |
			//  |    | -- |   x2 | |    | |   x2 |
			//  | E2 |    | M1   | | Z2 | | M2   |
			
			//  Block array exponentiation, multiplication, and addition
			
			//  Initialize the matrices Z1 and Z2
			
			int rows = 2, cols = rows, equations = 2, matrices = 5;
			
			int digits = z.trim().length(), radix = 16;
			
			int s = digits / rows / cols / equations;
			
			Number[] zn = new Number[2*2*2];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number( z.substring(
			
				(i+0)*s, (i+1)*s), radix );
			
			Matrix Z1 = new Matrix(new Number[][]{{ zn[0], zn[1] }, { zn[2], zn[3] }});
			Matrix Z2 = new Matrix(new Number[][]{{ zn[4], zn[5] }, { zn[6], zn[7] }});
			
			
			//  Define the matrices A, B, C, M1, M2
			
			Number[][] a = new Number[matrices][rows*cols];
			
			for (int k = 0; k <  matrices; k++)
			for (int i = 0; i < rows*cols; i++)
			
			    a[k][i] = new Number( pi16.substring(
			
				k*rows*cols*s + s*(i+0),
				k*rows*cols*s + s*(i+1)), radix );
			
			Matrix A, B, C, M1, M2;
			
			A  = new Matrix(new Number[][]{{ a[0][0], a[0][1] }, { a[0][2], a[0][3] }});
			B  = new Matrix(new Number[][]{{ a[1][0], a[1][1] }, { a[1][2], a[1][3] }});
			C  = new Matrix(new Number[][]{{ a[2][0], a[2][1] }, { a[2][2], a[2][3] }});
			M1 = new Matrix(new Number[][]{{ a[3][0], a[3][1] }, { a[3][2], a[3][3] }});
			M2 = new Matrix(new Number[][]{{ a[4][0], a[4][1] }, { a[4][2], a[4][3] }});
			
			
			//  Reduce the size of the private key to 2 log2 p
			
			Number x0 = x[0], x1 = x[1], x2 = x[2];
			
			x1 = x1 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			x2 = x2 .and(new Number(2).pow(p.bitCount()*2).subtract(1));
			
			
			//  Compute the secret matrix E1 + E2
			
			Matrix M11 = M1 .modPow(x1, p),  M12 = M1 .modPow(x2, p);
			Matrix M21 = M2 .modPow(x1, p),  M22 = M2 .modPow(x2, p);
			
			Matrix E1 = M11 .multiply(Z1) .multiply(M21) .mod(p);
			Matrix E2 = M12 .multiply(Z2) .multiply(M22) .mod(p);
			
			Matrix E12 = E1 .add(E2) .mod(p) .multiply(x0) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E12 .toIntegerString(s, radix), radix)
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		
		else if ( z.trim().length() == size150 )
		{
		
			//  | x1[i] u^[i]  x2[i] u^[i] | | a1[i] u^[i]  a2[i] u^[i] | | x3[i] u^[i]  x4[i] u^[i] |
			//  |                          | |                          | |                          |
			//  | x2[i] u^[i]  x1[i] u^[i] | | a3[i] u^[i]  a4[i] u^[i] | | x4[i] u^[i]  x3[i] u^[i] |
			
			//  30 terms / element x 4 elements x 5 bits / term x 1 digit / 4 bits == 150 digits
			
			
			//  Initialize z
			
			int length = z.trim().length(), digits = length;
			
			String z0 = new Number(z.trim(), 16) .toString(16);
			
			int p = 31, q = p-1, t = q, bits = 5, radix = 16;
			
			
			//  Convert the string to number
			
			Number number = new Number(z0, 16);
			
			
			//  Unpack the 5-bit coefficients
			
			Number number1 = number;
			
			int[] values = new int[2*2*t];
			
			for (int i = 0; i < values.length; i++)
			{
				values[values.length -1 -i] = number1 .and(
				
				    new Number(2).pow(bits).subtract(1) ) .intValue();
				
				number1 = number1 .shiftRight(bits) .trim();
			}
			
			
			//  Initialize the coefficients of Z
			
			int[][][][] Z = new int[2][2][t][2];
			
			for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
				int value = values[t*(2*i + j) + k];
				
				//  int coefficient = value >> 5;
				//  int    exponent = value & 0x1f;
				
				int coefficient = value, exponent = k;
				
				Z[i][j][k][0] = coefficient;
				Z[i][j][k][1] = exponent;
			}
			
			
			//  Define the private coefficients
			
			String xstr = "";
			
			for (int i = 0; i < x.length; i++)
			
			    xstr += x[i].toString(16);
			
			
			//  Initialize the coefficients
			
			int[][] c = new int[4][t];
			
			for (int i = 0; i < 4; i++)
			for (int j = 0; j < t; j++)
			{
				//  Copy 2 hex digits == 8 bits
				
				int value = new Number(xstr .substring(
				
				    2*(i*t + j), 2*(i*t + (j+1))), radix) .intValue();
				
				c[i][j] = value % p;
			}
			
			
			//  Initialize the matrix X1
			
			int[][][][] X1 = new int[2][2][t][2];
			
			for (int i = 0; i < 1; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X1[i][j][k][0] = c[2*i+j][k];
			     X1[i][j][k][1] = k;
			}
			
			for (int i = 1; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X1[i][j][k][0] = X1[i-1][(j+1)%2][k][0];
			     X1[i][j][k][1] = k;
			}
			
			
			//  Initialize the matrix X2
			
			int[][][][] X2 = new int[2][2][t][2];
			
			for (int i = 0; i < 1; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X2[i][j][k][0] = c[2*(i+1)+j][k];
			     X2[i][j][k][1] = k;
			}
			
			for (int i = 1; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
			     X2[i][j][k][0] = X2[i-1][(j+1)%2][k][0];
			     X2[i][j][k][1] = k;
			}
			
			
			//  Compute the secret key
			
			int[][][][] ZX = Polynomial.multiply(Z,  X2, p, q);
			int[][][][] E1 = Polynomial.multiply(X1, ZX, p, q);
			
			
			//  Extract the coefficients and exponents
			
			values = new int[2*2*t];
			
			for (int i = 0; i < 2; i++)
			for (int j = 0; j < 2; j++)
			for (int k = 0; k < t; k++)
			{
				int coefficient = E1[i][j][k][0];
				int    exponent = E1[i][j][k][1];
				
				//  int value = (coefficient << 5) + exponent;
				
				if (exponent != k) throw new ArithmeticException();
				
				int value = coefficient;
				
				values[(2*i+j)*t + k] = value;
			}
			
			
			//  Compress the 5-bit int array to a 32-bit array
			
			Number E = new Number(0);
			
			for (int i = 0; i < t; i++)
			
			    E = E .shiftLeft(32, bits) .add(values[i]) .trim();
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return  E .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size60 )
		{
		
			//  A^x C B^x + ... + A^0 C B^0
			
			int rows = 2, cols = rows, matrices = 3;
			
			int radix = 16;
			
			int s = z.trim().length() / rows / cols;
			
			String str = z.trim();
			
			Number[] zn = new Number[rows*cols];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number( str.substring(
			
				(i+0)*s, (i+1) * s), radix );
			
			Matrix Z = new Matrix(zn, 2, 2);
			
			Number x0 = new Number(x[0]).and(new Number(2)
			
			    .pow(128).subtract(1)); x0.setBit(127);
			
			Number[][][] elements = new Number[matrices][rows][cols];
			
			for (int k = 0; k < matrices; k++)
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[k][i][j] = new Number( pi16.substring(
			
				k*rows*cols*s + i*rows*s + (j+0)*s,
				k*rows*cols*s + i*rows*s + (j+1)*s), radix);
			
			Matrix A0 = new Matrix(elements[0]);
			Matrix B0 = new Matrix(elements[1]);
			Matrix C0 = new Matrix(elements[2]);
			
			//  Compute the secret matrix
			
			Matrix E = Polynomial.modPow(A0, B0, C0, Z, x0, p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size144 )
		{
		
			//  E  =  X1 [ Z ] X2  ==  X1 [ K1 A K2 ] X2
			
			
			int rows = 64, cols = rows;
			
			int t = rows, bits = 9, radix = 16;
			
			int length = z.trim().length(), digits = length;
			
			
			//  Read the base-16 digits and convert to base-2
			
			String z0 = new Number(z.trim(), radix)
			
			    .toString(2) .replaceAll(" ", "");
			
			
			//  Prepend zeros and convert the string to array
			
			while (z0.length() < cols*bits)  z0 = "0" + z0;
			
			Number[] arrayz0 = new Number(z0, 2)
			
			    .toArray(new Number(2).pow(bits));
			
			Matrix Z  = new Matrix(arrayz0, -1);
			
			
			//  Define the private Latin squares
			
			Number[] array1 = Arrays.copyOfRange(x[0].toArray(256, 2), 0, t);
			Number[] array2 = Arrays.copyOfRange(x[1].toArray(256, 2), 0, t);
			
			int[] x1 = new int[t], x2 = new int[t];
			
			for (int i = 0; i < t; i++) x1[i] = array1[i].intValue();
			for (int i = 0; i < t; i++) x2[i] = array2[i].intValue();
			
			for (int i = 0; i < t; i++) if (Math.countOneBits(x1) != t/2) x1[i] ^= 1; else break;
			for (int i = 0; i < t; i++) if (Math.countOneBits(x2) != t/2) x2[i] ^= 1; else break;
			
			Matrix X1 = new Matrix(x1, +1);
			Matrix X2 = new Matrix(x2, +1);
			
			
			//  Compute the secret key
			
			
			//  Multiply the top row
			
			Matrix temp1 = X1 .multiply(Z, 1);
			
			temp1 = new Matrix(temp1.getRow(0), -1);
			
			//  Multiply the top row
			
			Matrix temp2 = temp1 .multiply(X2, 1);
			
			temp2 = new Matrix(temp2.getRow(0), -1);
			
			//  Copy the top row
			
			Number[] e0 = new Matrix(temp2).getRow(0);
			
			
			//  Convert the array to number
			
			StringBuilder sb = new StringBuilder();
			
			for (int i = 0; i < e0.length; i++)
			
			    sb.append(e0[i].toString(radix));
			
			String Estring = sb.toString();
			
			
			//  Reduce E modulo F8 and return the secret key
			
			Number E = new Number(Estring, radix);
			
			return E.mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size56 )
		{
		
			//           x1   x2   |            k1 x1   k1 x2
			//  Y1  =  A    B      |   E1  =  A       B
			//                     |
			//           x1   x2   |            k2 x1   k2 x2
			//  Y2  =  B    C      |   E2  =  B       C
			//
			//
			//  Block array exponentiation and multiplication
			//
			//  { E1, E2 } = { Z1 ^ x1, Z2 ^ x2 } ,  E = E1 E2
			
			
			int p = 23, q = p-1, t = q, bits = 5, radix = 16;
			
			int digits = z.trim().length();
			
			
			//  Convert the string to number
			
			Number number = new Number(z.trim(), 16);
			
			
			//  Unpack the 5-bit coefficients using subtracts and shifts
			
			Number number1 = number;
			
			int[] values = new int[2*t];
			
			for (int i = 0; i < values.length; i++)
			{
				values[values.length -1 -i] = number1 .and(
				
				    new Number(2).pow(bits).subtract(1) ) .intValue();
				
				number1 = number1 .shiftRight(bits) .trim();
			}
			
			
			//  Initialize the coefficients of Z1 and Z2
			
			int[][] z1 = new int[t][2];
			int[][] z2 = new int[t][2];
			
			for (int i = 0; i < t; i++)
			{
				int value1 = values[0*t + i];
				int value2 = values[1*t + i];
				
				//  int coefficient = value >> 5;
				//  int    exponent = value & 0x1f;
				
				int coefficient1 = value1, exponent1 = i;
				int coefficient2 = value2, exponent2 = i;
				
				z1[i][0] = coefficient1; z1[i][1] = exponent1;
				z2[i][0] = coefficient2; z2[i][1] = exponent2;
			}
			
			
			Polynomial Z1 = new Polynomial(z1, p, q, t);
			Polynomial Z2 = new Polynomial(z2, p, q, t);
			
			
			//  Reduce the size of the private keys
			
			x[0] = x[0] .and(new Number(2).pow(digits*2).subtract(1));
			x[1] = x[1] .and(new Number(2).pow(digits*2).subtract(1));
			
			int[] x1 = x[0] .toIntArray();
			int[] x2 = x[1] .toIntArray();
			
			
			//  Compute the secret key E = E1 E2
			
			Polynomial E1 = Z1 .modPow(x1);
			Polynomial E2 = Z2 .modPow(x2);
			
			Polynomial E = E1.multiply( E2 ) .add();
			
			
			//  Extract the coefficients and exponents
			
			values = new int[1*t];
			
			for (int i = 0; i < t; i++)
			{
				int coefficient = E.get(i,0);
				int    exponent = E.get(i,1);
				
				//  int value = (coefficient << 5) + exponent;
				
				if (exponent != i) throw
				
				    new ArithmeticException();
				
				int value = coefficient;
				
				values[i] = value;
			}
			
			//  Compress the 5-bit int array to a 32-bit array
			
			Number E0 = new Number(0);
			
			for (int i = 0; i < t; i++)
			
			    E0 = E0 .shiftLeft(32, bits) .add(values[i]) .trim();
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return  E0 .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size80 )
		{
		
			//         -x1   x   x1      -k1-x1   k x   k1+x1
			//  E  =  A    Z   A    ==  A       B     A
			
			
			//  Initialize the public quaternion Z
			
			final int radix = 16, t = 4, s = z.trim().length() / t;
			
			Number[] zn = new Number[t];
			
			for (int i = 0; i < zn.length; i++)
			
			    zn[i] = new Number(z.substring(s*i, s*(i+1)), 16);
			
			Quaternion Z = new Quaternion(
			
			    new Number[] { zn[0], zn[1], zn[2], zn[3] });
			
			
			//  Define the public quaternion A
			
			Number[] a = new Number[2*t];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = new Number(pi16.substring(s*i, s*(i+1)), 16);
			
			Quaternion A = new Quaternion( new Number[] { a[0], a[1], a[2], a[3] } );
			Quaternion B = new Quaternion( new Number[] { a[4], a[5], a[6], a[7] } );
			
			Quaternion invA = A.modInverse(p);
			
			
			//  Define the private variables
			
			Number x0 = x[0], x1 = x[1];
			
			Number n = new Number(radix).pow(s*t);
			
			x0 = x0.mod(n);  x1 = x1.mod(n);
			
			
			//  Compute the secret quaternion
			
			Quaternion Z2x0 = Z .modPow(x0, p);
			Quaternion A2x1 = A .modPow(x1, p);
			
			Quaternion E = invA .modPow(x1, p) .multiply(Z2x0)
			
			    .mod(p) .multiply(A2x1) .mod(p);
			
			
			//  Convert the quaternion to an integer string
			
			Number E0 = new Number(E.toIntegerString(s, 16), 16);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return E0 .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size108 )
		{
			//          x              k+x
			//  E  =  A   Z   X  ==  A     K  X
			
			
			int rows = 3, cols = rows, radix = 16;
			
			int s = z.trim().length() / rows / cols;
			
			
			//  Initialize the matrix A
			
			Number[][] elements = new Number[rows][cols];
			
			for (int i = 0; i < rows; i++)
			for (int j = 0; j < cols; j++)
			
			    elements[i][j] = new Number( pi16.substring(
			
				i*rows*s + s*(j+0), i*rows*s + s*(j+1)), radix);
			
			Matrix A = new Matrix(elements);
			
			
			//  Reduce the size of the private keys
			
			Number n = new Number(radix).pow(s);
			
			for (int i = 1; i < x.length; i++)
			
			    x[i] = x[i] .mod(n);
			
			
			//  Define the private matrix X
			
			Matrix X = new Matrix( new Number[]
			
			    { x[1], x[2], x[3] }, 1) .mod(p);
			
			
			//  Initialize the public matrix Z
			
			Matrix Z = new Matrix(z, radix, rows, cols);
			
			
			//  Compute the secret matrix
			
			Matrix E = A.modPow(x[0], p) .multiply(Z) .multiply(X) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		else if ( z.trim().length() == size84 )
		{
		
			//         -1   x              -1   k x
			//  E  =  X   Z   X  == ( K X )   A    ( K X )
			
			
			int s = z.trim().length() / 6, radix = 16;
			
			
			//  Convert the number string to matrix
			//  (Note that there are only 6 elements)
			//
			//        |  1   2   3   4  |
			//        |                 |
			//        |  4   5   2   6  |
			//        |                 |
			//        |  3   4   1   2  |
			//        |                 |
			//        |  2   6   4   5  |
			
			
			String string = z.trim();
			
			Number z1 = new Number(string.substring(0*s, 1*s), radix);
			Number z2 = new Number(string.substring(1*s, 2*s), radix);
			Number z3 = new Number(string.substring(2*s, 3*s), radix);
			Number z4 = new Number(string.substring(3*s, 4*s), radix);
			Number z5 = new Number(string.substring(4*s, 5*s), radix);
			Number z6 = new Number(string.substring(5*s, 6*s), radix);
			
			
			//  Initialize the public matrix Z
			
			Matrix Z = new Matrix( new Number[][]
			{
				{ z1, z2, z3, z4 },
				{ z4, z5, z2, z6 },
				{ z3, z4, z1, z2 },
				{ z2, z6, z4, z5 }
			} );
			
			
			//  Define the private matrix X
			
			Number n = new Number(radix) .pow(s);
			
			for (int i = 0; i < x.length; i++) x[i] = x[i] .mod(n);
			
			Matrix X = new Matrix( new Number[][]
			{
				{ x[1], x[2], x[3], x[4] },
				{ x[2], x[1], x[4], x[3] },
			        { x[3], x[4], x[1], x[2] },
				{ x[4], x[3], x[2], x[1] },
			} );
			
			
			//  Compute the secret matrix
			
			Matrix E = X.modInverse(p) .mod(p)
			
			    .multiply( Z.modPow(x[0], p) ) .mod(p)
			
				.multiply( X ) .mod(p);
			
			
			//  Reduce E modulo F8 and return the secret key
			
			return new Number(E.toIntegerString(s, radix), radix )
			
			    .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		
		
		else if (z.trim().length() == size768)
		{
			//  Vector dot product cipher
			
			//  if (type == recipient / decryption) the sum of X[] is computed from z = b = A[] * X[]
			//  if (type ==    sender / encryption) the sum of X[] is chosen and z is ignored
			
			int digits = z.trim().length();
			
			final int s, t, radix, bits; Number ones, d;
			
			t = 6; s = digits / t; radix = 16; bits = 128;
			
			d = new Number(2).pow(bits);
			
			ones = d.subtract(1);
			
			if ((s % 4) != 0) throw new
			
			    IllegalArgumentException();
			
			
			Number M = null;
			
			if (type == 1)
			{
				//  Decrypt the message or compute X[] from b = A[] * X[]
				//
				//  Initialize b from z substring because z is padded to
				//  make the one-time key size equal to the static key size
				
				int zlen1 = s + s/4;
				
				String zstr1 = z.substring(0, zlen1);
				
				Number b = new Number(zstr1, 16);
				
				
				//  Choose a random 128-bit radix or base B
				//  xor the upper and lower halves of x[0]
				//  because only 128 bits are required for B
				
				Number upper = new Number(x[0]).divide(d).and(ones);
				Number lower = new Number(x[0]).divide(1).and(ones);
				
				Number B = upper.xor(lower); B.setBit(bits-1);
				
				
				//  Read the base coefficients
				
				Number[] coefficients = b.toArray(B);
				
				
				//  Read the sum of X[]
				
				M = coefficients[2];
			}
			
			
			else // if (type == 2)
			{
			
				//  Choose the sender's random secret key
				//
				//  X[] = f(recipient's public key y, sender's private key k)
				
				String publickey = z;
				
				
				//  Choose the secret key X
				
				Number[] X = new Number[t];
				
				for (int i = 0; i < t; i++)
				
				    X[i] = new Number(x[i]) .and(ones);
				
				for (int i = 0; i < t; i++)
				{
					X[i] .clearBit(bits-1);
					X[i] .clearBit(bits-2);
					X[i] .clearBit(bits-3);
					X[i] .clearBit(bits-4);
					X[i]   .setBit(bits-5);
				}
				
				
				//  Convert the vector X to a number
				
				M = new Number(0);
				
				for (int i = 0; i < X.length; i++)
				
				    M = M .add(X[i]);
			}
			
			
			//  Reduce M modulo F8 and return the secret key
			
			return M .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		
		else if (z.trim().length() == sizeknapsack1)
		{
			//  Merkle-Hellman / knapsack cipher
			
			//  if (type == recipient / decryption) m is computed from z = b = c[] m[]
			//  if (type ==    sender / encryption) m is chosen and z is ignored
			
			int digits = z.trim().length();
			
			int pbits = -1, nbits = -1;
			
			int k = new Number(digits)
			
			    .sqrt() .round() .intValue();
			
			while ((k % 4) != 0) k--;
			
			pbits = 4; nbits = pbits*k + 4*1;
			
			final int offset = 16;
			final int k1 = offset*2;
			final int bits = k*pbits;
			
			Number[] m = null;
			
			
			
			long starttime = System.nanoTime();
			
			
			if (type == 1)
			{
				//  Decrypt the message or compute m[] == ssss(b, p)
				//
				//  (ssss = solve superincreasing subset sum problem)
				
				
				//  Recovering the secret key m[]
				//
				//  Use the subset sums
				//
				//  b0 = c[] (m[] + e[]) (mod p) and
				//
				//  b1 = r[][] (m[] + e[]) to solve for m[];
				//                            T
				//  since b0 = (s0 a[] + r[][] s[] mod n) (m[] + e[])
				//
				//  multiply b0 by s0 ^-1 (mod n) to get
				//
				//  b' = a[] m[] + (r[][] (m[] + e[])) s[] s0^-1 (mod n);
				//
				//  compute and subtract (r[][] (m[] + e[])) s[] s0^-1 (mod n)
				//
				//  to obtain the superincreasing sum b2 = a[] m[]
				//
				//  and then solve for the permuted secret key m'[];
				//
				//  unpermutate m'[] or discard the lower permuted
				//
				//  (m[] + e[]) elements to recover m[].
				
				
				//  Define the multiplier modulus
				
				Number p = new Number(2).pow(pbits);
				
				
				//  Define the superincreasing sequence
				
				Number[] a = new Number[k];
				
				for (int i = 0; i < a.length; i++)
				
				    a[i] = new Number(2).pow(pbits*i);
				
				if (!isSuperincreasingSequence(a, p))
				{
					System.out.println("a == " + Arrays.toString(a));
					
					throw new ArithmeticException();
				}
				
				
				//  Initialize the private modulus n
				
				Number n = x[0] .mod(
				
				    new Number(2).pow(nbits));
				
				n .setBit(nbits - 1);
				
				n = n .nextPrime();
				
				int c_digits = (int) n.bitCount() / 4;
				
				
				
				//  Initialize the secret number r and vector s[]
				//
				//  the mod n doesn't reduce the size of x[]
				//  unless the size of n is less than 256 bits
				
				//  Define the array multiplier r
				
				Number r  = new Number(x[1]) .mod(n);
				Number s0 = new Number(x[2]) .mod(n);
				
				r.setBit(nbits -1);
				
				if (!r.isCoprimeWith(n)) throw
				
				    new ArithmeticException();
				
				Number[] s1 = new Number[k1];
				
				s1[0] = new Number(
				
				    hash2(s0.toByteArray(32), bits));
				
				for (int i = 1; i < s1.length; i++)
				
				    s1[i] = new Number( hash2(s1[i-1]
				
					.toByteArray(32), bits) );
				
				for (int i = 0; i < s1.length; i++)
				
				    s1[i] = s1[i] .mod(n);
				
				
				//  Initialize b from z substring because z is padded to
				//  make the one-time key size equal to the static key size
				
				int zlen1 = (nbits + pbits + Math.log2(k) + 3) / 4;
				
				String zstr1 = z.substring(0, zlen1);
				
				Number b = new Number(zstr1, 16);
				
				//  System.out.println("one-time public key == " + zstr1);
				
				
				
				//  Initialize the vector product r[][] m[] from z substring
				
				int zlen2 = (nbits + pbits + Math.log2(k) + 3) / 4;
				
				Number[] r1_m = new Number[k1];
				
				for (int i1 = 0; i1 < k1; i1++)
				{
					String zstr2 = z.substring(
					
					    zlen1, zlen1 + zlen2);
					
					r1_m[i1] = new Number(zstr2, 16);
					
					zlen1 += zlen2;
				}
				
				
				//  Read more numbers from the sender's key
				//
				//  zlen2 = (nbits + pbits + Math.log2(k) + 3) / 4;
				//
				//  String zstr2 = z.substring(zlen1, zlen1 + zlen2);
				//
				//  Number ... = new Number(zstr2, 16);
				
				
				//  System.out.println("\n");
				//
				//  for (int i = 0; i < r1_m.length; i ++)
				//
				//      System.out.print(r1_m[i].toString(16) + "  ");
				
				
				//  Solve the superincreasing subset sum problem for
				//
				//  x[] = ssss(a[], b1, p) using the private key a
				
				
				
				//  Multiply the subset sum by 1 / r
				
				Number inv_r = r.modInverse(n);
				
				b = b .multiply(inv_r);
				
				
				//  Compute the product of (r[][] m[]) s[]
				
				for (int i1 = 0; i1 < k1; i1++)
				
				    s1[i1] = r1_m[i1] .multiply(s1[i1]);
				
				
				//  Subtract the r1[][] s1[] from the subset sum
				
				for (int i1 = 0; i1 < k1; i1++)
				
				    b = b .add( s1[i1].multiply(inv_r).negate(n) );
				
				b = b .mod(n);
				
				
				
				/********************************
				
				
				//  (This code is used if small random errors
				//  are added to the static public key)
				//
				//  Calculate the product t r^-1 (mod n)
				//
				//  If t.add(0) is changed to t.add(1,2,3,...)
				//  the method will find solutions for the subset
				//  sum problem but it will never find the correct key
				
				Number t = new Number(x[3]) .mod(n);
				
				Number t_inv_r = t .add(0) .multiply(inv_r);
				
				Number product = new Number(0);
				
				//  Try all the values of m[] rand[] errors
				
				//  This loop can use any range of i such as for (int i =
				//  4*1024; i < 5*1024; i++) and it still finds the key;
				//
				//  but if the wrong value of t is used such as t.add(1)
				//  then it still finds several solutions for every thou-
				//  sand iterations but it never finds the correct key.
				
				
				final int rep = 28;
				
				for (int i = 0; i < 2*1024; i++)
				{
					//  Compute the secret subset sum
					//
					//  b1 = r^-1 ( b - s_r1_m ) (mod n);
					
					final Number b1 = b .subtract(product).mod(n);
					
					final Number b1_ = b .add(product) .mod(n);
					
					product = product .add(t_inv_r);
					
					Number[] m1  = ssss(a, b1,  1, p);
					Number[] m1_ = ssss(a, b1_, 1, p);
					
					if ((m1 == null) && (m1_ == null)) continue;
					
					//  Show how many times the ssss() method returns
					//  a solution until the correct key is found
					
					System.out.print(" i == " + i);
					
					
					//  If m1 and m1_ are solutions to the subset sum problem,
					//  then we have to test both solutions to find the one
					//  that has several repeating digits.
					
					
					boolean bool = false;
					
					if (m1 != null)
					{
						//  Convert the numbers to ints
						
						m = m1; int[] mint = new int[m.length];
						
						for (int j = 0; j < mint.length; j++)
						
						    mint[j] = m[j].intValue();
						
						bool = false;
						
						//  Sort and collate to count the
						//  number of repeating elements
						
						int[][] array2 = Math.sortAndCollate(mint);
						
						for (int j = 0; j < array2.length; j++)
						{
							if (array2[j][1] >= rep)
							
							    { bool = true; break; }
						}
						
						if (bool)
						{
							//  System.out.print(i + "  ");
							
							break;
						}
					}
					
					if (m1_!= null)
					{
						m = m1_; int[] mint = new int[m.length];
						
						for (int j = 0; j < mint.length; j++)
						
						    mint[j] = m[j].intValue();
						
						bool = false;
						
						int[][] array2 = Math.sortAndCollate(mint);
						
						for (int j = 0; j < array2.length; j++)
						{
							if (array2[j][1] >= rep)
							
							    { bool = true; break; }
						}
						
						if (bool)
						{
							//  System.out.print(i + "  ");
							
							break;
						}
					}
				}
				
				
				********************************/
				
				
				//  Compute the secret subset sum
				//
				//  b1 = r^-1 ( b - s_r1_m ) (mod n);
				
				m = ssss(a, b, offset + 4, p);
				
				if (m == null) return new Number(0);
				
				//  System.out.println("m solved == " + Arrays.toString(m));
				
				
				long endtime = System.nanoTime();
				
				long decrypttime = endtime - starttime;
				
				//  System.out.println("knapsack decrypt time == "
				//
				//      + (decrypttime / 1000 / 1000) + " ms");
			}
			
			
			
			else // if (type == 2)
			{
			
				//  Choose the sender's random secret key
				//
				//  m[] = f(recipient's public key y, sender's private key k)
				
				String publickey = z;
				
				
				m = new Number[k];
				
				//  Define the values for m[]
				
				m[0] = new Number( hash2( new Number(
				
				    publickey, 16) .add(x[0])
				
					.toByteArray(32), bits ) );
				
				for (int i = 1; i < m.length; i++)
				
				    m[i] = new Number( hash2(
				
					m[i-1] .toByteArray(32), bits ) );
				
				
				//  Reduce m[] modulo 2 ^ pbits
				
				for (int i = 0; i < m.length; i++)
				
				    m[i] = m[i] .mod(new Number(2).pow(pbits));
				
				
				//  Set the last m[i] to 1
				
				m[m.length-1] = new Number(1);
				
				//  System.out.println(Arrays.toString(m));
				
				
				//  System.out.println("m chosen == " + Arrays.toString(m));
				
				
				//  Truncate the array
				
				final int d = offset + 4;
				
				Number[] m1 = new Number[m.length - d];
				
				for (int i = 0; i < m1.length; i++)
				
				    m1[i] = m[d + i];
				
				//  Re-assign the array
				
				m = m1;
			}
			
			
			//  Convert the vector m[] to a number
			
			Number M = new Number(0);
			
			for (int i = 0; i < m.length; i++)
			{
				//  System.out.println("i == " + i
				//
				//    + "  m[i] == " + m[i]);
				
				M = M .add(m[i]);
				
				if (i < m.length -1)
				
				    M = M .shiftLeft(pbits, pbits);
				
				//  System.out.println("M == " + M);
			}
			
			//  Reduce M modulo F8 and return the secret key
			
			return M .mod(new Number(16).pow(64).add(1));
		}
		
		
		
		//  Since z is either the recipient's static public key
		//  (for encryption) or the sender's one-time public key
		//  (for decryption), z could contain unknown ciphers or
		//  key sizes if z is the recipient's static public key.
		//
		//  if z.length() is unknown return the number zero to
		//  be xor-ed with the composite secret key
		
		else
		{	System.out.println(
			
			    "Unknown key length " + z.trim().length());
			
			return new Number(0);
		}
	}
	
	
	
	
	
	
	
	
	
	//  Merkle-Hellman / knapsack cipher methods
	
	
	private static boolean isSuperincreasingSequence(Number[] a, Number p)
	{
		//  A superincreasing sequence is a set of numbers where
		//  each number is greater than the sum of its predecessors
		//  multiplied by p-1. (For the binary subset sum problem
		//  the modulus p = 2 and the multiplier p-1 == 1.)
		
		Number p1 = p.subtract(1);
		
		Number a_sum = new Number(a[0]);
		
		for (int i = 1; i < a.length; i++)
		{
			if (!a[i].isGreaterThan(a_sum.multiply(p1)))
			
			    return false;
			
			a_sum = a_sum .add(
			
			    a[i-1].multiply(p1));
		}
		
		return true;
	}
	
	
	
	
	private static Number[] ssss(Number[] a, Number b, int offset, Number p)
	{
		return ssss(a, b, offset, -1, p);
	}
	
	
	private static Number[] ssss(Number[] a, Number b, int offset, int m0, Number p)
	{
	
		//  Solve superincreasing subset sum (ssss)
		
		//  This method solves the superincreasing subset sum problem
		//  for a superincreasing sequence a and a subset sum b. The
		//  smallest bits are not solved because they contain errors.
		//
		//  The superincreasing subset sum problem is the problem of solv-
		//  ing for x[] in the sum b = a[] (x[] mod p). (If p = 2 then x[]
		//  is an array of binary digits or bits.)
		//
		//  A superincreasing sequence modulo p is a set of numbers where
		//  each number is greater than the sum of its predecessors multi-
		//  plied by p-1. (For the binary subset sum problem the modulus
		//  p = 2 and the multiplier p-1 == 1.)
		//
		//  The superincreasing subset sum problem is used to decrypt the
		//  message or secret key in the Merkle-Hellman / knapsack cipher.
		
		
		//  Verify that a is a superincreasing sequence modulo p
		
		final int d = offset;
		
		Number p1 = p.subtract(1);
		
		Number temp = new Number(0);
		
		if (!isSuperincreasingSequence(a, p))
		{
			String message =
			
			   "vector is not a superincreasing sequence mod p";
			
			throw new IllegalArgumentException(message);
		}
		
		//  Solve the superincreasing subset sum problem
		
		Number[] x = new Number[a.length];
		
		int pbits = (int) p.subtract(1).bitCount();
		
		for (int i = 0; i < a.length - d; i++)
		{
			x[a.length -1 -i] = new Number(0);
			
			for (int j = 0, counter = 0; j < pbits -1; j++, counter = 0)
			{
				//  Number m = new Number(2) .pow(pbits -2 -j);
				
				Number m = new Number(1).shiftLeft(pbits -2 -j, pbits -2 -j);
				
				Number product = a[a.length -1 -i] .multiply(m);
				
				while (b.subtract(product).signum() != -1)
				{
					b = b .subtract(product);
					
					x[a.length-1 -i] = x[a.length -1 -i] .add(m);
					
					if (counter++ > pbits) break;
				}
			}
			
			if (((i == 0) || (i == 1)) && (m0 >= 0) &&
			
			    x[a.length-1 -i].intValue() != m0)
			
				return null;
		}
		
		//  Verify that the number is smaller than 80 bits
		
		if (b.bitCount() > 80) return null;
		
		
		Number[] x1 = new Number[x.length - d];
		
		for (int i = 0; i < x1.length; i++)
		
		    x1[i] = x[d + i];
		
		return x1;
	}
	
	
	
	private static void permutateLower(Number[] a, Number key, int n)
	{
		//  permutates the numbers from 0 to n
		
		if ((a.length % 2) != 0) throw
		
		    new IllegalArgumentException();
		
		final int size = a.length;
		
		//  Copy the lower and upper elements
		
		Number[] a1_ = new Number[n];
		Number[] a2_ = new Number[size - n];
		
		for (int i = 0; i < a1_.length; i++) a1_[i] = a[0 + i];
		for (int i = 0; i < a2_.length; i++) a2_[i] = a[n + i];
		
		
		Number[] a0;
		
		
		a0 = a1_;
		
		{	Number[] a1 = new Number[a0.length];
			
			for (int i = 0; i < a1.length; i++)
			
			    a1[i] = a0[i];
			
			permutate(a1, key);
			
			
			a0 = new Number[a0.length];
			
			for (int i = 0; i < a1.length; i++)
			
			    a0[i] = a1[i];
			
			
			//  Re-assign the elements of the array
			
			for (int i = 0; i < a0.length; i++)
			
			    a[i] = a0[i];
		}
	}
	
	
	
	private static void permutate(Number[] a, Number key)
	{
		int elements = a.length;
		
		int[] indexes = permutate(elements, key);
		
		for (int i = 0; i < a.length; i++)
		{
			int j = indexes[i];
			
			//  Swap elements i and j
			
			Number temp = a[i];
			
			a[i] = a[j];
			
			a[j] = temp;
		}
	}
	
	
	private static int[] permutate(int elements, Number rand)
	{
		//  returns a permuted array of integers using a key or value
		
		//  This method generates a perfectly random permutation
		//  of the indexes or integers 0, 1, 2, 3, ..., n-1.
		
		//  for (int i = 0; i < elements; i++)
		//
		//     swap element[n-1 -i] and element[rand(n - i)]
		//
		//  This swaps the elements in the array in reverse order
		//  starting from element n. Each highest element n, n-1,
		//  n-2, n-3, ... can only be swapped once because the mod-
		//  lus (n - i) of the random number generator decreases
		//  for each iteration.
		
		
		int n = elements;
		
		int[] a = new int[elements];
		
		for (int i = 0; i < elements; i++) a[i] = i;
		
		byte[] randbytes = rand.toByteArray(32);
		
		for (int i = 0; i < n; i++)
		{
			//  Generate a random index from 0 to n-2 -i
			
			//  int rand1 = random(n-1 - i); // 0 to n-2 -i
			
			randbytes = Cipher.hash(randbytes);
			
			int rand1 = 0, mod = n-1 -i;
			
			if (mod != 0) rand1 = new Number(
			
			    randbytes) .mod(n-1 -i) .intValue();
			
			//  Swap or interchange a[n-1 -i] and a[rand1]
			
			int temp = a[rand1];
			
			a[rand1] = a[n-1 -i];
			
			a[n-1 -i] = temp;
		}
		
		return a;
	}
}


//  End class PublicKey




















class Signature
{


	//  An integer discrete log digital signature algorithm
	
	//          x
	//  y  =  a   (mod p)   static signature key
	//          k
	//  r  =  a   (mod p)   one-time signature key
	//
	//  s  =  k m + x r  (mod p-1)  signature equation
	//
	//    m   r       s
	//  r   y   ==  a   (mod p)  verification equation
	//
	//         k  m       x  r      s = k m + x r
	//  ( r = a )  ( y = a )  ==  a               (mod p)
	//
	//  The signature is the quadruple { m, r, s, y }
	//
	//  For a complex integer algorithm, y = x1 c ^ x (mod p)
	//  where c = a + b i  or for multi-dimensional algebra
	//  such as 3-D algebra y = u2 c3 ^ x where u2 = x1 + x2 i
	//  and c3 = a1 + a2 i + a3 j.
	
	
	
	
	//  A Latin square discrete log / LSDL
	//  digital signature algorithm
	//
	//  A1 = { { a1, b1 }, { b1, a1 } }
	//  B1 = { { a2, b2 }, { b2, a2 } }
	//
	//             x1   x2
	//  Y  =  x  A1   A2    (mod p)  static signature key
	//
	//             k1   k2
	//  R  =  k  A1   A2    (mod p)  one-time signature key
	//
	//  s1  =  k1 m + x1 r (mod q)  signature equation
	//  s2  =  k2 m + x2 r (mod q)  signature equation
	//
	//  where q = p-1 for Latin squares / matrices
	//
	//  and r is a hash or integer value of R
	//
	//  such as r = (r11 || r12) mod q
	//
	//    m   r        s1   s2
	//  R   Y   ==  A1   A2   (mod p)  verification equation
	//
	//  The signature is the quadruple { m, r, s, y } where
	//
	//  m = H(M), r == r11 || r12, s = s1 || s2, y = y11 || y12
	//
	//  and || denotes the string concatenation operator.
	
	
	
	//  The one-time private key k could be a function of the static private key x
	//  and message m, or it could be a function of a random number and the message.
	//  (k should always be a function of the message even if it uses a random number
	//  generator.)
	//
	//  If k is a function of the static key and message (instead of a random number,
	//  static key and message), then the signer cannot sign the same message, check,
	//  or transaction more than once because it will generate the same one-time sig-
	//  nature key r = f(a, k) and the same signature equation s = f(k, m, x, r).
	//
	//  The one-time private key k cannot be reused or else the signature equation
	//  s = k m + x r could be solved for the static private key x because then there
	//  would be two equations s1 = k m1 + x r1 and s2 = k m2 + x r2 (mod q) for the
	//  variables k and x instead of one equation.
	
	
	//  The signature { m, r, s, y } is appended to a document as a block of 4 x 40,
	//  6 x 40, or 9 x 40 chars. In future versions of the software the signature block
	//  could be enclosed in two ------------- lines just like the public keys. The lines
	//  could include or omit the words signature block. If more than one signature algo-
	//  rithm uses the same the number of lines, then the software will verify the signa-
	//  ture starting with the fastest algorithm first and if the signature verifies then
	//  it will display the signature algorithm that was used to sign the document.
	
	
	
	
	//  Discrete log blind signatures
	//
	//  Blind signatures are useful for digital money laundering
	//
	//
	//  The signer chooses a one-time private key k
	//
	//  and sends a one-time signature key
	//
	//               k1   k2
	//  R1  =  k  A1   A2    (mod p)
	//
	//  to a client requesting a signature.
	//
	//
	//  The client generates random numbers a and b
	//
	//  and computes the one-time signature key
	//
	//           a        b           a k1 + b   a k2 + b
	//  R  =  R1  (A1 A2)   ==  k' A1         A2
	//
	//  and the message hash
	//
	//  m1  =  a m r1 / r  (mod p-1),
	//
	//  where r is a hash of R, r1 is a hash of R1,
	//
	//  (such that r and r1 are invertible modulo p-1)
	//
	//  and sends the message hash m1 to the signer.
	//
	//
	//  The signer receives m1 from the client,
	//
	//  verifies that m1 (mod q) is not zero,
	//
	//  and then computes and returns the signature
	//
	//  t1  =  k1 m1 + x1 r1  (mod p-1)
	//  t2  =  k2 m1 + x2 r1  (mod p-1)
	//
	//  The client computes the signature equation
	//
	//  s1 = t1 r / r1 + b m == a k1 m + x1 r + b m == (a k1 + b) m + x1 r  (mod p-1)
	//  s2 = t2 r / r1 + b m == a k2 m + x2 r + b m == (a k2 + b) m + x2 r  (mod p-1)
	//
	//
	//  The signature is the quadruple
	//
	//  { m, R, s = s1 || s2, Y }
	//
	//  where || is the concatenation operator
	//
	//
	//  The verification equation is
	//
	//    m   r       s1   s2
	//  R   Y   ==  A1   A2    (mod p)
	
	
	
	
	
	
	//  A Latin square discrete / LSD
	//  digital signature algorithm
	//
	//  Public signature key Y
	//
	//  One-time signature keys R1, R2, R3
	//
	//  One-time signature key hash R
	//
	//  Signature equation S
	//
	//                     -1  -1      -1  -1
	//  Y  =  X A X + X A X + X A X + X A X
	//                     -1  -1      -1  -1
	//  R1 =  K A K + K A K + K A K + K A K
	//                     -1  -1      -1  -1
	//  R2 =  K A X + K A X + K A X + K A X
	//                     -1  -1      -1  -1
	//  R3 =  X A K + X A K + X A K + X A K
	//
	//  R  =  H( R1, R2, R3 ) = ( R1 + R2 + R3 ) + R1 R2 R3
	//                           -1    -1
	//  S  =  ( K M + X R ) + ( K M + X R )
	//
	//
	//  The signature is the quadruple
	//
	//  { M = f(m), R1 || R2 || R3, S, Y }
	//
	//  where || is the concatenation operator
	//
	//
	//  Verification equation
	//
	//  S A S  ==  R Y R + M R1 M + M R2 R + R R3 M
	//
	//  ================================================================
	//
	//                           -1    -1                    -1    -1
	//  S A S  ==  [ K M + X R + K M + X R ] A [ K M + X R + K M + X R ] ==
	//
	//
	//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
	//
	//       -1  -1          -1  -1          -1  -1          -1  -1
	//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
	//
	//       -1              -1              -1              -1
	//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
	//
	//           -1              -1              -1              -1
	//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M
	//
	//
	//  ==  R Y R + M R1 M + M R2 R + R R3 M
	//
	//  ================================================================
	
	
	
	
	
	
	
	//  Signatures without signature algorithms
	
	//  Hashes and pre-images can be used instead of digital signature algorithms for
	//  some applications that require digital signatures. For example, for e-commerce
	//  applications that require a signature, the retailer or seller could generate a
	//  random 16 or 20-digit pre-image for each package and print the hash on the ship-
	//  ping label, and then provide the buyer or recipient with the pre-image or "sig-
	//  nature" which the recipient would give to the package courier to sign for the
	//  package. Amazon already provides passwords or "signature" keys to customers who
	//  want their purchases shipped to Amazon lockers; customers use the signature key
	//  or six-digit code to open the locker to retrieve their package.
	//
	//  A digital signature algorithm wouldn't make sense for this application because
	//  the recipient would have to be carrying a computer such as a phone or laptop to
	//  sign for a package and the buyer would have the responsibility of providing the
	//  seller with the static public key before the package could be shipped. This may
	//  be the reason why online retailers and shipping companies are still using hand-
	//  written signatures for expensive packages. Hand-written signatures work for bank
	//  checks but they don't provide any security for credit cards or for packages be-
	//  cause any resident, neighbor or employee at the shipping address can scribble a
	//  signature and walk off with someone else's package. This may be one of the rea-
	//  sons why a million packages are stolen every day in the US. In response to the
	//  problem of package theft Amazon has installed secure locker locations in over
	//  900 US cities.
	//
	//  By using a hash signature, the retailer or vendor could provide the customer or
	//  buyer with the pre-image, bar code, and/or QR code to sign for the package and
	//  the courier could verify the signature by hashing the pre-image and comparing it
	//  to a list of a few different hash standards that are used by different retailers.
	//  This would prove that the shipping company delivered the package to a recipient
	//  who was authorized to receive the package. A hand-written signature doesn't prove
	//  anything for a package or for a credit card.
	//
	//  Messages can also be signed without a signature algorithm if two computers have a
	//  shared secret key or a message authentication code. The sender can sign messages
	//  by computing the hash of the message + secret key and appending the hash to the
	//  message and then the receiver can verify the signature by removing the hash, com-
	//  puting the hash of the message + authentication code or H(m || e) and comparing
	//  the two hash values. If two computers communicate over a secure channel or use an
	//  encrypted / SSL socket, the sender could prepend the code but the message hash
	//  would still be required to verify that the ciphertext is not modified.
	
	
	
	
	
	
	
	
	//  Class members
	
	
	
	
	//  Signature ciphers
	
	
	//  The lsd algorithm is twice as fast for signing and
	//  20 times faster for verification compared to the
	//  lsdl algorithm but it doesn't do Schnorr signatures
	//  or blind signatures
	
	
	//  A Latin square / circulant matrix discrete log
	//  digital signature algorithm
	//
	//             x1   x2
	//  Y  =  x  A1   A2    (mod p)
	
	final public static String lsdl = "lsdl";
	
	
	
	//  A Latin square / circulant matrix discrete
	//  digital signature algorithm
	//
	//                     -1  -1      -1  -1
	//  Y  =  X A X + X A X + X A X + X A X
	
	final public static String lsd = "lsd";
	
	
	
	
	
	//  Instance members
	
	
	private Number p;
	private Number q;
	private Number r;
	
	private byte[] x;
	
	private String key;
	
	private String cipher;
	private int keysize;
	private int digits;
	private int radix;
	
	private static Matrix A1;
	private static Matrix A2;
	
	private static Matrix A;
	private static Matrix X;
	
	
	
	
	//  other signature ciphers
	
	//  ...   ...
	
	
	
	//  Random digits for the signature parameters or blank signature key
	
	private static String pi16 =
	
	"3243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c8" +
	"9452821e638d01377be5466cf34e90c6cc0ac29b7c97c50dd3f84d5b5b547091" +
	"79216d5d98979fb1bd1310ba698dfb5ac2ffd72dbd01adfb7b8e1afed6a267e9" +
	"6ba7c9045f12c7f9924a19947b3916cf70801f2e2858efc16636920d871574e6";
	
	
	
	
	//  y = 2 x 60 digits (3 lines)
	//  r = 2 x 60 digits (3 lines)
	//  s = 2 x 30 digits (1.5 lines)
	//  s = 2 x 40 digits (2 lines)
	//
	//  Add 10 digits or 40 bits to each s so that there are
	//  1 septillion solutions out of 240 bits or a septillion
	//  cubed. This means that one out of every septillion
	//  squared numbers or pairs of { x1, x2 } is a solution.
	//
	//                          120-40         120+40
	//  p = q r + 1  where r = 2      and q ~ 2
	//
	//  Number r = new Number(2).pow(120 - 40);
	//  Number q = new Number(2).pow(120 + 40).add(1);
	//
	//  while (!q.isPrime() || !r.multiply(q)
	//
	//      .add(1).isPrime()) q = q.add(2);
	//
	//  System.out.println("q == " + q);
	//
	//  Number p = r.multiply(q).add(1);
	//
	//  System.out.println(q.isPrime() && p.isPrime());
	//
	//  q = 1461501637330902918203684832716283019655932555573
	
	
	
	
	//  Signature constructors
	
	
	public Signature(byte[] privatekey, String cipher)
	{
	
		//  Define the base modulus p and exponent modulus q
		
		if (cipher.equalsIgnoreCase(""))  {  }
		
		else if (cipher.equalsIgnoreCase(lsd))
		{
			this.p = new Number(16) .pow(5) .subtract(3);
			
			this.digits = 5;
			
			this.keysize = 40;
		}
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
			this.q = new Number(
			
			    "1461501637330902918203684832716283019655932555573");
			
			this.r = new Number(2).pow(120 - 40);
			
			this.p = q.multiply(r).add(1);
			
			if (!this.q.isPrime() || !this.p.isPrime())
			
			    throw new IllegalArgumentException();
			
			this.digits = 40;
			
			this.keysize = 3*this.digits;
		}
		
		//  else if (cipher.equalsIgnoreCase(......))
		
		
		//  Initialize the private key
		
		//  x is the 160-bit secret key SK = H(SP)
		
		
		//  Hash the private key with the modulus of the public key to
		//  make the private key different for each signature cipher
		
		this.x = Cipher.hash( new Number(
		
		    privatekey) .add(p) .toByteArray(32) );
		
		
		if (privatekey.length < 20) System.out.println(
		
		    "Private key is less than 160 bits");
		
		
		//  Initialize the base modulus, exponent modulus,
		//
		//  and base variable (p, q, and a)
		
		init(cipher);
		
		
		//  Generate the signature key
		
		if (cipher.equalsIgnoreCase("")) ; // do nothing
		
		else  generateKey();
	}
	
	
	
	
	public Signature(String cipher)
	{
	
		//  no private key argument
		
		//  This constructor is used by the verifySignature method
		//  and by applications that use blind signatures
		
		init(cipher);
	}
	
	
	
	private void init(String cipher)
	{
	
		this.cipher = cipher;
		
		this.radix = 16;
		
		
		//  The private key is hashed with the cipher modulus to make
		//  the private key different for each signature cipher because
		//  signature ciphers are allowed to have the same size but not
		//  the same modulus.
		
		
		if (cipher.equalsIgnoreCase(""))  {  }
		
		if (cipher.equalsIgnoreCase(lsd))
		{
			//  Define the base A
			
			this.digits = 5; int s = 8;
			
			String[] piarray = new String[s];
			
			for (int i = 0; i < piarray.length; i++)
			
			    piarray[i] = pi16.substring(
			
				i * digits, (i+1) * digits);
			
			Number[] a = new Number[s];
			
			for (int i = 0; i < a.length; i++)
			
			    a[i] = new Number(piarray[i], radix);
			
			Matrix A = new Matrix(a, -1);
			
			Signature.A = A;
			
			//  Define the base modulus p
			
			this.p = new Number(16) .pow(5) .subtract(3);
			
			this.digits = 5;
			
			this.keysize = 40;
		}
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
			//  Define the base modulus p and exponent modulus q
			
			this.digits = 40;
			
			this.q = new Number(
			
			    "1461501637330902918203684832716283019655932555573");
			
			this.r = new Number(2) .pow(120 - 40);
			
			this.p = q.multiply(r).add(1);
			
			if (!this.q.isPrime() || !this.p.isPrime())
			
			    throw new IllegalArgumentException();
			
			this.keysize = 3*digits;
			
			//  System.out.println("modulus == " + this.p.toString(16));
			//  System.out.println("exp mod == " + this.q.toString(16));
			
			// 10000000000000000000000000000000000003135 00000000000000000001
			// 10000000000000000000000000000000000003135
			
			
			//  Define the base A1, A2
			
			//  Define the two matrices
			
			String[] elements = new String[4];
			
			for (int i = 0; i < elements.length; i++)
			
			    elements[i] = pi16.substring(
			
				i * digits, (i+1) * digits);
			
			Number a1 = new Number(elements[0], radix);
			Number a2 = new Number(elements[1], radix);
			Number a3 = new Number(elements[2], radix);
			Number a4 = new Number(elements[3], radix);
			
			Matrix A1 = new Matrix(new Number[] { a1, a2 }, 1);
			Matrix A2 = new Matrix(new Number[] { a3, a4 }, 1);
			
			A1 = A1 .modPow(r, p);
			A2 = A2 .modPow(r, p);
			
			Signature.A1 = A1;
			Signature.A2 = A2;
		}
		
		
		//  else if (cipher.equalsIgnoreCase(......))
	}
	
	
	
	
	public static String[] detachSignature(String document)
	{
	
		//  returns the text and signature strings
		
		//  This method does not trim the space or newlines
		//  between the text document and the signature block
		//
		//  so the signed document can be reconstructed by
		//  appending the signature to the text
		
		
		if (document.length() < 4*40)
		
		    //  no signature, return document, null
		
		    return new String[] { document, null };
		
		
		//  Find the last "\n\n" string before the signature
		
		String document1 = document .trim() .replaceAll("\t", "");
		
		String s = "\n\n";  int index = -1, index1 = 0;
		
		while ((index1 = document1.indexOf(s, index1 + 1)) != -1)
		
		    index = index1;
		
		
		//  Detach the signature from the document
		
		if (index == -1) return new String[] { document, null };
		
		String sign = document1 .trim() .substring(
		
		    index + s.length(), document1.length()) .replaceAll("\t", "");
		
		if (sign.indexOf("\n") == -1)
		
		    return new String[] { document, null };
		
		index1 = document.lastIndexOf(
		
		    sign.substring(0, sign.indexOf("\n")));
		
		String text = document .substring(0, index1); // no trim
		
		
		//  Verify that the signature is a base-16 string
		
		if (!Number.isBase16(sign.replaceAll("[ \t\n]", ""))) sign = null;
		
		return new String[] { text, sign };
	}
	
	
	
	
	private Matrix computePrivateMatrix(Number private_key, int s)
	{
	
		byte[][] hash = new byte[s][];
		
		hash[0] = Cipher.hash(private_key.toByteArray());
		
		for (int i = 1; i < hash.length; i++)
		
		    hash[i] = Cipher.hash(hash[i-1]);
		
		Number[] x = new Number[s];
		
		for (int i = 0; i < x.length; i++)
		
		    x[i] = new Number(hash[i]) .mod(p);
		
		
		Matrix X = new Matrix(x, 1);
		
		//  Make sure the matrix is invertible
		
		while (X .determinant(p) .equals(0))
		
		    X = X .add(Matrix.identityMatrix(s));
		
		return X;
	}
	
	
	
	
	private static Matrix computeMatrixR(Matrix R1, Matrix R2, Matrix R3, Number p, Number invp)
	{
	
		//  This method computes a matrix R from one-time signature keys R1, R2, and R3
		
		//  The simplest hash function of two or more values is the sum plus the product
		
		//  Compute R = f (R1, R2, R3) == (R1 + R2 + R3) + R1 R2 R3
		
		Matrix Rsum = R1 .add(R2) .mod(p, invp) .add(R3) .mod(p, invp);
		
		Matrix Rproduct = R1 .multiplyLs(R2) .mod(p, invp) .multiplyLs(R3) .mod(p, invp);
		
		Matrix R = Rsum .add(Rproduct) .mod(p, invp);
		
		
		//  Rotate matrix R
		
		for (int i = 0; i < R.rowCount(); i++)
		{
			Number[] rarray = R .getRow(i);
			
			rarray = Matrix.rotate(rarray,
			
			    (2*i) % R.columnCount());
			
			R .setRow(rarray, i);
		}
		
		return R;
	}
	
	
	
	
	private void generateKey()
	{
	
	
		if (cipher.equalsIgnoreCase(""))  {  }
		
		else if (cipher.equalsIgnoreCase(lsd))
		{
		
			//	Compute the public signature key
			//	
			//	                 -1  -1      -1  -1
			//	Y = X A X + X A X + X A X + X A X
			//	
			//	where A is a public latin square
			//	
			//	and X is a private latin square
			
			
			//  Compute the private matrix X
			
			int s = 8;
			
			Matrix X, X1;
			
			do
			{	//  There is a 1 in p chance that X will be non-invertible
				//  or that the determinant will equal zero modulo p
				
				Number x = new Number(this.x);
				
				X = computePrivateMatrix(x, s);
				
				X1 = X .modInverse(p);
				
				if (X1 == null) this.x = Cipher.hash(this.x);
			}
			
			while (X1 == null);
			
			Signature.X = X;
			
			//  if (X.commutesWith(A)) throw new ArithmeticException();
			
			
			Matrix Y =
			
			      ( X .multiplyLs(A) .mod(p) .multiplyLs(X)  .mod(p) ) // .mod(p)
			  .add( X .multiplyLs(A) .mod(p) .multiplyLs(X1) .mod(p) ) // .mod(p)
			  .add( X1.multiplyLs(A) .mod(p) .multiplyLs(X)  .mod(p) ) // .mod(p)
			  .add( X1.multiplyLs(A) .mod(p) .multiplyLs(X1) .mod(p) ) .mod(p);
			
			
			//  Convert the public key matrix to a number string
			
			String str = LatinSquareToString(Y);
			
			this.key = str;
		}
		
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
		
			//  Compute the static signature key
			//
			//             x1   x2
			//  Y  =  x  A1   A2    (mod p)
			
			
			byte[] hash0, hash1, hash2;
			
			hash0 = Cipher.hash(this.x);
			
			hash1 = Cipher.hash(hash0);
			hash2 = Cipher.hash(hash1);
			
			//  Define the private exponents
			
			Number x0 = new Number(hash0);
			Number x1 = new Number(hash1);
			Number x2 = new Number(hash2);
			
			Number x = new Number(hash0) .mod(q);
			
			//                x1   x2
			//  Compute  x  A1   A2   (mod p)
			
			Matrix A12x1 = A1 .modPow(x1, p);
			Matrix A22x2 = A2 .modPow(x2, p);
			
			Matrix Y = A12x1 .multiply(A22x2) .mod(p)
			
			    .multiply(x0) .mod(p);
			
			//  Convert the public key matrix to string
			
			String str = LatinSquareToString(Y);
			
			this.key = str;
		}
		
		//  else if (cipher.equalsIgnoreCase(......))
	}
	
	
	
	
	public Matrix[] getBase()
	{
	
		//  The base is required to do blind signatures
		
		//  In a blind signature scheme the client has to compute
		//
		//           a   b         a k + b
		//  R  =  R1   A  ==  k' A        (mod p)
		//
		//  in order to compute
		//
		//  m1  =  a m r1 / r  (mod q = p-1)
		//
		//  where r1 = f(R1) and r = f(R),
		//
		//  because R is required to compute r
		//
		//  where r is a hash or integer value
		//  of R such as r = r11||r12 (mod q)
		
		
		if (cipher.equalsIgnoreCase(lsdl))
		{
			String[] elements = new String[4];
			
			for (int i = 0; i < elements.length; i++)
			
			   elements[i] = pi16.substring(
			
			      i * digits, (i + 1) * digits);
			
			Number a1 = new Number(elements[0],radix);
			Number a2 = new Number(elements[1],radix);
			Number a3 = new Number(elements[2],radix);
			Number a4 = new Number(elements[3],radix);
			
			Matrix A1 = new Matrix(new Number[] { a1, a2 }, 1);
			Matrix A2 = new Matrix(new Number[] { a3, a4 }, 1);
			
			A1 = A1 .modPow(r, p);
			A2 = A2 .modPow(r, p);
			
			return new Matrix[] { A1, A2 };
		}
		
		else throw new IllegalArgumentException();
	}
	
	
	public Number getBaseModulus() { return p; }
	public Number getExpModulus () { return q; }
	
	
	public String getKey()
	{
		//  returns the signature key
		
		String signkey = this.key.trim();
		
		while ((signkey.length() % keysize) != 0)
		
		    signkey = "0" + signkey;
		
		return signkey;
	}
	
	public String getKeyID()
	{
		//  converts this signature key to a hash value
		
		String signkey = getKey();
		
		return getKeyID(signkey);
	}
	
	public static String getKeyID(String signkey)
	{
		//  converts a signature key to a hash value
		
		return Cipher.hash2(signkey);
	}
	
	public static String getKey(String signature)
	{
		//  extracts the signature key from a signed document
		
		String[] mrsy = parseSignature(signature);
		
		if (mrsy == null) return null;
		
		return mrsy[mrsy.length - 1];
	}
	
	
	public static boolean isSigned(String document, int hashtype)
	{
	
		//  verifies the signature format and hash type
		
		//  This method does not verify that the signature is true because ver-
		//  ifying signatures is more expensive than verifying message hashes.
		//
		//  This method could be changed to verify the signature because the
		//  Latin square discrete log signature cipher is faster than other
		//  discrete log ciphers such as integer and elliptic curve discrete
		//  log signature ciphers.
		
		
		//  Detach the signature
		
		String[] text_sign = detachSignature(document);
		
		String text = text_sign[0] .trim();
		String sign = text_sign[1];
		
		if ((text_sign.length != 2) ||
		
		    (sign == null) || sign.isEmpty())
		{
			System.out.println("error");
			
			return false;
		}
		
		//  Parse the signature block into
		//  the quadruple { m, r, s, y }
		
		String[] mrsy = parseSignature(sign);
		
		//  Verify that the signature was detached
		
		if ((mrsy == null) || (mrsy[0] == null))  return false;
		
		
		//  Verify the signature format
		
		if (!verifyFormat(sign)) return false;
		
		
		//  Verify the hash type
		
		int digits = 64, radix = 16;
		
		String m = mrsy[0] .trim();
		
		if (hashtype == 1)
		{
			String hash = Cipher.hash1(text, digits, radix);
			
			if (!hash.startsWith(m)) return false;
			
			else return true;
		}
		
		else if (hashtype == 2)
		{
			String hash = Cipher.hash2(text, digits, radix);
			
			if (!hash.startsWith(m)) return false;
			
			else return true;
		}
		
		else return false;
	}
	
	
	
	
	public String LatinSquareToString(Matrix R)
	{
		//  converts a Latin square / circulant matrix to string
		
		int d = this.keysize / R.rowCount(), r = radix;
		
		String rstring = R .toIntegerString(d, r);
		
		return rstring .substring(0,
		
		    rstring.length() / R.columnCount());
	}
	
	
	
	
	public static String[] mrsyToSignature(String[] mrsy)
	{
	
		//  converts a jagged array to a non-jagged array
		//  so the signature can be printed because m, r, s, y
		//  may not be the same length (depending on the cipher)
		
		//  m_160  xxxxxxxxxx xxxxxxxxxx
		//  r_480  xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx
		//  s_320  xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx
		//  y_480  xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx xxxxxxxxxx
		
		//  m   xxxxxxxxxx xxxxxxxxxx
		//  r0  xxxxxxxxxx xxxxxxxxxx
		//  r1  xxxxxxxxxx xxxxxxxxxx
		//  r2  xxxxxxxxxx xxxxxxxxxx
		//  s0  xxxxxxxxxx xxxxxxxxxx
		//  s1  xxxxxxxxxx xxxxxxxxxx
		//  y0  xxxxxxxxxx xxxxxxxxxx
		//  y1  xxxxxxxxxx xxxxxxxxxx
		//  y2  xxxxxxxxxx xxxxxxxxxx
		//
		//  the program or the user can hash the last
		//  two lines to compute the signature key hash
		
		
		String m, r, s, y;
		
		m = mrsy[0].trim();
		r = mrsy[1].trim();
		s = mrsy[2].trim();
		y = mrsy[3].trim();
		
		
		int digits = m.length();
		
		if (digits > 64) return null;
		
		if ((r.length() == 3*digits) &&
		    (s.length() == 2*digits) &&
		    (y.length() == 3*digits))
		{
			String[] array = new String[9];
			
			array[0] = m.substring(0*digits, 1*digits);
			array[1] = r.substring(0*digits, 1*digits);
			array[2] = r.substring(1*digits, 2*digits);
			array[3] = r.substring(2*digits, 3*digits);
			array[4] = s.substring(0*digits, 1*digits);
			array[5] = s.substring(1*digits, 2*digits);
			array[6] = y.substring(0*digits, 1*digits);
			array[7] = y.substring(1*digits, 2*digits);
			array[8] = y.substring(2*digits, 3*digits);
			
			return array;
		}
		
		
		if ((r.length() == 3*digits) &&
		    (s.length() == 1*digits) &&
		    (y.length() == 1*digits))
		{
			String[] array = new String[6];
			
			array[0] = m.substring(0*digits, 1*digits);
			array[1] = r.substring(0*digits, 1*digits);
			array[2] = r.substring(1*digits, 2*digits);
			array[3] = r.substring(2*digits, 3*digits);
			array[4] = s.substring(0*digits, 1*digits);
			array[5] = y.substring(0*digits, 1*digits);
			
			return array;
		}
		
		
		if (r.length() == 1*digits)
		{
			//  If r is the same length as m, then
			//  y is also the same length as m
			
			//  Return a copy of the array
			
			String[] array = new String[4];
			
			array[0] = m.substring(0*digits, 1*digits);
			array[1] = r.substring(0*digits, 1*digits);
			array[2] = s.substring(0*digits, 1*digits);
			array[3] = y.substring(0*digits, 1*digits);
			
			return array;
		}
		
		//  else if (r.length() == ...)
		//  {
		//	
		//  }
		
		else  return null;
	}
	
	
	
	
	public static String[] parseSignature(String signature)
	{
	
		//  converts a signature string to an mrsy array
		//
		//  m = message hash
		//  r = one-time signature key
		//  s = signature equation
		//  y = static signature key
		
		
		//  Verify the signature format
		
		if (!verifyFormat(signature)) return null;
		
		
		//  Split the signature into tokens and convert to mrsy
		
		signature = signature .trim().replaceAll("\t", "");
		
		String[] tokens = signature.split("\n{1,}");
		
		String[] mrsy = new String[4];
		
		//  if the number of tokens == 9 then
		//  the lengths of m,r,s,y are unequal
		
		if (tokens.length == 9)
		{
			mrsy[0] = tokens[0];
			mrsy[1] = tokens[1] + tokens[2] + tokens[3];
			mrsy[2] = tokens[4] + tokens[5];
			mrsy[3] = tokens[6] + tokens[7] + tokens[8];
			
			return mrsy;
		}
		
		if (tokens.length == 6)
		{
			mrsy[0] = tokens[0];
			mrsy[1] = tokens[1] + tokens[2] + tokens[3];
			mrsy[2] = tokens[4];
			mrsy[3] = tokens[5];
			
			return mrsy;
		}
		
		//  if the number of tokens == 4 then
		//  m,r,s,y are the same length
		
		if (tokens.length == 4)
		{
			mrsy[0] = tokens[0];
			mrsy[1] = tokens[1];
			mrsy[2] = tokens[2];
			mrsy[3] = tokens[3];
			
			return mrsy;
		}
		
		else return null;
	}
	
	
	
	
	public String Rstring(Number k1, Number k2)
	{
	
		//  This method is used only for blind signatures
		//
		//  This method will return null if r = f(R) is non-in-
		//  vertible modulo q which can happen if r == 0 (mod 2)
		//
		//  If this method returns null, try another { k1, k2 }
		//  until the method returns a string.
		
		
		//  One-time signature key
		//
		//               k1   k2
		//  R1  =  k  A1   A2   (mod p)
		
		
		if (cipher.equalsIgnoreCase(""))  { return null; }
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
			Number k = Number.random(digits, radix);
			
			Matrix A12k1 = A1 .modPow(k1, p);
			Matrix A22k2 = A2 .modPow(k2, p);
			
			Matrix R1 = A12k1 .multiply(A22k2)
			
			    .mod(p) .multiply(k) .mod(p);
			
			String R1string = LatinSquareToString(R1);
			
			Number r1 = new Number( R1string, radix ) .mod( p );
			
			if (! r1.isCoprimeWith(q) ) return null;
			
			return R1string.trim();
		}
		
		else throw new IllegalArgumentException();
	}
	
	
	
	
	public String sString(Number k1, Number k2, String mstring, String Rstring)
	{
	
		//  This method is used only for blind signatures
		//
		//  In a blind signature scheme, the signer has to call the Rstring
		//  method to generate a random R1, send R1 to the client, wait for
		//  the client to compute and return m1 = f(m, r1) where r1 = f(R1),
		//  and then compute the signature equation s1 = k m1 + x r1.
		//
		//  The signMessage method cannot be used here because it just gen-
		//  erates a signature pair { r1, s1 }. But the client first has to
		//  receive the one-time signature key r1 = f(R1) from the signer
		//  in order to compute the message m1 = f(m, r1 = f(R1)).
		
		
		//  Public key signature
		
		//  s  =  k m + x r  (mod q)
		
		//  Test for empty string and for m == 0 (mod q)
		
		if (mstring.isBlank()) return null;
		
		if (Number.isBase16(mstring.trim())
		
		    && new Number(mstring.trim(), 16).mod(q).equals(0))
		
			return null;
		
		
		if (cipher.equalsIgnoreCase("")) {   }
		
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
		
			//  Static signature key
			//
			//             x1   x2
			//  Y  =  x  A1   A2    (mod p)
			
			
			//  One-time signature key
			//
			//              k1   k2
			//  R1  =  k  A1   A2    (mod p)
			
			
			//  Signature equations
			//
			//  s1  =  k1 m1 + x1 r1  (mod q)
			//  s2  =  k2 m1 + x2 r1  (mod q)
			
			
			//  Verification equation
			//
			//     m   r       s1   s2
			//  R1   Y   ==  A1   A2   (mod p)
			
			
			if ( new Number(mstring, radix) .equals(0)
			
			    || Number.isDigitString(mstring, 1) ) return null;
			
			
			//  k[i] is a random number
			//
			//  k[i] = hash( m + x[i] )  (mod q)
			//
			//  (the same document m can be signed once)
			
			
			//  or k[i] = hash(m + x[i] + Number.random(64, 16).toString(16)).mod(q);
			//
			//  (the same document m can be signed more than once)
			
			
			Number r1 = new Number( Rstring, radix ) .mod(q);
			
			
			byte[] hash0, hash1, hash2;
			
			hash0 = Cipher.hash(this.x);
			
			hash1 = Cipher.hash(hash0);
			hash2 = Cipher.hash(hash1);
			
			
			//  Define the private exponents
			
			Number x1 = new Number(hash1) .mod(q);
			Number x2 = new Number(hash2) .mod(q);
			
			
			//  Compute the one-time signature equation
			//
			//  s1 = k1 m1 + x1 r  (mod q)
			//  s2 = k2 m1 + x2 r  (mod q)
			
			
			Number s1, s2;
			
			s1 = k1 .multiply(new Number(mstring, radix)) .add(x1.multiply(r1)) .mod(q);
			s2 = k2 .multiply(new Number(mstring, radix)) .add(x2.multiply(r1)) .mod(q);
			
			String str1 = s1 .toString(digits, radix);
			String str2 = s2 .toString(digits, radix);
			
			while (str1.length() != digits) str1 = "0" + str1;
			while (str2.length() != digits) str2 = "0" + str2;
			
			String sstring = str1 + str2;
			
			
			Signature sig = new Signature(cipher);
			
			String sstring1 = sstring.substring( 0, 40);
			String sstring2 = sstring.substring(40, 80);
			
			String ystring = this.getKey().trim();
			
			Matrix Y = sig.stringToLatinSquare(ystring, 2, 1);
			Matrix R = sig.stringToLatinSquare(Rstring, 2, 1);
			
			//            m   r      s1   s2
			//  Verify  R   Y  ==  A1   A2
			
			Number m1 = new Number(mstring, 16);
			
			Matrix R2m = R .modPow(m1, p);
			Matrix Y2r = Y .modPow(r1, p);
			
			Matrix A12s1 = A1 .modPow(s1, p);
			Matrix A22s2 = A2 .modPow(s2, p);
			
			
			Matrix M1 = R2m .multiply(Y2r) .mod(p);
			
			Matrix M2 = A12s1 .multiply(A22s2) .mod(p);
			
			////  boolean bool = M1.equals(M2);
			
			boolean bool = M1.get(0,0) .modDivide(M1.get(1,0), p)
			       .equals(M2.get(0,0) .modDivide(M2.get(1,0), p));
			
			if (!bool) throw new ArithmeticException();
			
			System.out.println();
			System.out.println("m1 == " + mstring);
			System.out.println("r1 == " + Rstring);
			System.out.println("s1 == " + sstring);
			System.out.println("y1 == " + ystring);
			System.out.println();
			
			return sstring;
		}
		
		return null;
	}
	
	
	
	public String[] signMessage(String message, int hashtype)
	{
		return signMessage(message, hashtype, false);
	}
	
	
	public String[] signMessage(String message, int hashtype, boolean random)
	{
	
		//  computes the signature and returns
		//  the array { m, r, s, y }
		//
		//  m = message hash
		//  r = one-time signature key
		//  s = signature equation
		//  y = static signature key
		
		//  The message is trimmed before hashing
		
		long starttime = System.nanoTime();
		
		message = message .trim();
		
		//  Test for empty string and for m == 0 (mod q)
		
		if (message.isEmpty())  return null;
		
		if ((q != null) && Number.isBase16(message) && new Number(
		
		    message, 16) .mod(q) .equals(0))  return null;
		
		
		//  If the message length == 40 or 64,  m = the message.
		//  If the message length != 40 or 64,  m = hash(message).
		
		String mstring = null;
		
		int mlength = message.length();
		
		
		//  If the message is a 40 or 64 hex-digit string
		//  then there is no reason to hash the message
		
		if ( ((mlength == 40) || (mlength == 64))
		
		   && Number.isDigitString(message, radix) )
		{
			//  message is a hash if m length == 40
			
			if (message.length() > 40)
			
			    mstring = message.substring(0, 40);
			
			if (new Number(mstring, 16).mod(q)
			
			    .equals(0)) return null;
		}
		
		else    //  message is a document, not a hash
		{
			if (hashtype == 1) mstring = Cipher.hash1(message.trim());
			if (hashtype == 2) mstring = Cipher.hash2(message.trim());
			
			if ((hashtype != 1) && (hashtype != 2)) return null;
		}
		
		//  If a string is an integer in radix one, then it equals zeros
		
		Number m = new Number(mstring, 16);
		
		if (Number.isDigitString(mstring, 1))  return null;
		
		if ((q != null) && m.mod(q).equals(0)) return null;
		
		
		
		//  Choose or compute the one-time private key
		//
		//  If the one-time private key k is a function of the message m and the
		//  static private key x, then the document m can only be signed once.
		//
		//  If the one-time private key k is a function of m, x, and a random
		//  number, then the document m can be signed more than once
		
		
		Number k0, k1, k2;
		
		
		if (!random) // if k is a function of m, x
		{
			//  one (r, s) signature per document m, per signature key x
			
			byte[] mplusx = m.add(new Number(x)).toByteArray();
			
			byte[] array0 = Cipher.hash(mplusx);
			byte[] array1 = Cipher.hash(array0);
			byte[] array2 = Cipher.hash(array1);
			
			k0 = new Number(array0) .mod(p);
			k1 = new Number(array1) .mod(p);
			k2 = new Number(array2) .mod(p);
		}
		
		else // if k is random
		{
			//  multiple (r, s) signatures per document m
			
			int digits = 64;
			
			k0 = Number.random(digits, radix) .mod(p);
			k1 = Number.random(digits, radix) .mod(p);
			k2 = Number.random(digits, radix) .mod(p);
		}
		
		
		
		
		if (cipher.equalsIgnoreCase("")) {  }
		
		
		else if (cipher.equalsIgnoreCase(lsd))
		{
		
		
			//  LSD signatures
			//
			//  Public signature key Y
			//
			//  One-time signature keys R1, R2, R3
			//
			//  One-time signature key hash R
			//
			//  Signature equation S
			//
			//                     -1  -1      -1  -1
			//  Y  =  X A X + X A X + X A X + X A X
			//                     -1  -1      -1  -1
			//  R1 =  K A K + K A K + K A K + K A K
			//                     -1  -1      -1  -1
			//  R2 =  K A X + K A X + K A X + K A X
			//                     -1  -1      -1  -1
			//  R3 =  X A K + X A K + X A K + X A K
			//
			//  R  =  f (R1, R2, R3) = R1 + R2 + R3 + R1 R2 R3
			//                           -1    -1
			//  S  =  ( K M + X R ) + ( K M + X R )
			//
			//
			//  Verification equation
			//
			//  S A S  ==  R Y R + M R1 M + M R2 R + R R3 M
			
			
			//                           -1    -1                    -1    -1
			//  S A S  ==  [ K M + X R + K M + X R ] A [ K M + X R + K M + X R ] ==
			//
			//
			//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
			//
			//       -1  -1          -1  -1          -1  -1          -1  -1
			//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
			//
			//       -1              -1              -1              -1
			//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M +
			//
			//           -1              -1              -1              -1
			//  M ( K A K ) M + R ( X A X ) R + M ( K A X ) R + R ( X A K ) M
			
			
			
			
			//  Define the matrix M = f(m)
			
			int s = mstring.length() / digits;
			
			Matrix K = computePrivateMatrix(k0, s);
			
			Matrix M = stringToLatinSquare(mstring, s, +1);
			
			Matrix X = Signature.X;
			
			Matrix K1 = K .modInverse(p);
			Matrix X1 = X .modInverse(p);
			
			
			
			//  Compute the one-time signature keys
			//
			//                     -1  -1      -1  -1
			//  R1 == K A K + K A K + K A K + K A K
			//                     -1  -1      -1  -1
			//  R2 == K A X + K A X + K A X + K A X
			//                     -1  -1      -1  -1
			//  R3 == X A K + X A K + X A K + X A K
			
			
			Matrix R1, R2, R3;
			
			//  multiplyLs should be faster than multiply for latin squares
			//  because it only has to multiply one row by all of the columns
			//  instead of multiplying all the rows by all the columns
			
			
			
			R1 =  ( K .multiplyLs(A) .mod(p) .multiplyLs(K)  )
			  .add( K .multiplyLs(A) .mod(p) .multiplyLs(K1) )
			  .add( K1.multiplyLs(A) .mod(p) .multiplyLs(K)  )
			  .add( K1.multiplyLs(A) .mod(p) .multiplyLs(K1) ) .mod(p);
			
			R2 =  ( K .multiplyLs(A) .mod(p) .multiplyLs(X)  )
			  .add( K .multiplyLs(A) .mod(p) .multiplyLs(X1) )
			  .add( K1.multiplyLs(A) .mod(p) .multiplyLs(X)  )
			  .add( K1.multiplyLs(A) .mod(p) .multiplyLs(X1) ) .mod(p);
			
			R3 =  ( X .multiplyLs(A) .mod(p) .multiplyLs(K)  )
			  .add( X .multiplyLs(A) .mod(p) .multiplyLs(K1) )
			  .add( X1.multiplyLs(A) .mod(p) .multiplyLs(K)  )
			  .add( X1.multiplyLs(A) .mod(p) .multiplyLs(K1) ) .mod(p);
			
			
			
			//  Compute the one-time hash key
			//
			//  R = f(R1, R2, R3) = (R1 + R2 + R3) + R1 R2 R3
			
			int digits1 = (int) p.bitCount() / 4;
			
			Number invp = p .setPrecision(16 + digits1) .inverse();
			
			Matrix R = computeMatrixR(R1, R2, R3, p, invp);
			
			
			//  System.out.println(K .commutesWith(M));
			//  System.out.println(X .commutesWith(R));
			//  System.out.println(K1.commutesWith(M));
			//  System.out.println(X1.commutesWith(R));
			//  
			//  System.out.println(!K.multiplyLs(M) .commutesWith(A));
			//  System.out.println(!X.multiplyLs(R) .commutesWith(A));
			
			
			
			//  Compute the signature equation
			//
			//  S = K M + X R + K1 M + X1 R
			//
			//  where R = f (R1, R2, R3)
			
			
			Matrix S = (K .multiply(M)) .add(X .multiply(R))
			       .add(K1.multiply(M)) .add(X1.multiply(R)) .mod(p);
			
			if (A.commutesWith(S)) throw new IllegalArgumentException();
			
			
			//  Compute the static signature key
			//
			//                    -1  -1      -1  -1
			//  Y == X A X + X A X + X A X + X A X
			
			Matrix Y =
			
			      ( X .multiply(A) .mod(p) .multiply(X)  )
			  .add( X .multiply(A) .mod(p) .multiply(X1) )
			  .add( X1.multiply(A) .mod(p) .multiply(X)  )
			  .add( X1.multiply(A) .mod(p) .multiply(X1) ) .mod(p);
			
			
			//  Verify that S A S == R Y R + M R1 M + M R2 R + R R3 M
			//
			//  to make sure that the message was signed correctly
			
			
			//  Compute the signature value S A S
			
			Matrix SAS = S .multiply(A) .mod(p) .multiply(S) .mod(p);
			
			
			//  Compute the signature value
			//
			//  R Y R + M R1 M + M R2 R + R R3 M
			
			Matrix RYRMR1MMR2RRR3M =
			
			      ( R .multiply(Y)  .mod(p) .multiply(R) )
			  .add( M .multiply(R1) .mod(p) .multiply(M) )
			  .add( M .multiply(R2) .mod(p) .multiply(R) )
			  .add( R .multiply(R3) .mod(p) .multiply(M) ) .mod(p);
			
			if (!SAS .equals(RYRMR1MMR2RRR3M))
			{
				System.out.println("p == " + p.toString(16));
				
				System.out.println(SAS            .toMatrixString(16));
				System.out.println(RYRMR1MMR2RRR3M.toMatrixString(16));
				
				throw new ArithmeticException();
			}
			
			
			//  Convert the matrices to integer strings
			
			String R1string = R1 .toIntegerString(digits, radix);
			String R2string = R2 .toIntegerString(digits, radix);
			String R3string = R3 .toIntegerString(digits, radix);
			String  sstring =  S .toIntegerString(digits, radix);
			
			R1string = R1string .substring(0, R1string.length() / R1.rowCount());
			R2string = R2string .substring(0, R2string.length() / R2.rowCount());
			R3string = R3string .substring(0, R3string.length() / R3.rowCount());
			 sstring =  sstring .substring(0,  sstring.length() /  S.rowCount());
			
			String Rstring = R1string + R2string + R3string;
			
			String Ystring = LatinSquareToString(Y);
			
			
			//  return  m, r, s, y
			
			String[] mrsy = new String[4];
			
			mrsy[0] = mstring.trim();
			mrsy[1] = Rstring.trim();
			mrsy[2] = sstring.trim();
			mrsy[3] = Ystring.trim();
			
			return mrsy;
		}
		
		
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
		
			//  Latin square discrete log signatures
			
			
			//  The static signature key is
			//
			//             x1   x2
			//  Y  =  x  A1   A2   (mod p)
			//
			//  To sign a message, the signer
			//
			//  computes the one-time signature key
			//
			//             k1   k2
			//  R  =  k  A1   A2   (mod p)
			//
			//  and the signature equations
			//
			//  s1  =  k1 m + x1 r  (mod q)
			//  s2  =  k2 m + x2 r  (mod q)
			//
			//  The signature is the quadruple
			//
			//  S  =  { m, R, s1||s2, Y }
			//
			//  The verification equation is
			//
			//    m   r       s1   s2
			//  R   Y   ==  A1   A2   (mod p)
			
			
			//  Compute the one-time signature key
			//
			//             k1   k2
			//  R  =  k  A1   A2   (mod p)
			
			
			//  Define the private exponents
			
			byte[] hash0, hash1, hash2;
			
			hash0 = Cipher.hash(this.x);
			
			hash1 = Cipher.hash(hash0);
			hash2 = Cipher.hash(hash1);
			
			Number x0 = new Number(hash0) .mod(q);
			Number x1 = new Number(hash1) .mod(q);
			Number x2 = new Number(hash2) .mod(q);
			
			
			//  Compute the one-time signature key
			
			Matrix A12k1 = A1 .modPow(k1, p);
			Matrix A22k2 = A2 .modPow(k2, p);
			
			Matrix R = A12k1 .multiply(A22k2)
			
			    .mod(p) .multiply(k0) .mod(p);
			
			String Rstring = LatinSquareToString(R);
			
			//  Reduce R modulo the exp modulus q
			
			Number r = new Number(Rstring, radix) .mod(q);
			
			
			//  Compute the one-time signature equations
			//
			//  s1 = k1 m + x1 r  (mod q)
			//  s2 = k2 m + x2 r  (mod q)
			
			Number s1 = k1 .multiply(m) .add(x1.multiply(r)) .mod(q);
			Number s2 = k2 .multiply(m) .add(x2.multiply(r)) .mod(q);
			
			String str1 = s1.toString(digits, radix).trim();
			String str2 = s2.toString(digits, radix).trim();
			
			while (str1.length() < digits) str1 = "0" + str1;
			while (str2.length() < digits) str2 = "0" + str2;
			
			String sstring = str1 + str2;
			
			String[] mrsy = new String[4];
			
			mrsy[0] = mstring.trim();
			mrsy[1] = Rstring.trim();
			mrsy[2] = sstring.trim();
			mrsy[3] = this.key.trim();
			
			return mrsy;
		}
		
		
		//  else if (cipher.equalsIgnoreCase(......))
		
		
		return null;
	}
	
	
	
	public Matrix stringToLatinSquare(
	
		String str, int cols, int direction)
	{
		//  constructs a Latin square from a string
		
		int digits = str.length() / cols;
		
		Number[] a = new Number[cols];
		
		for (int i = 0; i < a.length; i++)
		
		   a[i] = new Number(str .substring(
		
		      i*digits, (i+1)*digits), 16);
		
		return new Matrix(a, direction);
	}
	
	
	
	
	public static boolean verifyFormat(String signature)
	{
		//  verifies the signature format
		
		String[] tokens;
		
		tokens = signature.trim().split("\n{1}");
		
		if ( (tokens.length != 4)
		  && (tokens.length != 6) 
		  && (tokens.length != 9) )
		
		    return false;
		
		for (int i = 0; i < tokens.length; i++)
		{
			String t = tokens[i];
			
			if ((t.length() > 64) || !Number.isBase16(t))
			
			    return false;
		}
		
		return true;
	}
	
	
	
	
	public static boolean verifySignature(String document, String cipher)
	{
		//  verifies the mrsy signature
		
		//  Parse the signature
		
		String[] text_sign = detachSignature(document);
		
		String[] mrsy = parseSignature(text_sign[1]);
		
		for (String str : mrsy)
		
		    if (str == null) return false;
		if (mrsy[0] == null) return false;
		
		
		//  Verify that m == hash(M)
		//
		//  or that m is a hash of the document
		
		String hash1, hash2;
		
		String m = mrsy[0];
		
		String text = text_sign[0];
		
		hash1 = Cipher.hash1(text);
		hash2 = Cipher.hash2(text);
		
		if (!m.startsWith(hash1)
		 && !m.startsWith(hash2))
		
		    return false;
		
		
		//  Verify the signature
		
		return verifySignature(mrsy, cipher);
	}
	
	
	
	public static boolean verifySignature(
	
		String document, String signkey, String cipher)
	{
		//  verifies the mrsy signature and the sign key
		
		if ( (document == null) || document.isBlank()
		  || ( signkey == null) ||  signkey.isBlank() )
		
			return false;
		
		//  Parse the signature
		
		String[] mrsy = Signature.parseSignature(document.trim());
		
		for (String str : mrsy) if (str == null) return false;
		
		String m = mrsy[0], y = mrsy[3];
		
		if (m == null) return false;
		
		if (! y .startsWith(signkey.trim())) return false;
		
		//  Verify the signature
		
		return verifySignature(mrsy, cipher);
	}
	
	
	
	public static boolean verifySignature(String[] mrsy, String cipher)
	{
	
		//  verifies the mrsy signature
		
		long starttime = System.nanoTime();
		
		long time1 = System.nanoTime();
		
		if ((mrsy == null) || (mrsy.length != 4)) return false;
		
		for (int i = 0; i < mrsy.length; i++) if ((mrsy[i] == null)
		
		    || (mrsy[i] = mrsy[i].trim()).isEmpty())  return false;
		
		for (int i = 0; i < mrsy.length; i++)
		
		  if (!Number.isBase16(mrsy[i]) || new Number(
		
		     mrsy[i], 16) .isLessThan(2))  return false;
		
		
		long time2 = System.nanoTime();
		
		
		String mstring = mrsy[0];
		String rstring = mrsy[1];
		String sstring = mrsy[2];
		String ystring = mrsy[3];
		
		
		Signature sig = new Signature(cipher);
		
		Number p = sig.p;
		Number q = sig.q;
		
		Number m = new Number(mstring, 16);
		
		if ((m.equals(0)) || (m.length() > 64)) return false;
		
		if ((q != null) && m.mod(q).equals(0)) return false;
		
		
		//  System.out.println("Verifying signature");
		
		
		int digits = sig.digits;
		int radix  = sig.radix;
		
		
		if (cipher.equalsIgnoreCase("")) return false;
		
		
		else if (cipher.equalsIgnoreCase(lsd))
		{
			if ((mstring.length() != 1*40)
			 || (rstring.length() != 3*40)
			 || (sstring.length() != 1*40)
			 || (ystring.length() != 1*40))
			
			    return false;
			
			long time3 = System.nanoTime();
			
			int s = mstring.length() / digits;
			
			Matrix M = sig.stringToLatinSquare(mstring, s, +1);
			
			int rlength = mrsy[1].trim().length();
			
			String R1string = mrsy[1].trim() .substring(0 * rlength/3, 1 * rlength/3);
			String R2string = mrsy[1].trim() .substring(1 * rlength/3, 2 * rlength/3);
			String R3string = mrsy[1].trim() .substring(2 * rlength/3, 3 * rlength/3);
			
			Matrix R1 = sig.stringToLatinSquare(R1string, s, -1);
			Matrix R2 = sig.stringToLatinSquare(R2string, s, -1);
			Matrix R3 = sig.stringToLatinSquare(R3string, s, -1);
			
			Matrix S = sig.stringToLatinSquare(mrsy[2].trim(), s, +1);
			Matrix Y = sig.stringToLatinSquare(mrsy[3].trim(), s, -1);
			
			long time4 = System.nanoTime();
			
			
			//  Verify that
			//
			//  S A S == R Y R + M R1 M + M R2 R + R R3 M
			
			
			int digits1 = (int) p.bitCount() / 4;
			
			Number invp = p .setPrecision(16 + digits1) .inverse();
			
			
			long time5 = System.nanoTime();
			
			
			Matrix R = computeMatrixR(R1, R2, R3, p, invp);
			
			
			long time6 = System.nanoTime();
			
			Matrix SAS = S .multiplyLs(A) .mod(p, invp) .multiplyLs(S) .mod(p, invp);
			
			long time7 = System.nanoTime();
			
			
			Matrix RYRMR1MMR2RRR3M =
			
			      ( R .multiplyLs(Y)  .mod(p, invp) .multiplyLs(R) )
			  .add( M .multiplyLs(R1) .mod(p, invp) .multiplyLs(M) )
			  .add( M .multiplyLs(R2) .mod(p, invp) .multiplyLs(R) )
			  .add( R .multiplyLs(R3) .mod(p, invp) .multiplyLs(M) ) .mod(p, invp);
			
			long time8 = System.nanoTime();
			
			
			long totaltime = time8 - time1;
			
			double frac1 = 1.0D * (time2 - time1) / totaltime;
			double frac2 = 1.0D * (time3 - time2) / totaltime;
			double frac3 = 1.0D * (time4 - time3) / totaltime;
			double frac4 = 1.0D * (time5 - time4) / totaltime;
			double frac5 = 1.0D * (time6 - time5) / totaltime;
			double frac6 = 1.0D * (time7 - time6) / totaltime;
			double frac7 = 1.0D * (time8 - time7) / totaltime;
			
			//  System.out.println("frac12345678 == " + frac1 + "  " + frac2 + "  " +
			//
			//    frac3 + "  " + frac4 + "  " + frac5 + "  " + frac6 + "  " + frac7);
			
			
			long computetime = System.nanoTime() - starttime;
			
			//  System.out.print("Verify signature time = ");
			//  System.out.print(new Number(computetime)
			//      .setPrecision(4) .divide(1L*1024*1024*1024));
			//  System.out.println(" seconds");
			
			return SAS.equals(RYRMR1MMR2RRR3M);
		}
		
		
		
		else if (cipher.equalsIgnoreCase(lsdl))
		{
		
			//	-----------------------------------------
			//	
			//	Latin square / circulant matrix
			//	discrete log digital signature algorithm
			//	
			//	p is the base modulus
			//	q = p-1 is the exp modulus
			//	
			//	A1 and A2 are public Latin squares
			//	or circulant matrices
			//	
			//	x1 and x2 are static private keys
			//	k1 and k2 are one-time private keys
			//	
			//	m is the hash of the message
			//	R is the one-time signature key
			//	s is the signature equation
			//	Y is the static signature key
			//	
			//	r is an integer value of R
			//	(such as R.toIntegerString)
			//	
			//	           x1   x2
			//	Y  =  x  A1   A2   (mod p)
			//	           k1   k2
			//	R  =  k  A1   A2   (mod p)
			//	
			//	s1  =  k1 m + x1 r  (mod q)
			//	s2  =  k2 m + x2 r  (mod q)
			//	
			//	  m   r       s1   s2
			//	R   Y   ==  A1   A2   (mod p)
			//	
			//	-----------------------------------------
			
			
			String sstring1 = sstring.substring( 0, 40);
			String sstring2 = sstring.substring(40, 80);
			
			Number s1 = new Number(sstring1, 16);
			Number s2 = new Number(sstring2, 16);
			
			Matrix R = sig.stringToLatinSquare(mrsy[1].trim(), 2, 1);
			Matrix Y = sig.stringToLatinSquare(mrsy[3].trim(), 2, 1);
			
			String Rstring = sig.LatinSquareToString(R);
			
			Number r = new Number(Rstring,radix) .mod(q);
			
			//            m   r       s1   s2
			//  Verify  R   Y   ==  A1   A2
			
			Matrix R2m = R .modPow(m, p);
			Matrix Y2r = Y .modPow(r, p);
			
			Matrix A12s1 = A1 .modPow(s1, p);
			Matrix A22s2 = A2 .modPow(s2, p);
			
			Matrix M1 = R2m .multiply(Y2r) .mod(p);
			
			Matrix M2 = A12s1 .multiply(A22s2) .mod(p);
			
			////  boolean bool = M1.equals(M2);
			
			boolean bool = M1.get(0,0) .modDivide(M1.get(1,0), p)
			       .equals(M2.get(0,0) .modDivide(M2.get(1,0), p));
			
			long computetime = System.nanoTime() - starttime;
			
			//  System.out.print("Verify signature time = ");
			//  System.out.print(new Number(computetime)
			//      .setPrecision(2) .divide(1000000000));
			//  System.out.println(" seconds");
			
			return bool;
		}
		
		//  else if (cipher.equalsIgnoreCase(......))
		
		else return false;
	}
}


//  End class Signature























class Cipher
{

	//  The Private Key / Cipher class
	
	
	//  static variables for static encryption methods
	
	//  The default encryption methods
	
	final public static int encrypt_method_1 = 1; // hash + cbc;
	final public static int encrypt_method_2 = 2; // big hash;
	final public static int encrypt_method_3 = 3; // big hash;
	
	//  The second and third encrypt methods are 10 times faster
	//  than the first encrypt method for file encryption
	
	
	public static int encrypt_method = encrypt_method_3;
	
	
	//  member variables for non-static encryption methods
	
	//  ...
	
	
	
	//  Hash encryption ciphers are used in the private key / cipher
	//  class because hash ciphers are unbreakable.
	
	//  These encryption methods could change in future versions of
	//  the software. If the hash functions or encryption protocols
	//  are changed, users will have to upgrade to the new software
	//  and re-encrypt their files, folders or directories.
	
	
	
	//  Messages are encrypted by choosing a random number or one-time encryption key
	//  (using the passphrase, the system nano time, and the plaintext hash as sources
	//  of entropy), hashing the random number to create a one-time pad, xor-ing the one-
	//  time pad and the plaindata or plaintext to generate the cipherdata or ciphertext,
	//  and then using the shared secret key or passphrase hash as a re-usable pad to en-
	//  crypt the random number. The receiver decrypts a message by xor-ing the encrypted
	//  random number using the shared secret key as a one-time or reusable pad, hashing
	//  the random number to create the one-time pad, and then xor-ing the one-time pad
	//  and the cipherdata to recover the plaindata.
	
	
	
	//  For a hash cipher, c[i] = p[i] (+) H(k + i)
	//
	//  where p is the plaintext, c is the ciphertext, k is a one-time encryption key,
	//  and i is an indexer. The secret key k can be generated from the hash of the
	//  plaintext, the system nano time (to initialize the rng), and the passphrase.
	//
	//  The encrypted one-time encryption key is k' = k (+) SK where the secret key
	//  SK = the hash of the passphrase for private key encryption or SK = the public
	//  key agreement or shared secret key for public key encryption. The encrypted one-
	//  time encryption key k' can be prepended or appended to the ciphertext because
	//  only the encryptor, decryptor, or recipient knows the value of SK to decrypt
	//  k' and recover the one-time encryption key k.
	
	//  An encrypted or secret message can be called a cryptogram or cryptograph, or it
	//  can be called cipherdata, ciphertext, or cipher. Cipher can refer to the secret
	//  message or to the algorithm or method used to encipher the message.
	//
	//  The words encipher and encrypt can be used synonymously because they have similar
	//  meanings. To encipher means to make empty or zero and to encrypt means to make
	//  secret or hidden.
	
	
	
	
	
	//  Private key cipher notes
	//
	//  The private key / cipher class uses a hash function for encryption. Only one hash function is
	//  required for encryption because a hash function is more complicated than a public key function.
	//  Hash functions are more complicated than public key ciphers because public key ciphers are equa-
	//  tions that have to be commutative or invertible for key agreement whereas hash functions are algo-
	//  rithms that only have to be computable.
	//
	//  A hash function doesn't encrypt messages because a hash function is non-invertible. A hash func-
	//  tion is used to generate a sequence of random numbers or a one-time pad which is xor-ed with the
	//  plaintext to generate the ciphertext c[i] = p[i] + H(k + i). A hash cipher is provably unbreakable
	//  because it uses a non-invertible sequence of random numbers or a one-time pad for encryption.
	//
	//  A one-time pad is provably secure by the definition of randomness (all possible values are equally
	//  probable) and the rotation of equal probabilities. To prove that a one-time pad is perfectly se-
	//  cure, or that adding a non-random number m to a random number k still generates a random number c,
	//  write the equation k + m == c and then solve for the message m = c - k. Since k is random, by def-
	//  inition this means that all values of k are equally likely or probable; therefore all values of
	//  m = c - k are also equally probable, because adding a constant to a random number just rotates the
	//  probabilities modulo the number of digits or values.
	//
	//  The random and non-random numbers have to have the same modulus or number of digits or else the
	//  probabilities would be unequal and the one-time pad would be insecure. For example, if the random
	//  number k were a binary number and m were a decimal number, then adding the two numbers modulo 10
	//  would generate a non-random number c because adding a binary number modulo 10 is equivalent to
	//  adding a decimal number in which the first two values 0 and 1 each have a 1/2 probability and the
	//  next eight values 2 to 9 have a zero probability. This would mean that a random binary number is
	//  really a non-random decimal number being added to a decimal number. Adding or multiplying two
	//  numbers that have different moduli is also an illegal or undefined operation in math.
	//
	//  A one-time pad is also proved to be secure by matrix theory because any system of simultaneous
	//  linear equations in which there are more variables than equations is indeterminate or has an in-
	//  finite or modular number of solutions. A system of linear equations that has more variables than
	//  equations cannot be reduced to echelon (triangular) form and row canonical (diagonal) form or
	//  solved by Gaussian elimination. This proves that a one-time pad is unsolvable or cannot be reduced
	//  to echelon form because it has two variables but only one equation.
	//
	//  If the same one-time pad were reused for another message, then the ciphertext would no longer be
	//  secure because there would be two equations k + m1 == c1 and k + m2 == c2 for each digit or char-
	//  acter, and then the random value k could be eliminated by subtraction to get the non-random dif-
	//  ference m1 - m2 == c1 - c2 == c3 for each character in the plaintext. This means that each message
	//  would be encrypted with another message or a non-random one-time pad.
	//
	//  The only reason to use an (invertible) encryption cipher instead of a hash cipher or one-time pad
	//  is to be able to reuse the same encryption key so the message or file does not have to expand to
	//  include the one-time secret key. However, an encryption cipher may also require an initialization
	//  vector because files that start with the same plaintext will also start with the same ciphertext
	//  unless a different iv is used. The initialization vector or initial value negates the benefit of
	//  using an encryption cipher because a one-time iv has to be stored instead of a one-time encrypted
	//  encryption key.
	//
	//  The use of invertible private key ciphers violates a principle of cryptography that private keys
	//  are not supposed to be reused for each block of data. Encryption ciphers also have a one-to-one
	//  mapping of plaindata to cipherdata because the functions have to be invertible which makes them
	//  vulnerable to cryptanalysis or susceptible to Fourier analysis.
	//
	//  Another problem with encryption ciphers is that nobody knows which ciphers are broken because the
	//  methods of cryptanalysis are secret. By using a hash cipher instead of an encryption cipher, the
	//  private key / cipher class sidesteps the problem of cryptanalysis and makes the knowledge that
	//  cryptanalysts have worthless because hash functions are non-invertible. Even a quantum computer
	//  would be unable to break a hash cipher.
	//
	//  Moreover, the hash function uses a large memory buffer which not only reduces the amount of work
	//  required to compute n multiplications for each hash value from O(n) to O(n^0) or O(1) but also
	//  makes cryptanalysis impossible because the internal state of the hash machine is unknown. Each
	//  hash value uses the sum of the four matrix elements at the current index of the circular array
	//  instead of using the element values by themselves so a cryptanalyst has no information about the
	//  cipher except for the sum of four variables that are added to the plaintext.
	//
	//  A hash cipher requires a one-time secret key such as k + H(m) for file encryption or the public
	//  key agreement for message encryption. For file encryption the secret encryption key has to be en-
	//  crypted by xor-ing it with a static or shared secret key so the key can be attached (prepended or
	//  appended) to the encrypted file. (The encrypted encryption key could be stored with the file name
	//  if the operating system or file system allows programs to set a file key for each file just as it
	//  allows programs to store metadata such as access permissions, content type, last-modification
	//  time, and other information about the file.)
	//
	//  For email or asynchronous communication messages are converted to base 64 after encryption because
	//  encrypted data or cipherdata contains random characters. If there are any missing data blocks the
	//  ciphertext will not be decryptable even if CBC is used because the message will not decode from
	//  base 64 unless it just happens to be missing a sequence of four consecutive base-64 chars.
	//
	//  The ciphers in the private key / cipher class are not compatible with other private key standards,
	//  just as the ciphers in the public key class are not compatible with other public key standards;
	//  the Mail program is not compatible with PCP; and the SSL class is not compatible with other SSL /
	//  TLS classes because it uses different ciphers, multiple / composite keys, and a different key
	//  exchange / key agreement protocol.
	
	
	
	
	
	
	//  encrypt / decrypt methods
	
	
	//  If a file is larger than the max file size, the hash
	//  methods will use the RandomAccessFile or FileChannel
	//  methods instead of reading the entire file into memory.
	
	
	public static final int maxfilesize = (int) (2L*1024*1024*1024-1);
	
	
	public static String encrypt(String message, byte[] encryptionkey)
	{
		byte[] plaindata = message.getBytes();
		
		byte[] cipherdata = encrypt(plaindata, encryptionkey);
		
		String str = Convert.byteArrayToBase64(cipherdata);
		
		return str;
	}
	
	
	public static String decrypt(String message, byte[] encryptionkey)
	{
		byte[] cipherdata = Convert.base64ToByteArray(message);
		
		byte[] plaindata = decrypt(cipherdata, encryptionkey);
		
		if (plaindata == null) return null;
		
		String str = new String(plaindata);
		
		return str;
	}
	
	
	
	
	//  Padding is used to make an array or file a multiple of the cipher block size such as a
	//  multiple of 32 bytes or 256 bits and to test if the cipherdata decrypted correctly be-
	//  cause encryption and decryption generate random bytes of data unless the correct decryp-
	//  tion key is used. The padding also has to have a pattern that can be detected so that it
	//  can be removed without removing bytes from the plaindata or plaintext. Of course any non-
	//  random pattern could be used to pad the plaindata. (For example, the padding could append
	//  a 1 and then the Fibonacci sequence 1,1,2,3,5,8,13,21,34,55,89,..., and the isPadded
	//  method could test if each byte is the sum of the two preceding bytes modulo 256 to remove
	//  the padding.) But the simplest pattern is to repeat the last char or byte and then use a
	//  repeating increment such as 1,2,3,4,5,6,7,8,... The padding could also append the number
	//  of bytes which would require up to five bytes for files larger than 4 G unless the size
	//  is reduced modulo 256 or 64 K. Appending the number of bytes would verify the length of
	//  the message, but it wouldn't verify the integrity of the message unless a hash value were
	//  appended to the padding.
	//
	//  No padding scheme is perfect because if the user intentionally creates a document that
	//  uses the padding scheme, then the test will return true even though the padding is part
	//  of the document. A user would have to repeat the last char and then append at least
	//  32 + 1 consecutive chars from the ASCII set ... !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
	//  HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ... to create a padded document
	//  which couldn't happen accidentally.
	//
	//  For example, if the user types a document, appends an 'A' and then the Latin alphabet
	//  A to Z followed by the seven chars [\]^_`a, or the user types 00123456789:;<=>?@ABCDEFG
	//  HIJKLMNOP the isPadded method will return true. If the chars are reversed it will also
	//  return true because the front of the array will be padded. But it wouldn't matter be-
	//  cause if the encrypt and decrypt methods pad and remove from the same end of the array,
	//  then only the encrypt padding would get removed, unless the encrypt method does an is-
	//  Padded test (which it does so the plaindata doesn't get padded twice by the PublicKey
	//  and the Private Key / Cipher encrypt methods). And even if it does get removed it
	//  wouldn't matter if the user is padding the document intentionally, and if the padding
	//  is unintentional then the recipient will only be missing an increasing sequence of bytes
	//  (or a sequence of Fibonacci numbers modulo 256).
	//
	//  For email encryption the front of the array should be padded so the recipient can down-
	//  load the tops of the messages and decrypt the partial ciphertexts to read the subject
	//  lines and from addresses. Otherwise the program would have to do a randomness test to
	//  determine if the ciphertext decrypted correctly. Any randomness test would work for
	//  plaintext because decryption generates perfectly random numbers if the wrong decryption
	//  key is used. (Multiple random tests are only required for chosen plaintext or plaindata.
	//  For example, the increasing sequence of bytes 0,1,2,...,255 passes some randomness tests
	//  and the isRandom() method may return true unless more tests are added.) Even a randomness
	//  test wouldn't be a perfect solution to test for decryption because a sender could choose
	//  a random sequence of bytes such as a secret key or one-time pad and then the receiver or
	//  decryption method wouldn't know if the ciphertext decrypted correctly because the plain-
	//  text would be perfectly random.
	//
	//  This padding method could be replaced by another pattern in future versions of the soft-
	//  ware if there is a reason to replace it and then the isPadded method would have to test
	//  for different patterns. For example, if some file types use a repeating char and an in-
	//  crementing sequence, then the padding method would have to be replaced by another pattern
	//  such as the Fibonacci sequence.
	
	
	
	public static byte[] addPadding(byte[] plaindata)
	{
		//  Pad at least 32 and less than 64 bytes at the end of the array
		
		//  if (isPadded(plaindata)) System.out
		//
		//      .println("data is already padded");
		
		int bytes = 64 - (plaindata.length % 32);
		
		byte[] paddeddata = addPadding(plaindata, bytes, false);
		
		return paddeddata;
	}
	
	
	public static byte[] addPadding(byte[] plaindata, boolean front)
	{
		//  Pad at least 32 and less than 64 bytes at the end of the array
		
		//  if (isPadded(plaindata)) System.out
		//
		//      .println("data is already padded");
		
		int bytes = 64 - (plaindata.length % 32);
		
		byte[] paddeddata = addPadding(plaindata, bytes, front);
		
		return paddeddata;
	}
	
	
	public static byte[] addPadding(byte[] plaindata, int bytes, boolean front)
	{
	
		//  Pad the plaindata with any byte and use any increment
		//  from 0 to 255 that is different from the last two bytes
		//
		//  Use the same last byte of the array and then increment
		//  each byte by one so the two increments are different
		
		byte c = 0, d = 1; // c = plaindata[0] or plaindata[-1]
		
		byte[] array = new byte[plaindata.length + bytes];
		
		if (front) // Add padding to the front of the array
		{
			if (plaindata.length != 0) c = plaindata[0];
			
			//  Add padding to the front of the array
			
			for (int i = 0; i < plaindata.length; i++)
			
			    array[bytes + i] = plaindata[i];
			
			//  Prepend the byte c and increment by d
			
			array[bytes -1] = c;
			
			for (int i = 0; i < bytes -1; i++)
			
			   array[bytes -2 -i] = (byte)
			  (array[bytes -1 -i] + d);
			
			return array;
		}
		
		
		else // if (!front)
		{
			//  Add padding to the back of the array
			
			if (plaindata.length != 0)
			
			    c = plaindata[plaindata.length -1];
			
			for (int i = 0; i < plaindata.length; i++)
			
			    array[i] = plaindata[i];
			
			//  Append the byte c and increment by d
			
			array[array.length - bytes] = c;
			
			for (int i = 1; i < bytes; i++)
			
			   array[array.length - bytes + i] = (byte)
			  (array[array.length - bytes + i -1] + d);
			
			return array;
		}
	}
	
	
	
	public static byte[] removePadding(byte[] plaindata)
	{
	
		if (plaindata.length < 8) return null;
		
		int s = 256; // the size of a byte
		
		byte[] plaindata1 = Arrays.copyOf(
		
		   plaindata, plaindata.length);
		
		if (!isPadded(plaindata1)) return plaindata1;
		
		byte[] array = null;
		
		
		if (isPadded(plaindata1, false))
		{
			//  Remove back padding and truncate the array
			
			//  The increment between two consecutive bytes
			//  is reduced modulo the size of a byte
			
			int d = plaindata1[plaindata1.length -1]
			      - plaindata1[plaindata1.length -2];
			
			d = ((d % s) + s) % s;
			
			for (int i = 0; i < 8; i++)
			{
				int d1 = plaindata1[plaindata1.length -1 -i]
			               - plaindata1[plaindata1.length -2 -i];
				
				d1 = ((d1 % s) + s) % s;
				
				if (d1 != d) break; // no padding
			}
			
			//  Find the length of the padding
			
			int index = 0;
			
			while (index < plaindata1.length -1)
			{
				int d1 = plaindata1[plaindata1.length -1 -index]
				       - plaindata1[plaindata1.length -2 -index];
				
				d1 = ((d1 % s) + s) % s;
				
				if (d1 == d) index++;
				
				else break;
			}
			
			if (index >= 8)
			{
				int padlength = index + 1;
				
				array = new byte[plaindata1.length - padlength];
				
				for (int i = 0; i < array.length; i++)
				
				    array[i] = plaindata1[i];
			}
			
			//  Re-assign the array
			
			plaindata1 = array;
		}
		
		
		if (isPadded(plaindata1, true))
		{
			//  Remove front padding and truncate the array
			
			int d = plaindata1[1] - plaindata1[0];
			
			d = ((d % s) + s) % s;
			
			for (int i = 1; i < 8; i++)
			{
				int d1 = plaindata1[i] - plaindata1[i-1];
			
				d1 = ((d1 % s) + s) % s;
				
				if (d1 != d) break; // no padding
			}
			
			//  Find the length of the padding
			
			int index = 0;
			
			while (index < plaindata1.length -1)
			{
				int d1 = plaindata1[index+1] - plaindata1[index];
				
				d1 = ((d1 % s) + s) % s;
				
				if (d1 == d) index++;
				
				else break;
			}
			
			if (index >= 8)
			{
				int padlength = index + 1;
				
				array = new byte[plaindata1.length - padlength];
				
				for (int i = 0; i < array.length; i++)
				
				    array[i] = plaindata1[padlength + i];
			}
		}
		
		
		if (array.length == 0)
		
		try { throw new ArithmeticException(); }
		
		catch (ArithmeticException ex)
		{
			System.out.println(Arrays.toString(plaindata1));
			
			ex.printStackTrace();
			
			return null;
		}
		
		return array;
	}
	
	
	
	public static boolean isPadded(byte[] array)
	{
		return isPadded(array, true) || isPadded(array, false);
	}
	
	
	public static boolean isPadded(byte[] array, boolean front)
	{
	
		//  tests if a decrypted array is padded
		
		if (array.length < 32) return false;
		
		int s = 256; // the size of a byte
		
		
		if (front == false)
		{
			//  Calculate the difference between the last two elements
			
			boolean padded = true;
			
			int d = array[array.length -1]
			      - array[array.length -2];
			
			d = ((d % s) + s) % s;
			
			if (d == 0) return false;
			
			//  Calculate the difference between the next several elements
			
			for (int i = 0; array.length -i -2 >= 0; i++)
			{
				int d1 = array[array.length -i -1]
				       - array[array.length -i -2];
				
				d1 = ((d1 % s) + s) % s;
				
				//  Test for a minimum number of increments
				//  and then a repeating char or byte
				
				if ((d1 != d) || (array.length -i -2 == 0))
				{
					if ((array[array.length -i -1]
					  != array[array.length -i -2]) || (i < 32))
					 
					    padded = false;
					
					break;
				}
			}
			
			return padded;
		}
		
		
		else // if (front == true)
		{
			//  Calculate the difference between the first two elements
			
			boolean padded = true;
			
			int d = array[1] - array[0];
			
			d = ((d % s) + s) % s;
			
			if (d == 0) return false;
			
			//  Calculate the difference between the next several elements
			
			for (int i = 1; i < array.length; i++)
			{
				int d1 = array[i] - array[i-1];
				
				d1 = ((d1 % s) + s) % s;
				
				//  Test for a minimum number of increments
				//  and then a repeating char or byte
				
				if ((d1 != d) || (i == array.length-1))
				{
					if ((array[i] != array[i-1]) || (i < 32))
					
					    padded = false;
					
					break;
				}
			}
			
			return padded;
		}
	}
	
	
	
	
	private static byte[] oneTimeEncryptionKey(byte[] encryptionkey)
	{
	
		//  Chooses a one-time secret encryption key k
		//  using multiple sources of entropy
		//
		//  (The three sources of entropy are the user's private key or
		//  passphrase, the plaintext message, and the current time in
		//  nano seconds. Secure Random is too slow for multiple file
		//  or directory encryption.)
		
		
		//  Generate random bytes using the current time
		
		long randtime = System.nanoTime();
		
		Random rng = new Random(randtime);
		
		double rand = rng.nextDouble();
		
		long rand64 = (long) (0x4000000000000000L * rand);
		
		int rand32 = (int) (rand64 % 0xffffffffL);
		
		byte[] randbytes = Cipher.hash(
		
		    new Number(rand32).toByteArray());
		
		
		//  Generate a one-time encryption key
		//
		//  k = H(encryption key, random bytes, m = H(M))
		
		byte[] k = Cipher.hash(
		
		    Math.xor(encryptionkey, randbytes) );
		
		return k;
	}
	
	
	
	public static byte[] encrypt(byte[] plaindata, byte[] encryptionkey)
	{
		return encrypt(plaindata, encryptionkey, encrypt_method, null);
	}
	
	
	public static byte[] encrypt(byte[] plaindata, byte[] encryptionkey, int encrypt_method)
	{
		return encrypt(plaindata, encryptionkey, encrypt_method, null);
	}
	
	
	public static byte[] encrypt(
	
	    byte[] plaindata, byte[] encryptionkey, int encrypt_method, byte[] bytes)
	{
	
		//  This method pads the data, generates a random one-time encryption key e,
		//  encrypts the random one-time key by xor-ing the static encryption key,
		//  encrypts the plaindata, and prepends the encrypted one-time encryption
		//  key to the cipherdata array.
		
		//  The first 32 bytes are reserved for the encrypted encryption key.
		//  The second 32 bytes contain the hash of the encrypted encryption key
		//  but they can be used for any other data. The hash is used only to
		//  occupy the empty space. The isEncrypted(file) method uses the hash
		//  to test if the file is encrypted, but other tests can be added to
		//  the isEncrypted(file) method.
		
		//  (encrypted encryption key k' = one-time encryption key k (+) static / file key e)
		//
		//   k'= k (+) e   random bytes           plaindata or cipherdata
		//    xxxx xxxx     xxxx xxxx     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx ....
		
		
		//  Test the data array, the encryption key, and the file information
		
		if ((bytes != null) && (bytes.length != 32))
		
		    throw new IllegalArgumentException();
		
		if (plaindata == null) return null;
		
		if (encryptionkey.length != 32)
		
		    encryptionkey = hash(encryptionkey);
		
		
		//  Pad the plaindata to a multiple of 32 bytes
		
		boolean front = false;
		
		if (!isPadded(plaindata))
		
		    plaindata = addPadding(plaindata, front);
		
		
		//  Generate a one-time encryption key
		
		byte[] k = oneTimeEncryptionKey(encryptionkey);
		
		
		//  Encrypt the one-time encryption key k using
		//  the static / file key as a reusable pad
		//
		//  encrypted key k' = k (+) static / file key
		
		byte[] encryptedkey = Math.xor(k, encryptionkey);
		
		
		//  Encrypt the plaindata with the one-time secret key k
		
		byte[] cipherdata;
		
		if (encrypt_method == encrypt_method_1)
		
		    cipherdata = hashEncrypt(plaindata, k, new byte[32], true);
		
		else if (encrypt_method == Cipher.encrypt_method_3)
		
		    cipherdata = bigHashEncrypt(plaindata, k, new byte[32]);
		
		////  else if (encrypt_method == Cipher.encrypt_method ...)
		////
		////      cipherdata = ... Encrypt(plaindata, k, new byte[32]);
		
		else throw new IllegalArgumentException();
		
		
		
		//  Prepend the hash of the encrypted key
		//
		//  or the 32-byte file information (if byte[] != null)
		
		byte[] encryptedkeyhash = hash(encryptedkey);
		
		byte[] data = new byte[32];
		
		byte[] array = new byte[cipherdata.length + 32];
		
		for (int i = 0; i < 32; i++) array[0 + i]
		
		    = (bytes != null) ? bytes[i] : encryptedkeyhash[i];
		
		for (int i = 0; i < cipherdata.length; i++)
		
		    array[32 + i] = cipherdata[i];
		
		cipherdata = array;
		
		
		//  Prepend the encrypted one-time encryption key
		
		array = new byte[cipherdata.length + 32];
		
		for (int i = 0; i < 32; i++)
		
		    array[0 + i] = encryptedkey[i];
		
		for (int i = 0; i < cipherdata.length; i++)
		
		    array[32 + i] = cipherdata[i];
		
		cipherdata = array;
		
		
		return cipherdata;
	}
	
	
	
	
	public static byte[] decrypt(byte[] cipherdata, byte[] encryptionkey)
	{
	
		//  This method removes the prepended encrypted one-time encryption key
		//  from the cipherdata array, decrypts the one-time encryption key k by
		//  xor-ing the static encryption key, and decrypts the cipherdata using
		//  the decrypted one-time encryption key k.
		
		
		if ((cipherdata == null) || (cipherdata.length < 64))
		
		    throw new IllegalArgumentException();
		
		if (encryptionkey.length != 32)
		
		     encryptionkey = hash(encryptionkey);
		
		
		//  Read the encrypted encryption key (bytes 0 to 32)
		
		byte[] encryptedkey = new byte[32];
		
		for (int i = 0; i < 32; i++)
		
		    encryptedkey[i] = cipherdata[0 + i];
		
		
		//  Read the empty space (bytes 32 to 64)
		//
		//  This hash of the encrypted key is used to fill
		//  this space which is reserved for future use
		
		byte[] encryptedkeyhash = new byte[32];
		
		for (int i = 0; i < 32; i++)
		
		    encryptedkeyhash[i] = cipherdata[32 + i];
		
		
		//  Decrypt the encrypted one-time key
		
		//  k = encrypted key k' - static encryption key
		
		byte[] k = Math.xor(encryptedkey, encryptionkey);
		
		
		//  Read the cipherdata
		
		byte[] array = new byte[cipherdata.length - 64];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = cipherdata[64 + i];
		
		cipherdata = array;
		
		byte[] plaindata = null;
		
		
		//  Decrypt the cipherdata by trying all the ciphers
		
		//  Try the fastest decryption method first
		
		if ((plaindata == null) || !isPadded(plaindata))
		
		    plaindata = bigHashDecrypt(cipherdata, k, new byte[32]);
		
		
		//  This test was added to make the code backward com-
		//  patible but it could be removed in future versions
		
		if ((plaindata == null) || !isPadded(plaindata))
		{
			encrypt_method = encrypt_method_2;
			
			plaindata = bigHashDecrypt(cipherdata, k, new byte[32]);
			
			encrypt_method = encrypt_method_3;
		}
		
		
		if ((plaindata == null) || !isPadded(plaindata))
		
		    plaindata = hashDecrypt(cipherdata, k, new byte[32], true);
		
		//  Return null if the cipherdata does not decrypt
		
		if ((plaindata == null) || !isPadded(plaindata)) return null;
		
		
		//  Remove the padding
		
		plaindata = removePadding(plaindata);
		
		return plaindata;
	}
	
	
	
	
	public static boolean encryptLargeFile(File file, byte[] encryptionkey) throws IOException
	{
		//  Encrypts a large file using the FileChannelReader and FileChannel Writer class
		
		//  The encryption method was tested by hashing a large file before
		//  and after encryption and verifying that the hashes are identical
		
		//  Note that using force() after each write operation makes file encryption and
		//  decryption one-third slower. The updates will be written to storage anyway be-
		//  cause the file channel reader and writer are closed at the end of the method.
		
		
		//  Set the array size for the buffer and read the array size plaindata;
		//  write the encrypted encryption key to the file channel writer and
		//  write the encrypted encryption key hash to the file channel writer
		//  using a 32-byte buffer; then for each array size read the plaindata
		//  from the file channel reader while bytes read >= 0, encrypt the
		//  plaindata, and write the cipherdata to the file channel writer.
		
		//  The read positions are 0*size, 1*size, 2*size, 3*size, 4*size, ...
		//  the write positions are 64, 64 + padlen + 1*size, 64 + padlen + 2*size, ...
		
		final int arraysize = 128*1024*1024;
		
		String filepath = file.getPath();
		
		FileChannelReader reader = new FileChannelReader(filepath);
		
		String tempfilepath = null;
		
		try
		{
		
		File tempfile = File.createTempFile(
		
		    file.getName(), null, new File(file.getParent()));
		
		tempfilepath = tempfile.getPath();
		
		FileChannelWriter writer;
		
		writer = new FileChannelWriter(tempfilepath);
		
		
		ByteBuffer bytebuffer;
		
		bytebuffer = ByteBuffer.allocate(arraysize);
		
		
		long bytesread = 0;
		
		long byteswritten = 0;
		
		reader.position(bytesread);
		
		bytesread += reader.read(bytebuffer);
		
		
		//  Pad the front / left side of the plaindata
		
		byte[] plaindata = bytebuffer.array();
		
		int numberofpadbytes = arraysize / 2 + Math.random(arraysize / 2);
		
		while (((plaindata.length + numberofpadbytes) % 4) != 0)
		
		    numberofpadbytes++;
		
		if (numberofpadbytes >= arraysize)
		
		    throw new IllegalArgumentException();
		
		int padlen = numberofpadbytes;
		
		plaindata = addPadding(plaindata, padlen, true);
		
		
		//  Generate a one-time encryption key
		
		byte[] k = oneTimeEncryptionKey(encryptionkey);
		
		
		//  Encrypt the one-time encryption key k using
		//  the static / file key as a reusable pad
		//
		//  encrypted key k' = k (+) static / file key
		
		byte[] encryptedkey = Math.xor(k, encryptionkey);
		
		
		//  Compute the hash of the encrypted key
		//
		//  or the 32-byte file information (if byte[] != null)
		
		byte[] encryptedkeyhash = hash(encryptedkey);
		
		
		//  Write the encrypted encryption key to the file channel writer and
		//  write the encrypted encryption key hash to the file channel writer
		
		byte[] byte32;
		
		ByteBuffer bytebuffer32;
		
		byte32 = encryptedkey;
		
		bytebuffer32 = ByteBuffer.wrap(byte32);
		
		writer.position(0);
		
		byteswritten += writer.write(bytebuffer32);
		
		byte32 = encryptedkeyhash;
		
		bytebuffer32 = ByteBuffer.wrap(byte32);
		
		byteswritten += writer.write(bytebuffer32);
		
		
		//  For each array size read the plaindata from the file channel reader
		//  while bytes read >= 0, encrypt the plaindata and write the cipherdata
		//  to the file channel writer
		
		BigHash bighash = new Cipher() .new BigHash(k);
		
		
		//  Encrypt the plaindata with the one-time secret key k
		//  Use a fast hash algorithm that generates an array of
		//  random numbers or one-time pad for file encryption
		
		byte[] hasharray = bighash.hash(plaindata.length);
		
		//  Encrypt the plaindata by xor-ing the hash
		//
		//  c[i] = p[i] (+) hash[i]
		
		byte[] cipherdata = Math.xor(plaindata, hasharray);
		
		boolean lastarray = false;
		
		for (int t = 0;  ; t++)
		{
			//  Read the next array size or less of plaindata
			
			bytebuffer = ByteBuffer.allocate(arraysize);
			
			reader.position(bytesread);
			
			int bytesread1 = reader.read(bytebuffer);
			
			
			//  Write the cipherdata
			
			writer.position(byteswritten);
			
			byteswritten += writer.write(
			
			    ByteBuffer.wrap(cipherdata));
			
			
			if (bytesread1 > 0) bytesread += bytesread1;
			
			if (bytesread1 < arraysize) lastarray = true;
			
			plaindata = bytebuffer.array();
			
			//  Encrypt the plaindata with the one-time secret key k
			//  Use a fast hash algorithm that generates an array of
			//  random numbers or one-time pad for file encryption
			
			//  For the final hash it doesn't matter if the
			//  number of bytes read is not divisible by 4
			
			hasharray = bighash.hash(bytesread1);
			
			//  Encrypt the plaindata by xor-ing the hash
			//
			//  c[i] = p[i] (+) hash[i]
			
			if (lastarray) plaindata = Arrays.copyOf(plaindata, bytesread1);
			
			cipherdata = Math.xor(plaindata, hasharray);
			
			if (lastarray == true)
			{
				//  Write the cipherdata
				
				writer.position(byteswritten);
				
				byteswritten += writer.write(
				
				    ByteBuffer.wrap(cipherdata));
				
				break;
			}
		}
		
		reader.close();
		writer.close();
		
		boolean delete = file.delete();
		
		tempfile.renameTo(new File(filepath));
		
		return true;
		
		}
		
		finally
		{	if (tempfilepath != null)
			
			    new File(tempfilepath).delete();
		}
	}
	
	
	
	public static boolean decryptLargeFile(File file, byte[] encryptionkey) throws IOException
	{
		//  Decrypts a large file using the FileChannelReader and FileChannel Writer class
		
		//  The encryption method was tested by hashing a large file before
		//  and after encryption and verifying that the hashes are identical
		
		
		//  Read the encrypted encryption key from the file channel reader and
		//  read the encrypted encryption key hash from the file channel reader
		//  using a 32-byte buffer; set the arraysize for the byte buffer; then
		//  for each array size read the cipherdata from the file channel reader
		//  while bytes read >= 0, decrypt the cipherdata, and write the plaindata
		//  to the file channel writer.
		
		//  The read positions are 64 + 0*size, 64 + 1*size, 64 + 2*size, 64 + 3*size, ...
		//  the write positions are 0*size, 1*size - padlen - 64, 2*size - padlen - 64, ...
		
		final int arraysize = 128*1024*1024;
		
		String filepath = file.getPath();
		
		FileChannelReader reader = new FileChannelReader(filepath);
		
		String tempfilepath = null;
		
		try
		{
		
		File tempfile = File.createTempFile(
		
		    file.getName(), null, new File(file.getParent()));
		
		tempfilepath = tempfile.getPath();
		
		FileChannelWriter writer = new FileChannelWriter(tempfilepath);
		
		
		byte[] byte32;
		
		ByteBuffer bytebuffer32;
		
		byte32 = new byte[32];
		
		bytebuffer32 = ByteBuffer.wrap(byte32);
		
		reader.position(0);
		
		reader.read(bytebuffer32);
		
		byte[] encryptedkey = Arrays.copyOf(
		
		    bytebuffer32.array(),
		    bytebuffer32.array().length);
		
		byte32 = new byte[32];
		
		bytebuffer32 = ByteBuffer.wrap(byte32);
		
		reader.read(bytebuffer32);
		
		byte[] encryptedkeyhash = Arrays.copyOf(
		
		    bytebuffer32.array(),
		    bytebuffer32.array().length);
		
		
		//  Decrypt the encrypted one-time key
		
		//  k = encrypted key k' - static encryption key
		
		byte[] k = Math.xor(encryptedkey, encryptionkey);
		
		
		//  For each array size read the plaindata from the file channel reader
		//  while bytes read >= 0, encrypt the plaindata and write the cipherdata
		//  to the file channel writer
		
		ByteBuffer bytebuffer;
		
		bytebuffer = ByteBuffer.allocate(arraysize);
		
		
		long bytesread = 0;
		
		long byteswritten = 0;
		
		reader.position(64);
		
		bytesread += reader.read(bytebuffer);
		
		
		boolean padded = false;
		
		byte[] cipherdata = bytebuffer.array();
		
		
		//  Decrypt the cipherdata with the one-time secret key k
		//  Use a fast hash algorithm that generates an array of
		//  random numbers or one-time pad for file encryption
		
		BigHash bighash = new Cipher() .new BigHash(k);
		
		byte[] hasharray = bighash.hash(cipherdata.length);
		
		
		//  Decrypt the cipherdata by xor-ing the hash
		//
		//  p[i] = c[i] (+) hash[i]
		
		byte[] plaindata = Math.xor(cipherdata, hasharray);
		
		int padlen = 0;
		
		if (!isPadded(plaindata))
		{
			tempfile.delete();
			
			return false;
		}
		
		else
		{	padded = true;
			
			byte[] plaindata1 = removePadding(plaindata);
			
			padlen = plaindata.length - plaindata1.length;
			
			plaindata = plaindata1;
		}
		
		boolean lastarray = false;
		
		for (int t = 0;  ; t++)
		{
			//  Read the next array size or less of cipherdata
			
			bytebuffer = ByteBuffer.allocate(arraysize);
			
			long position = 64L + bytesread;
			
			reader.position(position);
			
			int bytesread1 = reader.read(bytebuffer);
			
			if (bytesread1 > 0) bytesread += bytesread1;
			
			
			//  Write the plaindata
			
			position = byteswritten;
			
			writer.position(position);
			
			byteswritten += writer.write(
			
			    ByteBuffer.wrap(plaindata));
			
			
			if (bytesread1 < arraysize) lastarray = true;
			
			cipherdata = bytebuffer.array();
			
			
			//  Decrypt the cipherdata with the one-time secret key k
			//  Use a fast hash algorithm that generates an array of
			//  random numbers or one-time pad for file encryption
			
			//  For the final hash it doesn't matter if the
			//  number of bytes read is not divisible by 4
			
			hasharray = bighash.hash(bytesread1);
			
			//  Decrypt the cipherdata by xor-ing the hash
			//
			//  p[i] = c[i] (+) hash[i]
			
			if (lastarray) cipherdata = Arrays.copyOf(cipherdata, bytesread1);
			
			plaindata = Math.xor(cipherdata, hasharray);
			
			if (lastarray == true)
			{
				//  Write the last plaindata
				
				position = byteswritten;
				
				writer.position(position);
				
				byteswritten += writer.write(ByteBuffer.wrap(plaindata));
				
				break;
			}
		}
		
		reader.close();
		writer.close();
		
		boolean delete = file.delete();
		
		tempfile.renameTo(new File(filepath));
		
		return true;
		
		}
		
		finally
		{	if (tempfilepath != null)
			
			    new File(tempfilepath).delete();
		}
	}
	
	
	
	
	private static byte[] hashEncrypt(byte[] plaindata, byte[] k, byte[] iv, boolean cbc)
	{
	
		if (!isPadded(plaindata))
		
		    plaindata = addPadding(plaindata);
		
		if ((plaindata.length % 32) != 0)
		
		    throw new IllegalArgumentException();
		
		
		//  Initialize the cipherdata array
		
		byte[] temp = new byte[32];
		
		final byte[] k1 = hash(k);
		
		final byte[] prevcipherdata = new byte[32];
		
		final byte[] cipherdata = new byte[plaindata.length];
		
		if ((iv != null) && (iv.length == 32))
		
		    for (int i = 0; i < 32; i++)
		
			prevcipherdata[i] = iv[i];
		
		
		//  Hash encryption and decryption  CTR / CBC
		//
		//  c[i] = p[i] (+) key(i),  p[i] = c[i] (+) ( key(i) = f(k, i) )
		//  c[i] = p[i] (+) key(i),  p[i] = c[i] (+) ( key(i) = f(k, c[i]) )
		//
		//  where p and c are the plaindata and cipherdata, i is an indexer,
		//  and k is the secret encryption key, public key agreement, or any
		//  one-time secret number.
		//
		//  The first method (called counter or CTR mode) cannot recover from
		//  missing cipher blocks because it uses an indexer i for decryption.
		//  Encryption and decryption are parallelizable using this method.
		//
		//  The second method (called cipher block chaining or CBC mode) can
		//  recover from missing cipher blocks because each block p[i] depends
		//  only on the previous block c[i-1], but encryption is not parallel-
		//  izable because each thread requires the final cipher block from
		//  another thread. Decryption is still parallelizable by this method.
		
		
		
		//  Convert the plaindata to cipherdata
		
		//  Divide the byte array into 32-byte, 256-bit arrays
		
		for (int i = 0; i < plaindata.length / 32; i++)
		{
			//  256 bits = hash( 256 bits || 256 bits )
			//
			//  CTR mode  key(i) = H( H( k (+)  H(i) ) || H( k1 (+) H(i) ) )
			//  CBC mode  key(i) = H( H( k (+) c[i-1]) || H( k1 (+) c[i-1] ) )
			
			
			byte[] block_key;
			
			//  Compute the current block key(i)
			
			if (cbc) block_key = hash( Math.join(
			
			    hash( Math.xor(k,  prevcipherdata) ),
			    hash( Math.xor(k1, prevcipherdata) ) ) );
			
			else // if (ctr)
			{
				byte[] array_i = Convert.intToByteArray(i);
				
				byte[] h = hash(array_i);
				
				block_key = hash( Math.join(
				
				    hash( Math.xor(k,  h) ),
				    hash( Math.xor(k1, h) ) ) );
			}
			
			
			//  Read 32 bytes of plaindata
			
			for (int j = 0; j < 32; j++)
			
			    temp[j] = plaindata[32*i + j];
			
			
			//  Encrypt the plaindata by xor-ing the block key
			//
			//  c[i] = p[i] (+) hash(k || c[i-1])
			
			temp = Math .xor(temp, block_key);
			
			
			//  Update the previous cipherdata
			
			for (int j = 0; j < 32; j++)
			
			    prevcipherdata[j] = temp[j];
			
			
			//  Copy the encrypted plaindata / cipherdata
			
			for (int j = 0; j < 32; j++)
			
			    cipherdata[32*i + j] = temp[j];
		}
		
		return cipherdata;
	}
	
	
	
	
	private static byte[] hashDecrypt(byte[] cipherdata, byte[] k, byte[] iv, boolean cbc)
	{
	
		if ((cipherdata.length % 32) != 0)
		{
			//  System.out.println("cipher length is not a multiple of 32");
			
			return null;
		}
		
		//  Initialize the plaindata array
		
		byte[] plaindata = new byte[cipherdata.length];
		
		byte[] temp = new byte[32];
		
		final byte[] k1 = hash(k);
		
		byte[] prevcipherdata = new byte[32];
		
		if ((iv != null) && (iv.length == 32))
		
		    for (int i = 0; i < 32; i++)
		
			prevcipherdata[i] = iv[i];
		
		
		//  Decrypt the cipherdata
		
		//  Divide the byte array into 32-byte, 256-bit arrays
		
		for (int i = 0; i < plaindata.length / 32; i++)
		{
			byte[] block_key;
			
			//  Compute the current block key(i)
			
			if (cbc) block_key = hash( Math.join(
			
			    hash( Math.xor(k,  prevcipherdata) ),
			    hash( Math.xor(k1, prevcipherdata) ) ) );
			
			else // if (ctr)
			{
				byte[] array_i = Convert.intToByteArray(i);
				
				byte[] h = hash(array_i);
				
				block_key = hash( Math.join(
				
				    hash( Math.xor(k,  h) ),
				    hash( Math.xor(k1, h) ) ) );
			}
			
			
			//  Read 32 bytes of cipherdata
			
			for (int j = 0; j < 32; j++)
			
			    temp[j] = cipherdata[32*i + j];
			
			
			//  Update the previous cipherdata
			
			for (int j = 0; j < 32; j++)
			
			    prevcipherdata[j] = temp[j];
			
			
			//  Decrypt the cipherdata by xor-ing the block key
			//
			//  p[i] = c[i] (+) hash[k (+) c[i-1]]
			
			temp = Math .xor(temp, block_key);
			
			
			//  Copy the decrypted cipherdata / plaindata
			
			for (int j = 0; j < 32; j++)
			
			    plaindata[32*i + j] = temp[j];
		}
		
		return plaindata;
	}
	
	
	
	private static byte[] bigHashEncrypt(byte[] plaindata, byte[] k, byte[] iv)
	{
	
		//  Pad the plaindata if not padded
		
		if (!isPadded(plaindata))
		
		    plaindata = addPadding(plaindata);
		
		if ((plaindata.length % 32) != 0)
		
		    throw new IllegalArgumentException();
		
		//  Use a fast hash algorithm that generates an array of
		//  random numbers or one-time pad for file encryption
		
		BigHash bighash = new Cipher() .new BigHash(k);
		
		byte[] hasharray = bighash .hash(plaindata.length);
		
		//  Encrypt the plaindata by xor-ing the hash
		//
		//  c[i] = p[i] (+) hash[i]
		
		byte[] cipherdata = Math.xor(plaindata, hasharray);
		
		return cipherdata;
	}
	
	
	
	private static byte[] bigHashDecrypt(byte[] cipherdata, byte[] k, byte[] iv)
	{
	
		if ((cipherdata.length % 32) != 0)
		{
			//  System.out.println("cipher length is not a multiple of 32");
			
			return null;
		}
		
		BigHash bighash = new Cipher() .new BigHash(k);
		
		byte[] hasharray = bighash .hash(cipherdata.length);
		
		//  Decrypt the cipherdata by xor-ing the hash
		
		byte[] plaindata = Math.xor(cipherdata, hasharray);
		
		return plaindata;
	}
	
	
	
	
	
	
	//  A hash function can be created by multiplying and adding an array of
	//  random numbers modulo n to generate an explosion of polynomial terms.
	//  This is faster than computing the exponential function y = a ^ x (mod n)
	//  which also uses multiplication because only O(1) multiplication is re-
	//  quired for each hash value. (Using the exponential function y = a ^ x
	//  (mod n) as a hash function for encryption would require O(log2(n)) in-
	//  stead of O(1) multiplications.) To make the function even more compli-
	//  cated the array of numbers is interpreted as an array of matrices and
	//  the array elements are permutated.
	//
	//  Even the world's fastest supercomputers could not expand this polynomial
	//  function for several iterations because the size of the hash, or number of
	//  terms in the polynomial, increases exponentially by ~ 1/2 per iteration.
	//  Expanding the first 16 iterations would be impossible for any computer.
	//
	//  For example, using an array of random numbers a, b, c, d, ..., i, j, k, l
	//
	//  a,b,c,d,e,f,g,h,i,j,k,l = var('a','b','c','d','e','f','g','h','i','j','k','l');
	//
	//  multiply the two previous variables and add the current variable
	//
	//  c += a*b;  d += b*c;  e += c*d;  f += d*e;  g += e*f;
	//  h += f*g;  i += g*h;  j += h*i;  k += i*j;  l += j*k;  ...
	//
	//  expand(c)    a*b + c
	//  expand(d)    a*b^2 + b*c + d
	//  expand(e)    a^2*b^3 + 2*a*b^2*c + b*c^2 + a*b*d + c*d + e
	//
	//  expand(f)    a^3*b^5 + 3*a^2*b^4*c + 3*a*b^3*c^2 + 2*a^2*b^3*d + b^2*c^3 + 4*a*b^2*c*d
	//               + 2*b*c^2*d + a*b*d^2 + a*b^2*e + c*d^2 + b*c*e + d*e + f
	//
	//  expand(g)    a^5*b^8 + 5*a^4*b^7*c + 10*a^3*b^6*c^2 + 3*a^4*b^6*d + 10*a^2*b^5*c^3
	//               + 12*a^3*b^5*c*d + 5*a*b^4*c^4 + 18*a^2*b^4*c^2*d + 3*a^3*b^4*d^2 + 2*a^3*b^5*e
	//               + b^3*c^5 + 12*a*b^3*c^3*d + 9*a^2*b^3*c*d^2 + 6*a^2*b^4*c*e + 3*b^2*c^4*d
	//               + 9*a*b^2*c^2*d^2 + a^2*b^2*d^3 + 6*a*b^3*c^2*e + 4*a^2*b^3*d*e + 3*b*c^3*d^2
	//               + 2*a*b*c*d^3 + 2*b^2*c^3*e + 8*a*b^2*c*d*e + a^2*b^3*f + c^2*d^3 + 4*b*c^2*d*e
	//               + 2*a*b*d^2*e + a*b^2*e^2 + 2*a*b^2*c*f + 2*c*d^2*e + b*c*e^2 + b*c^2*f + a*b*d*f
	//               + d*e^2 + c*d*f + e*f + g
	//
	//  These polynomials are too large to expand
	//
	//  h	(((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)
	//      *((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f) + h
	//
	//  i	((((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)
	//	 *((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f) + h)*(((((a*b + c)*b + d)*(a*b + c) + e)
	//	   *((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g) + i
	//
	//  j	(((((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)
	//	  *((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f) + h)*(((((a*b + c)*b + d)*(a*b + c) + e)
	//	    *((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g) + i)*((((((a*b + c)*b + d)*(a*b + c) + e)
	//	    *((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)*((((a*b + c)*b + d)*(a*b + c) + e)
	//	    *((a*b + c)*b + d) + f) + h) + j
	//
	//  k	((((((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)
	//	   *((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f) + h)*(((((a*b + c)*b + d)*(a*b + c) + e)
	//	     *((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g) + i)*((((((a*b + c)*b + d)*(a*b + c) + e)
	//	     *((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g)*((((a*b + c)*b + d)*(a*b + c) + e)
	//	     *((a*b + c)*b + d) + f) + h) + j)*(((((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)
	//	    *(((a*b + c)*b + d)*(a*b + c) + e) + g)*((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f) + h)
	//	  *(((((a*b + c)*b + d)*(a*b + c) + e)*((a*b + c)*b + d) + f)*(((a*b + c)*b + d)*(a*b + c) + e) + g) + i) + k
	
	
	
	
	class BigHash
	{
	
		//  A faster hash for creating a one-time pad for encryption
		//
		//  This makes directory or file encryption 10 times faster
		//
		//  The class has only one constructor and one public method. The BigHash(byte[] key)
		//  constructor sets the private key and then the hash(int bytes) method generates a
		//  number of random bytes. A hash is created by using byte[] hash = new BigHash(key)
		//  .hash(numberofbytes) and then a message can be encrypted and decryped by xor-ing
		//  the plaintext and hash arrays.
		
		
		//  The BigHash class uses a circular array of matrices and non-linear arithmetic to
		//  generate a one-time pad or sequence of random bytes for encrypting files or messages.
		//
		//  The method uses multiplications and additions but it computes the hash in O(1) steps
		//  or operations instead of O(log2(n)) operations for exponentiation. The hash function
		//  is much more complicated than y = a ^ x (mod n) because it uses multiplication and
		//  addition to generate an explosion of polynomial terms where the coefficients and
		//  variables are all unknown and it uses different variables for each iteration.
		//
		//  The hash constructor initializes the matrices using the hash of the private key.
		//  The hash(int bytes) method computes each hash byte by multiplying the two preceding
		//  matrices in the array at the current index modulo 2 ^ 32 mod 2 ^ 16 + 1, storing the
		//  sum of the four elements in a hash array, and then adding the product matrix to the
		//  next matrix. This is more complicated than just adding the two preceding matrices
		//  (as in a Fibonacci series) because multiplication is non-linear.
		//
		//  The modular reduction is not exact because the integers are signed; the upper half of
		//  the integer is added to, not subtracted from, the lower half; and the residue is great-
		//  er than the modulus because the upper half of the integer is not subtracted. The modu-
		//  lar reduction does not have to be exact because unlike an encryption cipher the hash
		//  function does not have to be invertible.
		//
		//  This hash method is non-invertible because there are multiple inverses for each hash
		//  value. Each hash value has 2 ^ 768 inverses or matrices that can add to the same value.
		//
		//  An array hash or any hash method could only be 3/2 as fast as (or 1/2 faster than) a
		//  matrix hash because commenting the code and returning new byte[bytes] only makes the
		//  hash method ~ 1/2 faster. An array hash would use a function or sum of the three vari-
		//  ables so that there would be 2 ^ 512 inverses for each hash value.
		//
		//  Because the BigHash class has a large secret array of matrices and each hash is com-
		//  puted as the sum of the four elements of the matrix at the current array index, the
		//  hash or encryption can never be broken because there is nothing for a cryptanalyst
		//  to cryptanalyze. The elements of the matrices are not public, and even the value of
		//  the hash or the sum of the elements is not public because the hash is added to the
		//  plaintext to generate the ciphertext. Unlike an encryption cipher which maps each
		//  block of plaintext p[i] to ciphertext c[i] = E(p[i]), a hash cipher has no one-to-one
		//  mapping because the ciphertext c[i] = p[i] + H[i] is the sum to two unknown variables
		//  p[i] and H[i].
		
		
		
		//  X[1] X[2] ... X[i] X[i+1] ... X[63] X[64]
		
		
		private byte[] key;
		
		private int[] a, b;
		
		private int t = 2*64;
		
		private int index = 0;
		
		
		//  the constructor uses the private key
		//  to create an array of random numbers
		
		public BigHash(byte[] key)
		{
			this.key = key;
			
			init();
		}
		
		
		private void init()
		{
		
			//  2 t ints x (4 bytes / int) == 8 t bytes
			
			//  Create an array of t / 4 hashes == 8 t bytes
			
			byte[][] array = new byte[8*t / 32][32];
			
			//  Hash the private key
			
			byte[] hash0 = Cipher.hash(key);
			byte[] hash1 = Cipher.hash(hash0);
			
			//  Initialize the zeroth array
			
			for (int i = 0; i < 32; i++)
			
			    array[0][i] = hash0[i];
			
			//  For each byte array hash the previous array
			
			for (int i = 1; i < array.length; i++)
			
			    array[i] = Cipher.hash(array[i-1]);
			
			//  Create an array of 2 t ints == 8 t bytes
			
			int[] intarray = new int[2*t]; // 8 x b.length == 2 t
			
			//  For each byte array convert the 32 bytes to 8 ints
			//  and copy the 8 ints to the int array
			
			for (int i = 0; i < array.length; i++) // b.length == t/4
			{
				int[] int_8 = Convert
				
				    .byteArrayToIntArray(array[i]);
				
				for (int j = 0; j < 8; j++)
				
				    intarray[8*i+j] = int_8[j];
			}
			
			//  32 matrices x (4 elements / matrix) x (32 bytes / element) == 4 K bytes
			
			//    32 32     32 32     32 32   ...    32  32  == 2 K bytes / row
			//
			//  | a1 a2 | | a3 a4 | | a5 a6 | ... | a63 a64 |
			//  | b1 b2 | | b3 b4 | | b5 b6 | ... | b63 b64 |
			
			//  Initialize the arrays
			
			a = new int[t];  b = new int[t];
			
			for (int i = 0; i < t; i++)
			{
				a[i] = intarray[0*t+i];
				b[i] = intarray[1*t+i];
			}
			
			
			//  This test was added to make the code backward com-
			//  patible but it could be removed in future versions
			
			if (encrypt_method != encrypt_method_3) return;
			
			
			//  Permutate the elements in a[] and b[]
			
			//  This code was added to make the cipher
			//  even more complicated
			
			//  For 64 elements there are 64! possible
			//  permutations or 64*63*62*...*4*3*2*1
			//  ~ (64 / e) ^ 64 ~ 24 ^ 64 ~ 10 ^ 88.
			//
			//  For two arrays there are (10 ^ 88) ^ 2
			//  == 10 ^ 176 permutations which is more
			//  than 2 ^ 512 or 512 bits of entropy,
			//  randomness or disorder.
			
			
			Number key0 = new Number(hash0);
			Number key1 = new Number(hash1);
			
			permutate(a, key0);
			permutate(b, key1);
		}
		
		
		private static void permutate(int[] A, Number key)
		{
			int elements = A.length;
			
			int[] indexes = permutate(elements, key);
			
			for (int i = 0; i < A.length; i++)
			{
				int j = indexes[i];
				
				//  Swap elements i and j
				
				int temp = A[i];
				
				A[i] = A[j];
				
				A[j] = temp;
			}
		}
		
		
		private static int[] permutate(int elements, Number rand)
		{
			//  returns a permuted array of integers using a key or value
			
			//  This method generates a perfectly random permutation
			//  of the indexes or integers 0, 1, 2, 3, ..., n-1.
			
			//  for (int i = 0; i < elements; i++)
			//
			//     swap element[n-1 -i] and element[rand(n - i)]
			//
			//  This swaps the elements in the array in reverse order
			//  starting from element n. Each highest element n, n-1,
			//  n-2, n-3, ... can only be swapped once because the
			//  modulus (n - i) of the random number generator de-
			//  creases for each iteration.
			
			
			int n = elements;
			
			int[] a = new int[elements];
			
			for (int i = 0; i < elements; i++) a[i] = i;
			
			byte[] randbytes = rand.toByteArray(32);
			
			for (int i = 0; i < n; i++)
			{
				//  Generate a random index from 0 to n-2 -i
				
				//  int rand1 = random(n-1 - i); // 0 to n-2 -i
				
				randbytes = Cipher.hash(randbytes);
				
				int rand1 = 0, mod = n-1 -i;
				
				if (mod != 0) rand1 = new Number(
				
				    randbytes) .mod(n-1 -i) .intValue();
				
				//  Swap or interchange a[n-1 -i] and a[rand1]
				
				int temp = a[rand1];
				
				a[rand1] = a[n-1 -i];
				
				a[n-1 -i] = temp;
			}
			
			return a;
		}
		
		
		public byte[] hash(int bytes)
		{
		
			//  The circular matrix array is
			//
			//  X[1] X[2] ... X[i] X[i+1] ... X[63] X[64]
			//
			//  Multiply X[i%t] by X[(i+1)%t] to compute the hash
			//  matrix and then add the hash matrix to X[(i+2)%t].
			//
			//  The hash[i] value is the sum of the 2x2 hash matrix
			//  elements modulo 2^32.
			
			//  Initialize the hash array
			
			int[] array = new int[bytes/4];
			
			for (int k = 0; k < array.length; k++, index += 2)
			{
				//  Define the six column indexes
				//  for the three matrices A, B, C
				
				int i0 = (index + 0) & (t-1);
				int i1 = (index + 1) & (t-1);
				
				int i2 = (index + 2) & (t-1);
				int i3 = (index + 3) & (t-1);
				
				int i4 = (index + 4) & (t-1);
				int i5 = (index + 5) & (t-1);
				
				//  Define the elements for the
				//  first two matrices A, B
				
				int a0 = a[i0] + (a[i0] >> 16);
				int a1 = a[i1] + (a[i1] >> 16);
				int b0 = b[i0] + (b[i0] >> 16);
				int b1 = b[i1] + (b[i1] >> 16);
				
				int a2 = a[i2] + (a[i2] >> 16);
				int a3 = a[i3] + (a[i3] >> 16);
				int b2 = b[i2] + (b[i2] >> 16);
				int b3 = b[i3] + (b[i3] >> 16);
				
				//  Compute the product of the matrices by
				//  multiplying the row and column vectors
				//
				//  | a0  a1 | | a2 | a3 | __ | p1 | p2 |
				//  | ------ | |    |    | __ | ---+--- |
				//  | b0  b1 | | b2 | b3 |    | p3 | p4 |
				
				//  Calculate the product of the elements
				
				int p1 = (a0|1) * (a2|1),  p2 = (a1|1) * (b2|1);
				int p3 = (a0|1) * (a3|1),  p4 = (a1|1) * (b3|1);
				int p5 = (b0|1) * (a2|1),  p6 = (b1|1) * (b2|1);
				int p7 = (b0|1) * (a3|1),  p8 = (b1|1) * (b3|1);
				
				//  Discard the lower 16 bits
				
				int q1 = p1 >> 16,  q2 = p2 >> 16;
				int q3 = p3 >> 16,  q4 = p4 >> 16;
				int q5 = p5 >> 16,  q6 = p6 >> 16;
				int q7 = p7 >> 16,  q8 = p8 >> 16;
				
				//  Calculate the sums of the products of the two
				//  matrices and add the sums to the matrix C
				
				int s1 = p1 + p2 + q1 + q2;  a[i4] += s1;
				int s2 = p3 + p4 + q3 + q4;  a[i5] += s2;
				int s3 = p5 + p6 + q5 + q6;  b[i4] += s3;
				int s4 = p7 + p8 + q7 + q8;  b[i5] += s4;
				
				//  The hash value is the quaternity
				//  s1 + s2 + s3 + s4
				
				int hash = s1 + s2 + s3 + s4;
				
				array[k] = hash;
			}
			
			return Convert.intArrayToByteArray(array);
		}
	}
	
	//  End class BigHash
	
	
	
	
	
	
	
	
	public static byte[] hash(File file)
	
		throws IOException, FileNotFoundException
	{
		if (file.length() <= maxfilesize)
		{
			byte[] array = DataStream.read(file);
			
			return hash(array);
		}
		
		else return hashLargeFile(file);
	}
	
	
	
	public static byte[] hash(byte[] M)
	{
		//  returns a 32-byte hash using SHA256
		
		//  Set the empty string hash to zero so
		//  users know if a passphrase field is empty
		
		if (M.length == 0) return new byte[32];
		
		MessageDigest md;
		
		try { md = MessageDigest.getInstance("SHA-256"); }
		
		catch (NoSuchAlgorithmException ex)
		
		  { System.out.println(ex); return null; }
		
		md.update(M);
		
		return md.digest();
	}
	
	
	
	
	public static byte[] hashLargeFile(File file)
	
		throws IOException, FileNotFoundException
	{
		//  hashes files larger than 2 GB
		
		MessageDigest md;
		
		try { md = MessageDigest.getInstance("SHA-256"); }
		
		catch (NoSuchAlgorithmException ex)
		
		  { System.out.println(ex); return null; }
		
		int bytes = 0;
		
		FileChannelReader reader = null;
		
		try
		{	reader = new FileChannelReader(file.getPath());
			
			do
			{	int size = 1024*1024*1024;
				
				ByteBuffer bytebuffer;
				
				//  ByteBuffer.allocate(size);
				
				byte[] array = new byte[size];
				
				bytebuffer = ByteBuffer.wrap(array);
				
				bytes = reader.read(bytebuffer);
				
				array = bytebuffer.array();
				
				if (bytes < 0) break;
				
				if (bytes < bytebuffer.array().length)
				{
					byte[] array1 = new byte[bytes];
					
					for (int i = 0; i < bytes; i++)
					
					    array1[i] = array[i];
					
					array = array1;
				}
				
				md.update(array);
				
			}	while (bytes > 0);
			
			return md.digest();
		}
		
		finally
		{
			if (reader != null) reader.close();
		}
	}
	
	
	
	
	public static String hash1(String M)
	{
		//  returns a 40-digit, base-16, type 1 hash string
		
		int digits = 40, radix = 16;
		
		return hash1(M, digits, radix);
	}
	
	
	public static String hash2(String M)
	{
		//  returns a 40-digit, base-16, type 2 hash string
		
		int digits = 40, radix = 16;
		
		return hash2(M, digits, radix);
	}
	
	
	public static String hash1(String M, int digits, int radix)
	{
		//  returns a type 1 hash string
		
		byte[] hash = hash(M.getBytes());
		
		String str = new Number(hash)
		
		    .toString(64, radix).trim();
		
		//  toString(16) is the same as hexformat
		
		HexFormat hex = HexFormat.of();
		
		String str1 = hex.formatHex(hash);
		
		if ((radix == 16) && !str.endsWith(str1))
		
		    throw new ArithmeticException();
		
		//  The toString(digits, radix) method is not guaranteed
		//  to pad the left side of a number with zeros except
		//  for radix 16; it could pad the left side with spaces.
		
		while (str.length() != 64)
		
		    str = "0" + str;
		
		str = str.substring(0, digits);
		
		return str;
	}
	
	
	public static String hash2(String M, int digits, int radix)
	{
		//  returns a type 2 hash string
		
		//  Remove the white space characters
		
		M = M .trim() .replaceAll("[ \r\n\t]", "");
		
		byte[] hash = hash(M.getBytes());
		
		String str = new Number(hash)
		
		    .toString(64, radix).trim();
		
		//  toString(16) is the same as hexformat
		
		HexFormat hex = HexFormat.of();
		
		String str1 = hex.formatHex(hash);
		
		if ((radix == 16) && !str.endsWith(str1))
		
		    throw new ArithmeticException();
		
		//  The toString(digits, radix) method is not guaranteed
		//  to pad the left side of a number with zeros except for
		//  radix 16; it could pad the left side with spaces.
		
		while (str.length() != 64)
		
		    str = "0" + str;
		
		return str.substring(0, digits);
	}
	
	
	
	
	public static boolean isEncrypted(File file)
	{
	
		//  tests if a file is encrypted
		
		if (file.length() < 64) return false;
		
		byte[] input = null;
		
		try
		{	if (file.length() < 2L*1024*1024*1024)
			
			input = DataStream.read(file);
			
			else
			{	ByteBuffer bytebuffer = ByteBuffer.allocate(1024*1024);
				
				new FileChannelReader(file.getPath()).read(bytebuffer);
				
				input = bytebuffer.array();
			}
		}
		
		catch (IOException ex)
		{
			System.out.println(ex);
			
			return false;
		}
		
		
		//  Test if the first 32 bytes equals
		//  the hash of the second 32 bytes
		//
		//  or if the second 32 bytes equals
		//  the hash of the first 32 bytes
		
		
		byte[] array1 = Arrays.copyOfRange(input,  0, 32);
		byte[] array2 = Arrays.copyOfRange(input, 32, 64);
		
		byte[] hasharray1 = hash(array1);
		byte[] hasharray2 = hash(array2);
		
		boolean bool = false;
		
		if ( Arrays.equals(array1, hasharray2)
		  || Arrays.equals(array2, hasharray1) )
		
		    { bool = true;  return bool; }
		
		
		//  Other encryption formats can be added
		
		//  ...
		
		//  ...
		
		
		return bool;
	}
	
	
	
	public static boolean isEncrypted(byte[] array)
	{
		//  tests if an array is encrypted by testing for randomness
		
		//  If the ciphertext is properly encrypted then all the
		//  byte values should be equally probable
		//
		//  If there is any non-randomness in an encrypted file,
		//  the method will return false
		
		//  If the array is less than the padding size and the
		//  prepended key size return false
		
		if (array.length < 32) return false;
		
		
		return isRandom(array);
	}
	
	
	
	
	
	
	//  The isRandom(byte[]) method should have more tests for
	//  randomness because it returns true for byte arrays such
	//  as the consecutive integers { 0, 1, 2, 3, ..., n }
	//
	//  For example,
	//
	//  byte[] a = new byte[64*1024];
	//
	//  for (int i = 0; i < a.length; i++) a[i] = (byte) i;
	//
	//  boolean random = Cipher.isRandom(a);
	//
	//  System.out.println("random == " + random); // true
	
	
	public static boolean isRandom(byte[] array)
	{
	
		//  performs statistical tests for randomness
		
		{
			//  Count the frequencies of 0's, 1's, 2's, ..., f's
			
			int[] counter = new int[16];
			
			for (int i = 0; i < array.length; i++)
			
			    counter[array[i] & 0xf]++;
			
			int min = counter[0];
			int max = counter[0];
			
			for (int i = 0; i < counter.length; i++)
			{
				if (counter[i] < min) min = counter[i];
				if (counter[i] > max) max = counter[i];
			}
			
			if (min < 4) min = 4;
			
			//  System.out.println("array length == " + array.length);
			//  System.out.println("frequencies == " + Arrays.toString(counter));
			//  System.out.println("array length == " + array.length
			//   + "  max / min == " + (max / min));
			
			//  These numbers should be set to 2 x the average value of (max / min)
			
			if      (array.length <  128) { if ((max / min) > 9) return false; }
			else if (array.length <  512) { if ((max / min) > 5) return false; }
			else if (array.length < 2048) { if ((max / min) > 4) return false; }
			else                          { if ((max / min) > 2) return false; }
		}
		
		
		if (array.length > 16*1024)
		{
			//  Count the frequencies of 0's, 1's, 2's, ..., ff's
			
			int[] counter = new int[256];
			
			for (int i = 0; i < array.length; i++)
			
			    counter[array[i] & 0xff]++;
			
			int min = counter[0];
			int max = counter[0];
			
			for (int i = 0; i < counter.length; i++)
			{
				if (counter[i] < min) min = counter[i];
				if (counter[i] > max) max = counter[i];
			}
			
			if (min < 4) min = 4;
			
			//  System.out.println("array length == " + array.length);
			//  System.out.println("frequencies == " + Arrays.toString(counter));
			//  System.out.println("array length == " +
			//      array.length + "  max / min == " + (max / min));
			
			if ((max / min) > 2) return false;
		}
		
		
		//  Count the number of positive and negative numbers
		
		//  If the ciphertext is encrypted properly there should be
		//  approximately as many positive and negative numbers
		//
		//  (This is the same as testing if the most significant bit
		//  contains an equal number of zeros and ones.)
		
		//  Use a code block to hide the variables from the other tests
		{
			int p = 0, n = 0;
			
			for (int i = 0; i < array.length; i++)
			
			    if (array[i] < 0) n++; else p++;
			
			if ( (p / (n + 1) > 1) || (n / (p + 1) > 1) )
			
			     return false;
		}
		
		
		//  Perform a run test for randomness
		
		//  This test is only applied to small arrays because the
		//  test is too slow for large arrays (It could take 1/2
		//  longer to decrypt a directory if the test is used for
		//  large arrays or files unless the countRuns(byte[])
		//  method can be made faster.
		
		
		if (array.length < 4096)
		{
			//  The number of runs should always be approximately
			//  4 times the array length or 1/2 the number of bits
			
			//  This example would pass the run test because the
			//  number of runs equals one-half the number of bits
			//
			//  001100110011001100110011 // runs = 12 = (1/2) x 24
			
			int runs = countRuns(array);
			
			//  System.out.println("array length == "
			//    + array.length + "  runs == " + runs);
			
			double q = 1.0 * runs / array.length;
			
			if ((q > 5.0) || (q < 3.2)) return false;
		}
		
		else
		{	//  Test random samples of the array
			
			int length = array.length, size1 = 512;
			
			for (int i = 0; i < 4; i++)
			{
				int from = Math.random(length - size1), to = from + size1;
				
				byte[] array1 = Arrays.copyOfRange(array, from, to);
				
				int runs = countRuns(array1);
				
				//  System.out.println("array length == "
				//    + array.length + "  runs == " + runs);
				
				double q = 1.0D * runs / array1.length;
				
				if ((q > 5.0) || (q < 3.2)) return false;
			}
		}
		
		
		//  Add other tests for randomness
		
		//  ...   ...
		
		//  ...   ...
		
		
		return true;
	}
	
	
	
	private static int countRuns(byte[] array)
	{
		//  counts the number of consecutive sequences of zeros and ones
		
		//  01010101 has 8 runs, 00110011 has 4 runs,
		//  00001111 has 2 runs, 11111111 has 1 run
		
		int runs = 1, bits = 8*array.length;
		
		for (int i = 0, prevbit = 0; i < array.length; i++)
		{
			int a = array[array.length -1 -i];
			
			if ((a & 1) != prevbit) runs++;
			
			for (int j = 0; j < 8 -1; j++)
			{
				if (  (a & (1 << (j+1)))
				  != ((a & (1 << (j+0))) << 1) ) runs++;
				
				prevbit = (a & (1 << (j+1))) >> (j+1);
			}
		}
		
		return runs;
	}
	
	
	
	
	public static byte[] passphraseToKey(String passphrase)
	{
	
		//  This method converts a passphrase or string to an encryption
		//  key, signature key, or file key which is 20 bytes or 160 bits.
		//
		//  If the string is 40 hex digits, then the string is assumed to
		//  be the hash of the original passphrase and the string is con-
		//  verted to a 20 byte array.
		//
		//  If the string is empty or contains only white space then the
		//  method returns a null byte array so that the secret key gets
		//  assigned to null.
		
		
		passphrase = passphrase.trim();
		
		if (passphrase.length() == 0) return null;
		
		String str = hash2(passphrase) .substring(0, 40);
		
		byte[] key = new Number(str, 16) .toByteArray(20);
		
		//  If the passphrase is exactly 40 hex digits, then the user
		//  already hashed the passphrase (or passphrase and address)
		
		if (                (passphrase.replaceAll("[ \t\n]", "").length() == 40)
		  && Number.isBase16(passphrase.replaceAll("[ \t\n]", "")))
		
		    key = new Number(passphrase, 16) .toByteArray(20);
		
		return key;
	}
}


//  End class Cipher































class Math
{


	//  Private Math constructor
	//
	//  No instantiation from outside of class
	
	private Math() {  }
	
	
	
	public static final double e  = 2.7182818284590452354;
	public static final double pi = 3.1415926535897932384;
	
	public static final double E = e, PI = pi;
	
	
	//  The number of threads variable is public. If the number
	//  of threads is changed to private, then a get and set
	//  method will be required to change the number of threads.
	
	
	
	//  static class member
	
	public static int numberofthreads =
	
	    Runtime.getRuntime().availableProcessors();
	
	
	
	//  static class methods
	
	
	public static double abs(double d)
	{
		//  returns the absolute value
		
		return  d >= 0 ? d : d * -1.0D;
	}
	
	public static int abs(int i)
	{
		//  returns the absolute value
		
		return i >= 0 ? i : i * -1;
	}
	
	public static long abs(long l)
	{
		//  returns the absolute value
		
		return l >= 0 ? l : l * -1L;
	}
	
	
	public static int[] add(int[] addend, int[] summand)
	{
		//  adds two int arrays
		//
		//  This method is used by the number class
		
		//  These lines expand one of the two arrays to equalize the array lengths
		
		if ( addend.length > summand.length)
		
		    return add(addend, expand(summand, addend.length));
		
		if (summand.length > addend.length)
		
		    return add(expand(addend, summand.length), summand);
		
		if (addend.length != summand.length)
		
		    throw new IllegalArgumentException();
		
		int length = addend.length;
		
		int a_length = length;
		int b_length = length;
		int c_length = length;
		
		int[] a = new int[length];
		int[] b = new int[length];
		
		int[] c = new int[length];
		
		for (int i = 0; i < a_length; i++) a[i] =  addend[i];
		for (int i = 0; i < b_length; i++) b[i] = summand[i];
		for (int i = 0; i < c_length; i++) c[i] = 0;
		
		long temp, temp_a, temp_b;
		
		temp = temp_a = temp_b = 0L;
		
		for (int i = 0; i < a_length; i++)
		{
			temp_a += a[a_length -1 -i];
			temp_b += b[b_length -1 -i];
			
			temp_a &= 0xffffffffL;
			temp_b &= 0xffffffffL;
			
			temp += temp_a;
			temp += temp_b;
			
			c[c_length -1 -i] += temp;
			
			temp >>= 32;
			
			temp_a = temp_b = 0L;
		}
		
		return c;
	}
	
	
	
	public static int[] and(int[] array1, int[] array2)
	{
		//  ands two int arrays
		
		//  int arrays are right-aligned because they
		//  are used by the number class for arithmetic
		
		int size = Math.min(array1.length, array2.length);
		
		int[] array = new int[size];
		
		for (int i = 0; i < array.length; i++)
		
		    array [array .length -1 -i]
		  = array1[array1.length -1 -i]
		  & array2[array2.length -1 -i];
		
		return array;
	}
	
	
	
	public static int bitCount(long n)
	{
		//  returns log2((int) n)
		//
		//  (log2((double) n) returns a fractional log)
		
		int j = 0;
		
		while (n != 0) { n >>>= 1; j++; }
		
		return  j;
	}
	
	
	public static long bitCount(int[] array)
	{
		//  returns log2(n)
		
		int i = 0, j = 0;
		
		while ((i < array.length -1) && (array[i] == 0)) i ++;
		
		int b = array[i];  while (b != 0) { b >>>= 1; j++; }
		
		return  32*(array.length -1 -i) + j;
	}
	
	
	
	public static void clearBit(byte[] array, long bit)
	{
		//  clears a bit of an array
		
		if ((bit / 8) >= array.length) return;
		
		array[array.length -1 - (int) (bit / 8)]
		
		    &= ~(1 << bit % 8);
	}
	
	
	
	public static void clearBit(int[] array, long bit)
	{
		//  clears a bit of an array
		
		if ((bit / 32) >= array.length) return;
		
		array[array.length -1 - (int) (bit / 32)]
		
		    &= ~(1 << bit % 32);
	}
	
	
	
	public static int[][] collate(int[] a)
	{
	
		//  collates the elements of a sorted array
		//  and returns the elements and frequencies;
		//  duplicates of elements are removed
		
		
		//  Make sure the array is sorted
		
		for (int i = 1; i < a.length; i++)
		
		    if (a[i] < a[i-1]) throw new
		
			IllegalArgumentException();
		
		//  Count the number of unique elements
		
		int i, j, k;
		
		for (i = 1, j = 1; j < a.length; j++)
		
		    if (a[j] != a[j-1]) i++;
		
		int[][] int_freq = new int[i][2];
		
		//  Find the frequency of each element
		
		i = 0;  j = 0;  k = a[0];
		
		for (int int1 : a)
		{
			if (int1 == k) j++;
			
			else
			{	int_freq[i][0] = k;
				int_freq[i][1] = j;
				
			 	i++;  j = 1;
			}
			
			k = int1;
		}
		
		int_freq[int_freq.length -1][0] = k;
		int_freq[int_freq.length -1][1] = j;
		
		return int_freq;
	}
	
	
	
	public static int compareTo(int[] a, int[] b)
	{
	
		//  Unsigned int comparator  returns 0, 1, or -1
		
		//  Note that the Java and C++ comparators are slightly different
		//  because in C++  an int & 0x80000000 == (a signed int) & (an unsigned int),
		//  whereas in Java an int & 0x80000000 == (a signed int) & (   a signed int).
		//
		//  In Java the result of the && equals a negative value whereas in C++ it
		//  equals a positive value. The two versions would be identical if the C++
		//  version used (signed) 0x80000000.
		
		int d = abs(a.length - b.length);
		
		if (a.length > b.length)
		{
			for (int i = 0; i < d; i++) if (a[i] != 0) return 1;
			
			if      ((a[d] & 0x80000000) < (b[0] & 0x80000000)) return  1;
			else if ((a[d] & 0x80000000) > (b[0] & 0x80000000)) return -1;
			else if ((a[d] & 0x7fffffff) > (b[0] & 0x7fffffff)) return  1;
			else if ((a[d] & 0x7fffffff) < (b[0] & 0x7fffffff)) return -1;
			
			else for (int i = 0; i < b.length; i++)
			{
				if      ((a[d+i] & 0x80000000) < (b[i] & 0x80000000)) return  1;
				else if ((a[d+i] & 0x80000000) > (b[i] & 0x80000000)) return -1;
				else if ((a[d+i] & 0x7fffffff) > (b[i] & 0x7fffffff)) return  1;
				else if ((a[d+i] & 0x7fffffff) < (b[i] & 0x7fffffff)) return -1;
			}
		}
		
		else if (b.length > a.length)
		{
			for (int i = 0; i < d; i++) if (b[i] != 0) return -1;
			
			if      ((a[0] & 0x80000000) < (b[d] & 0x80000000)) return  1;
			else if ((a[0] & 0x80000000) > (b[d] & 0x80000000)) return -1;
			else if ((a[0] & 0x7fffffff) > (b[d] & 0x7fffffff)) return  1;
			else if ((a[0] & 0x7fffffff) < (b[d] & 0x7fffffff)) return -1;
			
			else for (int i = 0; i < a.length; i++)
			{
				if      ((a[i] & 0x80000000) < (b[d+i] & 0x80000000)) return  1;
				else if ((a[i] & 0x80000000) > (b[d+i] & 0x80000000)) return -1;
				else if ((a[i] & 0x7fffffff) > (b[d+i] & 0x7fffffff)) return  1;
				else if ((a[i] & 0x7fffffff) < (b[d+i] & 0x7fffffff)) return -1;
			}
		}
		
		else if (a.length == b.length)
		{
			if      ((a[0] & 0x80000000) < (b[0] & 0x80000000)) return  1;
			else if ((a[0] & 0x80000000) > (b[0] & 0x80000000)) return -1;
			else if ((a[0] & 0x7fffffff) > (b[0] & 0x7fffffff)) return  1;
			else if ((a[0] & 0x7fffffff) < (b[0] & 0x7fffffff)) return -1;
			
			else for (int i = 0; i < a.length; i++)
			{
				if      ((a[i] & 0x80000000) < (b[i] & 0x80000000)) return  1;
				else if ((a[i] & 0x80000000) > (b[i] & 0x80000000)) return -1;
				else if ((a[i] & 0x7fffffff) > (b[i] & 0x7fffffff)) return  1;
				else if ((a[i] & 0x7fffffff) < (b[i] & 0x7fffffff)) return -1;
			}
		}
		
		return 0;
	}
	
	
	
	
	private static double[] cos_sin(double x)
	{
	
		//  The series for cosine and sine are
		//
		//                n  2 n + 0
		//  cos(x) == (-1)  x    /   (2 n + 0)!
		//
		//                n  2 n + 1
		//  sin(x) == (-1)  x    /   (2 n + 1)!
		
		
		//  Reduce x modulo 2 pi
		
		x = x % (2 * pi);
		
		double cosx = 0.0D, sinx = 0.0D;
		double inv1 = 1.0D, inv2 = 1.0D;
		
		for (int n = 0; n < 8; n++)
		{
			if (n > 0)
			{
				inv1 = inv1 / (2*n - 0) / (2*n - 1);
				inv2 = inv2 / (2*n + 1) / (2*n + 0);
			}
			
			cosx += pow(x, 2*n + 0) * inv1 * (((n % 2) == 0) ? 1 : -1);
			sinx += pow(x, 2*n + 1) * inv2 * (((n % 2) == 0) ? 1 : -1);
		}
		
		return new double[] { cosx, sinx };
	}
	
	
	
	public static double cos(double x)
	{
		//  returns the cosine of an angle in radians
		
		return cos_sin(x)[0];
	}
	
	
	public static double cosh(double u)
	{
		//  returns the hyperbolic cosine
		//
		//  cosh(u) =  1/2 ( e^u + e^-u )
		
		return ( exp(u) + exp(-u) ) / 2;
	}
	
	
	public static double[] cos_table(int n)
	{
		//  returns a table of cosines
		
		if (n == 1) return new double[] { 1.0D };
		if (n == 2) return new double[] { 1.0D, -1.0D };
		
		double[] sin_table = sin_table(n);
		double[] cos_table = new double[n];
		
		int offset = n / 4;
		
		for (int i = 0; i < n - offset; i++)
		
		    cos_table[i] = sin_table[offset + i];
		
		for (int i = 0; i < offset; i++)
		
		    cos_table[n - offset + i] = sin_table[i];
		
		return cos_table;
	}
	
	
	
	public static Number[] cos_table(Number n)
	{
		//  returns a table of cosines
		
		if (n.equals(1)) return new Number[] { new Number(1) };
		if (n.equals(2)) return new Number[] { new Number(1), new Number(-1) };
		
		if (n .isGreaterThan(2L*1024*1024*1024-1))
		
		    throw new IllegalArgumentException();
		
		int m = n.intValue();
		
		double[] sin_table = sin_table(m);
		Number[] cos_table = new Number[m];
		
		int offset = m / 4;
		
		for (int i = 0; i < m - offset; i++)
		
		    cos_table[i] = new Number(sin_table[offset + i]);
		
		for (int i = 0; i < offset; i++)
		
		    cos_table[m - offset + i] = new Number(sin_table[i]);
		
		return cos_table;
	}
	
	
	
	public static int countOneBits(int a)
	{
		//  counts the number of 1-bits in an int
		
		//  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
		//
		//  0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111,
		//  1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111
		
		int[] ones = new int[] { 0, 1, 1, 2, 1, 2, 2, 3,
		                         1, 2, 2, 3, 2, 3, 3, 4 };
		int onebits = 0;
		
		//  Read 4 bits at a time, 8 times
		
		for (int i = 0; i < 8; i++, a >>>= 4)
		
		    onebits += ones[a & 0xf];
		
		return onebits;
	}
	
	
	public static int countOneBits(int[] array)
	{
		//  counts the number of 1-bits in an array
		
		int onebits = 0;
		
		for (int i = 0; i < array.length; i++)
		
		    onebits += countOneBits(array[i]);
		
		return onebits;
	}
	
	
	public static int discreteLog(
	
		int base, int residue, int modulus)
	{
		//  solves y == a ^ x (mod n)
		
		int a = base, n = modulus;
		
		int x = 1;
		
		for (long y = a; x < modulus; x++)
		{
			if (y == residue) break;
			
			y = (1L * a * y) % n;
		}
		
		//  Verify the answer
		
		long y1 = modPow(a, x, n);
		
		if (y1 != residue)
		
		    return -1;
		
		return x;
	}
	
	
	public static double exp(double x)
	{
		//  computes e ^ x
		
		return pow(e, x);
	}
	
	
	public static int[] expand(int[] array1, int new_size)
	{
		//  expands the left side of a signed array
		
		//  int arrays are right-aligned because they are used for arithmetic
		
		if (new_size < array1.length)
		{
			String message = "new size < array size";
			
			throw new IllegalArgumentException(message);
		}
		
		//  Expand the array
		
		int array_length1 = array1.length;
		
		int[] array2 = new int[new_size];
		
		
		//  Copy the sign
		
		int sign_int = (array1[0] < 0) ? -1 : 0;
		
		for (int i = 0; i < new_size; i++)
		
		    array2[i] = sign_int;
		
		
		//  Copy right to left
		
		for (int i = 0; i < array1.length; i++)
		
		    array2[new_size -1 -i] = array1[array1.length -1 -i];
		
		return array2;
	}
	
	
	
	public static int[] factor(long n)
	{
		//  factors a long integer
		
		if ((n <= 0) || (n == 1)) return new int[] { };
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		for (int i = 2; i < 2L*1024*1024*1024 -1; i++)
		{
			if (Math.isDivisibleBy(n, i))
			
			   while (Math.isDivisibleBy(n, i))
			
			      { n /= i; list.add(i); }
			
			if (n <= 1) break;
		}
		
		if (n != 1) list.add((int) n);
		
		int[] primes = new int[list.size()];
		
		for (int i = 0; i < primes.length; i++)
		
		    primes[i] = list.get(i);
		
		return primes;
	}
	
	
	
	public static int[] factor(int n)
	{
		//  factors an int
		
		int factlimit = 0x10000; // sqrt 2^32
		
		int[] factors = factor(n, factlimit);
		
		if ((factors == null) || (factors.length == 0))
		
		    return new int[] { n };
		
		else return factors;
	}
	
	
	
	public static int[] factor(long n, int maxprime)
	{
		//  factors an int up to maxprime
		
		if ((n <= 0) || (n == 1)) return new int[] { };
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		int numberofprimes = (int) (2*maxprime / log(maxprime));
		
		int[] primes = primes(numberofprimes);
		
		for (int i = 0; i < primes.length; i++)
		{
			if (isDivisibleBy(n, primes[i]))
			{
				list.add(primes[i]);
				
				n /= primes[i--];
			}
		}
		
		if (n != 1) list.add((int) n);
		
		int[] array = new int[list.size()];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = list.get(i).intValue();
		
		return array;
	}
	
	
	public static double factorial(int n)
	{
		//  computes the product of integers from 1 to n
		
		if (n > 16*1024*1024) throw new
		
		    IllegalArgumentException();
		
		double product = 1.0D;
		
		for (int k = 1; k <= n; k++)
		
		    product *= k;
		
		return product;
	}
	
	
	public static int flipBit(int a, long bit)
	{
		//  flips one bit of an int
		
		//  Example  Generate random ints that contain
		//  an equal number of zeros and ones
		//
		//  First generate a random int and then flip the bits
		//  until there is an equal number of zeros and ones
		//
		//  while (true)
		//  {
		//	int rand = (int) Math.random(0x80000000L);
		//	
		//	for (int i = 0; i < 32; i++)
		//	
		//	if (Math.countOneBits(rand) != 16)
		//	
		//	    rand = Math.flipBit(rand, i);
		//	
		//	System.out.println(rand);
		//  }
		
		return  a ^= (1 << (bit % 32));
	}
	
	
	public static void flipBit(byte[] array, long bit)
	{
		//  flips one bit of an array
		
		if ((bit / 8) >= array.length)
		
		    throw new IllegalArgumentException();
		
		array[array.length -1 - (int)(bit / 8)] ^= (1 << (bit % 8));
	}
	
	
	
	public static void flipBit(int[] array, long bit)
	{
		//  flips one bit of an array
		
		if ((bit / 32) >= array.length)
		
		    throw new IllegalArgumentException();
		
		array[array.length -1 -(int)(bit / 32)] ^= (1 << (bit % 32));
	}
	
	
	
	public static long gcd(long m, long n)
	{
		//  returns the greatest common divisor
		//  or greatest common factor
		
		if ((m == 0) || (n == 0)) return 1;
		
		m = abs(m);  n = abs(n);
		
		long a, b, c = 1;
		
		if ( m >= n )
		
		     { a = m; b = n; }
		else { a = n; b = m; }
		
		do { c = a % b; a = b; b = c; }
		
		    while (c != 0);
		
		return a;
	}
	
	
	public static int getBit(int[] array, long bit)
	{
		//  returns a bit of an array
		//
		//  (if the bit < 0 then the method counts from left to
		//  right so the number class can test fractional bits)
		
		if (Math.abs(bit) / 32 >= array.length) return 0;
		
		if (bit >= 0)
		{
			int int_32 = array[array.length -1 - (int) (bit / 32)];
			
			return (int_32 & (1 << bit)) == 0 ? 0 : 1;
		}
		
		else
		{	int int_32 = array[(int) (bit / 32)];
			
			return (int_32 & (1 << (32 - bit))) == 0 ? 0 : 1;
		}
	}
	
	
	public static int getLowestSetBit(long a)
	{
		//  returns the lowest 1-bit of a long
		
		if (a == 0) throw new
		
		    IllegalArgumentException();
		
		int bit = 0;
		
		while ((a & 1) == 0)
		
		    { a >>= 1;  bit++; }
		
		return bit;
	}
	
	
	public static long getLowestSetBit(int[] array)
	{
		//  returns the lowest 1-bit of an array
		
		long bit = 0;
		
		while (!testBit(array, bit)
		
		    && (bit < 32L*array.length)) bit++;
		
		if (bit >= 32L*array.length)
		
		    throw new IllegalArgumentException();
		
		return bit;
	}
	
	
	public static double hypot(double x, double y)
	{
		//  returns the hypotenuse of a right triangle
		//                              _________
		//  a^2 + b^2 == c^2  or  c = \/a^2 + b^2
		
		double z = sqrt(x*x + y*y);
		
		return z;
	}
	
	
	public static int[] intersection(int[] a, int[] b)
	{
		//  returns the intersection of two int arrays
		
		//  Duplicates are included in the intersection. The
		//  caller can sortAndCollate() to remove duplicates.
		
		int[] sort_a = Arrays.copyOf(a, a.length);
		int[] sort_b = Arrays.copyOf(b, b.length);
		
		if (!isSorted(a)) sort(sort_a);
		if (!isSorted(b)) sort(sort_b);
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		int i = 0, j = 0;
		
		while ((i < a.length -1) || (j < b.length -1))
		{
			//  Skip duplicates in the first array and then the second array
			//
			//  while ((i < a.length -1) && (sort_a[i+1] == sort_a[i])) i++;
			//  while ((j < b.length -1) && (sort_b[j+1] == sort_b[j])) j++;
			
			//  Keep incrementing the array index that has the smaller elements
			
			while ((i < a.length -1) && (sort_a[i] < sort_b[j])) i++;
			while ((j < b.length -1) && (sort_b[j] < sort_a[i])) j++;
			
			//  If the two elements match then add the element
			//  to the list and increment both array indices
			
			if (sort_a[i] == sort_b[j]) { list.add(sort_a[i]); i++; j++; }
			
			//  If either index is at the end of the sorted array then break
			
			if ((i >= a.length -1) || (j >= b.length -1)) break;
		}
		
		int[] intersection = new int[list.size()];
		
		for (int k = 0; k < intersection.length; k++)
		
		    intersection[k] = list.get(k);
		
		return intersection;
	}
	
	
	public static double inverse(double n)
	{
		//  returns the inverse of a double
		
		return  1 / n;
	}
	
	public static boolean isCoprimeWith(long m, long n)
	{
		//  tests if two numbers are relatively prime
		
		return gcd(m, n) == 1;
	}
	
	public static boolean isDivisibleBy(long m, long n)
	{
		//  tests if an integer m is evenly divisible
		//  (or divisible without remainder) by n
		
		return (m % n) == 0;
	}
	
	public static boolean isGenerator(int a, int p)
	{
		//  tests if a number is a generator modulo p
		
		//  A number is a generator modulo p if a^x (mod p)
		//  generates all the elements from 1 to p-1 or 1 to -1.
		//
		//  A number is a generator if it doesn't have any co-
		//  composite factors in the totient (such as 2).
		//
		//  This means that a number a is a generator modulo n
		//  if a ^ (phi(n) / q[i]) != 1 (mod n) for each prime
		//  factor (not prime power) q[i] in the totient.
		
		int lambda = lambda(p);
		
		int[] factors = factor(lambda);
		
		int[][] primes_exp = sortAndCollate(factors);
		
		for (int i = 0; i < primes_exp.length; i++)
		
		   if (modPow(a, lambda / primes_exp[i][0], p) == 1)
		
		      return false;
		
		return true;
	}
	
	
	public static boolean isPower(double val, int exp)
	{
		//  tests if a number is a (prime or composite) power
		
		if (val == 0.0D)  return true;
		
		return pow((long) root(val, exp), exp) == val;
	}
	
	
	public static boolean isPowerOf2(long n)
	{
		return isPowerOf(2, n);
	}
	
	public static boolean isPowerOf(int base, long y)
	{
		//  tests if the function y = a ^ x
		
		int n = base; if (n == 0) return false;
		
		if (n == 2) return (y & (y-1)) == 0;
		
		if ((y % n) != 0) return false;
		
		long product = 1L;
		
		while (true)
		{
			long d = product - y;
			
			if (d == 0) return true;
			if (d >  0) return false;
			
			product = product * n;
		}
	}
	
	
	public static boolean isPrime(int n)
	{
		//  tests for primality
		
		final int[] primes = new int[]
		{
		     2,    3,    5,    7,   11,   13,   17,   19,   23,   29,   31,   37,
		    41,   43,   47,   53,   59,   61,   67,   71,   73,   79,   83,   89,
		    97,  101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,
		   157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,
		   227,  229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,
		   283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,
		   367,  373,  379,  383,  389,  397,  401,  409,  419,  421,  431,  433,
		   439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,
		   509,  521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,
		   599,  601,  607,  613,  617,  619,  631,  641,  643,  647,  653,  659,
		   661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,
		   751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,
		   829,  839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,
		   919,  929,  937,  941,  947,  953,  967,  971,  977,  983,  991,  997,
		};
		
		if (n < 0) throw new IllegalArgumentException();
		
		if ((n == 0) || (n == 1)) return false;
		
		//  Divide by the list of small primes
		
		for (int i = 0; i < primes.length; i++)
		
		    if ((n % primes[i]) == 0)
		
			if (n > primes[primes.length-1]) return false;
			
			else if (n / primes[i] == 1) return true;
			
			else return false;
		
		//                         n-1
		//  Apply the Fermat test a  == 1 (mod n)
		//  using bases a = 2 and a = 3 as witnesses
		
		if ((modPow(2, n-1, n) != 1)
		 || (modPow(3, n-1, n) != 1))
		
		     return false;  // composite
		
		//  The Fermat test is only guaranteed to be true if the output is false
		//  or the number is non-prime.
		//
		//  A composite number n that can pass the Fermat test a^(n-1) == 1 (mod n)
		//  for some base a is called a pseudo prime. A composite number that can
		//  pass the Fermat test for all bases is called an absolute pseudo prime
		//  or Carmichael number.
		//
		//  If the number has passed the Fermat test then we have to test for
		//  Carmichael numbers and other pseudo primes.
		
		//  n - 1 = (2 ^ s) r
		
		int r = n - 1;  int s = 0;
		
		while ((r % 2) == 0) { r >>>= 1; s++; }
		
		for (int i = 1; i <= 2; i++)
		{
			//  Choose 1 < a < n-1
			
			int a = i+1; long y;
			
			//  Compute y = a^r (mod n) and test if it equals 1 or -1
			
			if (((y = modPow(a, r, n)) != 1) && (y != n - 1))
			{
				int j = 1;
				
				while ((j++ <= (s - 1)) && (y != n - 1))
				{
					//  Compute y = y^2 (mod n);
					
					y = (y * y) % n;
					
					if (y == 1) return false;
				}
				
				if (y != n - 1) return false;
			}
		}
		
		return true;
	}
	
	
	public static boolean isSorted(int[] a)
	{
		//  tests if an array is sorted
		
		for (int i = 1; i < a.length; i++)
		
		    if (a[i] < a[i-1]) return false;
		
		return true;
	}
	
	
	public static boolean isSorted(int[][] a)
	{
		//  tests if an array is sorted
		
		for (int i = 1; i < a.length; i++)
		
		    if (a[i][0] < a[i-1][0]) return false;
		
		return true;
	}
	
	
	public static byte[] join(byte[] a, byte[] b)
	{
		//  concatenates two byte arrays
		
		byte[] c = new byte[a.length + b.length];
		
		for (int i = 0; i < a.length; i++) c[i] = a[i];
		for (int i = 0; i < b.length; i++) c[a.length + i] = b[i];
		
		return c;
	}
	
	
	public static int lambda(int n)
	{
	
		//  returns the Carmichael lambda function
		//
		//  lambda(n) == lcm((p[i]-1) p[i]^(k[i]-1))
		//
		//  where p[] = fact(n). (If there are no prime powers in n
		//  where the exponent is > 1 then this formula reduces to
		//  the lcm of (p[i]-1]))
		//
		//  The lambda function is the order or exponent modulus of
		//  the congruence a^x == 1 (mod n). The phi function is a
		//  multiple of the lambda function because it equals the
		//  product instead of the lcm of the phi functions of fact(n).
		//
		//  Powers of 2 are an exception to the rule. If n contains
		//  a factor 2^k >= 8, then the lambda function of 2^k is not
		//  phi(2^k) == 2^(k-1); the lambda function is 2^(k-2).
		
		
		if (n < 2) return 1;
		
		int[] fact = factor(n);
		
		int[][] int_freq = sortAndCollate(fact);
		
		int lambda = 1;
		
		for (int i = 0; i < int_freq.length; i++)
		{
			int p = int_freq[i][0], k = int_freq[i][1];
			
			int phi = (p-1) * (int) Math.pow(p, k-1);
			
			if ((p == 2) && (k > 2))
			
			     lambda = (int) lcm(lambda, phi/2);
			else lambda = (int) lcm(lambda, phi);
		}
		
		return lambda;
	}
	
	
	public static long lcm(int a, int b)
	{
		//  returns the least common multiple
		
		//  This method uses the equation
		//
		//  a x b == gcd(a, b) x lcm(a, b)
		
		return 1L * (a * b) / gcd(a, b);
	}
	
	
	public static Number lcr(int[] r, int[] n)
	{
		Number[] r1 = new Number[r.length];
		Number[] n1 = new Number[n.length];
		
		for (int i = 0; i < r.length; i++)
		{
			r1[i] = new Number(r[i]);
			n1[i] = new Number(n[i]);
		}
		
		return lcr(r1, n1);
	}
	
	
	public static Number lcr(long[] r, long[] n)
	{
		Number[] r1 = new Number[r.length];
		Number[] n1 = new Number[n.length];
		
		for (int i = 0; i < r.length; i++)
		{
			r1[i] = new Number(r[i]);
			n1[i] = new Number(n[i]);
		}
		
		return lcr(r1, n1);
	}
	
	
	
	public static Number lcr(Number[] r, Number[] n)
	{
	
		//  computes the least common remainder, least Chinese remainder,
		//  or least composite residue using Gauss's remainder algorithm
		//
		//  The name lcr refers to the value that is computed and returned
		//  instead of the algorithm or theorem. The method was originally
		//  called GaussRemainderAlgorithm.
		
		
		//  The least common remainder or lcr is used to refer to the object or value
		//  that is returned instead of the theorem or algorithm, just as fact(n) is
		//  used instead of fta, uft(n), or quadratic sieve to refer to the factori-
		//  zation instead of the fundamental theorem of arithmetic, the unique fac-
		//  torization theorem, or the method used to factor the number such as the
		//  quadratic sieve or number field sieve.
		//
		//  The terms lcr(r, n) and fact(n) don't replace the terms crt, fta, Gauss's
		//  algorithm, or quadratic sieve. The theorem, the algorithm, and the object
		//  or value returned by the algorithm are three different things. The crt
		//  and fta say that there is a common remainder or a factorization for any
		//  set of reduced residues and reduced moduli, or a composite number n, but
		//  they don't provide a method for computing the composite residue or the
		//  factorization of a number.
		//
		//  It doesn't make sense to use the Chinese remainder theorem to find the
		//  common remainder of a set of reduced residues r[] and reduced moduli n[],
		//  or to use the fta to find the factorization of a number n, because the crt
		//  and fta are not methods or algorithms. Some authors conflate the theorem,
		//  the algorithm, and the value and refer to Gauss's remainder algorithm,
		//  Garner's formula, and the least common remainder as crt.
		//
		//  Gauss's remainder algorithm comes from Disquisitiones Arithmeticae (1801).
		//  Carl F. Gauss is the greatest mathematician of all time followed by Newton,
		//  Euler, Archimedes, Euclid, Diophantus, Lagrange, Fermat, Cauchy, Riemann,
		//  Descartes, Galois, Leibniz, Fourier, Laplace, Abel, Legendre, ... and the
		//  second most prolific after Euler whose works are published in 70 large vol-
		//  umes. Cauchy is the third most prolific mathematician having 27 volumes of
		//  collected works.
		//
		//  There is a Chinese remainder algorithm 500 years before Gauss that is based
		//  on least common multiples, not modular inversion because modular inversion
		//  was unknown before Fermat's little theorem a^(p-1) == 1 (mod p) was pub-
		//  lished in the seventeenth century. (This theorem says that a^(p-1) == 1 ==
		//  a^0 (mod p) for a != 0 (mod p) which implies that the inverse of a or 1/a
		//  is a^(p-1) / a == a ^ (p-2) (mod p))
		//
		//  In the first century A.D., Nicomachus mentioned the problem of computing
		//  the composite residue from a set of reduced residues and moduli but he did
		//  not provide a method for solving the problem. One of two treatises by
		//  Nicomachus that has survived is called Introductio Arithmetica.
		//
		//  The name crt is still correctly used to refer to the Chinese remainder the-
		//  orem, just as fta is used to refer to the fundamental theorem of arithmetic.
		//  The name lcr is used to refer to the least Chinese remainder, least common
		//  remainder, or least composite residue. Gauss uses the term "least residue"
		//  in his book Disquisitiones Arithmeticae. The word common makes the least
		//  common remainder consistent with the terms least common multiple, greatest
		//  common divisor, and least common denominator.
		
		
		
		
		
		//  Gauss's Remainder Algorithm
		//
		//  This method uses Gauss's remainder algorithm to compute
		//  the least common remainder, Chinese remainder, or composite
		//  residue R mod n ... from a set of reduced residues
		//
		//  r = { r1, r2, ..., rk }, and a set of coprime moduli
		//  p = { p1, p2, ..., pk }.
		//
		//  The composite modulus N = p1 p2 ... pk.
		//
		//  The composite residue R ==
		//
		//  (r[i] N / p[i]) * ((N / p[i])^-1 mod p[i]) (mod N)
		//  
		//   ==    (r1 N / p1) ((N / p1) ^-1 mod p1)
		//       + (r2 N / p2) ((N / p2) ^-1 mod p2)
		//       + (r3 N / p3) ((N / p3) ^-1 mod p3)
		//       + ...    ...    ...    ...    ...
		//       + (rk N / pk) ((N / pk) ^-1 mod pk)  (mod N)
		
		
		
		//  Verify that the reduced residues and
		//  moduli have the same number of terms
		
		if (r.length != n.length)
		{
			String message = "number of residues" +
			  " does not equal number of moduli";
			
			throw new IllegalArgumentException(message);
		}
		
		for (int i = 0; i < r.length; i++)
		
		    r[i] = r[i] .mod(n[i]) .add(n[i]) .mod(n[i]);
		
		//  t = the number of coprime moduli
		
		final int t = n.length;
		
		//  For each n[i] compute n[i]^-1 mod p[i]
		
		Number[] m = new Number[t];
		
		Number N = new Number(1);
		
		for (int j = 0; j < t; j++)
		
		    N = N .multiply(n[j]);
		
		
		//  this is a slow loop because
		//  of the large modular reduction
		
		for (int i = 0; i < t; i++)
		{
			Number p = n[i];
			
			Number N1 = N .divide(n[i]); // slow
			
			N1 = N1 .mod(p);
			
			if (!N1.equals(0))  m[i] = N1.modInverse(p);
			
			else // p[i] == 1, m[i] = 0 since r[i] (mod 1) = 0
			
			    m[i] = new Number(0); // r[i] (mod 1) equals 0
		}
		
		
		//  Compute N[i], M[i], and the composite residue
		//
		//  R = the sum of r[i] N[i] M[i] (mod N)
		
		Number R = new Number(0);
		
		for (int i = 0; i < t; i++)
		{
			N = new Number(1);
			
			for (int j = 0; j < t; j++)
			
			    if (j != i)  N = N .multiply(n[j]);
			
			R = R .add( r[i] .multiply(m[i]) .multiply(N) );
		}
		
		
		//  Compute the composite modulus N
		
		N = new Number(1);
		
		for (int i = 0; i < t; i++)
		
		    N = N .multiply(n[i]);
		
		
		//  Reduce the common residue modulo N
		
		R = R .mod(N);
		
		//  Verify the answer
		
		for (int i = 0; i < n.length; i++)
		{
			if (!R .mod(n[i]) .equals(r[i].mod(n[i])))
			{
				System.out.println(Arrays.toString(r));
				System.out.println(Arrays.toString(n));
				
				throw new ArithmeticException();
			}
		}
		
		return R;
	}
	
	
	private static Number GarnersFormula(Number[] r, Number[] n)
	{
	
		//  This method was included to compare the speeds of Gauss's and
		//  Garner's formulas. Both methods have the same quadratic running
		//  time, but Gauss's algorithm is a few times faster than Garner's
		//  formula unless the size of the composite modulus (or the sum of
		//  the reduced moduli sizes) is greater than ~ 1 M bit. At ~ 1 G bit
		//  Garner's formula may be several times faster.
		//
		//  The following formula was excerpted from the Handbook of Applied
		//  Cryptography. The algorithm is not correct but it can be used to
		//  test the speed of the algorithm. (See the commented code below that
		//  was used to compare the speed of Gauss's and Garner's formulas.)
		//
		//                                __ t
		//  Input: a positive integer M = ||   m[i] > 1, with (m[i], m[j]) == 1 for all
		//                                  i=1
		//  i != j, and a modular representation v(x) = (v1, v2, ..., vt) of x for the m[i].
		//
		//  Output: the integer x in radix b representation.
		//
		//  1.  For i from 2 to t do the following:
		//	
		//	1.1  C[i] = 1.
		//	
		//	1.2  For j from 1 to i - 1 do the following:
		//	
		//	     u = m[j] ^ -1   (mod m[i]),
		//	
		//	     C[i] = u * C[i] (mod m[i]).
		//	
		//  2.  u = v[1],  x = u;
		//
		//  3.  For i from 2 to t do the following:
		//
		//	u = (v[i] - x) C[i] (mod m[i]),
		//	
		//	            __i-1
		//	x = x + u * ||   m[j].
		//                    j=1
		//  4.  Return x.
		
		
		
		if (r.length != n.length)
		{
			String message = "number of residues"
			
			    + " does not equal number of moduli";
			
			throw new IllegalArgumentException(message);
		}
		
		//  t = the number of coprime moduli
		
		int t = n.length;
		
		Number[] C = new Number[t];
		
		for (int i = 0; i < t; i++)
		{
			C[i] = new Number(1);
			
			for (int j = 0; j < i - 1; j++)
			{
				Number u = n[j] .modInverse(n[i]);
				
				C[i] = u .multiply(C[i]) .mod(n[i]);
			}
		}
		
		Number u = r[0], R = u;
		
		Number M = new Number(1);
		
		for (int i = 0; i < t; i++)
		{
			u = r[i].subtract(R) .multiply(C[i]) .mod(n[i]);
			
			M = M .multiply(n[i]);
			
			//  System.out.println("M == " + M);
			
			R = R .add(u.multiply(M));
		}
		
		//  Verify the answer
		
		for (int i = 0; i < n.length; i++)
		
		    if (!R .mod(n[i]) .equals(r[i].mod(n[i])))
		
			throw new ArithmeticException();
		
		return R;
		
		
		
		//  This code shows that Garner's formula is a few times slower
		//  than Gauss's remainder algorithm for numbers up to ~ 1 M bit.
		//  For numbers > 1 M bit, Garner's formula is a few times faster.
		//
		//  final int t = 160; // 4*160^2 ~ 100 K bits
		//
		//  Number[] r = new Number[t];
		//  Number[] n = new Number[t];
		//
		//  int digits = t, radix = 16;
		//
		//  System.out.println("size == " + 4*t*t/1024 + " K bits");
		//
		//  //  The moduli don't have to be prime to test the remainder algo-
		//  //  rithm; they just have to be comprime. This means that we can
		//  //  construct large coprime moduli by multiplying smaller primes
		//  //  (such as 256-bit or 64-bit primes) because finding large primes
		//  //  requires O(n) multi-precision exponentiations, O(n^2) multi-
		//  //  precision multiplications (because each exponentiation requires
		//  //  n multiplications), or O(n^4) single-precision operations using
		//  //  a quadratic multiplier.
		//
		//  for (int i = 0; i < t; i++)
		//  {
		//	//  Choose a random residue r[i] and construct
		//	//  a modulus n[i] using large prime factors
		//	
		//	r[i] = Number.random(digits, radix);
		//	
		//	n[i] = new Number(1);
		//	
		//	for (int j = 0; j < digits / 64; j++)
		//	
		//	    n[i] = n[i] .multiply( // 64 digits == 256 bits
		//	
		//		Number.random(64, radix) .nextPrime());
		//  }
		//
		//  long starttime1, starttime2;
		//  long   endtime1,   endtime2;
		//
		//  starttime1 = System.currentTimeMillis();
		//
		//  Math.lcr(r, n);
		//
		//  endtime1 = System.currentTimeMillis();
		//
		//  starttime2 = System.currentTimeMillis();
		//
		//  try { Math.GarnersFormula(r, n); }
		//
		//  catch (ArithmeticException ex) {  }
		//
		//  endtime2 = System.currentTimeMillis();
		//
		//  double quotient = 1.0 *
		//
		//     (endtime2 - starttime2) /
		//     (endtime1 - starttime1);
		//
		//  System.out.println("Garner formula time / " +
		//
		//    "Gauss's algorithm time == " + (float) quotient);
	}
	
	
	
	public static double log(double a, double b)
	{
		//  returns log(a) to the base b
		//
		//  using the logarithmic identity
		//
		//  log (a) / log (b) == log (a)
		//     x         x          b
		
		return log(a) / log(b);
	}
	
	
	public static double log(double d)
	{
	
		//  returns the natural logarithm
		//
		//  ln(x) for any real x > 0
		//
		//  The series for log(1 + x) is
		//
		//                    n+1   n
		//  log(1 + x) == (-1)    x  /  n
		//
		//  for -1 < x <= 1  or  0 < (1 + x) <= 2
		
		
		if (d == Double.POSITIVE_INFINITY)
		
		    throw new IllegalArgumentException();
		
		if (d == 1) return 0.0;
		
		if (d == 0) return Double.NEGATIVE_INFINITY;
		
		if (Double.isNaN(d) || (d < 0))
		
		    return Double.NaN;
		
		
		//  Set d = e^k * b. Then
		//
		//  log(d) == log(e^k * b) == k + log(b)
		
		int k = 0;  double d1 = d;
		
		while (d1 > 1.5)  { d1 /= e;  k++; }
		
		double b = d1,  x = b - 1,  log = k;
		
		for (long n = 1; n < 32; n++)
		{
			double t = pow(x, n) / n;
			
			if ((n % 2) == 1) log += t;
			
			else log -= t;
		}
		
		//  Check the answer
		
		//  Verify that e ^ log(x) / x == x / x == 1
		
		double q = abs(exp(log) / d);
		
		if ((q < 0.9999D) || (q > 1.00001D))
		{
			System.out.println("d == " + d + " log(d) == " + log);
			
			System.out.println("e^log(d) / d == " + (exp(log) / d));
			
			throw new ArithmeticException();
		}
		
		return log;
	}
	
	
	
	public static int log2(int n)
	{
		//  returns the bit count
		
		return bitCount(n);
	}
	
	
	public static double log2(double n)
	{
		//  computes the log to the base 2 of n
		//
		//  using the logarithmic identity
		//
		//  log n / log 2  == log x log n == log n
		//     x       x         2     x        2
		
		
		return log(n) / log(2);
	}
	
	
	public static double log10(double n)
	{
		//  computes the base-10 logarithm
		//
		//  using the logarithmic identity
		//
		//  log n / log 10  == log x log n == log n
		//     x       x         10     x       10
		
		return log(n) / log(10);
	}
	
	
	
	public static  int max( int a,  int b) { return a >= b ? a : b; }
	public static long max(long a, long b) { return a >= b ? a : b; }
	
	public static double max(double a, double b)
	{
		//  returns the greater of two values
		
		if (a != a) return a; // a is NaN
		
		return a >= b ? a : b;
	}
	
	public static float max(float a, float b)
	{
		//  returns the greater of two values
		
		if (a != a) return a; // a is NaN
		
		return a >= b ? a : b;
	}
	
	public static  int min( int a,  int b) { return (a <= b) ? a : b; }
	public static long min(long a, long b) { return (a <= b) ? a : b; }
	
	public static float min(float a, float b)
	{
		//  returns the lesser of two values
		
		if (a != a) return a; // a is NaN
		
		return a <= b ? a : b;
	}
	
	public static double min(double a, double b)
	{
		//  returns the lesser of two values
		
		if (a != a) return a; // a is NaN
		
		return a <= b ? a : b;
	}
	
	
	
	
	public static int modDivide(int dividend, int divisor, int n)
	{
	
		//  modular division
		//
		//  This method computes a / b  (mod n)
		//
		//  using modDivide(a, b, n) which is simpler
		//
		//  than (a * (modInverse(b, n))) % n
		
		
		int a = dividend % n;  if (a < 0) a += n;
		
		if ((divisor == 0) || !isCoprimeWith(divisor, n)) return -1;
		
		int quotient = (int) ((1L * a * modInverse(divisor, n)) % n);
		
		if (quotient < 0) quotient += n;
		
		if (((((1L * quotient * divisor) % n) + n) % n) != a)
		{
			System.out.println();
			System.out.println("dividend == " + dividend);
			System.out.println("divisor  == " + divisor);
			System.out.println("quotient == " + quotient);
			System.out.println("modulus  == " + n);
			System.out.println("1 / " + divisor + " mod " + n
			
			    + " == " + modInverse(divisor, n));
			
			throw new ArithmeticException();
		}
		
		return quotient;
	}
	
	
	
	public static int modInverse(int a1, int n)
	{
	
		//  This method uses the extended Euclidean algorithm to
		//  find the inverse of a modulo n or to solve the congru-
		//  ence a x == 1 (mod n) or the equation a x - k n == 1
		
		//  variables:  a, b, c, q, r,  x, x1, x2,  y, y1, y2;
		
		if (n < 0) throw new IllegalArgumentException();
		
		if (a1 < 0)  a1 = ((a1 % n) + n) % n;
		
		long a, b, c, q, r;  a = b = c = q = r = 0;
		
		long x, x1, x2,  y, y1, y2;
		
		x1 = 0;  x2 = 1;  y1 = 1;  y2 = 0;
		
		a = abs(a1 % n);  b = n;
		
		while (a != 0)
		{
			q = b / a;
			
			r = b - q * a;
			
			x = x2 - q * x1;
			y = y2 - q * y1;
			
			x2 = x1;  x1 = x;
			y2 = y1;  y1 = y;
			
			b = a;  a = r;
		}
		
		c = b;  x = x2;  y = y2;
		
		long inva = y;
		
		if (c != 1)
		{
			String message = "non-invertible number";
			
			throw new ArithmeticException(message);
		}
		
		//  Verify the modular inverse
		
		long product = (((inva * (a1 % n)) % n) + n) % n;
		
		if (product != 1)
		{
			System.out.println("a == " + a1 +
			
			  "  n == " + n + "  inva == " + inva);
			
			throw new ArithmeticException();
		}
		
		inva %= n;
		
		if (inva < 0) inva += n;
		
		return (int) inva;
	}
	
	
	
	public static int modPow(int base, int exp, int mod)
	{
	
		//  computes y = a ^ x (mod n)
		
		//  Test for (x == 0) before
		//  testing for (base == 0)
		
		if (exp  == 0)  return 1;
		if (base == 0)  return 0;
		
		long n = mod & 0xffffffffL;
		long x = exp & 0xffffffffL;
		
		if (mod == 0) n = 0x100000000L;
		
		if (base < 0) base = ((base % mod) + mod) % mod;
		
		long a = (base & 0xffffffffL) % n;
		
		long y = 1L;
		
		final boolean powerof2;
		
		if (((n - 1) & n) == 0)
		
		     powerof2 = true;
		else powerof2 = false;
		
		long modm1 = n - 1;
		
		//  Use the square and multiply method
		
		while (x != 0)
		{
			if ((x % 2) == 1)
			{
				y = a * y;
				
				if (powerof2) y &= modm1;
				
				else y %= n;
			}
			
			a *= a;
			
			if (powerof2) a &= modm1;
			
			else  a %= n;
			
			x >>>= 1;
		}
		
		return (int) y;
	}
	
	
	
	public static int[] multiply(int[] x, int y)
	{
		//  multiplyByInt method
		//
		//  multiplies an array by an int
		
		int m1 = x.length;
		
		int[] w = new int[m1 + 1];
		
		int z = 0;  long uv = 0L;  long xy = 0L;
		
		for (int j = 0; j < m1; j++)
		{
			//  Compute the unsigned product of x[j] and y
			
			xy = 1L * x[x.length -1 -j] * y;
			
			//  Convert the signed product to an unsigned product
			
			if (x[x.length -1 -j] < 0) xy += ((1L * y) << 32);
			if (y < 0) xy += ((1L * x[x.length -1 -j]) << 32);
			
			//  Add the product and carry bits to the sum and prevent the sign bit
			//  from expanding in the variables w and z as they widen from int to long
			
			uv = xy + (w[w.length -1 -(j)] & 0xffffffffL) + (z & 0xffffffffL);
			
			//  Copy the lower int or uv to the product array w
			
			//  w = uv mod 2^32
			
			w[w.length -1 - j] = 0;
			w[w.length -1 - j] += uv;
			
			//  Copy the upper int of uv to the carry int z
			
			//  z = (uv >>> 32) mod 2^32
			
			z = 0;  z += (uv >>> 32);
		}
		
		//  Copy the upper int of uv to w
		
		w[w.length -1 - m1] = 0;
		w[w.length -1 - m1] += (uv >>> 32);
		
		return w;
	}
	
	
	
	public static int[] multiply(int[] multiplier, int[] multiplicand)
	{
		//  multiplies two int arrays
		//
		//  This method is used by the number class
		
		//  Count the number of twos or zeros
		
		long twos1 = 0, twos2 = 0;
		
		for (int i = 0; i < multiplier.length; i++)
		{
			if (multiplier[multiplier.length-1-i] == 0) twos1++;
			
			else break;
		}
		
		for (int i = 0; i < multiplicand.length; i++)
		{
			if (multiplicand[multiplicand.length-1-i] == 0) twos2++;
			
			else break;
		}
		
		//  Right shift the multiplier and multiplicand to remove the
		//  trailing zeros and then trim to remove the leading zeros
		
		int[] multiplier1, multiplicand1, product1;
		
		multiplier1   = trim(shiftRight(multiplier,   32*twos1));
		multiplicand1 = trim(shiftRight(multiplicand, 32*twos2));
		
		
		//  Compute the product using the quadratic multiplier
		
		product1 = quadMultiply(multiplier1, multiplicand1);
		
		
		//  Replace the twos or zeros in the product
		
		long twos = twos1 + twos2;
		
		int[] product = trim(shiftLeft(
		
		    product1, 32*twos, 32*twos));
		
		return product;
	}
	
	
	
	public static int nextPrime(int n)
	{
		//  returns the next prime p
		
		if (n < 2) return 2;
		
		if ((n % 2) == 1) n += 2;  else n += 1;
		
		while (!isPrime(n)) n += 2;
		
		return n;
	}
	
	
	public static int nextSafePrime(int n)
	{
		//  returns the next safe prime
		//
		//  p = 2 q + 1 where p and q are prime
		
		int prime = n;
		
		do { prime = nextPrime(prime); }
		
		    while (!isPrime((prime-1)/2));
		
		return prime;
	}
	
	
	
	public static Number nCr(int n, int r)
	{
		//  returns the number of ways to choose r elements
		//  from a set of n elements (or n C r == n Choose r)
		
		//  The number of combinations of n elements taken r at a time is
		//
		//  n C r  ==  n! / r! / (n - r)!
		//
		//  (If permutations are allowed, then n P r = n C r * r!)
		//
		//  n C r == n C -r (= n C n-r) because n C r is symmetrical.
		
		return new Number(n) .factorial() .divide(
		
		    new Number(n - r) .factorial() .multiply(
		
			new Number(r) .factorial() ) );
	}
	
	
	
	public static int[] not(int[] array)
	{
		//  negates or complements the bits
		
		int[] array1 = new int[array.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = ~ array[i];
		
		return array1;
	}
	
	
	public static int phi(int n)
	{
		//  computes the phi function or totient of n
		//
		//  The Euler phi function is
		//            __                k[i] -1
		//  phi(n) == || (p[i] - 1) p[i]
		//
		//  (If there are no prime powers in n where k > 1, then this
		//  formula reduces to the product of p[i] - 1.
		//
		//  The Carmichael lambda function computes the least common
		//  multiple instead of the product of the phi functions of p[i].
		
		if (n < 2) return 1;
		
		int[] fact = factor(n);
		
		int[][] int_freq = sortAndCollate(fact);
		
		int phi = 1;
		
		for (int i = 0; i < int_freq.length; i++)
		{
			int p = int_freq[i][0], k = int_freq[i][1];
			
			phi = phi * (p-1) * (int) Math.pow(p, k-1);
		}
		
		return phi;
	}
	
	
	
	public static byte[] or(byte[] array1, byte[] array2)
	{
		//  ors the bits of two byte arrays
		
		//  byte arrays are left-aligned because they are
		//  used for cryptography instead of arithmetic
		
		int maxsize = Math.max(array1.length, array2.length);
		
		byte[] array3 = new byte[maxsize];
		
		for (int i = 0; i < array1.length; i++)
		
			array3[array3.length -1 -i]
		     |= array1[array1.length -1 -i];
		
		for (int i = 0; i < array2.length; i++)
		
			array3[array3.length -1 -i]
		     |= array2[array2.length -1 -i];
		
		return array3;
	}
	
	
	
	public static int[] or(int[] array1, int[] array2)
	{
		//  ors the bits of two int arrays
		
		int maxsize = Math.max(array1.length, array2.length);
		
		int[] array3 = new int[maxsize];
		
		for (int i = 0; i < array1.length; i++)
		
		      array3[array3.length -1 -i]
		   |= array1[array1.length -1 -i];
		
		for (int i = 0; i < array2.length; i++)
		
		      array3[array3.length -1 -i]
		   |= array2[array2.length -1 -i];
		
		return array3;
	}
	
	
	
	public static int[] permutate(int elements, long rand)
	{
		//  returns a permuted array of integers using a key or value
		
		//  Note that this method uses the Math.random() method
		//  which is not used for encryption.
		
		//  This method generates a perfectly random permutation
		//  of the indexes or integers 0, 1, 2, 3, ..., n-1.
		
		//  for (int i = 0; i < elements; i++)
		//
		//     swap element[n-1 -i] and element[rand(n - i)]
		//
		//  This swaps the elements in the array in reverse order
		//  starting from element n. Each highest element n, n-1,
		//  n-2, n-3, ... can only be swapped once because the
		//  modulus (n - i) of the random number generator de-
		//  creases for each iteration.
		
		
		int n = elements;
		
		int[] a = new int[elements];
		
		for (int i = 0; i < elements; i++) a[i] = i;
		
		for (int i = 0; i < n; i++)
		{
			//  Generate a random index from 0 to n-2 -i
			
			int rand1 = random(n-1 -i); // 0 to n-2 -i
			
			//  Swap or interchange a[n-1 -i] and a[rand1]
			
			int temp = a[rand1];
			
			a[rand1] = a[n-1 -i];
			
			a[n-1 -i] = temp;
		}
		
		return a;
	}
	
	
	
	
	public static double Poisson(double u, int x)
	{
	
		//  computes the probability that x random
		//  events will occur given an average rate u
		
		
		//  The Poisson function is
		//
		//              -u   x
		//  f(u, x) == e   u  / x!
		//
		//  where u is the mean and the variance
		//
		//  and x is a non-negative integer
		
		
		//  The Poisson function can be computed recursively from the formula
		//
		//                    - u   i+1
		//  P (x = i+1)      e    u    / (i+1)!        u  
		//  ___________  ==  __________________  ==  _____
		//                    - u   i+0
		//  P (x = i+0)      e    u    / (i+0)!      i + 1
		//
		//  This means that each value of P is equal to the previous
		//  value of P times  u / (i + 1). The zeroth value of P or
		//  P(x = 0) is  e^-u  u^0 / 0! == e^-u.
		
		
		int digits = (int) u;
		
		Number e2u = Number.e(digits) .pow(-u);
		
		Number u2x = new Number(u) .pow(x);
		
		Number fact = new Number(x) .factorial();
		
		//  System.out.println("e^u == " + e2u);
		//  System.out.println("u^x == " + u2x);
		//  System.out.println("fact == " + fact);
		
		Number P = e2u .multiply( u2x ) .divide( fact );
		
		return P .doubleValue();
	}
	
	
	
	public static double pow(double base, long exp)
	{
		//  computes y = a ^ x
		//
		//  for a real base and integer exponent
		
		if (exp == 1) return base;
		
		double a = base, y = 1.0D;
		
		long b = exp, x = abs(b);
		
		//  Use the square and multiply method
		
		while (x != 0)
		{
			if ((x & 1) == 1)  y *= a;
			
			a *= a;  x >>>= 1;
		}
		
		if (b < 0)  y = 1 / y;
		
		return y;
	}
	
	
	
	public static double pow(double base, double exp)
	{
	
		//  computes the function
		//
		//          x      log a  x       k x
		//  y  =  a   == (e     )   ==  e
		//
		//  for a real base and exponent.
		//
		//  (integer exponents should use pow(double, long))
		
		//                  x     n
		//  The series for e  is x / n!
		//
		//                             x
		//  The exponential function a   can be
		//                               x
		//  computed from the function e   because
		//
		//   x      k x      x k
		//  a  == (e )  == (e )
		//
		//  where a = exp(k), or k == log(a)
		
		
		//  The integer and fraction exponents
		//  can be computed separately because
		//
		//   intx + fracx      intx  fracx
		//  a             ==  a     a
		
		
		double a = base, b = exp;
		
		if (b == 0)  return 1.0D;
		
		//  If the exponent is an integer return y_int
		
		if (abs(b - (int) b) < 0.00000001D)
		
		    return pow(a, (long) b);
		
		
		//  Solve for k in the equation
		//
		//         k
		//  a == e  and multiply b (= exp) by k
		
		double k = (abs(a - e) > 0.00000001)? k = log(a) : 1;
		
		
		//            x     k x    k x   x'
		//  Compute a  == (e ) == e == e
		//
		//  where k = log(a) from the series
		//
		//   x      n                  2       3
		//  e  == x / n!  ==  1 + x + x / 2 + x / 6 + ...
		//
		//  This series brings the fraction x from
		//  the exponent down to the base to avoid
		//  doing square roots which are expensive
		
		
		double yfrac = 0.0D, temp = 1.0D;
		
		//  temp = x^0 / 0!
		
		double factorial = 1.0D;
		
		//  Compute the new exponent x' = k x
		
		double b1 = b*k;
		
		//  Compute the integer value y_int
		
		double yint = pow(e, (long) b1);
		
		//  Compute the fractional value y_frac
		
		b1 = abs(b1 - (long) b1);
		
		for (int n = 1; n < 32; n++)
		{
			yfrac += (temp / factorial);
			
			temp *= b1;
			
			factorial *= n;
		}
		
		//  Compute y = y_int * y_frac
		
		double y = yint * yfrac;
		
		//  Invert the output if the exponent is negative
		
		if (b <= 0)  y = inverse(y);
		
		return y;
	}
	
	
	
	
	public static int[] primes(int n)
	{
	
		//  returns the first n primes using the prime number sieve
		//
		//  (The prime number sieve is also called the sieve of Eratosthenes.)
		//
		//  The prime number sieve works by striking out integers that
		//  are multiples of integers starting from the number two.
		//
		//  The prime number sieve is thousands of times faster than the
		//  Fermat primality test for finding the first few million primes.
		
		//  Example  Print the first 168 primes
		//
		//  int[] primes = Math.primes(168);
		//
		//  System.out.println(Arrays.toString(primes));
		//
		//  [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,
		//   53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,
		//   113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179,
		//   181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,
		//   251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
		//   317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,
		//   397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
		//   463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,
		//   557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,
		//   619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,
		//   701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773,
		//   787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,
		//   863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,
		//   953, 967, 971, 977, 983, 991, 997 ]
		
		
		if (n == 0) return new int[0];
		
		final boolean[] sieve;
		
		int t = (int) (2*n * log(n));
		
		if (t < 0) t = 0x7fffffff-1;
		
		sieve = new boolean[t];
		
		sieve[0] = false; sieve[1] = false;
		
		for (int i = 2; i < sieve.length; i++)
		
		    sieve[i] = true;
		
		for (int i = 0; i < sieve.length; i++)
		{
			if (!sieve[i]) continue;
			
			for (int j = 2; i*j < sieve.length; j++)
			
			    sieve[i*j] = false;
		}
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		for (int i = 0; i < sieve.length; i++)
		
		    if (sieve[i]) list.add(i);
		
		int[] primes = new int[n];
		
		for (int i = 0; i < primes.length; i++)
		
		    primes[i] = list.get(i);
		
		return primes;
	}
	
	
	
	
	
	private static int[] quadMultiply(int[] multiplier, int[] multiplicand)
	{
	
		//  multiplies two arrays using a quadratic multiplier
		
		//  The length of the product array equals the sum of the
		//  lengths of the two arrays.
		
		
		//  Squaring is twice as fast as multiplying
		//
		//  If the multiplier and multiplicand
		//  are the same use quadratic squaring
		//
		//  if (Arrays.equals(multiplier, multiplicand))
		//
		//      return quadSquare(multiplicand);
		
		
		int[] w;  int[] x, y;
		
		int m1 = multiplicand.length;
		int m2 = multiplier.length;
		
		
		x = new int[multiplicand.length];
		
		for (int i = 0; i < multiplicand.length; i++)
		
		    x[i] = multiplicand[i];
		
		y = new int[multiplier.length];
		
		for (int i = 0; i < multiplier.length; i++)
		
		    y[i] = multiplier[i];
		
		w = new int[m1 + m2];
		
		for (int i = 0; i < w.length; i++) w[i] = 0;
		
		for (int i = 0; i < m2; i++)
		{
			int z = 0;  long uv = 0L;  long xy = 0L;
			
			for (int j = 0; j < m1; j++)
			{
				//  Compute the unsigned product of x[j] and y[i]
				
				xy = 1L * x[m1 -1 -j] * y[m2 -1 -i];
				
				//  This code is necessary if x and y are ints instead of longs
				//
				//  Convert the signed product to an unsigned product
				
				if (x[m1 -1 -j] < 0) xy += ((1L * y[m2 -1 -i]) << 32);
				if (y[m2 -1 -i] < 0) xy += ((1L * x[m1 -1 -j]) << 32);
				
				//  Add the product and carry bits to the sum and prevent the sign bit
				//  from expanding in the variables w and z as they widen from int to long
				
				uv = xy + (w[(m1 + m2) -1 -(i+j)] & 0xffffffffL) + (z & 0xffffffffL);
				
				//  Copy the lower int to the product array w
				
				//  w = uv mod 2^32
				
				w[(m1 + m2) -1 - (i + j)] = 0;
				w[(m1 + m2) -1 - (i + j)] += uv;
				
				//  Copy the upper int to the carry int z
				
				//  z = (uv >>> 32) mod 2^32
				
				z = 0;  z += (uv >>> 32);
			}
			
			//  Copy the upper int from uv into w
			
			w[(m1 + m2) -1 - (i + m1)] = 0;
			w[(m1 + m2) -1 - (i + m1)] += (uv >>> 32);
		}
		
		return w;
	}
	
	
	
	public static void quadSort(int[] a)
	{
		//  A quadratic sorter
		
		//  This sorting method requires O(n^2) operations
		//
		//  This method is more efficient than a linear
		//  log O(n log n) sorter for small arrays
		
		for (int i = 0; i < a.length;    i++)
		for (int j = 0; j < a.length -1; j++)
		{
			int a1 = a[j+0];
			int a2 = a[j+1];
			
			if (a1 > a2) // swap the two elements
			{
				int temp = a[j+0];
				a[j+0]   = a[j+1];
				a[j+1]   = temp;
			}
		}
	}
	
	
	
	
	
	private static Random rng = new Random();
	
	//  pseudo-random number generator
	
	
	public static synchronized void initRng(long val)
	{
		//  Math.initRng(val);
		//
		//  int rand = Math.random(...);
		
		rng = new Random(val);
	}
	
	
	public static int random(int mod)
	{
		//  returns a random integer greater than
		//  or equal to 0 and less than the modulus
		
		double d = random();
		
		return (int) (d * mod);
	}
	
	
	public static long random(long mod)
	{
		//  returns a random integer greater than
		//  or equal to 0 and less than the modulus
		
		//  the modulus should be <= 52 bits or else
		//  the random number will end with zeros in
		//  base 16 because the significand of a double
		//  is only 52 bits; the other 12 bits are for
		//  the exponent and the two signs.
		
		if (mod > 0xfffffffffffffL)
		{
			String message = "random mod size > 52 bits";
			
			System.out.println(message);
		}
		
		double d = random();
		
		return (long) (d * mod);
	}
	
	
	public static double random(double mod)
	{
		//  returns a random number greater than
		//  or equal to 0.0 and less than the modulus
		
		double d = random();
		
		return (d * mod);
	}
	
	
	public static double random()
	{
	
		//  returns a random number greater than
		//  or equal to 0.0 and less than 1.0
		
		//  If multiple threads call the random() method,
		//  it is faster to use the code
		//
		//  Random rng = new Random(System.nanoTime());
		//  double d = rng.nextDouble();
		//  long rand = (long) (d * 0xfffffffffffffL);
		//
		//  to create a separate random number generator
		//  for each thread instead of the code
		//
		//  double rand = Math.random();
		//
		//  because only one thread at a time can
		//  access the synchronized random method.
		
		
		//  Example  Use the random method to generate random numbers in any base
		//
		//  The double random method returns a real number from 0 to 0.99999...
		//
		//  Multiply by the base and convert to int to generate a random
		//  number from 0 to base-1
		//
		//  rand integer = (int) (base * (double rand = 0.0 to 9.99999...))
		//
		//  int base = 2;  //  2, 10, 16, ...
		//  
		//  int digits = 128;
		//  
		//  for (int i = 0; i < digits; i++)
		//  {
		//	double d = Math.random();
		//	
		//	int randdigit = (int) (d * base);
		//	
		//	if (i % 32 == 0) System.out.println();
		//	
		//	    System.out.print(randdigit + " ");
		//  }
		
		
		return rng .nextDouble();
	}
	
	
	
	public static double root(double n, int k)
	{
	
		//  computes the kth root of a
		//  number n by iterating
		//
		//  r = ((k-1) r + n / r^(k-1)) / k
		//
		//   linear root  r == (0 r + n / r^0) / 1
		//   square root  r == (1 r + n / r^1) / 2
		//     cube root  r == (2 r + n / r^2) / 3
		//  quartic root  r == (3 r + n / r^3) / 4
		//  quintic root  r == (4 r + n / r^4) / 5
		//
		//      ...        ...        ...
		//      ...        ...        ...
		//
		//  The minus one root is Newton's iter-
		//  ation for inversion  u = u (2 - v u).
		//
		//  To invert n, set k = -1, then iterate
		//
		//  r ==  [(k-1) r + n / r ^ (k-1)] / k
		//
		//    ==  [(-2) r + n / r ^ (-2)] / -1
		//
		//    ==  [ 2 r - n r ^ 2]
		//
		//    ==  r (2 - n r)
		
		
		if ((k < 1) || ((k % 2 == 0) && (n < 0)))
		
		    throw new IllegalArgumentException();
		
		if (n == 0)  return 0;
		if (k == 1)  return n;
		
		//  Set r approximately equal to root(n)
		
		double r = 1.0D;
		
		//  ...
		
		//  ...
		
		for (int j = 0; j < 256; j++)
		{
			double pow = pow(r, k-1);
			
			r = ((k-1)*r  +  n / pow) / k;
		}
		
		if (abs(pow(r, k) / n) > 1.0001D)
		{
			System.out.println("radicand == " + n);
			System.out.println("    root == " + r);
			System.out.println("   index == " + k);
			System.out.println("| root^exp | == " + abs(pow(r, k)));
			System.out.println("root^exp - radicand == " + abs(pow(r, k) - n));
			
			String message = "root extraction error";
			
			throw new ArithmeticException(message);
		}
		
		return r;
	}
	
	
	
	public static int[] safePrimes(int n)
	{
		//  returns n primes of the form p = 2 q + 1
		
		//  The density of safe primes is ~
		//  (1 / log n) (1 / log n) == (1 / log n)^2
		//  where n is the number of bits
		
		//  The first few safe primes are
		//
		//     5,    7,   11,   23,   47,   59,   83,  107,  167,
		//   179,  227,  263,  347,  359,  383,  467,  479,  503,
		//   563,  587,  719,  839,  863,  887,  983
		
		
		int[] safeprimes = new int[n];
		
		int N = (int) (4*n * log(n));
		
		int[] primes = primes(N);
		
		for (int i = 0, j = 0; i < safeprimes.length; i++, j++)
		{
			while (!isPrime((primes[j] - 1) / 2)) j++;
			
			safeprimes[i] = primes[j];
		}
		
		return safeprimes;
	}
	
	
	
	public static void setBit(byte[] array, long bit)
	{
		//  sets a bit of an array
		
		if ((bit / 8) >= array.length)
		
		    throw new IllegalArgumentException();
		
		array[array.length -1 - (int) (bit / 8)]
		
		    |= (1 << bit % 8);
	}
	
	
	public static void setBit(int[] array, long bit)
	{
		//  sets a bit of an array
		
		if ((bit / 32) >= array.length)
		
		    throw new IllegalArgumentException();
		
		array[array.length -1 - (int) (bit / 32)]
		
		    |= (1 << bit % 32);
	}
	
	
	public static int[] shiftLeft(int[] array, long bits)
	{
		//  shifts an array left without expanding
		
		if ((bits > 32L*array.length) || (bits < 0))
		
		    throw new IllegalArgumentException();
		
		int ints = (int) (bits / 32);
		int b    = (int) (bits % 32);
		
		int[] array1 = new int[array.length];
		
		for (int i = 0; i < array1.length; i++) array1[i] = array[i];
		
		if (ints > 0)
		{
			for (int i = 0; (i + ints) < array1.length; i++)
			
			    array1[i] = array[i + ints];
			
			for (int i = (array1.length - ints); i < array1.length; i++)
			
			    array1[i] = 0;
		}
		
		long carry = 0L;
		
		for (int i = array1.length - 1; i >= 0; i--)
		{
			long a = (array1[i] & 0xffffffffL);
			
			array1[i] = (int) (((a << b) + carry) & 0xffffffffL);
			
			carry = a >>> (32 - (1L*b));
		}
		
		return array1;
	}
	
	
	
	public static int[] shiftLeft(int[] array, long expansion, long bits)
	{
		//  shifts and expands an array
		
		if (bits < 0) throw new IllegalArgumentException();
		
		int[] array2;
		
		if (expansion % 32 != 0)
		
		     array2 = new int[1 + array.length + (int) (expansion / 32)];
		else array2 = new int[0 + array.length + (int) (expansion / 32)];
		
		for (int i = 0; i < array.length; i++)
		
		    array2[array2.length -1 -i]
		  = array [array .length -1 -i];
		
		array2 = shiftLeft(array2, bits);
		
		return array2;
	}
	
	
	
	public static int[] shiftRight(int[] array, long bits)
	{
		//  shifts right without contracting
		
		if ((bits > 32L*array.length) || (bits < 0))
		
		    throw new IllegalArgumentException();
		
		int ints = (int) (bits / 32);
		int b    = (int) (bits % 32);
		
		int[] array1 = new int[array.length];
		
		for (int i = 0; i < array1.length; i++) array1[i] = array[i];
		
		if (ints > 0)
		{
			for (int i = 0; (i + ints) < array.length; i++)
			
			    array1[array1.length -1 -i] =
			    array [array .length -1 - (i + ints)];
			
			for (int i = 0; i < ints; i++)  array1[i] = 0;
		}
		
		long carry = 0L;
		
		for (int i = 0; i < array1.length; i++)
		{
			long a = (array1[i] & 0xffffffffL);
			
			array1[i] = (int) (((a >>> b) + carry) & 0xffffffffL);
			
			carry = ( a << (32 - (1L*b)) );
		}
		
		return array1;
	}
	
	
	
	public static double sin(double x)
	{
		//  returns the sine of an angle in radians
		
		return cos_sin(x)[1];
	}
	
	
	public static double sinh(double u)
	{
		//  returns the hyperbolic sine
		//
		//  sinh(u) =  1/2 ( e^u - e^-u )
		
		return ( exp(u) - exp(-u) ) / 2;
	}
	
	
	public static double[] sin_table(int n)
	{
		//  returns a table of sines
		
		if (n == 0) throw new IllegalArgumentException();
		
		if (n == 1) return new double[] { 0.0D };
		if (n == 2) return new double[] { 0.0D, 0.0D };
		
		double[] sin = new double[n];
		double[] cos = new double[n];
		
		if ((n % 2) == 0)
		{
			sin[0] = 0.0D;  cos[0] = 1.0D;
			
			if ((n == 1) || (n == 2))  return sin;
			
			sin[1] = sin(2*3.141592653589793D / n );
			
			for (int i = 2; i <= n / 4; i++)
			
			    sin[i] = sin(2*3.14159265358979D*i / n);
			
			for (int i = 0; i <= n/4; i++)  sin[1*n/4 + i] =  sin[1*n/4 - i];
			for (int i = 0; i <  n/2; i++)  sin[2*n/4 + i] = -sin[0*n/4 + i];
		}
		
		else
		{	for (int i = 0; i < n; i++)
			
			    sin[i] = sin(2*3.14159265358979D*i / n);
		}
		
		return sin;
	}
	
	
	
	public static Number[] sin_table(Number n)
	{
		//  returns a table of sines
		
		int m = n.intValue();
		
		if (m == 0) throw new IllegalArgumentException();
		
		if (n.equals(1)) return new Number[] { new Number(0) };
		if (n.equals(2)) return new Number[] { new Number(0), new Number(0) };
		
		Number[] sin = new Number[m];
		
		if ((m % 2) == 0)
		{
			sin[0] = new Number(0);
			
			if (m == 1)  return sin;
			
			int precision = n.getPrecision() == 0 ?
			
			    8 : n.getPrecision();
			
			sin[1] = Number.pi(precision)
			
			    .multiply(2).divide(n).sin();
			
			if (m == 2)  return sin;
			
			    for (int i = 2; i <= m / 4; i++)
			
				sin[i] = Number.pi(precision).multiply(2)
				
				    .divide(n).multiply(i).sin();
			
			for (int i = 0; i <= m / 4; i++)  sin[1*m/4 +i] = sin[1*m/4 -i];
			for (int i = 0; i <  m / 2; i++)  sin[2*m/4 +i] = sin[0*m/4 +i].negate();
		}
		
		else
		{	int precision = n.getPrecision() == 0 ?
			
			    8 : n.getPrecision();
			
			for (int i = 0; i < m; i++)
			
			    sin[i] = Number.pi(precision).multiply(2)
			
				.divide(n).multiply(i).sin();
		}
		
		return sin;
	}
	
	
	
	
	
	
	
	
	
	//  The Merge Sort algorithm
	//
	//  a linear log sorter O(n log n)
	
	
	//  The merge sort algorithm requires two arrays or
	//  twice the memory of other sorting algorithms
	
	
	//  Example  Sort the array { 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 }
	//           by merging and swapping the elements
	//
	//  | 3 | 1 | 4 | 1 | 5 | 9 | 2 | 6 | 5 | 3 | 5 | 8 | 9 | 7 | 9 | 3 |
	//  | 1,  3 | 1,  4 | 5,  9 | 2,  6 | 3,  5 | 5,  8 | 7,  9 | 3,  9 |
	//  | 1,  1,  3,  4 | 2,  5,  6,  9 | 3,  5,  5,  8 | 3,  7,  9,  9 |
	//  | 1,  1,  2,  3,  4,  5,  6,  9 | 3,  3,  5,  5,  7,  8,  9,  9 |
	//  | 1,  1,  2,  3,  3,  3,  4,  5,  5,  5,  6,  7,  8,  9,  9,  9 |
	//
	//
	//  Example  Sort a 16 million int array
	//
	//  int size = 4096*4096;
	//
	//  int[] array = new int[size];
	//
	//  for (int i = 0; i < array.length; i++) array[i] = i;
	//
	//  Math.unsort(array);
	//
	//  System.out.println("Start sorting");
	//
	//  Math.sort(array); // or Arrays.sort(array)
	//
	//  System.out.println("End sorting");
	
	
	//  This method can sort one million elements / sec on a 1 GHz processor.
	//
	//  This algorithm is about 2 1/2 times slower than the linear log
	//  sorter used in the Arrays.sort(int[]) method, but the method is
	//  guaranteed to run in linear log time for all data sets. The
	//  Arrays.parallelSort(int[]) method is also a few times faster.
	//
	//  For small arrays it is faster to use a quadratic sorter.
	
	
	
	public static void sort(int[] a)
	{
		//  If the array is small use the quadratic sorter
		
		if (a.length <= 64) { quadSort(a); return; }
		
		//  Copy and pad the array
		
		int[] x = new int[a.length];
		
		for (int i = 0; i < a.length; i++)  x[i] = a[i];
		
		//  Find the smallest element
		
		int s = 0;
		
		for (int int1 : a)
		
		    if (int1 < s)  s = int1;
		
		if ( (x.length & (x.length -1)) != 0 )
		{
			//  Pad the array to a power of two
			
			int length = x.length;
			
			int poweroftwo = 1;
			
			while (length != 0)
			
			    { length >>= 1; poweroftwo <<= 1; }
			
			int[] array = new int[poweroftwo];
			
			for (int i = 0; i < x.length; i++)
			
			    array[array.length -1 -i] = x[x.length -1 -i];
			
			x = array;
		}
		
		for (int i = 0; i < (x.length - a.length); i++) x[i] = s;
		
		
		//  Create a new array to hold the result
		
		int[] y = new int[x.length];
		
		int N = x.length / 2;
		
		//  Sort the array by merging and swapping
		
		for (int i = 1; i <= N; i <<= 1)
		{
			for (int j = 0; j < 2*N; j += 2*i)
			{
				for (int k = j, k1 = 0, k2 = 0; k < (j + 2*i); k++)
				{
					if ( (k1 < i) && (k2 < i) )
					{
						if (x[j+0 + k1] <= x[j+i + k2])
						
						      y[k] = x[j+0 + k1++];
						else  y[k] = x[j+i + k2++];
					}
					
					else
					{	if (k1 < i)
						
						      y[k] = x[j+0 + k1++];
						else  y[k] = x[j+i + k2++];
					}
				}
			}
			
			//  Copy the result back to the original array
			
			for (int k = 0; k < x.length; k++) x[k] = y[k];
		}
		
		//  Unpad the array
		
		for (int i = 0; i < a.length; i++)
		
		    a[i] = x[(x.length - a.length) + i];
	}
	
	
	
	public static int[][] sortAndCollate(int[] a)
	{
		//  returns the sorted array and the
		//  number of times each element occurs;
		//  duplicates of elements are removed
		
		//  For example, the array
		//
		//  { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4 }
		//
		//  is sorted and collated to
		//
		//  [ 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 9, 9 ]
		//
		//  { { 1, 2 }, { 2, 3 }, { 3, 4 }, { 4, 3 }, { 5, 3 }, { 6, 3 }, { 7, 1 }, { 8, 2 }, { 9, 3 } }
		
		
		if ((a == null) || (a.length == 0))
		
		    throw new IllegalArgumentException();
		
		a = Arrays.copyOf(a, a.length);
		
		Arrays.sort(a); // Sort the array
		
		return collate(a);
	}
	
	
	public static double sqrt(double n)
	{
		//  computes the sqrt of n
		
		return root(n, 2);
	}
	
	public static double square(double n)
	{
		//  computes the square of n
		
		return n * n;
	}
	
	
	public static int[] subtract(int[] minuend, int[] subtrahend)
	{
		//  subtracts two int arrays
		//
		//  This method is used by the number class
		
		//  Negate the subtrahend and then call the add method
		
		int[] twos_comp = twosComplement(subtrahend);
		
		return add(minuend, twos_comp);
	}
	
	
	public static double tan(double x)
	{
		//  returns the tangent of x
		
		return sin(x) / cos(x);
	}
	
	
	public static double tanh(double x)
	{
		//  returns the hyperbolic tangent of x
		
		return sinh(x) / cosh(x);
	}
	
	
	public static boolean testBit(int[] array, long bit)
	{
		//  tests if a bit is set
		
		//  (if the bit < 0 then the method counts from left to
		//  right so the number class can test fractional bits)
		
		if (Math.abs(bit) / 32 >= array.length) return false;
		
		if (bit >= 0) return (array[array.length -1 - (int) (bit / 32)]
		
		    & (1 << (bit % 32))) != 0;
		
		else return (array[(int)(bit/32)]
		
		    & (1 << (32 - (bit % 32)))) != 0;
	}
	
	
	public static int[] trim(int[] array)
	{
		//  removes leading zeros from an array
		
		if (array.length == 1) return new int[] { array[0] };
		
		//  Count the number of leading zeros
		
		int i = 0,  zeros = 0;
		
		while ((i < array.length -1) && (array[i] == 0))
		
		    { i++; zeros++; }
		
		int size = array.length - zeros;
		
		if (size == 0)  size = 1;
		
		int[] array1 = new int[size];
		
		for (i = 0; i < array1.length; i++)
		
		    array1[array1.length -1 -i] =
		    array [array .length -1 -i];
		
		return array1;
	}
	
	
	public int[] trim(int[] array1, int zeros)
	{
		//  removes leading zeros from an array
		
		if (zeros >= array1.length)
		{
			String message = "zeros >= array size";
			
			throw new IllegalArgumentException(message);
		}
		
		if (array1.length == 1)
		{
			int[] array2 = new int[1];
			
			array2[0] = array1[0];
			
			return array2;
		}
		
		int size = array1.length - zeros;
		
		int[] array2 = new int[size];
		
		for (int i = 0; i < array2.length; i++)
		
		    array2[array2.length -1 -i]
		  = array1[array1.length -1 -i];
		
		return array2;
	}
	
	
	public static int[] twosComplement(int array1[])
	{
		//  multiplies a signed array by -1 by
		//  complementing the bits and adding 1
		
		int[] array2 = new int[array1.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array2[i] = ~array1[i];
		
		return add(array2, new int[] { 1 });
	}
	
	
	
	public static int[] unsort(int elements)
	{
		return unsort(elements, random(elements));
	}
	
	public static int[] unsort(int elements, long rand)
	{
		//  returns an unsorted array of indexes or indices using a random key
		
		return permutate(elements, rand);
	}
	
	
	
	public static void unsort(int[] a)
	{
		//  unsorts an array of int
		
		int[] b = unsort(a.length);
		
		int[] a1 = new int[a.length];
		
		for (int i = 0; i < a.length; i++) a1[i] = a[b[i]];
		for (int i = 0; i < a.length; i++) a [i] = a1[i];
	}
	
	
	
	public static void unsort(ArrayList<String> list)
	{
		//  unsorts an array of string
		
		int[] intarray = unsort(list.size());
		
		ArrayList<String> list1;
		
		list1 = new ArrayList<String>(list.size());
		
		for (int i = 0; i < intarray.length; i++)
		
		    list1.add(list.get(intarray[i]));
		
		for (int i = 0; i < intarray.length; i++)
		
		    list.set(i, list1.get(i));
	}
	
	
	
	public static byte[] xor(byte[] array1, byte[] array2)
	{
		//  exclusively ors byte arrays
		
		//  byte arrays are left-aligned because they are
		//  used for cryptography instead of arithmetic
		
		int maxsize = max(array1.length, array2.length);
		
		byte[] array3 = new byte[maxsize];
		
		for (int i = 0; i < array1.length; i++)
		
		    array3[i] ^= array1[i];
		
		for (int i = 0; i < array2.length; i++)
		
		    array3[i] ^= array2[i];
		
		return array3;
	}
	
	
	public static int[] xor(int[] array1, int[] array2)
	{
		//  exclusively ors int arrays
		
		//  int arrays have to be right-aligned
		//  because they are used by the number class
		
		if ( array1.length > array2.length)
		
		    return xor(array1, expand(array2, array1.length));
		
		if (array2.length > array1.length)
		
		    return xor(expand(array1, array2.length), array2);
		
		if (array1.length != array2.length)
		
		    throw new IllegalArgumentException();
		
		int maxsize = max(array1.length, array2.length);
		
		int[] array3 = new int[maxsize];
		
		for (int i = 0; i < array1.length; i++)
		
		    array3[i] ^= array1[i];
		
		for (int i = 0; i < array2.length; i++)
		
		    array3[i] ^= array2[i];
		
		return array3;
	}
}


//  End class Math




















class Number implements Comparable<Number>
{


	//  The Number class provides methods or operations for fixed-point / integer
	//  and floating-point arithmetic similar to the BigInteger and BigDecimal
	//  classes except that the Number class can use any base.
	//
	//  The BigInteger and MutableBigInteger classes use one or two algorithms that
	//  are a few times faster such as the window algorithm from Colin Plumb's
	//  C library for computing modular exponentiations. For example, for 256-bit
	//  numbers, modular exponentiation is around five times faster, but multi-
	//  plication is just as fast in the Number class as in the BigInteger class.
	//  The modular inversion algorithm used by the BigInteger class may be 3/2
	//  to twice as fast as the method used by the Number class.
	
	
	
	
	//  Instance members
	
	
	//  A complex number has a real and imag component
	//
	//  complex = real + i imag
	//                                   __
	//  where the imaginary number i = \/-1
	
	
	//  Real members
	
	private int[] intarray;
	
	private int intpoint;
	
	private int precision;
	
	private char sign;
	
	
	//  Imag members
	
	private int[] intarray1;
	
	private int intpoint1;
	
	private int precision1;
	
	private char sign1;
	
	
	//  the intpoint is the integer / fraction point
	//  where the digit size is an int or 32 bits;
	//
	//  if the digit modulus were 2 instead of 2^32, then the
	//  integer / fraction point would also be called a binary
	//  point; for a digit size or modulus 16, it would be
	//  called a hexadecimal point; and for a digit modulus 10,
	//  the integer / fraction point would be called a decimal
	//  point. The toString(digits, radix) method can convert a
	//  number and the integer point to binary, decimal, hexa-
	//  decimal, or any base from 2 to 16.
	
	
	
	//  Number constructors
	
	
	public Number(byte[] array)
	{
		this.intarray = Convert.
		
		    byteArrayToIntArray(array);
		
		this.intpoint  = 0;
		this.precision = 0;
		this.sign = '+';
	}
	
	
	public Number(char sign, byte[] array)
	{
		this.intarray = Convert.
		
		    byteArrayToIntArray(array);
		
		this.intpoint  = 0;
		this.precision = 0;
		this.sign = sign;
	}
	
	
	
	public Number(double d)
	{
		Number number = doubleToNumber(d);
		
		this.intarray  = number.intarray;
		this.intpoint  = number.intpoint;
		this.precision = number.precision;
		this.sign      = number.sign;
	}
	
	
	
	public Number(int val)
	{
		if (val < 0)
		{
			//  two's complement
			
			val = ~ val + 1;
			
			this.sign = '-';
		}
		
		else this.sign = '+';
		
		this.intarray = new int[1];
		
		this.intarray[0] = val;
		
		this.intpoint  = 0;
		this.precision = 0;
	}
	
	
	
	public Number(long val)
	{
		if (val < 0)
		{
			//  two's complement
			
			val = ~ val + 1;
			
			this.sign = '-';
		}
		
		else this.sign = '+';
		
		this.intarray = new int[2];
		
		this.intarray[0] = (int) (val >>> 32);
		this.intarray[1] = (int) (val >>>  0);
		
		this.intpoint  = 0;
		this.precision = 0;
	}
	
	
	
	public Number(Number val)
	{
		//  This is the copy constructor
		
		int[] array1 = new int[val.intarray.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = val.intarray[i];
		
		this.intarray = array1;
		
		this.intpoint  = val.intpoint;
		this.precision = val.precision;
		this.sign      = val.sign;
		
		if (val.intarray1 != null)
		{
			array1 = new int[val.intarray1.length];
			
			for (int i = 0; i < array1.length; i++)
			
			    array1[i] = val.intarray1[i];
			
			this.intarray1  = array1;
			this.intpoint1  = val.intpoint1;
			this.precision1 = val.precision1;
			this.sign1      = val.sign1;
		}
	}
	
	
	
	public Number(String digits)
	{
		//  radix == 10
		
		Number number;
		
		number = stringToNumber(digits, 10);
		
		this.intarray  = number.intarray;
		this.intpoint  = number.intpoint;
		this.precision = number.precision;
		this.sign      = number.sign;
	}
	
	
	
	public Number(String digits, int radix)
	{
		if (!isNumberString(digits, radix))
		
		    throw new IllegalArgumentException();
		
		Number number = stringToNumber(digits, radix);
		
		this.intarray  = number.intarray;
		this.intpoint  = number.intpoint;
		this.precision = number.precision;
		this.sign      = number.sign;
	}
	
	
	
	public Number(int[] array) // radix 2^32
	{
		int[] array1 = new int[array.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = array[i];
		
		this.intarray = array1;
		this.intpoint  = 0;
		this.precision = 0;
		this.sign = '+';
	}
	
	
	
	public Number(int[] array, boolean signed)
	{
		int array_length = array.length;
		
		if (array_length == 0) array_length++;
		
		int[] array1;
		
		if (!signed)
		{
			array1 = new int[array.length]; array1[0] = 0;
			
			for (int i = 0; i < array.length; i++)
			
			    array1[i] = array[i];
			
			this.intarray = array1;
			this.intpoint  = 0;
			this.precision = 0;
			this.sign = '+';
		}
		
		else // if (signed) // two's complement
		{
			//  Complement the bits and add 1
			
			if ((array.length != 0) && (array[0] < 0))
			{
				array1 = Math.twosComplement(array);
				
				this.sign = '-';
			}
			
			else
			{	array1 = new int[array_length];
				
				if (array.length != 0)
				
				    for (int i = 0; i < array_length; i++)
				
					array1[i] = array[i];
				
				this.sign = '+';
			}
			
			this.intarray = array1;
			this.intpoint  = 0;
			this.precision = 0;
		}
	}
	
	
	public Number(Number[] array, Number radix)
	{
		//  Converts an array of coefficients in base radix to a Number
		
		//  a[k-1] r^(k-1) + ... + a[2] r^2 + a[1] r^1 + a[0] r^0
		
		Number n = new Number(0);
		
		Number r = new Number(1);
		
		for (int i = array.length -1; i >= 0; i--)
		{
			n = n .add( array[i].multiply(r) );
			
			r = r.multiply(radix);
		}
		
		int[] array1 = n.intarray;
		
		this.intarray = array1;
		this.intpoint  = 0;
		this.precision = 0;
		this.sign = '+';
	}
	
	
	
	
	
	//  Complex constructors
	
	
	public Number(int real, int imag)
	{
		if (real < 0)
		{
			real = ~ real + 1;
			
			this.sign = '-';
		}
		
		else this.sign = '+';
		
		this.intarray = new int[1];
		
		this.intarray[0] = real;
		this.intpoint  = 0;
		this.precision = 0;
		
		
		if (imag < 0)
		{
			imag = ~ imag + 1;
			
			this.sign1 = '-';
		}
		
		else this.sign1 = '+';
		
		this.intarray1 = new int[1];
		
		this.intarray1[0] = imag;
		
		this.intpoint1  = 0;
		this.precision1 = 0;
	}
	
	
	
	public Number(double real, double imag)
	{
		Number nreal = doubleToNumber(real);
		Number nimag = doubleToNumber(imag);
		
		this.intarray = nreal.intarray;
		
		this.intpoint  = nreal.intpoint;
		this.precision = nreal.precision;
		this.sign      = nreal.sign;
		
		this.intarray1  = nimag.intarray;
		this.intpoint1  = nimag.intpoint;
		this.precision1 = nimag.precision;
		this.sign1      = nimag.sign;
	}
	
	
	
	public Number(Number real, Number imag)
	{
		//  This is the complex constructor
		
		if (real.isComplex() || imag.isComplex())
		
		    throw new IllegalArgumentException();
		
		
		//  real component
		
		int[] array1;
		
		array1 = new int[real.intarray.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = real.intarray[i];
		
		this.intarray = array1;
		
		this.intpoint  = real.intpoint;
		this.precision = real.precision;
		this.sign      = real.sign;
		
		
		//  imag component
		
		array1 = new int[imag.intarray.length];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = imag.intarray[i];
		
		this.intarray1 = array1;
		
		this.intpoint1  = imag.intpoint;
		this.precision1 = imag.precision;
		this.sign1      = imag.sign;
	}
	
	
	
	
	//  Static factory methods called by the constructors
	//
	//  These static methods are required to avoid calling a
	//  Number constructor from within a Number constructor,
	//  because calling a constructor from within a constructor
	//  creates a local variable that is deleted when the thread
	//  exits the constructor and the variable goes out of scope.
	
	
	private static Number doubleToNumber(double d)
	{
		String str = Double.toString(d);
		
		int index = -1, exp = 0;
		
		for (int i = 0; i < str.length(); i++)
		
		    if (Character.isLetter(str.charAt(i)))
		
			{ index = i;  break; }
		
		if (index != -1) exp = Integer
		
		    .parseInt(str.substring(index +1));
		
		String significand = ( (index != -1) ?
		
		    str.substring(0, index) : str );
		
		if (significand.contains("."))
		
		    while (significand.length() < 15)
		
			significand += "00";
		
		Number number = stringToNumber(significand, 10);
		
		number = number.multiply( stringToNumber("10", 10)
		
		    .setPrecision(number.precision) .pow(exp) );
		
		return number;
	}
	
	
	
	private static Number stringToNumber(String digits, int radix)
	{
		char sign = '+';
		
		Number number = new Number(0);
		
		String str = digits.toLowerCase() .replaceAll(" ", "") .trim();
		
		
		if (str.isEmpty())
		{
			String message = "empty constructor string";
			
			throw new IllegalArgumentException(message);
		}
		
		if (str.charAt(0) == '-')
		{
			str = str.substring(1, str.length()).trim();
			
			sign = '-';
		}
		
		else if (str.charAt(0) == '+')
		{
			str = str.substring(1, str.length()).trim();
			
			sign = '+';
		}
		
		else sign = '+';
		
		
		if (!isNumberString(str, radix))
		{
			String message =
			
			    "number constructor string " + str +
			
			    " is not a number string in radix " + radix;
			
			throw new IllegalArgumentException(message);
		}
		
		if (str.endsWith("."))
		
		    str = str .substring(0, str.length() -1).trim();
		
		
		int exp = 0;
		
		if (str.contains("."))
		{
			exp = str.length() - str.indexOf(".") -1;
			
			str = str.replace(".", "").trim();
		}
		
		int precision = exp;
		
		
		if (radix == 16)
		{
			//  Convert from string to 4-bit hex chars (log 16)
			//  Convert from 4-bit chars (log 16) to 8-bit chars (log 256)
			//  Convert from 8-bit chars to 32-bit (log 2^32 == 32)
			
			number.intarray =
			
			   Convert.byteArrayToIntArray(
			
			      Convert.byte16ArrayToByte256Array(
			
			         Convert.charArrayToByteArray(
			
			            str.toCharArray())));
			
			number = number.setPrecision(precision);
			
			//  Set the integer / fraction point
			
			if (exp > 0) // divide by 16 ^ exp (w/o using a divider)
			{
				int div = exp / 8, mod = exp % 8;
				
				number .intpoint += div;
				
				if (mod != 0)
				{
					number = number .shiftLeft(32, 32);
					
					number .intpoint += 1;
					
					number = number .shiftRight(4*mod);
				}
			}
		}
		
		
		else // if (radix != 16)
		{
			//  Compute the integer value
			
			number = stringToNumber1(str, radix);
			
			//  Compute the integer point
			
			number = number.setPrecision(precision);
			
			number = number.divide( new Number(radix).pow(exp) );
		}
		
		number.sign = sign;
		
		return number.trim();
	}
	
	
	
	
	private static Number stringToNumber1(String str, int radix)
	{
	
		//  This method bifurcates an n-digit integer string into two d and
		//  (n - d) length strings where d = (approx) n / 2, computes the
		//  left and right numbers separately, and then computes the number
		//  n = (left x radix ^ d) + right. This reduces the time complexity
		//  from quadratic to linear log or O(n^2) to O(n log(n)).
		
		
		int maxsize = 256;
		
		str = str.trim();
		
		
		//  Test before recursion
		
		if (str.length() < maxsize)
		{
			//  Convert a small string to a number
			
			Number number = new Number(0);
			
			for (int i = 0; i < str.length(); i++)
			{
				int c = str.charAt(str.length() -1 -i);
				
				int digit = 0;
				
				if ((c >= '0') && (c <= '9'))
				
				     digit = c - '0';
				
				else if ((c >= 'a') && (c <= 'z'))
				
				    digit = c + 10 - 'a';
				
				else throw new IllegalArgumentException();
				
				number = number .add( new Number(
				
				    radix) .pow(i) .multiply(digit) );
			}
			
			return number;
		}
		
		//  else if (str.length() >= maxsize)
		
		//  Convert a large string to number
		
		int d = str.length() / 2;
		
		String lstr = str.substring(
		
		    0, str.length() - d);
		
		String rstr = str.substring(
		
		    str.length() - d, str.length());
		
		
		//  Start recursion to compute
		//
		//  n = (left x radix ^ d) + right
		
		return stringToNumber1(lstr, radix)
		
		    .multiply( new Number(radix) .pow(d) )
		
			.add( stringToNumber1(rstr, radix) );
	}
	
	
	
	
	
	
	
	
	//  Public Number methods
	
	
	
	
	public Number abs()
	{
		//  returns the absolute value
		
		if (this.isComplex()) throw
		
		   new IllegalArgumentException();
		
		Number number = new Number(this);
		
		if (number.sign == '-')
		
		    number.sign = '+';
		
		return number;
	}
	
	
	public Number add(long addend)
	{
		return this.add(new Number(addend));
	}
	
	public Number add(double addend)
	{
		return this.add(new Number(addend));
	}
	
	public Number add(Number addend)
	{
		//  adds two numbers
		
		if (this.isComplex() || addend.isComplex())
		{
			//  use complex addition
			
			Number real1 = this.toReal();
			Number imag1 = this.toImag();
			
			Number real2 = addend.toReal();
			Number imag2 = addend.toImag();
			
			return new Number(real1.add(real2),
			                  imag1.add(imag2));
		}
		
		Number a = new Number(this).trim();
		Number b = new Number(addend).trim();
		
		int precision = Math.max(a.precision, b.precision);
		
		a = a.setPrecision(precision);
		b = b.setPrecision(precision);
		
		if (!this.isInteger() || !addend.isInteger())
		{
			//  Align the integer / fraction points
			
			int r = a.intpoint - b.intpoint;
			
			if      (r > 0) { b = b.shiftLeft( 32*r,  32*r); b.intpoint += r; }
			else if (r < 0) { a = a.shiftLeft(-32*r, -32*r); a.intpoint -= r; }
		}
		
		//  Expand the arrays by one int for the sign
		
		a = a .shiftLeft(32, 0);
		b = b .shiftLeft(32, 0);
		
		int[] c_signed;  int c_length;
		
		//  Set the size of the c array equal to the larger array
		
		c_length = Math.max(a.intarray.length, b.intarray.length);
		
		//  If a number sign is negative take the twos complement of the array
		
		if (a.sign == '-') a.intarray = Math.twosComplement(a.intarray);
		if (b.sign == '-') b.intarray = Math.twosComplement(b.intarray);
		
		int[] a_signed = a.intarray;
		int[] b_signed = b.intarray;
		
		//  Expand the a and b arrays to the size of the c array
		
		if (a.intarray.length < c_length) a_signed = Math.expand(a_signed, c_length);
		if (b.intarray.length < c_length) b_signed = Math.expand(b_signed, c_length);
		
		//  Add the two arrays
		
		c_signed = Math.add(a_signed, b_signed);
		
		//  Assign the array to a new number
		//  and set the intpoint and precision
		
		Number c = new Number(c_signed, true);
		
		c.intpoint = a.intpoint;
		c.precision = precision;
		
		return c.trim();
	}
	
	
	public static Number add(Number[] array)
	{
		//  returns the sum of array[]
		
		Number sum = new Number(0);
		
		for (int i = 0; i < array.length; i++)
		
		    sum = sum.add(array[i]);
		
		return sum;
	}
	
	
	public static Number[] add(Number[] array1, Number[] array2)
	{
		//  returns the sum of two number arrays
		
		if (array1.length != array2.length)
		
		    throw new IllegalArgumentException();
		
		Number[] array3 = new Number[array1.length];
		
		for (int i = 0; i < array3.length; i++)
		
		    array3[i] = array1[i].add(array2[i]);
		
		return array3;
	}
	
	
	public static Number[] add(Number[] array, Number n)
	{
		//  adds a number n to an array
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].add(n);
		
		return array1;
	}
	
	
	public Number and(Number val)
	{
		//  ands two numbers
		
		return new Number(Math.and(
		
		    this.intarray, val.intarray));
	}
	
	
	public Number arcCos()
	{
		//  computes the inverse cosine from
		//
		//     -1       -1
		//  cos  x + sin  x == pi/2  or
		//
		//  arc cos x + arc sin x == pi/2  or
		//
		//  arc cos x == pi/2 - arc sin x
		
		int p = this.precision;
		
		return Number .pi(p) .divide(2)
		
		    .subtract(this.arcSin());
	}
	
	
	public Number arcCosh()
	{
	
		//  computes the inverse hyperbolic cosine
		
		//  ...
		
		//  ...
		
		return null;
	}
	
	
	
	public Number arcSin()
	{
	
		//  computes the inverse sine
		
		//  The series for the inverse sine of x is
		//
		//                              2 n + 1
		//                    (2 n)!  x
		//  arc sin(x)  ==  ___________________
		//                   2 n   2
		//                  2    n!   (2 n + 1)
		
		
		//  If sin(x) is very close to 1, the arc sine series will
		//  converge very slowly to x == pi / 2;
		//
		//  on some calculators, entering "asin 0.9999999999999999..."
		//  causes *** ERROR OCCURRED IN MP_ATAN, RESULT INCORRECT ***
		
		
		if (this.abs().isGreaterThan(1))
		{
			String message = "arc sin is only defined for -1 < x < 1";
			
			throw new IllegalArgumentException(message);
		}
		
		int p = Math.max(this.precision, 8);
		
		Number sin = new Number(this) .setPrecision(p);
		
		Number arcsin = new Number(0);
		
		Number c = new Number(1) .setPrecision(p);
		
		Number x2n1 = sin .setPrecision(p);
		
		for (int n = 1; n < 8*p; n++)
		{
			arcsin = arcsin .add(c.multiply(x2n1));
			
			c = c .multiply(2*n -1) .divide(2*n +0)
			      .multiply(2*n -1) .divide(2*n +1);
			
			x2n1 = x2n1 .multiply(sin.square());
		}
		
		return arcsin;
	}
	
	
	
	public Number arcSinh()
	{
		//  ...
		
		//  ...
		
		return null;
	}
	
	
	
	public Number arcTan()
	{
	
		//  computes the inverse tangent
		
		//  The series for the inverse tangent of x is
		//
		//                       n   2 n + 1
		//                   (-1)  x
		//    arctan(x)  ==  _______________
		//
		//                       2 n + 1
		
		int p = Math.max(this.precision, 8);
		
		Number x = new Number(this) .setPrecision(p);
		
		Number arctan = new Number(0);
		
		Number x2n1 = new Number(x) .setPrecision(p);
		
		for (int n = 0; n < 16*p; n++)
		{
			Number   numerator = new Number(x2n1);
			Number denominator = new Number(2*n+1);
			
			Number quotient = numerator .divide(denominator);
			
			arctan = arctan .add(quotient);
			
			x2n1 = x2n1 .multiply(x.square());
		}
		
		return arctan;
	}
	
	
	public Number arcTanh()
	{
		//  ...
		
		//  ...
		
		return null;
	}
	
	
	public long bitCount()
	{
		//  returns the number of bits
		
		return Math.bitCount(this.intarray);
	}
	
	
	public byte byteValue()
	{
		//  returns the byte value of a number
		
		return byteValue(true);
	}
	
	
	private byte byteValue(boolean round)
	{
		Number n = new Number(this);
		
		if (n.intpoint != 0) n = n.toInteger(round);
		
		int intval = n.intarray[n.intarray.length -1];
		
		if (n.sign == '-') intval = ~ intval + 1;
		
		return (byte) intval;
	}
	
	
	public void clearBit(long bit)
	{
		//  clears a bit of the number array
		
		Math.clearBit((this.intarray), bit);
	}
	
	
	public int compareTo(double val)
	{
		return this.compareTo(new Number(val));
	}
	
	public int compareTo(long val)
	{
		return this.compareTo(new Number(val));
	}
	
	public int compareTo(Number val)
	{
		//  compares two numbers and returns 1, 0, -1
		
		Number a = new Number(this) .roundBit();
		Number b = new Number(val)  .roundBit();
		
		int[] array1 = a.intarray;
		int[] array2 = b.intarray;
		
		boolean iszero1 = true;
		boolean iszero2 = true;
		
		for (int i = 0; i < array1.length; i++)
		
		    if (array1[i] != 0) { iszero1 = false; break; }
		
		for (int i = 0; i < array2.length; i++)
		
		    if (array2[i] != 0) { iszero2 = false; break; }
		
		//  zero can be positive or negative
		
		if (iszero1) { a.sign = '+'; };
		if (iszero2) { b.sign = '+'; };
		
		
		//  If signs are both '-' swap the numbers and negate
		
		if ((a.sign == '-') && (b.sign == '-'))
		{
			Number temp = new Number(a);
			
			a = b.abs();  b = temp.abs();
		}
		
		
		//  integer comparison
		
		if ((a.precision == 0) && (b.precision == 0))
		{
			//  both values are integers
			
			//  First test for equality
			
			if (iszero1 && iszero2) return 0;
			
			if (a.sign != b.sign)
			{
				//  If signs are opposite and the numbers are integers, return 1 or -1
				//  (This test only works if the numbers have already been tested
				//  for equality because in math zero can be positive or negative)
				
				if      ((a.sign != '-') && (b.sign == '-'))  return  1;
				else if ((a.sign == '-') && (b.sign != '-'))  return -1;
			}
			
			array1 = Math.trim(a.intarray);
			array2 = Math.trim(b.intarray);
			
			if (array1.length > array2.length) return  1;
			if (array1.length < array2.length) return -1;
			
			for (int i = 0; i < array1.length; i++)
			{
				if (array1[i] == array2[i]) continue;
				
				long d = (array1[i] & 0xffffffffL)
				       - (array2[i] & 0xffffffffL);
				
				return  d > 0 ? 1 : -1;
			}
			
			return 0;
		}
		
		
		//  floating point comparison
		
		//  Note that two numbers can be represented differently but should
		//  compare equally even if there are rounding errors from different
		//  operations. For example, 1.0000000000000000 and 0.9999999999999999
		//  should compare equally. In two intarrays the same number could be
		//  written as [12345678, 0, 0] or [12345677, -1, -1] because of the
		//  rounding error. (Since the round method calls the divide method
		//  which calls the compareTo method, the compareTo method cannot call
		//  the round method because it would create an endless loop of function
		//  calls or method invocations causing the stack to overflow and the
		//  thread to terminate.)
		
		
		//  Use the smaller of the two precisions
		//
		//  except if one of the two precisions is precisely zero
		
		int p = Math.min(a.precision, b.precision);
		
		if (a.precision == 0) p = b.precision;
		if (b.precision == 0) p = a.precision;
		
		if      (p >= 4) p -= 2;
		else if (p >= 2) p -= 1;
		
		
		//  Set the new precision
		
		a = a.setPrecision(p);
		b = b.setPrecision(p);
		
		
		
		//  Convert the numbers to integers and fractions
		//  and compare the integers and fractions
		
		Number a_int = a.toInteger(true);
		Number b_int = b.toInteger(true);
		
		Number a_frac = a.toFraction(true);
		Number b_frac = b.toFraction(true);
		
		if ( Arrays.equals(a_int .intarray, b_int .intarray)
		 &&  Arrays.equals(a_frac.intarray, b_frac.intarray) )
		
		    return 0;
		
		
		
		//  Subtract the two numbers
		
		Number c = a.subtract(b);
		
		Number integer  = c.toInteger();
		Number fraction = c.toFraction();
		
		fraction = fraction .multiply(new
		
		    Number(16).pow(p)) .setPrecision(0);
		
		
		int[] array = c.intarray;
		
		int d = c.intpoint - array.length;
		
		//  if the intpoint is >, ==, or < the array length
		//           then d is >, ==, or < 0
		
		if (d < 0)
		{
			//  Read the digits to the left of the intpoint
			
			boolean iszero = true;
			
			for (int i = 0; i < array.length + d; i++)
			
			    if (array[i] != 0) iszero = false;
			
			if (!iszero) return  c.sign == '-' ? -1 : 1;
		}
		
		boolean iszero = true;
		
		for (int i = 0; (i < p - 8*d) && (i < array.length); i++)
		
		    if (array[i] != 0) { iszero = false;  break; }
		
		if (iszero) return 0;
		
		//  Test for greater or less than zero
		
		return  c.sign == '-' ? -1 : 1;
	}
	
	
	
	public Number complement()
	{
		//  returns the complement of a number x
		
		//  This is similar to the bitwise complement operator ~
		//  which is used by the not method, except that this method
		//  complements the number instead of the bits. A number can
		//  also be complemented by negating and adding 1.
		
		return new Number(1) .subtract(this);
	}
	
	
	private Number complexInverse()
	{
		//  computes the inverse of a complex number a + i b
		//
		//          1     (a - i b)       a - i b
		//   ==  _______  _________  ==  _________
		// 
		//       a + i b  (a - i b)      a^2 + b^2
		
		Number d = this.toReal().square()
		      .add(this.toImag().square());
		
		Number real = this.toReal()           .divide(d);
		Number imag = this.toImag() .negate() .divide(d);
		
		return new Number(real, imag);
	}
	
	
	private Number complexInverse(Number n)
	{
		//  computes the inverse of a complex number mod n
		
		Number d = this.toReal().square()
		      .add(this.toImag().square()) .mod(n);
		
		Number real = this.toReal() .modDivide(d, n);
		Number imag = this.toImag() .modDivide(d, n) .negate(n);
		
		return new Number(real, imag);
	}
	
	
	public Number complexConjugate()
	{
		//  returns the complex conjugate of a number
		
		//  Negate the imaginary component
		
		if (this.intarray1 == null) return this;
		
		this.sign1 = (this.sign1 == '-') ? '+' : '-';
		
		return this;
	}
	
	
	public Number cos()
	{
		//  returns the cosine of an angle in radians
		
		Number cos = cos_sin()[0];
		
		return cos .setPrecision(
		
		    Math.max(this.precision, 8));
	}
	
	
	
	
	private Number[] cos_sin()
	{
	
		//  returns a cosine and sine pair
		
		//  The series for cosine and sine are
		//
		//                n  2 n + 0
		//  cos(x) == (-1)  x    /  (2 n + 0)!
		//
		//                n  2 n + 1
		//  sin(x) == (-1)  x    /  (2 n + 1)!
		
		
		//  The sine and cosine for the angles [ 0, 30, 45, 60, 90 ]
		//  can be remembered from the mnemonic
		//  ____________________________________________
		//
		//           0       30      45      60      90
		//           _       _       _       _       _
		//   sin   \/0/2   \/1/2   \/2/2   \/3/2   \/4/2
		//           _       _       _       _       _
		//   cos   \/4/2   \/3/2   \/2/2   \/1/2   \/0/2
		//   ___________________________________________
		
		
		final int bits = 16;
		
		int p = (this.precision > 8) ?
		
		    this.precision + bits : 8 + bits;
		
		
		//  Reduce x modulo 2 pi
		
		Number pi = Number.pi(p);
		
		Number x = this .mod(pi.multiply(2));
		
		//  Compute the cosine and sine of x
		
		Number cosx = new Number(0);
		Number sinx = new Number(0);
		
		Number inv1 = new Number(1) .setPrecision(p);
		Number inv2 = new Number(1) .setPrecision(p);
		
		for (int n = 0; n < this.precision; n++)
		{
			if (n > 0)
			{
				inv1 = inv1 .divide(2*n - 0) .divide(2*n - 1);
				inv2 = inv2 .divide(2*n + 1) .divide(2*n + 0);
			}
			
			cosx = cosx.add(x.pow(2*n + 0) .multiply(inv1) .multiply((n % 2) == 0 ? 1:-1));
			sinx = sinx.add(x.pow(2*n + 1) .multiply(inv2) .multiply((n % 2) == 0 ? 1:-1));
		}
		
		cosx = cosx.setPrecision(p);
		
		return new Number[] { cosx, sinx };
	}
	
	
	
	public Number cosh()
	{
		//  returns the hyperbolic cosine
		//
		//  cosh(u)  =  1/2 ( e^u + e^-u )
		//
		//  The hyperbolic cosine is related to the cosine by
		//
		//  cos(u) == cosh(i u)  and  cosh(u) == cos(i u)
		//
		//  where i is the imaginary unit = sqrt(-1)
		
		int p = (this.precision > 0) ? this.precision : 16;
		
		return  e(p).pow(this) .subtract(e(p).pow(this.negate())) .divide(2);
	}
	
	
	public int countOneBits()
	{
		//  counts the number of 1-bits
		
		return Math.countOneBits(this.intarray);
	}
	
	public int countSignificantDigits(int base)
	{
		if (this.precision == 0) return 0;
		
		String str = this.toString(base);
		
		if (!str.contains(".")) return 0;
		
		String substr = str.substring(str.indexOf(".") + 1);
		
		int len = substr.length(), zeros = 0;
		
		for (int i = 0; i < len; i++) if (substr
		
		    .charAt(len -1 - i) == '0') zeros++;
		
		int digits = len - zeros;
		
		return digits;
	}
	
	public long countTwos()
	{
		//  counts the number of 2's
		
		return getLowestSetBit();
	}
	
	public Number cube()
	{
		//  returns the cube of a number
		
		return this.multiply(this).multiply(this);
	}
	
	public Number divide(int divisor)
	{
		return this.divide(new Number(divisor));
	}
	
	public Number divide(long divisor)
	{
		return this.divide(new Number(divisor));
	}
	
	public Number divide(double divisor)
	{
		return this.divide(new Number(divisor));
	}
	
	
	public Number divide(Number divisor)
	{
	
		//  divides two numbers and returns the quotient
		
		//  The divide method determines which divider to call based on the
		//  absolute and relative sizes of the dividend and divisor.
		//
		//  If the numbers are both integers, then the quotient will be an integer.
		//  If the dividend or the divisor is a real number, then the quotient will
		//  be a real number.
		//
		//  Fast division is done by inversion and multiplication using Newton's
		//  iteration (short division). Slow division is done by partial quotients
		//  using a quadratic divider (long division).
		//
		//  For computing the value of pi >= 1024 digits, the inverter is several
		//  times faster than the quadratic divider, but for computing public keys,
		//  the quadratic divider is a few times faster than the inverter.
		
		
		if (divisor.equals(0))
		{
			if (this.equals(0)) //  0 / 0 == 1
			
			    return new Number(1);
			
			String error = "divide by zero";
			
			throw new IllegalArgumentException(error);
		}
		
		if (this.equals(0) || divisor.equals(1))
		
		    return new Number(this);
		
		
		if (divisor.isComplex())
		{
		
			//  Compute the inverse of a complex number a + i b
			
			//  1 / (a + i b) [(a - i b) / (a - i b)] == (a - i b) / (a^2 + b^2)
			
			Number a = divisor.toReal(), b = divisor.toImag();
			
			Number real = a .divide( a.square() .add(b.square()) );
			Number imag = b .divide( a.square() .add(b.square()) );
			
			Number inverse = new Number(real, imag.negate());
			
			//  If the precision is too small the inverse will not be correct
			
			if (!divisor.multiply(inverse).round().equals(1))
			{
				String message = "complex division error";
				
				System.out.println("divisor == " + divisor);
				System.out.println("inverse == " + inverse);
				System.out.println("d x inv == " + divisor.multiply(inverse));
				
				throw new ArithmeticException(message);
			}
			
			Number quotient = this .multiply(inverse);
			
			//  Verify the complex inverse
			
			if (!quotient.multiply(divisor).round() .equals(this))
			{
				String message = "complex division error";
				
				System.out.println("dividend == " + this);
				System.out.println("quotient == " + quotient);
				System.out.println("q x div  == " + quotient.multiply(divisor));
				
				throw new ArithmeticException(message);
			}
			
			return quotient .trim();
		}
		
		
		if (this.isComplex())
		{
			Number real = this.toReal() .divide(divisor);
			Number imag = this.toImag() .divide(divisor);
			
			return new Number(real, imag);
		}
		
		
		
		Number a = new Number(this)    .abs() .trim();
		Number b = new Number(divisor) .abs() .trim();
		
		
		char sign = (this.sign != divisor.sign) ? '-' : '+';
		
		int precision = Math.max(a.precision, b.precision);
		
		
		
		
		//  Integer division
		
		
		if (a.isInteger() && b.isInteger())
		{
		
			Number q;
			
			int a_bits = (int) a.bitCount();
			int b_bits = (int) b.bitCount();
			
			
			//  Choose a divider
			
			
			String method = "";
			
			
			//  Three special cases for division
			//  
			//  size a < size b,  size a ~ size b,  size a >> size b
			
			
			if (a_bits < b_bits)
			{
				q = new Number(0);
				
				if (a.sign == '-') q = q .negate();
				
				method = "";
			}
			
			else if (a_bits - b_bits < 4)
			{
				//  Subtract the divisor from the dividend
				//  or add the divisor to the dividend
				
				//  This code makes the gcd method a few times faster be-
				//  cause the dividend and divisor are approx the same size
				
				q = new Number(0);
				
				Number temp = a .abs();
				
				while (!temp .isLessThan(b))
				{
					temp = temp .subtract(b);
					
					q = q .add(1);
				}
				
				if (a.sign == '-') q = q .negate();
				
				method = "subtraction";
			}
			
			else if ((a.length() > 1) && (b.length() == 1) && (b.intarray[0] > 0))
			{
				q = a.divideByInt(b.intValue());
				
				method = "divide by int";
			}
			
			else if ( ((a_bits < 4*1024) && (b_bits < 4*1024))
			
			       || (((1.0*a_bits) / (1.0*b_bits)) < 1.1)
			
			       || ((a_bits - b_bits) < 4*1024) )
			{
				//  quadratic division (long division)
				
				q = a.quadDivide(b);
				
				method = "quadratic divider";
			}
			
			else
			{	//  Newton's iteration for inversion (short division)
				
				int digits = a_bits > b_bits ? a_bits / 4 : b_bits / 4;
				
				//  Set the precision slightly larger than the number of digits or
				//  else the integer division test will throw an arithmetic exception
				
				Number inv_b = b .setPrecision(16 + digits*6/5) .inverse();
				
				//  Compute the unsigned quotient
				
				q = a .abs() .multiply(inv_b) .toInteger();
				
				Number remainder = a .subtract(q.multiply(b));
				
				//  Correct for a one-off error
				
				if (remainder.compareTo(b) >= 0) q = q .add(1);
				
				//  Replace the sign
				
				method = "Newton's iteration / inversion";
			}
			
			
			//  Replace the sign
			
			if (sign == '-') q = q .negate();
			
			
			
			//  Verify that the integer quotient is correct
			
			if (q.equals(0) && this.abs().isGreaterThan(divisor.abs()))
			{
				System.out.println("method == " + method);
				
				System.out.println("this    == " + this   .toString(16));
				System.out.println("divisor == " + divisor.toString(16));
				
				System.out.println("a == " + a.toString(16));
				System.out.println("b == " + b.toString(16));
				
				System.out.println("a b bits == "
				
				    + a.bitCount() + " " + b.bitCount());
				
				System.out.println(b.intarray[0] + " " + b.intarray[1]);
				
				System.out.println("b intpoint == " + b.intpoint);
				
				throw new ArithmeticException();
			}
			
			
			//  Compute the remainder of this - quotient x divisor
			
			Number qxv = q .multiply(divisor);
			
			Number remainder = this.subtract(qxv);
			
			
			//  Compare the magnitudes and signs of the remainder and divisor
			
			//  The remainder (or dividend - quotient * divisor) should not
			//  be greater than the divisor
			
			if ( ( remainder.abs() .compareTo(divisor.abs()) >= 0 ) ||
			
			     ( (this.sign != '-') && (remainder.sign == '-') ) ||
			     ( (this.sign == '-') && (remainder.sign != '-') && !remainder.equals(0) ) )
			{
				System.out.println("division method == " + method);
				System.out.println("dividend == " +    this.toString(16));
				System.out.println("quotient == " +       q.toString(16));
				System.out.println("divisor  == " + divisor.toString(16));
				System.out.println("this - q x v == " + remainder.toString(16));
				
				String message = "\ninteger division error";
				
				System.out.println(message + "\n");
				
				throw new ArithmeticException(message);
			}
			
			return  q.trim();
		}
		
		
		
		//  Floating point division
		
		
		a = a.trim();  b = b.trim();
		
		int a_length, b_length;
		
		a_length = a.intarray.length;
		b_length = b.intarray.length;
		
		
		//  Set a and b equal to the same precision
		
		a = a .setPrecision(precision);
		b = b .setPrecision(precision);
		
		//  Calculate the difference between the two intpoints
		
		int a_b_intpoint = a.intpoint - b.intpoint;
		
		
		//  The dividend has to be left shifted so that the size of the
		//  quotient (== dividend length - divisor length) is greater than
		//  the precision of the dividend or divisor (whichever is greater).
		//
		//  If the dividend length >= the divisor length, the dividend has to
		//  be left shifted by 4 bits x the precision (which should be rounded
		//  to a multiple of 32). The intpoint of the quotient is then set equal
		//  to the number of ints that were appended to the dividend.
		//
		//  If the dividend length < the divisor length, then it has to be left
		//  shifted by an additional (dividend bits - divisor bits) to equalize
		//  the two lengths. This multiplies the quotient by a power of two so
		//  the quotient has to be right shifted after division to reduce it to
		//  the correct size. Right shifting is done by incrementing the intpoint
		//  of the quotient.
		//
		//  (To simplify the method, the dividend is left shifted by a multiple
		//  of 32 (or the dividend - divisor bits + 31 / 32) so that the integer
		//  point can be incremented instead of right shifting.)
		
		
		
		int left_shifts = 0;
		
		if (a.intarray.length < b.intarray.length)
		{
			//  Equalize the two lengths
			
			int ints = b.intarray.length - a.intarray.length;
			
			a = a .shiftLeft(32*ints, 32*ints);
			
			left_shifts += ints;
		}
		
		
		//  Left shift the dividend to the precision of the quotient
		
		int ints = 1 + precision / 8;  // 8 hex chars == 1 int
		
		a = a .shiftLeft(32*ints, 32*ints);
		
		left_shifts += ints;
		
		
		//  Compute the integer quotient and convert to floating point
		
		
		Number q;
		
		
		
		//  Delete the intpoints of a and b to use an integer divider
		
		a.intpoint = 0;  a.precision = 0;
		b.intpoint = 0;  b.precision = 0;
		
		a.sign = '+';    b.sign = '+';
		
		
		
		//  Choose a divider
		
		
		String method = "";
		
		
		if (false) {  }
		
		else if ((a.length() > 1) && (b.length() == 1) && (b.intarray[0] > 0))
		{
			q = a.divideByInt(b.intValue());
			
			//  Round the quotient up or down to the nearest integer
			
			if (q.isGreaterThan(0))   q = q     .add(0.1);
			else                      q = q.subtract(0.1);
			
			q = q .toInteger();
			
			method = "divide by int";
		}
		
		
		else if ((a.intarray.length < 16) && (b.intarray.length < 16))
		{
			//  Use the quadratic divider
			
			q = a.quadDivide(b);
			
			method = "quadratic divider";
		}
		
		
		else
		{ 	//  Use the inverter to compute the quotient
		 	//
			//  a / b  ==  a x inv(b)
			
			//  First compute the inverse of the divisor
			
			Number inv_b = b.setPrecision((a.intarray.length + 7)*8).inverse();
			
			//  Multiply the inverse by the dividend
			
			q = a .multiply(inv_b);   q = q .toInteger();
			
			method = "Newton's iteration / inversion";
		}
		
		
		//  Reduce the quotient by adding the left shifts to the intpoint and
		//  adding the difference between the dividend and divisor intpoints
		
		q.intpoint += (left_shifts + a_b_intpoint);
		
		//  If the signs are the same, then the quotient is positive
		//  If the signs are opposite, then the quotient is negative
		
		if (sign == '-') q = q .negate();
		
		q = q.setPrecision(precision);
		
		
		
		//  Verify that the quotient is correct
		
		//  Compute the remainder of this - quotient x divisor
		
		Number qxv = q.multiply(divisor);
		
		Number remainder = this.subtract(qxv);
		
		if (remainder.abs() .compareTo(divisor.abs()) >= 0)
		{
			System.out.println(" dividend == " +      this.toString(16));
			System.out.println("  divisor == " +   divisor.toString(16));
			System.out.println(" quotient == " +         q.toString(16));
			System.out.println("remainder == " + remainder.toString(16));
			
			System.out.println("remainder is greater than divisor");
			
			System.out.println("division method == " + method);
			String message = "\nfloating point division error";
			
			System.out.println(message);
			
			throw new ArithmeticException(message);
		}
		
		q = q.setPrecision(precision);
		
		return q.trim();
	}
	
	
	
	public Number divide(Number n, Number inv)
	{
	
		//  This method is used for fast modular division
		//  (if the same divisor is used more than once)
		//  because the inverse of n can be pre-computed
		
		//  To call this method from another method,
		//  first pre-compute the inverse of n
		//
		//  int digits = (int) n.bitCount() / 4;
		//
		//  Number invn = n .setPrecision(2*digits) .inverse();
		//
		//  and then use .mod(n, invn) instead of .mod(n).
		
		
		if (!this.isInteger() || inv.isInteger())
		
		    throw new IllegalArgumentException();
		
		//  If the number is too large for the modulus
		//  then use the mod(Number) method to avoid an
		//  arithmetic exception
		
		if (this.trim().length() > 2*n.length())
		
		    return this.mod(n);
		
		Number r = new Number(this);
		
		//  Calculate the quotient q = [ a * inv ]
		
		Number q = r .multiply(inv) .toInteger();
		
		//  Verify the quotient
		
		//  Reduce the residue modulo n
		
		r = r .subtract(q.multiply(n));
		
		if (r.abs() .isGreaterThan(n))
		
		    throw new ArithmeticException();
		
		return q;
	}
	
	
	
	
	private Number divideByInt(int divisor)
	{
		//  This method is 10 to 20 times faster
		//  than the quadratic divide method
		
		int sign = 1;
		
		if (divisor < 0) { sign *= -1; divisor *= -1; }
		
		Number dividend1 = new Number(this);
		
		if (divisor == 1) return dividend1;
		
		int[] array = dividend1 .intarray;
		
		//  Calculate the digit quotients and remainders
		
		for (int i = 0, r = 0; i < array.length; i++)
		{
			//  Read the signed int value as an unsigned long
			
			long dividend = array[i] & 0xffffffffL;
			
			//  Add the previous remainder to the dividend
			
			long a = dividend + ((r & 0xffffffffL) << 32);
			
			//  Calculate the quotient and remainder
			//  of the dividend and divisor
			
			int q = (int) (a / divisor);
			
			r = (int) (a % divisor);
			
			array[i] = q;
		}
		
		Number quotient = new Number(array);
		
		if (sign == -1) quotient = quotient .negate();
		
		Number product = quotient .multiply(divisor);
		
		Number diff = this .subtract(product) .abs();
		
		return quotient;
	}
	
	
	
	public static Number[] divide(Number[] array, Number n)
	{
		//  divides an array by a number n
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].divide(n);
		
		return array1;
	}
	
	
	
	
	public double doubleValue()
	{
		//  returns the value as a double
		
		Number number = new Number(this);
		
		if (this.equals(0))  return 0;
		
		int exp = 0;
		
		//  the sign bit of intarray[0] should be zero
		
		if ( (number.intarray[0] & 0x80000000) != 0)
		
		    { number = number.shiftRight(1); exp += 1; }
		
		else while ((number.intarray[0] & 0x40000000) == 0)
		
		    { number = number.shiftLeft(1);  exp -= 1; }
		
		int int1 = number.intarray[0], int2 = 0;
		
		if (number.intarray.length > 1) int2 = number.intarray[1];
		
		exp += (number.intarray.length -1) * 32;
		
		exp -= number.intpoint * 32;
		
		double d = Math.pow(2, exp)
		
		    * (int1 + int2 * 1.0D / 0x10000 / 0x10000);
		
		if (this.signum() == -1)  d *= -1;
		
		return d;
	}
	
	
	public static Number e()
	{
		return e(32);
	}
	
	
	public static Number e(int digits)
	{
	
		//  computes the value of e or the base of the natural logarithm
		//
		//  using 1 / n! == 1/0! + 1/1! + 1/2! + 1/3! + ... == 1 + 1 + 1/2 + 1/6 + ...
		
		
		//  Example  Compute the value of e up to 16 K digits
		//
		//  and verify the accuracy of the digits
		//
		//  Number[] e = new Number[6];
		//
		//  for (int i = 0; i < e.length; i++)
		//
		//      e[i] = Number.e(256 * (1 << i));
		//
		//  System.out.println(Arrays.toString(e));
		//
		//  for (int i = 0; i < e.length -1; i++)
		//
		//      if (!e[i+1].toString(16).startsWith(
		//           e[i+0].toString(16)))
		//
		//  	System.out.println("error");
		
		
		long starttime = System.nanoTime();
		
		if (digits < 1) throw new IllegalArgumentException();
		
		
		//  Compute 1 / n! == 1/0! + 1/1! + 1/2! + ...
		
		final int p = 4 + digits;
		
		Number e = new Number(0);
		
		//  iterations == digits / digits per iteration
		
		int t = 4 + digits / 1;
		
		Number temp = new Number(1) .setPrecision(p);
		
		for (int i = 1; i < t; i++)
		{
			e = e .add( temp );
			
			temp = temp .divide(i);
		}
		
		e = e .setPrecision(digits);
		
		if (digits >= 256)
		{
			long computetime = System.nanoTime() - starttime;
			
			System.out.print("e(" + digits + ")" + " compute time = ");
			System.out.print(new Number(computetime).setPrecision(2)
			    .divide(1L*1000000000) .toString().trim());
			System.out.println(" seconds");
		}
		
		return e;
	}
	
	
	
	public boolean equals(int val)
	{
		//  tests for equality
		
		if (this.isComplex() && !this.toImag()
		
		    .equals(0)) return false;
		
		Number a = this.trim();
		
		if (a.intarray.length > 1) return false;
		
		if (a.intarray.length == 1)
		{
			if (a.sign != '-')
			
			    return a.intarray[0] == + val;
			
			else if (a.sign == '-')
			
			    return a.intarray[0] == - val;
		}
		
		Number b = new Number(val);
		
		int[] array1 = a.intarray;
		int[] array2 = b.intarray;
		
		if ((a.sign != b.sign) && (val != 0)) return false;
		
		return Math.compareTo(array1, array2) == 0;
	}
	
	
	public boolean equals(double val)
	{
		//  tests for equality
		
		if (this.isComplex() && !this.toImag()
		
		    .equals(0)) return false;
		
		Number d = this.subtract(val);
		
		return d.abs().doubleValue() < 0.00000001D;
	}
	
	
	public boolean equals(Number val)
	{
		//  tests for equality using the
		//  smaller of the two precisions
		
		if (this.isComplex() || val.isComplex())
		
		    return this.toReal().equals(val.toReal())
		        && this.toImag().equals(val.toImag());
		
		return this.compareTo(val) == 0;
	}
	
	
	public boolean equals(Object obj)
	{
		//  This method is required for ArrayLists or else the Array
		//  List equals() and contains() methods would return false.
		//
		//  (Xlint does not issue a warning if this method is omitted)
		
		if (obj instanceof Number)
		
		    return this.equals((Number) obj);
		
		else return false;
	}
	
	
	public boolean equals(String str)
	{
		//  A number cannot equal a string
		
		String message = "A string is not a number";
		
		throw new IllegalArgumentException(message);
	}
	
	
	public static Number exp(int x)
	{
		return exp(new Number(x));
	}
	
	public static Number exp(Number x)
	{
		//  returns e ^ x
		
		int precision = 16;
		
		if (x.precision >   precision)
		      precision = x.precision;
		
		return e(precision) .pow(x);
	}
	
	
	
	public int[] factor(int maxprime)
	{
		//  factors a number up to maxprime
		
		//  Create a table of primes
		
		int numberofprimes = (int) (maxprime / Math.log(maxprime));
		
		int[] primes = Math.primes(numberofprimes);
		
		Number n = new Number(this);
		
		if (n.equals(0) || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		ArrayList<Number> list = new ArrayList<Number>();
		
		if (n.signum() == -1) list.add(new Number(-1));
		
		for (int i = 0; i < primes.length; i++)
		{
			if (n.isDivisibleBy(primes[i]))
			{
				list.add(new Number(primes[i]));
				
				n = n.divide(primes[i--]);
			}
		}
		
		//  Convert the list to array
		
		int[] array = new int[list.size()];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = list.get(i).intValue();
		
		return array;
	}
	
	
	
	public int[] factor(int[] primes)
	{
		//  returns the factorization of a number
		//  using the primes in the primes array
		
		ArrayList<Integer> list;
		
		list = new ArrayList<Integer>();
		
		Number n = new Number(this);
		
		while (!n.testBit(0))
		
		   { list.add(2); n = n .shiftRight(1).trim(); }
		
		for (int i = 0; i < primes.length; i++)
		{
			if (n.isDivisibleBy(primes[i]))
			{
				list.add(primes[i]);
				
				n = n.divide(primes[i--]);
			}
		}
		
		//  Convert the list to array
		
		int[] factors = new int[list.size()];
		
		for (int i = 0; i < factors.length; i++)
		
		    factors[i] = list.get(i);
		
		return factors;
	}
	
	
	
	public Number factorial()
	{
		//  computes the product of integers from 1 to n
		
		//  The factorial is computed using only a few large multiplications
		//  by multiplying the numbers iteratively or recursively in pairs.
		
		//  Iterative methods that include the factorial function n! usually
		//  have a variable that stores the previous value of (n-1)! so the
		//  factorial doesn't have to be re-computed for each iteration.
		//
		//  The factorial of n is approximately equal to (n / e) ^ n.
		
		
		if (!this.isInteger() || this.isGreaterThan(16*1024*1024))
		
		    throw new IllegalArgumentException();
		
		Number n = new Number(this);
		
		if (n.signum() == -1)
		{
			System.out.println("n == " + n);
			
			throw new IllegalArgumentException();
		}
		
		int nint = n.intValue();
		
		Number product = new Number(1);
		
		for (int i = 1; i <= nint; i++)
		
		    product = product.multiply(i);
		
		return product;
	}
	
	
	
	public void flipBit(long bit)
	{
		//  flips a bit of the number array
		
		Math.flipBit(this.intarray, bit);
	}
	
	
	public float floatValue()
	{
		//  returns the value as a float
		
		double d = this.doubleValue();
		
		return (float) d;
	}
	
	
	public Number gcd(long n)
	{
		return gcd(new Number(n));
	}
	
	
	public Number gcd(Number n)
	{
		//  returns the greatest common divisor (gcd)
		//  or greatest common factor of two numbers
		//  using the gcd or Euclidean algorithm
		
		//  The gcd function is only defined for integers
		
		if (!this.isInteger() || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		if (this.equals(0)) return n;
		
		if (n.equals(0)) return this;
		
		Number a, b, c, m = this;
		
		if (m.abs().isGreaterThan(n.abs()))
		{
			a = new Number(m.abs());
			b = new Number(n.abs());
		}
		
		else
		{	a = new Number(n.abs());
			b = new Number(m.abs());
		}
		
		if (a.equals(1) || b.equals(1))
		
		    return new Number(1);
		
		if (a.equals(0) || b.equals(0) )
		
		     return a.isGreaterThan(b) ? a : b;
		
		if (a.equals(b)) return a;
		
		
		//  Compute the gcd
		
		Number gcd = null;
		
		while (true)
		{
			c = a.mod(b);
			
			if (c.equals(0))
			
			    return gcd != null ? gcd : b;
			
			else { gcd = c; a = b; b = c; }
		}
	}
	
	
	public int getBit(long bit)
	{
		//  returns a bit of a number
		
		int[] array = this.intarray;
		
		if ((precision != 0) && (bit >= 0))
		
		    array = this.toInteger().intarray;
		
		if ((precision != 0) && (bit < 0))
		
		    array = this.toFraction().intarray;
		
		if ((1 + Math.abs(bit) / 32) > array.length) return 0;
		
		return Math.getBit(array, bit);
	}
	
	
	public Number getDigits(long lower, long upper, int radix)
	{
		//  returns digits of a number in base radix
		
		//  This method could be used to read the 1 millionth digit
		//  of pi without converting the entire number to string.
		
		if ((upper <= lower) || (lower < 0) || (radix < 2)
		
		    || (this.precision != 0)) throw new
		
			IllegalArgumentException();
		
		Number n = new Number(this);
		
		//  Compute the quotient and remainder modulo
		//  the radix raised to the number of digits
		
		n = n .divide(new Number(radix).pow(lower));
		n = n    .mod(new Number(radix).pow(upper-lower));
		
		return n;
	}
	
	
	private Number getLower(int n)
	{
		//  This method is used for Karatsuba multiplication
		
		int len = this.intarray.length;
		
		if (len <= n) return this.abs();
		
		int[] lowerints = new int[n];
		
		System.arraycopy(this.intarray, len-n, lowerints, 0, n);
		
		return new Number(lowerints).trim();
	}
	
	
	public long getLowestSetBit()
	{
		//  returns the lowest set bit
		
		if (!this.isInteger()) throw new IllegalArgumentException();
		
		return Math.getLowestSetBit(this.intarray);
	}
	
	
	public int getPrecision()
	{
		//  returns the precision
		
		return this.precision;
	}
	
	
	private Number getUpper(int n)
	{
		//  This method is used for Karatsuba multiplication
		
		int len = this.intarray.length;
		
		if (len <= n) return new Number(0);
		
		int upperlen = len - n;
		
		int[] upperints = new int[upperlen];
		
		System.arraycopy(this.intarray, 0, upperints, 0, upperlen);
		
		return new Number(upperints).trim();
	}
	
	
	
	public int hashCode()
	{
		//  Xlint will issue a warning without this method ...
		//  "warning: [overrides] Class Number overrides equals, but
		//  neither it nor any superclass overrides hashCode method"
		
		int hashCode = 0;
		
		for (int i = 0; i < intarray.length; i++)
		
		    hashCode = 31 * hashCode + intarray[i];
		
		return hashCode * signum();
	}
	
	
	
	public int intValue()
	{
		//  returns the int value of a number
		
		//  the Number toString method requires the
		//  unrounded int value or else it will cause
		//  an error and throw an exception
		
		return intValue(true);
	}
	
	private int intValue(boolean round)
	{
		Number n = new Number(this);
		
		if (n.intpoint != 0) n = n.toInteger(round);
		
		int intval = n.intarray[n.intarray.length -1];
		
		if (n.sign == '-') intval = ~ intval + 1;
		
		return intval;
	}
	
	
	
	public Number inverse()
	{
	
		//  computes the inverse of a number u = 1 / v
		//
		//  If the number is small the method uses the quadratic divider.
		//  If the number is large the method uses Newton's iteration to com-
		//  pute u = u (2 - v u) where the initial value of u is set to ~ 1/v.
		//
		//  This iteration requires only a few multi-precision multiplications.
		//  Instead of converging linearly by 1 bit, 1 digit, or 1 int per iter-
		//  ation like the quadratic divider, Newton's iteration converges expo-
		//  nentially faster by doubling the number of digits per iteration.
		//
		//  This means that instead of requiring O(n) multi-precision multipli-
		//  cations or O(n^2) single-precision operations to do a division,
		//  inversion requires only O(log2(n)) multi-precision multiplications
		//  or O(n log n) single-precision operations. (For example, for a 1 M
		//  bit number, the number of multi-precision multiplications is about
		//  log2(1 M / 32 bits) == log2(1 M) - log2(32) == 20 - 5 == 15.)
		//
		//  By computing the inverse of a divisor, a quotient of two numbers
		//  can be computed by multiplying the inverse by the dividend because
		//  q = a / b == a * (1 / b) == a * inverse(b).
		
		
		
		if (this.isComplex())
		{
			//  Compute the inverse of a complex number a + i b
			//
			//         1     (a - i b)       a - i b
			//  ==  -------  ---------  ==  ---------
			//      a + i b  (a - i b)      a^2 + b^2
			
			Number d = this.toReal().square()
			      .add(this.toImag().square());
			
			Number real = this.toReal()         .divide(d);
			Number imag = this.toImag().negate().divide(d);
			
			return new Number(real, imag);
		}
		
		
		
		//  Define the precision of zero
		
		Number zero = new Number("0", 16)
		
		    .setPrecision(this.precision);
		
		if (this.equals(zero))
		{
			String message = "divide by zero";
			
			throw new IllegalArgumentException(message);
		}
		
		
		if (this.bitCount() < 32)
		
		    return new Number(1.0D / this.doubleValue());
		
		
		//  Calculate the number of int and frac digits
		
		int  intdigits = this.toInteger() .toString(16).length();
		int fracdigits = this.toFraction().toString(16).length();
		
		
		//  Set the inverse precision
		
		int inv_precision = fracdigits + 2*intdigits + 32;
		
		
		//  Use the quadratic divider if the number
		//  of bits is less than a minimum threshold
		
		if (this.bitCount() < 1024)
		{
			Number u = new Number(1).setPrecision(
			
			    inv_precision).divide(this);
			
			return u;
		}
		
		
		//  Compute u  = 1 / v by iterating
		//
		//  u = u (2 - v u)  log(n) times
		
		
		//  Set u approximately equal to 1 / v
		//
		//  Make sure the product v u is close to one
		//  or else u will converge to the inverse of v
		//  in O(n) instead of O(log(n)) multi-precision
		//  multiplications where n is the number of bits
		
		Number v = new Number(this).trim(),  v1;
		
		if (v.precision == 0)  v = v.setPrecision(8);
		
		
		//  Move the integer point of the input so that v ~ 1
		
		int d = (int) (v.bitCount() - 32 * v.intpoint);
		
		final long bits = (d / 32) * 32;
		
		if (d >= 0)
		{
			v1 = v .shiftLeft(bits + 32, bits);
			
			v1.intpoint += bits / 32;
			
			v1 = v1 .shiftRight(d).trim();
		}
		
		else // if (d < 0)
		{
			v1 = v .shiftLeft(-d + 32, -d);
		}
		
		
		//  Set the initial value of u1 ~ 1 / v1
		
		double dblv1 = v1.setPrecision(16) .doubleValue();
		
		double dblu1 = 1.0D / dblv1;
		
		Number u, u1 = new Number((long) dblu1);
		
		
		//  First iterate at 64-bits or 16 char precision
		
		int p = 64 / 4;
		
		for (int i = 0; i < 8; i++)  // constant precision
		{
			Number v1u1 = v1.setPrecision(8) .multiply(u1.setPrecision(p));
			
			Number two = new Number(2) .setPrecision(8);
			
			u1 = u1.setPrecision(p) .multiply(two.subtract(v1u1));
		}
		
		
		//  Do a few more iterations doubling the precision for each iteration
		
		while (true)
		{
			int p1 = (p = 2*p);
			
			if (p1 > inv_precision) p1 = inv_precision;
			
			Number v1u1 = v1.setPrecision(p1) .multiply(u1.setPrecision(p1));
			
			Number two = new Number(2) .setPrecision(p1);
			
			u1 = u1.setPrecision(p1) .multiply(two.subtract(v1u1));
			
			if (p1 >= inv_precision) break;
		}
		
		
		//  Move the integer point of the inverse
		
		if (d >= 0)
		{
			u1 = u1 .shiftLeft(bits + 32, bits);
			
			u1 .intpoint += bits / 32;
			
			u = u1 .shiftRight(d) .trim();
		}
		
		else    u = u1 .shiftLeft(-d + 32, -d);
		
		
		//  Verify the inverse u v ==
		//
		//  1.00000000000000000000... or
		//  0.ffffffffffffffffffff...
		//
		//  Note that u v can converge from above or below 1
		
		Number uv = this .setPrecision(u.precision)
		    .multiply(u) .setPrecision(u.precision);
		
		String uvstr = uv .toString(16);
		
		if ( ((uvstr.charAt(0) != '0') && (uvstr.charAt(0) != '1'))
		   || (uvstr.charAt(1) != '.') )
		{
			System.out.println("1 == " + uvstr.substring(0, 64) + "...");
			
			throw new ArithmeticException();
		}
		
		String frac = uvstr.substring(2);
		
		//  Count the number of 0's or f's
		
		int digits = 0, mindigits = inv_precision * 2/3;
		
		char fracchar = frac.charAt(0);
		
		for (int i = 1; i < frac.length(); i++)
		
		    if (frac.charAt(i) == fracchar) digits++;
		
		    else break;
		
		if (digits < mindigits)
		{
			System.out.println("Number of zeros or ones in "
			
			   + "u v == " + digits + " < " + mindigits);
			
			String message = "fft or multiplier is defective ";
			
			throw new ArithmeticException(message);
		}
		
		//  Set the correct precision
		
		return u .setPrecision(inv_precision) .trim();
	}
	
	
	
	public static boolean isBase16(String str)
	{
		//  tests if a string is in base 16
		
		//  base 16 is a subset of the base 64 character set
		//  but base 16 is not padded to a multiple of 4 bytes
		
		return isDigitString(str, 16);
	}
	
	
	public static boolean isBase64(String str)
	{
		//  tests if a string is in base 64 and veri-
		//  fies that the length is a multiple of 4
		
		if (((str.length() % 4) != 0)
		
		   || str.isEmpty()) return false;
		
		boolean bool = true;
		
		char[] array = str.toCharArray();
		
		for (int i = 0; i < array.length; i++)
		{
			if (array[i] >= Convert.base64ToInt.length)
			
			    { bool = false;  break; }
			
			if (Convert.base64ToInt[array[i]] == -1)
			{
				if (array[i] != '=') { bool = false;  break; }
				
				else if (i < array.length -2) { bool = false;  break; }
			}
		}
		
		return bool;
	}
	
	
	
	public boolean isComplex()
	{
		//  tests if a number is complex
		
		if ((this.intarray1 == null) || new Number(this.intarray1)
		
		    .equals(new Number(0).setPrecision(this.precision1)))
		
			return false;
		
		return true;
	}
	
	public boolean isCoprimeWith(long n)
	{
		return isCoprimeWith(new Number(n));
	}
	
	public boolean isCoprimeWith(Number n)
	{
		//  tests if two numbers are relatively prime
		//  or have no common factor greater than 1
		
		return this.gcd(n).equals(1);
	}
	
	public static boolean isDigitString(String str, int radix)
	{
		//  a digit string cannot have a sign or an intpoint;
		//  an integer string can have a sign but not an intpoint;
		//  a number string can have a sign, an intpoint, and any
		//  hex chars less than the base (such as 0 to f, or 0 to 9)
		
		if (str.contains("+") || str.contains("-")) return false;
		
		return isIntegerString(str, radix);
	}
	
	
	public boolean isDivisibleBy(int n)
	{
		//  return this.mod(n).equals(0);
		
		int[] intarray = this.mod(n).intarray;
		
		return intarray[intarray.length-1] == 0;
	}
	
	
	public boolean isDivisibleBy(Number n)
	{
		//  tests if an integer is evenly divisible
		//  (divisible without remainder) by n
		
		if (this.isInteger())
		
		    return this.mod(n).equals(0);
		
		Number quotient = this.divide(n);
		
		return quotient.round().subtract(quotient).equals(
		
		    new Number(0).setPrecision(this.precision));
	}
	
	
	public boolean isEven()
	{
		//  tests if an integer is divisible by 2
		
		if (!this.isInteger()) throw
		
		    new IllegalArgumentException();
		
		return this.getBit(0) == 0;
	}
	
	
	public boolean isFactorable(int maxprime)
	{
		//  tests if a number is factorable
		//  by primes less than max prime
		
		int numberofprimes = maxprime;
		
		int[] primes = Math.primes(maxprime);
		
		return isFactorable(primes);
	}
	
	
	public boolean isFactorable(int[] primes)
	{
		//  tests if a number is factorable by a primes array
		
		//  For large numbers of factorizations, this method
		//  may be faster than isFactorable(maxprime) because
		//  the primes array only has to be created once
		
		int[] array = factor(primes);
		
		Number product = new Number(1);
		
		for (int i = 0; i < array.length; i++)
		
		    product = product .multiply(array[i]);
		
		return product.equals(this);
	}
	
	
	public boolean isGreaterThan(double val)
	{
		return isGreaterThan(new Number(val));
	}
	
	public boolean isGreaterThan(long val)
	{
		return isGreaterThan(new Number(val));
	}
	
	public boolean isGreaterThan(Number val)
	{
		//  tests if one number is greater than the other
		
		if (this.equals(val)) return false;
		
		else return this.compareTo(val) == 1;
	}
	
	public boolean isInteger()
	{
		//  tests if the intpoint = 0
		
		return (this.intpoint  == 0)
		    && (this.intpoint1 == 0);
	}
	
	public static boolean isIntegerString(String str, int radix)
	{
		//  an integer string cannot have an integer point
		
		if (str.isBlank()) return false;
		
		if (str.contains(".")) return false;
		
		return isNumberString(str, radix);
	}
	
	
	public boolean isLessThan(double val)
	{
		return isLessThan(new Number(val));
	}
	
	public boolean isLessThan(long val)
	{
		return isLessThan(new Number(val));
	}
	
	public boolean isLessThan(Number val)
	{
		//  tests if one number is less than the other
		
		return this.compareTo(val) == -1;
	}
	
	
	public static boolean isNumberString(String str, int radix)
	{
		//  A number string can only have chars in
		//  base radix, an intpoint, and a sign
		
		//  An example of a number string, integer string, and digit string
		//
		//  - 1.23456789abcdef //  number string (chars, sign, and intpoint)
		//   - 123456789abcdef // integer string (chars and sign)
		//     123456789abcdef //   digit string (chars only)
		
		
		if (str.isBlank()) return false;
		
		String s = str.trim();
		
		if (s.startsWith("+") || s.startsWith("-"))
		{
			s = s.substring(1, s.length());
			
			if (s.startsWith(" "))
			
			    s = s.substring(1, s.length());
		}
		
		if (s.replaceAll("[.]", "").isEmpty())
		
		    return false;
		
		//  only one integer point is allowed
		
		int position = 0;
		
		if ( ((position = s.indexOf('.')) != -1)
		
		  && (s.indexOf('.', position + 1) != -1) )
		
			return false;
		
		char[] charray = s.toCharArray();
		
		for (int c : charray)
		{
			if ( (c < '0') || (c > ('0' + radix - 1 -  0)) )
			if ( (c < 'a') || (c > ('a' + radix - 1 - 10)) )
			
			if (c != '.') return false;
		}
		
		return true;
	}
	
	
	
	public boolean isPrimePower()
	{
		//  tests if a number is a prime power
		
		//  if a number n = p^k, then the totient is
		//
		//           k           k-1
		//  phi(n = p ) = (p-1) p
		//
		//  This means that for any base a < p
		//
		//    (p-1) p^(k-1)      phi(n)
		//  a               ==  a       ==  1 (mod n)
		//
		//  Fermat's test says that for any prime or prime power n = p^k,
		//  any coprime base raised to the (p-1) p^(k-1) equals 1. But the
		//  converse is not always true; if a ^ ((p-1) p^(k-1)) == 1 (mod n)
		//  for (a, n) == 1, it doesn't prove that n is a prime or prime power,
		//  because Fermat's test can only prove a negative or that a number is
		//  not a prime or prime power. For this reason the method tries divid-
		//  ing by the first few or 32 primes before applying the Fermat test.
		//
		//  If there are some composite (or prime) numbers that can still pass
		//  the prime power test then there may have to be an additional test
		//  similar to the Miller-Rabin test for primality that also uses Fer-
		//  mat's test but removes the twos from the totient.
		
		
		//  Example Find the first several prime powers
		//          4, 8, 9, 16, 25, 27, 32, 49, 64, 81, 121, ...
		//
		//  for (int i = 2; i < 1024*1024; i++)
		//
		//  if (new Number(i).isPrimePower())
		//  {
		//	int[] factors = Math.factor(i);
		//	int[][] prime_exp = Math.sortAndCollate(factors);
		//	int prime = prime_exp[0][0], exp = prime_exp[0][1];
		//	if ((prime_exp.length > 1) || !Math.isPrime(prime))
		//	    throw new ArithmeticException();
		//	System.out.print(prime_exp[0][0]
		//	        + "  " + prime_exp[0][1] + "   ");
		//  }
		//
		//  2  2   2  3   3  2   2  4   5  2   3  3   2  5   7  2   2  6
		//  3  4   11  2   5  3   2  7   13  2   3  5   2  8   17  2   7  3
		//  19  2   2  9   23  2   5  4   3  6   29  2   31  2   2  10
		//  11  3   37  2   41  2   43  2   2  11   3  7   13  3   47  2
		//  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..  ..
		//
		//  907  2   7  7   911  2   919  2   929  2   937  2   941  2   947  2
		//  953  2   97  3   31  4   967  2   971  2   977  2   983  2   991  2
		//  997  2   1009  2   1013  2   101  3   1019  2   1021  2
		
		
		//  Example  Find the prime powers between 10^9 and 10^9 + 10^6
		//
		//  int n = 1024*1024*1024;
		//  for (int i = n + 1; i < n + 1024*1024; i++)
		//    if (new Number(i).isPrimePower())
		//	System.out.print(i + "  ");
		//
		//  the output is 1073938441, 1074462841, 1074725089,
		//  or the squares of the three consecutive primes
		//  32771, 32779, and 32883.
		//
		//  For n ~ 10^9, there should be 10^4.5 or ~ 32 K perfect
		//  squares. Since the iteration is only over 10^6 instead
		//  of 10^9, there should be 32 squares including composite
		//  bases instead of 32 K squares; but the prime density is
		//  1 / ln n or 1 / ln 32 K ~ 1 / 10 which means that the
		//  number of perfect prime squares should be 32.768 / 10.4
		//  == 3.15 or ~ 3.
		
		
		Number p = this;
		
		if (p.isPrime()) return false;
		
		int[] primes = Math.primes(32);
		
		for (int prime : primes)
		
		if (p.mod(prime).intValue() == 0)
		{
			while (p.isDivisibleBy(prime))
			
			    p = p.divide(prime);
			
			return p.equals(1);
		}
		
		
		Number a = new Number(2);
		
		while (!a.isCoprimeWith(p)
		    || !a.isGenerator(p))
		
		    a = a.add(1);
		
		Number residue = a .modPow(
		
		    p.subtract(1), p) .modPow(p, p)
		
			.modPow(p, p) .modPow(p, p);
		
		if (!residue.equals(1)) return false;
		
		return true;
	}
	
	
	
	public boolean isPower(int n)
	{
		//  tests if a number is an nth power
		
		Number root = this.root(n).round();
		
		return root.pow(n).equals(this);
	}
	
	
	
	public boolean isPowerOf(int base)
	{
		//  tests if y == a ^ x
		
		int n = base; if (n == 0) return false;
		
		if (this.equals(1) || this.equals(n) ||
		
		 this.equals(new Number(n).square())) return true;
		
		if (!this.isInteger() || this.equals(0)
		
		 || !this.mod(n).equals(0)) return false;
		
		//  2^k & (2^k - 1) == 10000... & 01111... == 0
		
		if (n == 2) return this.and(
		
		    this.subtract(1)).equals(0);
		
		Number a = new Number(1);
		
		while (a.isLessThan(this))
		
		    a = a .multiply(base);
		
		return a.equals(this);
	}
	
	
	public boolean isPrime()
	{
		return isProbablePrime(2);
	}
	
	public boolean isProbablePrime()
	{
		return isProbablePrime(2);
	}
	
	public boolean isProbablePrime(int certainty)
	{
	
		//  tests if a number is prime
		
		//  A prime number is any integer greater than 1
		//  that is evenly divisible only by 1 and itself
		//
		//  (Evenly divisible means divisible without remainder)
		
		if (!this.isInteger())
		{
			String message = "primality test is only defined for integers";
			
			throw new IllegalArgumentException(message);
		}
		
		if (this.signum() == -1) throw
		
		    new IllegalArgumentException();
		
		Number n = new Number(this);
		
		//  The numbers 0 and 1 are neither prime nor composite because there
		//  is no unique factorization for these integers. The number 1 could
		//  be factored into an infinite number of ones, and the number 0 could
		//  be factored into an infinite number zeros because 1 and 0 are idem-
		//  potent (same power) which means that the exponent is undefined. The
		//  number 0 could also be multiplied by an infinite number of integers
		//  because any integer times zero equals zero.
		//
		//  The number 2 is semi-prime because some prime number theorems
		//  reject the number 2 as prime but others accept 2 as prime.
		
		
		if (n.equals(0) || n.equals(1)) return false;
		if (n.isEven() && !n.equals(2)) return false;
		
		
		int[] primes = new int[]
		{
		     2,    3,    5,    7,   11,   13,   17,   19,   23,   29,   31,   37,
		    41,   43,   47,   53,   59,   61,   67,   71,   73,   79,   83,   89,
		    97,  101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,
		   157,  163,  167,  173,  179,  181,  191,  193,  197,  199,  211,  223,
		   227,  229,  233,  239,  241,  251,  257,  263,  269,  271,  277,  281,
		   283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,
		   367,  373,  379,  383,  389,  397,  401,  409,  419,  421,  431,  433,
		   439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,  503,
		   509,  521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,
		   599,  601,  607,  613,  617,  619,  631,  641,  643,  647,  653,  659,
		   661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,
		   751,  757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,
		   829,  839,  853,  857,  859,  863,  877,  881,  883,  887,  907,  911,
		   919,  929,  937,  941,  947,  953,  967,  971,  977,  983,  991,  997,
		};
		
		
		//  If the number is less than 64 K
		//  test the first thousand primes
		
		int bits = (int) n.bitCount();
		
		if (this.bitCount() < 16)
		
		    for (int i = 0; i < primes.length; i++)
		
			if (this.equals(primes[i])) return true;
		
		
		//  Divide by small primes
		
		for (int i = 0; i < primes.length; i++)
		
		    if (this.isDivisibleBy(primes[i])) return false;
		
		//                         n-1
		//  Apply the Fermat test a   (mod n) == 1
		//  using bases a = 2 and a = 3 as witnesses
		
		if ( !new Number(2) .modPow(n.subtract(1), n) .equals(1)
		  || !new Number(3) .modPow(n.subtract(1), n) .equals(1) )
		
			return false;  // composite
		
		
		//  If the number has made it this far, it has passed the Fermat test
		//  using the first two primes as bases.
		//
		//  A composite number that can pass the Fermat test for some base is called
		//  a pseudo prime. A composite number that can pass the Fermat test for all
		//  bases is called an absolute pseudo prime or Carmichael number.
		
		
		//  Test for Carmichael numbers and other pseudo primes
		
		//  n - 1 = (2 ^ s) r
		
		Number r = this.subtract(1);  int s = 0;
		
		while (r.isEven()) { r = r.shiftRight(1); s++; }
		
		for (int i = 1; i <= certainty; i++)
		{
			//  Choose 1 < a < n-1
			
			Number a = new Number(i+1), y = null;
			
			//  Test whether y = a ^ r (mod n) == 1 or -1
			
			if ( !(y = a.modPow(r, n)) .equals(1) && !y .equals(n.subtract(1)) )
			{
				int j = 1;
				
				while ( (j++ <= (s-1)) && !y.equals(n.subtract(1)) )
				{
					//  Compute y = y ^ 2  mod n;
					
					y = y.square() .mod(n);
					
					if (y.equals(1)) return false;
				}
				
				if (!y.equals(n.subtract(1))) return false;
			}
		}
		
		return true;
	}
	
	
	public boolean isQuadraticResidue(Number p)
	{
		//  tests for quadratic residuosity
		
		boolean issquare = p.isPower(2);
		
		if (!p.isPrime() && !issquare)
		
		    throw new IllegalArgumentException();
		
		Number a = this .mod(p);
		
		Number phi;
		
		if (!issquare) phi = p.subtract(1);
		
		else phi = p.sqrt().subtract(1) .multiply(p.sqrt());
		
		return a.modPow(phi.divide(2), p).equals(1);
	}
	
	
	public Number lcm(long n)
	{
		return lcm(new Number(n));
	}
	
	
	public Number lcm(Number a)
	{
		//  returns the least common multiple
		
		Number b = this;
		
		return a.multiply(b) .divide(a.gcd(b));
	}
	
	
	public int length()
	{
		//  returns the size of the int array
		
		return this.intarray.length;
	}
	
	
	public Number ln()
	{
		//  computes the natural logarithm
		//
		//  for any real number x > 0
		
		return log();
	}
	
	
	public long log2()
	{
		//  returns the integer bit count
		
		return this.toInteger().bitCount();
	}
	
	
	public Number log(int base)
	{
		//  computes the log in any base
		
		return this.log(new Number(base));
	}
	
	
	
	public Number log(Number base)
	{
		//  computes the log in any base
		//
		//  using the logarithmic identity
		//
		//  log n == log n / log b
		//     b
		
		return this.log() .divide( base.log() );
	}
	
	
	
	public Number log()
	{
	
		//  computes the natural logarithm of a number
		//
		//  The base of the natural logarithm is e == 2.718281828459045...
		
		//  The natural log function can be denoted by log() or ln() because
		//  the common log and binary log functions are denoted by log10()
		//  and log2().
		
		//  The logarithmic function ln(1 + x) is evaluated from the series
		//  (-1)^(n + 1) x^n / n  which is defined for -1 < x <= 1 or 0 <
		//  (1 + x) <= 2.
		//
		//  The argument u = 1 + x has to be written as a product of a number
		//  and a power of the base to move the integer / fraction point so
		//  that the first argument is a number between 0 and the base 2.
		//  Then log(u) == the mantissa + exp ln(base).
		//
		//  For example, ln(1234.5678) == ln(1.2345678) * base^3 ==
		//  ln(1.2345678) + 3 ln base  == ln(1.2345678) + 3 ln(base)
		//  == the mantissa + exp ln(base).
		//
		//  The log of the argument between 1 and the base = 2 is a fractional
		//  number called the mantissa. The mantissa is a number between 0 and
		//  1 because the argument is always a number between 1 and the base
		//  (which equals 2 because computers use binary numbers). The integer
		//  / fraction point is moved to the left or right until there is ex-
		//  actly one bit to the left of the integer point. This makes the arg-
		//  ument between 1.00000000... and 1.ffffffff... < 2.
		//
		//  The first logarithm is the mantissa and the second logarithm is
		//  the exponent times the log of the base. The natural log of 2
		//  (or the log of any base) will not converge because the argument
		//  has to be between 0 and 2, so we have to make the base argument
		//  smaller by dividing by a constant. We can compute the natural log
		//  of (2 / e) to get ln (2 / e) == ln(2) - ln(e) == ln(2) - 1, and
		//  then solve for ln(2) == ln(2 / e) + 1. Then ln(u) == the mantissa
		//  + exp [ln(2 / e) + 1].
		
		
		//  To compute the log of a number to a high precision and accuracy,
		//  use a number string with zeros instead of the setPrecision method.
		//
		//  If the setPrecision method is used, unless the number is in binary
		//  or hexadecimal, the constructor will convert the decimal number to
		//  binary bits rounded down one bit, and the setPrecision method will
		//  add zeros to the right of the rounded number. Then the accuracy
		//  (correctness) will be less than the precision (exactness) or number
		//  of digits after the int point.
		
		//  Example  The number 1.234 converts to 1.233999999... and then
		//  the setPrecision(...) method expands it to 1.23399999900000000...
		//
		//  This number is precise but only accurate to one or two ints.
		//
		//  The number "1.234000000000000..." is precise and accurate to the
		//  number of digits after the int point.
		
		
		//  Set a minimum precision
		
		int p = Math.max(this.precision, 16);
		
		Number arg = new Number(this) .setPrecision(p);
		
		if (this.equals(0))
		{
			String message = "log(0) == - infinity";
			
			throw new IllegalArgumentException(message);
		}
		
		if (this.equals(1)) return new
		
		    Number(0).setPrecision(p);
		
		if (this.signum() == -1)
		{
			//  from  e ^ (i pi) == -1, log(-1) == i pi
			
			String message =
			
			    "log of -x == log(-1) + log(x) == i pi + log(x)";
			
			throw new IllegalArgumentException(message);
		}
		
		
		//  Move the integer / fraction point so the argument is close to 1
		
		int exp = 0;
		
		while (arg.isGreaterThan(0x7fffffff)) { arg.intpoint++; exp += 32; }
		while (arg.isGreaterThan(1)) { arg = arg.shiftRight(1); exp++; }
		while (arg.intpoint > arg.intarray.length) { arg.intpoint--; exp -= 32; }
		
		while (arg.isLessThan(1))   { arg = arg.multiply(2); exp--; }
		if (arg.isGreaterThan(1.8)) { arg = arg.  divide(2); exp++; }
		
		
		//  Compute log(u) == the mantissa + exp log(2)
		//
		//  == the mantissa + exp [ log(2 / e) + 1 ]
		
		Number mantissa = arg .log1();
		
		Number log2 = new Number(2) .divide(e(p)) .log1() .add(1);
		
		//               k
		//  log( arg * 2  ) == mantissa + k log 2
		
		Number log = mantissa .add( log2.multiply(exp) );
		
		
		//  Verify that e ^ log(x) / x ~ 1
		
		double e2logx = Math.pow(Math.e,
		
		    log.doubleValue()) / this.doubleValue();
		
		if ((e2logx < 0.9) || (e2logx > 1.1))
		
		    throw new ArithmeticException();
		
		return log.setPrecision(p);
	}
	
	
	
	private Number log1()
	{
	
		//  The logarithmic function log(1 + x) is computed
		//                      n+1  n
		//  from the series (-1)   x  / n  which is defined for
		//
		//  -1 < x <= 1  or  0 < 1 + x <= 2.
		//
		//  The argument (1 + x) must be close to 1 or else
		//  the series will converge very slowly
		
		
		if (this.isGreaterThan(2) || this.signum() == -1)
		
		    throw new IllegalArgumentException();
		
		Number log = new Number(0);
		
		Number x = this .subtract(1);
		
		int bits = 4 + this.precision;
		
		Number powerofx = new Number(1) .setPrecision(bits);
		
		for (int n = 1;  ; n++)
		{
			//                    n+1  n
			//  log(1 + x) == (-1)   x  / n  for 0 < (1 + x) < 2
			//
			//  log = log.add( x.pow(n) .divide(n)
			//
			//      .multiply(((n % 2) == 1) ? 1 : -1));
			
			powerofx = powerofx .multiply(x);
			
			Number log1 = powerofx .divide(n)
			
			    .multiply(((n % 2) == 1) ? 1 : -1 );
			
			log = log .add(log1);
			
			if (log1.equals(0))  break;
		}
		
		return log;
	}
	
	
	
	public long longValue()
	{
		//  returns the long value of a number
		
		return longValue(true);
	}
	
	private long longValue(boolean round)
	{
		Number n = new Number(this);
		
		if (n.intpoint != 0)  n = n.toInteger(round);
		
		long longval = n.intarray[n.intarray.length -1];
		
		longval &= 0xffffffffL;
		
		if (n.intarray.length > 1)
		
		    longval += ((1L * n.intarray[
		
			n.intarray.length -2]) << 32);
		
		longval &= 0x7fffffffffffffffL;
		
		if (n.sign == '-') longval = ~ longval + 1;
		
		return longval;
	}
	
	
	public Number max(Number val)
	{
		//  returns the greater of two numbers
		
		return this.compareTo(val) >= 0 ? this : val;
	}
	
	public Number min(Number val)
	{
		//  returns the lesser of two numbers
		
		return this.compareTo(val) < 0 ? this : val;
	}
	
	public static Number max(Number[] array)
	{
		//  returns the largest element
		
		Number max = new Number(array[0]);
		
		for (Number n : array) if (n
		
		   .isGreaterThan(max)) max = n;
		
		return max;
	}
	
	public static Number min(Number[] array)
	{
		//  returns the smallest element
		
		Number min = new Number(array[0]);
		
		for (Number n : array) if (n
		
		   .isLessThan(min)) min = n;
		
		return min;
	}
	
	
	public Number mod(double val)
	{
		return mod(new Number(val));
	}
	
	
	private Number mod(int val)
	{
		//  returns the value of this mod n
		
		//  This method is much faster than the mod(number) method
		
		//  Compute the mods of the digits and add them
		//
		//  a0 b0 + a1 b1 + a2 b2 + ... + ak bk  (mod p) ==
		//
		//  a0 b0 (mod p) + a1 b1 (mod p) + ... + ak bk (mod p)
		
		int sign = this.signum();
		
		if (val < 0) throw new IllegalArgumentException();
		
		if (this.isComplex()) return new Number(
		
		    this.toReal().mod(val), this.toImag().mod(val));
		
		Number n = this.abs();
		
		long residue = 0L;
		
		long twosr = 1L; // twos residue for (2^32)^i (mod val)
		
		for (int i = n.intarray.length -1; i >= 0; i--)
		{
			long a = n.intarray[i] & 0xffffffffL;
			
			long r = a % val;  r = (r * twosr) % val;
			
			twosr *= 0x100000000L;  twosr %= val;
			
			residue += r;
		}
		
		residue %= val;
		
		if (sign == -1) residue *= -1;
		
		if (residue < 0) residue += val;
		
		return new Number(residue);
	}
	
	
	public Number mod(long val)
	{
		return mod(new Number(val));
	}
	
	
	public Number mod(Number n)
	{
		//  returns mod(n) add(n) mod(n)
		
		Number result = this.remainder(n);
		
		if (!this.isComplex())
		
		return (result.signum() >= 0 ?
		
		    result : result.add(n));
		
		else
		{	Number a = result.toReal();
			Number b = result.toImag();
			
			return new Number(
			
			    a.signum() >= 0 ? a : a.add(n),
			    b.signum() >= 0 ? b : b.add(n));
		}
	}
	
	
	public static Number[] modPow(Number[] array, Number exp, Number n)
	{
		//  exponentiates an array modulo n
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].modPow(exp, n);
		
		return array1;
	}
	
	
	public static Number[] mod(Number[] array, Number n)
	{
		//  reduces an array modulo n
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].mod(n);
		
		return array1;
	}
	
	
	public static Number[] modDvide(Number[] array, Number n, Number m)
	{
		//  divides an array by a number n modulo m
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].modDivide(n, m);
		
		return array1;
	}
	
	
	
	
	public Number remainder(Number n)
	{
		//  returns the value of this mod n
		
		Number a = new Number(this);
		
		//  modular arithmetic is undefined
		//  for zero and complex moduli
		
		if (n.equals(0) || n.isComplex())
		{
			String message = (n.equals(0)) ?
			
			   "n equals 0" : "mod is complex";
			
			throw new IllegalArgumentException(message);
		}
		
		if (this.isComplex())
		{
			Number real = this.toReal();
			Number imag = this.toImag();
			
			real = real .mod(n);
			imag = imag .mod(n);
			
			return new Number(real, imag);
		}
		
		if (a .equals(0))
		
		    return new Number(0);
		
		n = n .abs();
		
		char sign = (this.sign == '+') ? '+' : '-';
		
		
		//  Compute the residue
		//
		//  r = a (mod n) = a - [a / n] n
		
		Number q = a .divide(n) .toInteger();
		
		Number qxn = q .multiply(n);
		
		Number r = a .subtract(qxn);
		
		r.sign = sign;
		
		//  Verify the residue
		//
		//  r + [a / n] n == a
		
		if (!r.add(q.multiply(n)).equals(a))
		{
			System.out.println("a == " + this.toString(16));
			System.out.println("r == " +    r.toString(16));
			
			throw new ArithmeticException();
		}
		
		return r;
	}
	
	
	public Number mod(Number n, Number inv)
	{
		//  returns the value of this mod n
		
		//  This method is used for fast modular reduction
		//  (if the same modulus is used more than once)
		//
		//  To call this method from another method,
		//  first pre-compute the inverse of n
		//
		//  int digits = (int) n.bitCount() / 4;
		//
		//  Number invn = n .setPrecision(2*digits) .inverse();
		//
		//  and then use .mod(n, invn) instead of .mod(n).
		
		
		if (this.isComplex())
		{
			Number real = this.toReal() .mod(n, inv);
			Number imag = this.toImag() .mod(n, inv);
			
			return new Number(real, imag);
		}
		
		if (!this.isInteger() || !n.isInteger())
		
		    return this.mod(n);
		
		//  If the number is too large for the modulus
		//  then use the mod(Number) method to avoid an
		//  arithmetic exception
		
		if (this.trim().length() > 2*n.length())
		
		    return this.mod(n);
		
		Number r = new Number(this);
		
		//  Calculate the quotient q = [ r * inv ]
		
		Number q = r .multiply(inv) .toInteger() .add(1);
		
		//  Reduce the residue modulo n
		
		r = r .subtract(q.multiply(n));
		
		while (r.signum() == -1) r = r .add(n);
		
		if (r.equals(n)) r = new Number(0);
		
		if (!r.isLessThan(n))
		{
			System.out.println("mod(n, invn) error");
			System.out.println("a == " + this);
			System.out.println("r == " + r);
			System.out.println("n == " + n);
			
			throw new ArithmeticException();
		}
		
		return r;
	}
	
	
	public Number modDivide(Number divisor, int n)
	{
		return modDivide(divisor, new Number(n));
	}
	
	public Number modDivide(int divisor, Number n)
	{
		return modDivide(new Number(divisor), n);
	}
	
	public Number modDivide(Number divisor, Number n)
	{
		//  modular division
		
		//  This method allows the user to compute a / b  (mod n)
		//
		//  by using  a .modDivide(b, n)  instead of
		//
		//  a .multiply(b.modInverse(n)) .mod(n)
		
		
		if (!this.isInteger() || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		Number a = this .mod(n);
		
		if (!this.isInteger() || !divisor.isInteger() || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		if (divisor.isComplex())
		
		    return a .multiply( divisor.complexInverse(n) ) .mod(n);
		
		if (divisor.equals(0) || !divisor.isCoprimeWith(n)) return null;
		
		//  Compute the modular quotient
		
		Number quotient = a .multiply( divisor .modInverse(n) ) .mod(n);
		
		if (! quotient .multiply(divisor) .mod(n) .equals(a) )
		
		    throw new ArithmeticException();
		
		return quotient;
	}
	
	
	public Number modInverse(long modulus)
	{
		return modInverse(new Number(modulus));
	}
	
	public Number modInverse(Number n)
	{
		//  returns the modular inverse of a number
		//
		//  The modular inverse of a number a is the solution to
		//  the congruence or modular equation a x == 1 (mod n)
		
		if (!this.isInteger()) throw new IllegalArgumentException();
		
		if (this.isComplex()) return this.complexInverse(n);
		
		if (this.equals(1)) return new Number(this);
		
		char sign = (this.sign == '+') ? '+' : '-';
		
		Number a = new Number(this) .abs();
		
		if (this.equals(0) || !this.isCoprimeWith(n))
		{
			String message = "non-invertible number";
			
			System.out.println();
			System.out.println("a == " + this.toString(16));
			System.out.println("n == " +    n.toString(16));
			System.out.println("gcd == " + this.gcd(n).toString(16));
			
			throw new ArithmeticException(message);
		}
		
		
		Number inva = a .modInverse1(n);
		
		
		//  Check the answer
		
		if (! inva.multiply(a).mod(n).equals(1) )
		{
			String message = "modular inversion or division error";
			
			throw new ArithmeticException(message);
		}
		
		//  Replace the sign
		
		if (sign == '-')
		
		    inva = n.subtract(inva);
		
		return inva;
	}
	
	
	
	private Number modInverse1(Number n)
	{
		//  This method implements the extended Euclidean algorithm
		
		if (!this.isInteger() || (this.sign == '-')
		    || !n.isInteger() || (   n.sign == '-'))
		
		    throw new IllegalArgumentException();
		
		//  variables:  a, b, q, r,  x, x1, x2,  y, y1, y2;
		
		Number a, b, q, r;
		
		a = b = q = r = null;
		
		Number x = null, x1 = null, x2 = null;
		Number y = null, y1 = null, y2 = null;
		
		x1 = new Number(0);  x2 = new Number(1);
		y1 = new Number(1);  y2 = new Number(0);
		
		a = new Number(this) .abs() .mod(n);
		
		b = new Number(n);
		
		while (!a.equals(0))
		{
			q = b.divide(a);
			
			r = b. subtract(q.multiply(a));
			
			x = x2.subtract(q.multiply(x1));
			y = y2.subtract(q.multiply(y1));
			
			x2 = x1;  x1 = x;
			y2 = y1;  y1 = y;
			
			b = a;    a = r;
		}
		
		if (!b.equals(1))
		{
			String message = "number " + this.toString() +
			
			    " is not invertible " + "modulo " + n.toString(10);
			
			message += "\n\ngcd =  " + b.toString(10);
			
			throw new ArithmeticException(message);
		}
		
		Number inva = y2;
		
		inva.sign = sign;
		
		Number product = inva.multiply(this) .mod(n);
		
		if (product.abs() .equals(n.subtract(1)))
		
		    inva = inva.negate(n);
		
		return inva;
	}
	
	
	
	
	private Number modMultiply(Number yr, Number n, Number n1, Number r)
	{
	
		//  Montgomery multiplication
		//
		//  This method performs modular multiplication without division.
		//  This is useful for methods that require large numbers of
		//  modular multiplications such as modular exponentiation.
		
		
		//  Montgomery multiplication computes the product
		//
		//  zr == xr yr r^-1 == x y r^2 r^-1 == x y r == z r
		//
		//  modulo n where xr = x r (mod n),  yr = y r (mod n),
		//
		//  r == 2^k,  n1 == - n ^-1 (mod r),  and (n, r) == 1.
		//
		//  r is chosen to be 2^k so that shifts and ands can be used
		//  instead of divs and mods (quotients and remainders).
		//
		//  In modular exponentiation, the r can be removed from the
		//  product zr by performing a final Montgomery multiplication
		//  with xr equal to zr, and yr equal to 1 instead of 1 r; then
		//  (xr = zr) * (yr = 1) == (zr * 1) * r^-1 == z r / r == z.
		
		
		//  Compute  zr = (xr * yr) * r^-1 (mod n)
		
		Number xr = this;
		
		int k = 32 * n.length();
		
		Number r1 = r.subtract(1);
		
		//  zr = ( xy + ( xy n1 mod r ) n ) / r
		
		Number xy = xr .multiply(yr);
		
		Number xy_n1 = xy .and(r1) .multiply(n1) .and(r1);
		
		Number xy_n1_n = n .multiply(xy_n1);
		
		Number zr = xy .add(xy_n1_n);
		
		zr = zr .shiftRight(k);
		
		if (zr.compareTo(n) >= 0)
		
		    zr = zr .subtract(n);
		
		return zr;
	}
	
	
	
	private Number modPow1(Number exp, Number n)
	{
		//  Montgomery exponentiation
		
		//  Define the variables
		//
		//  r = 2 ^ k,
		//
		//  n1 = - (n ^-1) mod r
		//
		//  a1 = a r (mod n)
		//  y1 = y r (mod n)
		
		
		int k = 32 * n.length();
		
		Number r = new Number(2).pow(k);
		
		Number a = this.mod(n);
		Number y = new Number(1);
		Number x = new Number(exp);
		
		
		Number a1 = a .multiply(r) .mod(n);
		Number y1 = y .multiply(r) .mod(n);
		
		
		//  Compute  n1 = r - 1 / n (mod r)
		
		Number n1 = r.subtract(n.modInverse(r));
		
		
		//  Compute y = a ^ x (mod n)
		
		//  Use the square and multiply method
		
		while (!x.equals(0))
		{
			//  Accumulate squares for each 1-bit
			
			if (x.testBit(0))
			
			    y1 = a1 .modMultiply(y1, n, n1, r);
			
			//  y' = a' y' = (a r) (y r) r^-1 = a y r (mod n)
			
			//  Square the square
			
			a1 = a1 .modMultiply(a1, n, n1, r);
			
			//  a'^2 = (a r) (a r) r^-1 = a^2 r (mod n)
			
			//  Shift the exponent to the next bit
			
			x = x.shiftRight(1);
		}
		
		//  Remove the residue r from y1 = a^x r (mod n)
		//  by multiplying by 1 instead of by 1 r
		
		y = y1 .modMultiply(new Number(1), n, n1, r);
		
		return y;
	}
	
	
	public Number modPow(int exp, int m)
	{
		return modPow(new Number(exp), new Number(m));
	}
	
	public Number modPow(int exp, Number m)
	{
		return modPow(new Number(exp), m);
	}
	
	public Number modPow(Number exp, int m)
	{
		return modPow(exp, new Number(m));
	}
	
	public Number modPow(Number exp, Number n)
	{
		//  computes y = a ^ x (mod n)
		
		if (!exp.isInteger())
		{
			String message =
			
			    "Use the pow method for non-integer exponents";
			
			throw new IllegalArgumentException(message);
		}
		
		//  modular exponentiation is defined only for integers
		
		if (!this.isInteger() || !n.isInteger())
		{
			String message = "non-integer modulus or base";
			
			throw new IllegalArgumentException(message);
		}
		
		if (exp .equals(0)) return new Number(1);
		if (this.equals(0)) return new Number(0);
		
		if (n.signum() == -1)
		{
			String message = "negative modulus";
			
			System.out.println("n == " + n);
			
			throw new IllegalArgumentException(message);
		}
		
		
		Number a = this .mod(n);
		
		Number x = new Number(exp);
		
		
		//  The BigInteger modPow method makes the nextPrime method several
		//  times faster for finding primes that are greater than 256 bits
		
		//  The BigInteger class uses a faster algorithm for modular exponentiation
		
		if (!this.isComplex())
		{
			//  Convert Number to BigInteger to compute the modPow and then back to Number
			
			BigInteger bigthis = new BigInteger(a.toString(16), 16);
			BigInteger bigexp  = new BigInteger(x.toString(16), 16);
			BigInteger bign    = new BigInteger(n.toString(16), 16);
			
			return new Number(bigthis.modPow(bigexp, bign).toString(16), 16);
		}
		
		
		//  Compute y = a ^ x (mod n)
		
		Number y = new Number(1);
		
		
		if (exp.signum() == -1) { a = a.modInverse(n); x = x.abs(); }
		
		if (n.isInteger() && !n.isEven() && !this.isComplex())
		
		     return a.modPow1(x, n);
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		int digits = (int) n.bitCount() / 4;
		
		Number invn = n .setPrecision(2*digits) .inverse();
		
		
		//  Use the square and multiply method
		
		//  (This method works for real and complex numbers
		//  because it uses multiply and divide / mod methods)
		
		while (x.bitCount() != 0)
		{
			//  Accumulate squares for each 1-bit
			
			if (x.testBit(0))
			{
				y = a .multiply(y);
				
				if (!y.isComplex())
				
				     y = y .mod(n, invn);
				else y = y .mod(n);
			}
			
			//  Square the square
			
			a = a .square();
			
			if (!a.isComplex())
			
			     a = a .mod(n, invn);
			else a = a .mod(n);
			
			//  Shift the exponent to the next bit
			
			x = x.shiftRight(1);
		}
		
		return y;
	}
	
	
	
	
	//  This method has not been tested or debugged
	
	//  The modRoot(k, n) method calls the modRoot1 method for a composite modulus,
	//  and then the modRoot1(k, n) method iteratively or recursively calls the
	//  modRoot method for each prime power in the modulus, just as the toString(
	//  digits, radix) method calls the toString1 method for large strings which
	//  iteratively or recursively calls the toString method.
	
	private Number[] modRoot1(int k, Number n)
	{
		//  returns the modular roots for a composite modulus by factoring
		//  the modulus n = p1 p2 ... pm, iterating to find the reduced roots
		//  for each prime power, and then computing the k^m composite roots
		//  modulo n using Gauss's algorithm or the least common remainder
		//  method lcr = lcr(r[], p[]) for the k^m combinations of r[].
		//
		//  For example if the root index k = 2 and the modulus has two
		//  prime powers, then the k^m == 2^2 == 4 combinations of r[][]
		//  would be r[1] = { r1, r2 }, r[2] = { r1, -r2 }, r[3] = { -r1,
		//  r2 }, r[4] = { -r1, -r2 }.
		//
		//  The k^m == 2^2 == 4 common or composite roots would be
		//  R1 = lcr1 = lcr(r[1][], p[]), R2 = lcr2 = lcr(r[2][], p[]),
		//  R3 = lcr3 = lcr(r[3][], p[]), R4 = lcr4 = lcr(r[4][], p[]).
		//
		//  Writing all the combinations requires a counter in base k
		//  that has m digits where each digit i and value j are the two
		//  indexers for the reduced root arrays r[][].
		
		
		if (n.bitCount() >= 64) throw new IllegalArgumentException();
		
		long modulus = n.longValue();
		
		int[] primes = Math.factor(modulus);
		
		int[][] prime_exp = Math.sortAndCollate(primes);
		
		final int m = prime_exp.length;
		
		int[] factors = new int[m];
		
		Number[][] roots = new Number[m][];
		
		for (int i = 0; i < prime_exp.length; i++)
		{
			int prime = prime_exp[i][0];
			int exp   = prime_exp[i][1];
			
			int factor = (int) Math.pow(prime, exp);
			
			factors[i] = factor;
		}
		
		//  Compute the reduced roots for each prime power
		
		for (int i = 0; i < factors.length; i++)
		
		    roots[i] = modRoot(k, new Number(factors[i]));
		
		//  Create an m-digit counter in base k
		
		Number counter = new Number((int) Math.pow(k, m) - 1);
		
		//  Create an array of arrays to write the combinations
		
		int[][] R_arrays = new int[(int) Math.pow(k, m)][m];
		
		for (int i = 0; i < R_arrays.length; i++)
		for (int j = 0; j < m; j++)
		
		    R_arrays[i][j] = counter.getDigits(i, i+1, k).intValue();
		
		//  Compute the array of common or composite roots from
		//  the arrays of reduced roots { r1[], r2[], ..., rm[] }.
		
		Number[] R_array = new Number[R_arrays.length];
		
		for (int i = 0; i < R_array.length; i++)
		
		    R_array[i] = Math.lcr(R_arrays[i], factors);
		
		//  Return the common modular roots
		
		return R_array;
	}
	
	
	
	//  This method has not been tested or debugged
	
	public Number[] modRoot(int k, Number p)
	{
	
		//  the modular root extractor
		//
		//  computes the k kth roots of a number modulo p if the index k is co-
		//  composite with the totient. If the index is coprime, then finding the
		//  mod root is the coprime root extraction problem m = c ^ (1/k) (mod n).
		
		//  The root index can be any integer except for zero because 1 / k is un-
		//  defined for k == 0; a negative k inverts the root because 1 /-1 == -1;
		//  a unit k returns the same number because 1 / 1 == 1.
		
		
		if (!p.isPrime()) return modRoot1(k, p);
		
		Number residue = this.mod(p);
		
		//                                  k-1
		//  totient( n = p^k ) == (p - 1) p
		
		Number totient = p.subtract(1);
		
		if (!p.isPrimePower()) totient = p.subtract(1);
		
		else if (p.isPower(2)) totient = p.root(2).subtract(1).multiply(p.root(2));
		else if (p.isPower(3)) totient = p.root(3).subtract(1).multiply(p.root(3));
		
		
		if (k < 0) { residue = residue.modInverse(p); k *= -1; }
		
		if ((k == 0) || !p.isPrime()) throw new IllegalArgumentException();
		
		//  If the totient has a factor k then the number has to be a kth residue
		//  or else there is no solution because k is non-invertible modulo p-1
		
		if (!totient.isCoprimeWith(k) && !residue.isResidue(k, p)) return null;
		
		//  If the root index is coprime with the totient (which includes k = 1)
		//  then return the coprime root == residue ^ (k^-1 mod (p-1)) (mod p)
		
		if (totient.isCoprimeWith(k)) return new Number[] // residue ^ (1/k mod (p-1))
		
		    { residue .modPow( new Number(k) .modInverse(totient), p ) };
		
		if (k == 2)
		{
			Number r = modSqrt(p);
			
			return new Number[] { r, r.negate(p) };
		}
		
		Number phi = totient;
		
		int s = 0;
		
		//  Count the number of k's
		
		while (phi.isDivisibleBy(k))
		
		    { phi = phi.divide(k); s++; }
		
		Number q = phi.divide(new Number(k).pow(s));
		
		//  Find a kth non-residue z
		
		Number z = new Number(2);
		
		while (!z.modPow(phi.divide(k), p)
		
		  .equals(p.subtract(1))) z = z.add(1);
		
		Number n = this.mod(p);
		
		Number c = new Number(z) .modPow(q, p);
		
		Number t = n.modPow(q, p);
		
		Number r = n.modPow(q.add(1).divide(2), p);
		
		int m = s;
		
		while(!t.mod(p).equals(1))
		{
			//  Find the least value of i
			//
			//              k^i
			//  such that t    == 1 mod p
			
			int i = 0;
			
			while (!t.modPow(new Number(k)
			
			    .pow(++i), p).equals(1)) ;
			
			Number t1 = t;
			
			//              m-i-1
			//            k
			//  Let b = c        (mod p)
			
			Number exp = new Number(k).pow(m-i-1);
			
			Number b = c.modPow(exp, p );
			
			c = b .pow(k) .mod(p);
			
			t = t.multiply(b.pow(k)) .mod(p);
			
			r = r.multiply(b) .mod(p);
			
			m = i;
		}
		
		if (!r.pow(k).mod(p).equals(n))
		{
			System.out.println("n == " + n);
			System.out.println("p == " + p);
			System.out.println("r == " + r);
			System.out.println("r^k == " + r.modPow(k, p));
			
			throw new ArithmeticException();
		}
		
		
		//  Compute all the kth roots by multiplying
		//  by the k powers of r1 = z^((p-1)/k) (mod p)
		//  or the root of 1 (mod p).
		
		Number r1 = z.modPow(phi.divide(k), p);
		
		Number[] kth_roots = new Number[k];
		
		for (int i = 0; i < k; i++)
		
		    kth_roots[i] = r.multiply(
		
			r1.modPow(i, p)) .mod(p);
		
		return kth_roots;
	}
	
	
	
	public Number modSqrt(Number p)
	{
		if (!this.isQuadraticResidue(p))
		
		    throw new IllegalArgumentException();
		
		if (p.equals(2)) return this.mod(2);
		
		if (this.equals(0)) return new Number(0);
		if (this.equals(1)) return new Number(1);
		
		Number sqrt = null;
		
		//  If p is a prime power use Tonelli's algorithm because
		//  only Tonelli's formula works for prime powers unless
		//  Cipolla's algorithm can be modified to compute square
		//  roots modulo prime powers.
		
		if (p.isPrimePower()) return modSqrt1(p);
		
		//  Tonelli's algorithm is faster if the totient
		//  has a small number of twos, but Cipolla's algo-
		//  rithm is faster if the totient has a large num-
		//  ber of twos because Cipolla's method requires
		//  only one exponentiation modulo p.
		
		if (p.subtract(1).countTwos() < p.bitCount()/8)
		
		     return modSqrt1(p);
		else return modSqrt2(p);
	}
	
	
	
	private Number modSqrt1(Number p)
	{
	
		//  Tonelli's algorithm for mod sqrts
		//
		//  Tonelli's algorithm (1891) is also called
		//  Tonelli-Shanks (1973) because Shanks developed
		//  an equivalent algorithm that is slightly less
		//  redundant than Tonelli's original algorithm.
		//
		//  This method is very slow if the totient of p^k
		//  or (p-1) p^(k-1) has a large number of twos
		
		
		//  Compute the totient of p
		//                            k-1
		//  phi( n = p^k ) == (p-1) p
		
		Number phi = p.subtract(1);
		
		if (!p.isPrimePower()) phi = p.subtract(1);
		
		else if (p.isPower(2)) phi = p.root(2).subtract(1).multiply(p.root(2));
		else if (p.isPower(3)) phi = p.root(3).subtract(1).multiply(p.root(3));
		
		
		final int s = (int) phi.countTwos();
		
		Number q = phi.divide(new Number(2).pow(s));
		
		//  Find a quadratic non-residue z
		
		Number z = new Number(2);
		
		while (!z.modPow(phi.divide(2), p)
		
		    .equals(p.subtract(1)))
		
			z = z.add(1);
		
		Number n = this.mod(p);
		
		Number c = new Number(z) .modPow(q, p);
		
		Number t = n.modPow(q, p);
		
		Number r = n.modPow(q.add(1).divide(2), p);
		
		int m = s;
		
		while(!t.mod(p).equals(1))
		{
			//  Find the least value of i
			//  such that t ^ (2^i) == 1 mod p
			
			int i = 0;
			
			while (!t.modPow(new Number(2)
			
			    .pow(++i), p).equals(1)) ;
			
			Number t1 = t;
			
			//              m-i-1
			//            2
			//  Let b = c      (mod p)
			
			Number exp = new Number(2).pow(m-i-1);
			
			Number b = c.modPow(exp, p );
			
			c = b.square() .mod(p);
			
			t = t.multiply(b.square()) .mod(p);
			
			r = r.multiply(b) .mod(p);
			
			m = i;
		}
		
		if (!r.square().mod(p).equals(n))
		{
			System.out.println("n == " + n);
			System.out.println("p == " + p);
			System.out.println("r == " + r);
			System.out.println("r^2 == " + r.modPow(2, p));
			
			throw new ArithmeticException();
		}
		
		return r;
	}
	
	
	
	public Number modSqrt2(Number p)
	{
	
		//  Cipolla's algorithm for modular square roots uses a
		//  single modular exponentiation to find the squre root
		//  of a number modulo p
		//
		//  Cipolla's algorithm is faster than Tonelli's algorithm
		//  if the totient has a large number of twos; but it is
		//  slower for random moduli because the algorithm has to
		//  do a modular exponentiation which requires O(p) multi-
		//  precision multiplications or O(p^3) single-precision
		//  operations and it also uses complex multiplication
		//  which makes it 4 times slower.
		
		
		
		//  Modular square root algorithm:
		//
		//  Input:  a quadratic residule n modulo p
		//  Output: a square root r = n^(1/2) mod p
		//
		//  Find an a such that a^2 - n is a
		//  quadratic non-residue modulo p;
		//
		//  then compute the value
		//
		//             (p+1)/2
		//  r = (a + b)       (mod p)
		//
		//  where b = sqrt(a^2 - n) is an imaginary number,
		//  except than unlike i^2 == - 1, b^2 == a^2 - n.
		//
		//  Each multiplication of (c1 + c2 b) (c3 + c4 b)
		//  == (c5 + c6 b) where c5 = c1 c3 + c2 c4 b^2,
		//  c6 = (c1 c4 + c2 c3) b
		//
		//  just like multiplying two complex numbers
		//  (c1 + c2 i) (c3 + c4 i) == (c5 + c6 i) where
		//  c5 = c1 c3 + c2 c4 i^2, c6 = (c1 c4 + c2 c3) i.
		//
		//  The coefficient of b for x = (a + b) ^ ((p+1)/2)
		//  will equal 0 (mod p) so we don't have to compute
		//  b = sqrt(a^2 - n) which doesn't exist because a^2 -
		//  n is chosen to be a quadratic non-residue modulo p.
		
		
		
		//  Find an a such that a^2 - n
		//  is non-square modulo p
		
		Number n = this.mod(p);
		
		Number a = new Number(2);
		
		while (a.square().subtract(n)
		
		   .isQuadraticResidue(p))
		
		      a = a .add(1);
		
		
		//  Define the exponent x = (p+1)/2
		
		Number x = p.add(1) .divide(2);
		
		//  Define the imaginary number
		//
		//  b = sqrt(a^2 - n) mod p
		
		Number b2 = a.square().subtract(n).mod(p);
		
		
		//  Initialize y to 1 + 0 b == 1
		//
		//  (y is a complex number in which the
		//  imaginary unit is b = sqrt(a^2 - n))
		
		Number y1 = new Number(1);
		Number y2 = new Number(0);
		
		//  Initialize a to a + 1 b == a + b
		
		Number a1 = new Number(a);
		Number a2 = new Number(1);
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		int digits = (int) p.bitCount() / 4;
		
		Number invp = p .setPrecision(32 + digits) .inverse();
		
		
		//  Compute y = a ^ x (mod p)
		
		while (x.bitCount() != 0)
		{
			//  Accumulate squares for each 1-bit
			
			if (x.testBit(0))
			{
				//  Compute the product of a and y (mod p)
				//
				//  (c1 + c2 b) (c3 + c4 b) == (c5 + c6 b)
				//  where c5 =  c1 c3 + c2 c4 b^2,
				//        c6 = (c1 c4 + c2 c3) b
				
				Number c1 = a1, c2 = a2;
				Number c3 = y1, c4 = y2;
				
				Number c5 = c1.multiply(c3) .add(c2.multiply(c4).multiply(b2));
				Number c6 = c1.multiply(c4) .add(c2.multiply(c3));
				
				c5 = c5 .mod(p, invp);
				c6 = c6 .mod(p, invp);
				
				y1 = c5;  y2 = c6;
			}
			
			//  Square the square
			
			{	//                            2^i
				//  Compute the powers (a + b)   (mod p)
				//
				//  (c1 + c2 b) (c3 + c4 b) == (c5 + c6 b)
				//  where c5 =  c1 c3 + c2 c4 b^2,
				//        c6 = (c1 c4 + c2 c3) b
				
				Number a3 = a1,  a4 = a2;
				Number a5 = a1.multiply(a3) .add(a2.multiply(a4).multiply(b2));
				Number a6 = a1.multiply(a4) .add(a2.multiply(a3));
				
				a5 = a5 .mod(p, invp);
				a6 = a6 .mod(p, invp);
				
				a1 = a5;  a2 = a6;
			}
			
			//  Shift the exponent to the next bit
			
			x = x.shiftRight(1);
		}
		
		
		Number r = y1;
		
		if (!r.square().mod(p).equals(n))
		{
			System.out.println("a == " + a);
			System.out.println("p == " + p);
			System.out.println("r == " + r);
			System.out.println("r^2 == " + r.modPow(2, p));
			
			throw new ArithmeticException();
		}
		
		return r;
	}
	
	
	
	public boolean isGenerator(Number p)
	{
		//  tests if a number is a probable generator modulo p
		//
		//  This method only tests the small factors in the totient
		//  because there is no polynomial-time algorithm for factor-
		//  ing numbers.
		
		//  Find all the small factors in the totient up to some value
		
		int maxprime = 16*1024;
		
		Number totient = p.subtract(1);
		
		int[] factors = totient.factor(maxprime);
		
		for (int factor : factors)
		{
			Number exp = totient .divide(factor);
			
			if (this.modPow(exp, p).equals(1))
			
			    return false;
		}
		
		return true;
	}
	
	
	public boolean isResidue(int k, Number p)
	{
	
		//  tests if a number has a modular root for the root index k
		
		//  This method is used by the method to test if a number has a
		//  modular root. For example, if a number is a quadratic non-res-
		//  idue modulo p, then there is no square root for that modulus.
		//
		//  The isResidue method is also used to find a generator modulo p.
		//  A number a is a generator mod p if a ^ x (mod p) generates all
		//  the values from 1 to -1 (mod p).
		//
		//  To test if a number a is a generator mod p, factor phi(p) ==
		//  fact(p-1) and then for each k[i] in the factorization, test
		//  if r[i] = a ^ ((p-1) / k[i]) == 1 mod p. If any test equals 1,
		//  then a is not a generator mod p because it contains a factor
		//  of k[i] in the exponent. If r[i] != 1 for all values of k[i],
		//  then a is a generator modulo p.
		
		Number totient = p.subtract(1);
		
		if (!p.isPrime())
		{
			String message = "Modulus is non-prime";
			
			throw new IllegalArgumentException(message);
		}
		
		if (!Math.isPrime(k))
		{
			String message = "Factor the root index";
			
			throw new IllegalArgumentException(message);
		}
		
		if (!totient.isDivisibleBy(k))
		{
			String message =
			
			    "All numbers are kth residues modulo p " +
			    "because the root index k is coprime " +
			    "with the totient of p";
			
			throw new IllegalArgumentException(message);
		}
		
		
		//           (p-1)/k
		//  Test if r       == 1 (mod p)
		//
		//  If the residue contains a factor k in the exponent
		//  then r == a^(x k) which means that a^(x k)^((p-1)/k)
		//  == a^((p-1)x) == a^(0) == 1 (mod p).
		//
		//  If the residue doesn't contain a k in the exponent
		//  then a^x ^ ((p-1)/k) == the kth root of 1 which is
		//  != 1 mod p.)
		
		return this.modPow(totient.divide(k), p).equals(1);
	}
	
	
	
	public static Number multiply(int[] n)
	{
		//  returns the product of n[] by multiplying
		//  iteratively in pairs until the array size == 1
		
		//  Copy and expand the array to a power of 2
		
		int size = n.length;
		
		while (!Math.isPowerOf2(++size)) ;
		
		Number[] n1 = new Number[size];
		
		for (int i = 0; i < n.length; i++)
		
		    n1[i] = new Number(n[i]);
		
		for (int i = n.length; i < n1.length; i++)
		
		    n1[i] = new Number(1);
		
		
		//  For each iteration multiply the elements
		//  in pairs and halve the size of the array
		
		size = n1.length;
		
		for (int t = size/2; t >= 1; t/=2)
		{
			Number[] products = new Number[t];
			
			for (int i = 0; i < products.length; i++)
			
			    products[i] = n1[2*i].multiply(n1[2*i+1]);
			
			n1 = products;
		}
		
		if (n1.length != 1) throw
		
		    new ArithmeticException();
		
		return n1[0];
	}
	
	
	public static Number multiply(Number[] n)
	{
		//  returns the product of the elements of n[]
		
		if (n.length < 1024)
		{
			Number product = new Number(1);
			
			for (int i = 0; i < n.length; i++)
			
			    product = product.multiply(n[i]);
			
			return product;
		}
		
		//  Copy and expand the array to a power of 2
		
		int size = n.length;
		
		while (!Math.isPowerOf2(++size)) ;
		
		Number[] n1 = new Number[size];
		
		for (int i = 0; i < n.length; i++) n1[i] = n[i];
		
		for (int i = n.length; i < n1.length; i++)
		
		    n1[i] = new Number(1);
		
		
		//  For each iteration multiply the elements
		//  in pairs and halve the size of the array
		
		size = n1.length;
		
		for (int t = size/2; t >= 1; t/=2)
		{
			Number[] products = new Number[t];
			
			for (int i = 0; i < products.length; i++)
			
			    products[i] = n1[2*i].multiply(n1[2*i+1]);
			
			n1 = products;
		}
		
		if (n1.length != 1) throw
		
		    new ArithmeticException();
		
		return n1[0];
	}
	
	
	public static Number[] multiply(Number[] array, Number n)
	{
		//  multiplies an array by n
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].multiply(n);
		
		return array1;
	}
	
	
	public Number multiply(int multiplier)
	{
		return this.multiply(new Number(multiplier));
	}
	
	public Number multiply(long multiplier)
	{
		return this.multiply(new Number(multiplier));
	}
	
	public Number multiply(double multiplier)
	{
		return this.multiply(new Number(multiplier));
	}
	
	
	public Number multiply(Number multiplier)
	{
		//  multiplies two numbers using the Math multiply method
		
		//  Multiplication can also be done by squaring numbers using the identity
		//
		//  (a + b)^2 - (a - b)^2 == a^2 + 2 a b + b^2 - (a^2 - 2a b + b^2) == 4 a b
		//
		//  (The 4 is removed by shifting two bits to the right)
		
		
		Number mult = multiplier;
		
		if (this.isComplex() || mult.isComplex())
		{
			//  Compute the complex product
			//
			//  (a1 + i b1) * (a2 + i b2) == (a1 a2 - b1 b2) + i (a1 b2 + a2 b1)
			
			Number real1, real2, imag1, imag2;
			
			real1 = this.toReal();  imag1 = this.toImag();
			real2 = mult.toReal();  imag2 = mult.toImag();
			
			Number real = real1.multiply(real2) .subtract(imag1.multiply(imag2));
			Number imag = real1.multiply(imag2)      .add(real2.multiply(imag1));
			
			return new Number(real, imag);
		}
		
		
		//  below size1 the math multiplier will call the grade-school / quadratic multiplier
		//  above size1 the Number multiplier will call the Karatsuba / sesquilinear or 3/2 multiplier
		//  above size2 the math multiplier will call the Fourier / linear log multiplier
		
		
		//  Set the minimum threshold for the Karatsuba / three-halves multiplier
		
		final int karatthreshold = 64; //  64 ints ~ 2 K bits
		
		//  Set the minimum threshold for the fft / linear log multiplier
		//
		//  the fft threshold is set to infinity until the fft multiply method is debugged
		
		final int fftthreshold = 1024*1024*1024; ////  8*1024; // 8 K ints * 32 bits / int == 256 K bits
		
		
		//  product == multiplicand x multiplier
		
		int precision = Math.max(this.precision, mult.precision);
		
		Number product;
		
		if ((this.intarray.length < karatthreshold) || (mult.intarray.length < karatthreshold))
		
		    product = new Number(Math.multiply(this.intarray, mult.intarray));
		
		else if ((this.intarray.length > fftthreshold) && (mult.intarray.length > fftthreshold))
		
		    product = new Number(Fourier.multiply(this.intarray, mult.intarray));
		
		else product = multiplyKaratsuba(new Number(this.intarray), new Number(mult.intarray));
		
		product.intpoint = this.intpoint + mult.intpoint;
		
		product = product .trim() .setPrecision(precision);
		
		product.sign = ((this.sign != mult.sign)
		
		    && !product.equals(0)) ? '-' : '+';
		
		return product;
	}
	
	
	
	
	public static Number multiplyKaratsuba(Number x, Number y)
	{
	
		//  Karatsuba Multiplication (Karatsuba and Ofman, Soviet Physics, 1963)
		//
		//  Karatsuba multiplication uses only three multiplications instead of four.
		//
		//  Let N1 and N2 be two-digit numbers where N1 = a1 a0  and  N2 = b1 b0.
		//
		//  Instead of computing the product N1 * N2 as the sum of four single-digit products
		//
		//      a1 * b1 << 2  +  [ (a1 * b0 + a0 * b1) ] << 1  +  a0 * b0 << 0
		//
		//  compute the product N1 * N2 as the sum of three single-digit products
		//
		//      a1 * b1 << 2  +  [ ( (a0 + a1) * (b0 + b1) - a0 * b0 - a1 * b1 ) ] << 1  +  a0 * b0 << 0
		//
		//  Only one cross product (a0 + a1) * (b0 + b1) is computed instead of two cross products a1 * b0 and a0 * b1.
		//
		//
		//  Example  1234 * 5678 = [12][34] * [56][78]  (the "digit" size for this example is 10^2 or 100)
		//
		//  == ( 34 * 78 ) * 100^0 + ( 12 * 56 ) * 100^2 + ( (12 + 34) * (56 + 78) - (34 * 78) - (12 * 56) ) * 100^1
		//
		//  == ( 34 * 78 ) << 0 + ( 12 * 56 ) << 2 + ( (12 + 34) * (56 + 78) - (34 * 78) - (56 * 12) ) << 1
		
		
		//  Karatsuba multiplication has a running time of O(n ^ log2(3)) == O(n ^ 1.58)
		//  Quadratic multiplication has a running time of o(n ^ log2(4)) == O(n ^ 2.00)
		
		
		//  This method was excerpted / extracted from the Java BigInteger class.
		
		int xlen = x.length();
		int ylen = y.length();
		
		//  the number of ints in each half of the number
		
		int half = (Math.max(xlen, ylen) + 1) / 2;
		
		//  Assign the upper and lower halves of x and y
		
		Number xl = x.getLower(half);
		Number xh = x.getUpper(half);
		
		Number yl = y.getLower(half);
		Number yh = y.getUpper(half);
		
		//  Compute the products of the upper digits and lower digits
		
		Number p1 = xh.multiply(yh); // p1 = xh * yh
		Number p2 = xl.multiply(yl); // p2 = xl * yl
		
		//  Compute the cross products of the sums of the upper and lower digits
		
		//  p3 = (xh + xl) * (yh + yl)
		
		Number p3 = xh.add(xl) .multiply(yh.add(yl));
		
		//  result = p1 * 2^(32*2*half) + (p3 - p1 - p2) * 2^(32*1*half) + p2
		
		Number result = p1.shiftLeft(32*half, 32*half)
		
		    .add( p3.subtract(p1).subtract(p2) )
		
			.shiftLeft(32*half, 32*half) .add(p2);
		
		if (x.signum() != y.signum())
		
		     return result.negate();
		
		else return result;
	}
	
	
	public Number negate()
	{
		//  negates the number
		
		Number number = new Number(this);
		
		if      (this.sign == '+')  number.sign = '-';
		else if (this.sign == '-')  number.sign = '+';
		
		if      (this.sign1 == '+')  number.sign1 = '-';
		else if (this.sign1 == '-')  number.sign1 = '+';
		
		return number;
	}
	
	public Number negate(int n)
	{
		return negate(new Number(n));
	}
	
	public Number negate(Number n)
	{
		//  negates the number modulo n
		
		if (n == null) return negate();
		
		return n.subtract(this.mod(n)) .mod(n);
	}
	
	
	public Number nextPrime()
	{
		//  returns the next prime
		
		if (!this.isInteger())
		
		    throw new IllegalArgumentException();
		
		Number n = new Number(this);
		
		if (n.isLessThan(2)) return new Number(2);
		
		if (n.isEven()) n = n.add(1);
		else            n = n.add(2);
		
		while (!n.isPrime()) n = n.add(2);
		
		return n;
	}
	
	
	public Number not()
	{
		//  complements the bits
		
		int[] array = Math.not(this.intarray);
		
		int bitcount = (int) this.bitCount() % 32;
		
		array[0] &= (1 << (bitcount-1));
		
		return new Number(array);
	}
	
	
	public Number or(Number val)
	{
		//  ors two numbers
		
		return new Number(Math.or(this.intarray, val.intarray));
	}
	
	
	
	
	//   Iterative formulas for pi
	//
	//
	//   a[0] = 1; a[n+1] = (1 + 1 / (1 + 2 n)) a[n];
	//
	//   pi = limit a[n]^2 / n
	//
	//                           n
	//   (Newton)  pi/4  ==  (-1)  / (1 + 2 n) == 1 - 1/3 + 1/5 - 1/7 + ...
	//
	//           _        (n^2-n)/2
	//   pi / 2\/2 == (-1)         / (1 + 2 n) == 1 + 1/3 - 1/5 - 1/7 + ...
	//
	//
	//                        ___  4 n^2 - 0    2 2  4 4  6 6  8 8
	//   (John Wallis)  pi == | |  --------- == ---  ---  ---  ---  ...
	//                        n=1  4 n^2 - 1    1 3  3 5  5 7  7 9
	//
	//
	//                i pi
	//   (L. Euler)  e     +  1 == 0
	//
	//    pi^2      __    1
	//    ----  ==  \    ---  ==  1/1 + 1/4 + 1/9 + 1/16 + ...
	//     6        /_   m^2
	//              m=1
	//    pi^2      __    1
	//    ----  ==  \    ---  ==  1/1 + 1/16 + 1/81 + 1/256 + ...
	//     90       /_   m^4
	//              m=1
	//                  __                        __
	//    pi^2          \         1               \    (1 m)!^2
	//    ----  ==   3  /_   ------------  ==  3  /_   ----------
	//     6            m=1  m^2 (2m C m)         m=1  m^2 (2 m)!
	//
	//
	//    (Louis Comtet)
	//                  __                        __
	//    pi^2      36  \         1           36  \    (1 m)!^2
	//    ----  ==  --  /_   ------------  == --  /_   ----------
	//     90       17  m=1  m^4 (2m C m)     17  m=1  m^4 (2 m)!
	//
	//
	//   n choose r == n! / r! / (n - r)!, therefore
	//
	//   2m C 1m == (2 m)! / (1 m)! / (1 m)!
	//
	//
	//
	//   (S. Ramanujan)
	//            __
	//    1       \   (2n C n)^3  (42 n + 5)      (2 n)!^3  (42 n + 5)
	//    --  ==  /_  ---------------------- == ------------------------
	//    pi      n=0     2 ^ (12 n + 4)        (1 n)!^6  2 ^ (12 n + 4)
	//
	//              _    __
	//    1       \/8    \    (4 n)! (1103 + 26390 n)
	//    --  ==  ----   /_   -----------------------
	//    pi      9801   n=0  (1 n)!^4   396 ^ (4 n)
	//
	//   (Each term of the series adds about 8 digits)
	//
	//
	//   (Chudnovsky and Chudnovsky)
	//             __
	//    1        \      (-1)^n (6 n)! (A + B n)
	//   ----  ==  /_   -----------------------------
	//   12 pi     n=0  (1 n)!^3 (3 n)! C ^ (n + 1/2)
	//
	//   A = 13591409,  B = 545140134,  C = 640320 ^ 3
	//
	//   (Each term of the series adds about 15 digits)
	//
	//
	//   (Borwein and Borwein)
	//                      __
	//   A = 212175710912 \/61 + 1657145277365
	//                        __
	//   B = 13773980892672 \/61 + 107578229802750
	//                                __
	//   C = [ 5280 (236674 + 30303 \/61) ] ^ 3
	//
	//   (Each term of the series adds about 31 digits)
	
	
	
	
	//   A quadratically convergent formula for pi
	//
	//   (Eugene Salamin and Richard Brent)
	//                          _
	//   Set a0 = 1, b0 = 1 / \/2, s0 = 1/2, then iterate
	//
	//   a[k] = (a[k-1] + b[k-1])/2,
	//            _____________
	//   b[k] = \/a[k-1] b[k-1],
	//
	//   c[k] = a[k]^2 - b[k]^2,
	//
	//   s[k] = s[k-1] - 2^k c[k],
	//
	//   p[k] = 2 a[k]^2 / s[k].
	//
	//   p[k] converges quadratically to pi.
	
	
	
	//   A cubically convergent formula for pi
	//
	//   (Borwein and Borwein)
	//                             _
	//   Set a0 = 1/3, and s0 = (\/3 - 1)/2, then iterate
	//
	//   r[k+1] = 3 / (1 + 2 (1 - s[k]^3) ^ (1/3)),
	//
	//   s[k+1] = (r[k+1] - 1) / 2,
	//
	//   a[k+1] = r[k+1]^2 a[k] - 3^k (r[k+1]^2 - 1).
	//
	//   1/a^k converges cubically to pi
	
	
	
	//   A quartically convergent formula for pi
	//
	//   (Borwein and Borwein)
	//
	//                        _              _
	//   Set a[0]  =  6 - 4 \/2,  y[0]  =  \/2 - 1, and iterate
	//
	//                              4  1/4
	//   	        1 - ( 1 - y[k] )            1 - z
	//   y[k+1]  =  ----------------------  ==  ----- ,
	//                              4  1/4      1 + z
	//   	        1 + ( 1 - y[k] )
	//
	//                               4     2k+3        1        2        3
	//   a[k+1]  =  a[k] (1 + y[k+1])  -  2    ( y[k+1] + y[k+1] + y[k+1] ).
	//
	//   Then a[k] coverges quartically to 1 / pi.
	//
	//
	//   The quartically convergent formula for computing pi is only
	//   2 * (10 multiplies / 16 multiplies) == 1.25 times as fast as
	//   the quadratically convergent formula for pi.
	
	
	
	public static Number pi() { return pi(32); }
	
	
	public static Number pi(int digits)
	{
	
		//  Computes the value of pi or the ratio of the circumference of a circle
		//  to its diameter
		
		//  The pi method is used to generate random public digits for cryptography
		//  and to test the square root, division, and (quadratic / karatsuba / fft)
		//  multiplication methods.
		
		
		//  Example  Compute 1024 digits of pi
		//
		//  Number pi = Number.pi(1024);
		//
		//  System.out.println(pi.toString().trim());
		//
		//  3.141592653589793238462643383279502884197169399375105820974944592307816406286208
		//  99862803482534211706798214808651328230664709384460955058223172535940812848111745
		//  02841027019385211055596446229489549303819644288109756659334461284756482337867831
		//  65271201909145648566923460348610454326648213393607260249141273724587006606315588
		//  17488152092096282925409171536436789259036001133053054882046652138414695194151160
		//  94330572703657595919530921861173819326117931051185480744623799627495673518857527
		//  24891227938183011949129833673362440656643086021394946395224737190702179860943702
		//  77053921717629317675238467481846766940513200056812714526356082778577134275778960
		//  91736371787214684409012249534301465495853710507922796892589235420199561121290219
		//  60864034418159813629774771309960518707211349999998372978049951059731732816096318
		//  59502445945534690830264252230825334468503526193118817101000313783875288658753320
		//  83814206171776691473035982534904287554687311595628638823537875937519577818577805
		//  321712268066130019278766111959092164201989380952572010654858632790
		
		
		
		//  Example  Compute 256 digits of pi in base 2
		//
		//  Number pi = Number.pi(256);
		//
		//  System.out.println(pi.toString(2));
		//
		//  11.00100100001111110110101010001000100001011010001100001000110100110001001100011
		//  00110001010001011100000001101110000011100110100010010100100000010010011100000100
		//  01000101001100111110011000111010000000010000010111011111010100110001110110001001
		//  1100110110010001010
		
		
		
		//  Example  Compute digits of pi from 128 to 65536
		//
		//  and verify the accuracy of the digits
		//
		//  Number[] pi = new Number[10];
		//
		//  for (int i = 0; i < pi.length; i++)
		//
		//      pi[i] = Number.pi(128 * (1 << i));
		//
		//  for (int i = 0; i < pi.length -1; i++)
		//
		//      if (!pi[i+1].toString(16).startsWith(
		//           pi[i+0].toString(16)))
		//
		//  	System.out.println("error");
		
		
		
		//  Example  Compute 256 K digits (1 M bit) of pi and write the output to file
		//
		//  Number pi = Number.pi(256*1024);
		//
		//  String str = pi.toString();
		//
		//  System.out.println(str);
		//
		//  Execute the program and redirect standard output with the > operator
		//
		//  /usr/jdk/jdk-<version>/bin/java -Xmx1g -cp
		//
		//     <class path folder> <program name> <file path>
		
		
		if (digits <= 256)
		
		      return pi11(digits);
		else  return pi1 (digits);
	}
	
	
	
	
	public static Number pi1(int digits)
	{
		//  A quartically convergent formula for pi
		
		long starttime = System.nanoTime();
		
		int d = digits + 96;
		
		Number a, y;
		
		a = new Number(6).setPrecision(d) .subtract(
		    new Number(4).setPrecision(d) .multiply(
		    new Number(2).setPrecision(d) .sqrt() ) );
		
		y = new Number(2) .setPrecision(d) .sqrt() .subtract(1);
		
		for (int k = 0; k < Math.log2(d)/2; k++)
		{
			//  k (d = 16 K) == Math.log2(16K) / 2 ==  7 iterations
			//  k (d =  1 M) == Math.log2(1M) / 2  == 10 iterations
			
			//  or 1 quartic root + 1 cube + 5 squares + 1 divide
			//  + 2 multiplies == 16 multiplies per iteration
			
			Number z = new Number(1) .setPrecision(d) .subtract(y.pow(4)) .root(4);
			
			y = new Number(1).setPrecision(d) .subtract(z) .divide(
			    new Number(1).setPrecision(d) .add(z) );
			
			a = new Number(1).setPrecision(d) .add(y) .square().square()
			    .multiply(a) .subtract( y.cube() .add(y.square()) .add(y)
			        .multiply(new Number(2).pow(2*k + 3)) );
		}
		
		if (digits >= 256)
		{
			long computetime = System.nanoTime() - starttime;
			
			System.out.print("Pi(" + digits + ")" + " compute time = ");
			System.out.print(new Number(computetime).setPrecision(2)
			    .divide(1L*1000000000) .toString().trim());
			System.out.println(" seconds");
		}
		
		Number pi = a.inverse();
		
		return pi.setPrecision(digits);
	}
	
	
	
	
	public static Number pi11(int digits)
	{
	
		//  This formula by Borwein and Borwein (B & B)
		//
		//  is twice as fast as Chudnovsky and Chudnovsky (C & C)
		//
		//  and four times as fast as Ramanujan
		//
		//                      n
		//    1        __   (-1) (6 n)! (A + B n)
		//  _____  ==  \    _____________________
		//             /_       3         n + 1/2
		//  12 pi      n=0  (n!) (3 n)! C
		//
		//                             __
		//  where   A = 212175710912 \/61 + 1657145277365
		//                               __
		//          B = 13773980892672 \/61 + 107578229802750
		//                                       __   3
		//          C = [ 5280 (236674 + 30303 \/61) ]
		//
		//  Each term of this series adds 31 digits
		
		
		long starttime = System.nanoTime();
		
		int d = digits * 6/5 + 64;
		
		Number A = new Number("212175710912") .setPrecision(d)
		 .multiply(new Number(61) .setPrecision(d) .sqrt())
		      .add(new Number("1657145277365"));
		
		Number B = new Number("13773980892672") .setPrecision(d)
		 .multiply(new Number(61) .setPrecision(d) .sqrt())
		      .add(new Number("107578229802750"));
		
		Number C = new Number("5280") .setPrecision(d)
		 .multiply(new Number("236674") .add(new Number("30303")
		 .multiply(new Number(61) .setPrecision(d) .sqrt()))) .cube();
		
		Number D = C .sqrt() .inverse();
		
		Number D2 = D .square();
		
		Number E    = new Number(1) .setPrecision(d);
		Number F    = new Number(1) .setPrecision(d);
		Number G    = new Number(1) .setPrecision(d);
		Number H    = new Number(1) .setPrecision(d);
		Number invH = new Number(1) .setPrecision(d);
		
		G = G.multiply(D);
		
		Number sum = new Number(0);
		
		Number product = new Number(1);
		
		for (int n = 0; n < d / 30; n++)
		{
			//  E = (6 n)!
			
			if (n == 0) E = new Number(1);
			
			else for (int j = 0; j < 6; j++)
			
			    E = E .multiply(6*n - j);
			
			//  F = A + B n
			
			F = A.add(B.multiply(n));
			
			//  H[n] == n!^3 (3 n)! == (0!)^3 * 0!, (1!)^3 * 3!, (2!)^3 * 6!, ...
			//
			//       == H[n-1] n^3 ( 3 (n - 0) * 3(n - 1) * 3(n - 2) )
			
			if (n > 0)
			{
				invH = invH .divide(n*n) .divide(n);
				
				for (int j = 0; j < 3; j++)
				
				    invH = invH .divide(3*n - j);
			}
			
			//  1 / (12 pi) == (-1)^n E F G H^-1
			
			product = (E) .multiply(F) .multiply(G) .multiply(invH);
			
			G = G .multiply(D2);  //  G = C ^ (n+1/2)
			
			if ((n % 2) == 0)
			
			      sum = sum     .add(product);
			else  sum = sum.subtract(product);
		}
		
		Number pi = sum.inverse().divide(12)
		
		     .setPrecision(digits);
		
		if (digits >= 64)
		{
			long computetime = System.nanoTime() - starttime;
			
			System.out.print("Pi(" + digits + ")" + " compute time = ");
			System.out.print(new Number(computetime)
			    .setPrecision(2).divide(1000000000));
			System.out.println(" seconds");
		}
		
		return pi;
	}
	
	
	public Number pow(double exp)
	{
		return pow(new Number(exp));
	}
	
	
	public Number pow(long exp)
	{
		Number a = new Number(this);
		
		Number y = new Number(1);
		
		int expsign = 0;
		
		if (exp < 0) { exp *= -1; expsign = -1; }
		
		Number x = new Number(exp) .abs();
		
		//  Use the square and multiply method
		
		while (!x.equals(0))
		{
			if (x.testBit(0))
			
			    y = a .multiply(y);
			
			a = a .square();
			
			x = x .shiftRight(1);
		}
		
		if (expsign == -1)  y = y.inverse();
		
		if ((this.sign == '-') && ((exp & 1) == 1)) y.sign = '-';
		
		return y;
	}
	
	
	
	public Number pow(Number exp)
	{
	
		//  computes the function
		//
		//          x      (log a) x      k x
		//  y  =  a   ==  e          == e
		
		
		//  The series for the exponential function
		//
		//    x       n    
		//  e   ==  x  / n!
		
		
		//  The series for the exponential function
		//
		//    x      k x          n
		//  a   ==  e    ==  (k x) / n!
		//
		//               k
		//  where a == e,  or  k == log(a).
		
		
		//  Example  Compute the square root using the
		//  pow method instead of the root method
		//
		//  Number a = new Number(3);
		//
		//  int p = Math .max(a.getPrecision(), 16);
		//
		//  Number exp = new Number(1) .setPrecision(p) .divide(2);
		//
		//  Number root = a .pow(exp);
		//
		//  System.out.println("sqrt(" + a + ") ==" + root);
		//
		//  sqrt(3) == 1.7320508075688773
		
		
		int precision = Math.max(this.precision, exp.precision);
		
		if (exp.equals(0)) return new Number(1);
		if (exp.equals(1)) return new Number(this);
		
		
		if (exp.isComplex())
		{
			Number a = exp.toReal();
			Number b = exp.toImag();
			
			Number e2ib = new Number(exp.cos(), exp.sin());
			
			Number e2a = e(precision) .pow(a);
			
			return e2a .multiply(e2ib);
		}
		
		
		//  Compute the integer value
		
		Number yint = pow1(exp.abs().toInteger());
		
		
		//  If exponent is an integer, return y_int
		
		if (exp.isInteger())  return yint;
		
		
		//                                    k
		//  Solve for k in the equation a = e,  or k = ln(a)
		
		Number base = new Number(this) .setPrecision(precision);
		
		Number k = base.log();
		
		
		//           k x                   k x         n
		//  Compute e    from the series  e    == (k x) / n!
		//
		//  where x is the exponent and n is the index 0, 1, 2, ...
		//
		//  This power series brings the fraction k x from the
		//  exponent down to the base to avoid doing square roots
		//  which are expensive.
		
		
		Number yfrac = new Number(0);
		
		Number factorial = new Number(1);
		
		
		//  iterations = digits / digits per iteration
		
		int d = 4 + (int) (2*precision / Math.log(precision, 16));
		
		Number exp1 = exp .abs() .toFraction();
		
		Number kx = k.multiply(exp1) .setPrecision(precision);
		
		Number kx2n = new Number(1) .setPrecision(precision);
		
		//  a ^ x == (k x) ^ n / n!
		
		for (int i = 1;  ; i++)
		{
			Number kx2ndf = kx2n .divide(factorial);
			
			yfrac = yfrac .add(kx2ndf);
			
			kx2n = kx2n .multiply(kx);
			
			factorial = factorial .multiply(i);
			
			if (kx2ndf.equals(0)) break;
		}
		
		//  Compute y = y_int * y_frac
		
		Number y = yint .multiply(yfrac);
		
		
		//  Invert the output if the exponent is negative
		
		if (exp.signum() == -1)  y = y.inverse();
		
		return y;
	}
	
	
	
	private Number pow1(Number exp)
	{
		//  integer exponent method
		
		if (!exp.isInteger()) throw
		
		    new IllegalArgumentException();
		
		Number a = new Number(this);
		
		Number y = new Number(1);
		
		Number x = new Number(exp).abs();
		
		//  Use the square and multiply method
		
		while (!x.equals(0))
		{
			//  Accumulate squares for each 1-bit
			
			if (x.testBit(0))
			
			    y = a .multiply(y);
			
			//  Square the square
			
			a = a .square();
			
			//  Shift the exponent to the next bit
			
			x = x.shiftRight(1);
		}
		
		if (exp.signum() == -1)  y = y.inverse();
		
		if ((this.sign == '-') && exp.testBit(0))
		
		    y.sign = '-';
		
		return y;
	}
	
	
	
	public Number previousPrime()
	{
		//  returns the previous prime
		
		if (!this.isInteger())
		
		    throw new IllegalArgumentException();
		
		if (this.isLessThan(3)) return null;
		
		Number n = new Number(this);
		
		if (n.isEven()) n = n.subtract(1);
		else            n = n.subtract(2);
		
		while (!n.isPrime())  n = n.subtract(2);
		
		return n;
	}
	
	
	
	public Number quadDivide(Number divisor)
	{
	
		//  The quadratic divider (or subtract and shift divider) uses long
		//  division or partial quotients to divide two numbers. The partial
		//  quotients are shifted and added to calculate the quotient.
		//
		//  This method is the inverse of the quadratic multiplier. Instead
		//  of doing small multiplies, left shifts and adds, the quadratic
		//  divider does small divides, right shifts and subtracts.
		//
		//  The quadratic divider works by dividing the most significant bits
		//  of the dividend by the most significant bits of the divisor, then
		//  multiplying the partial quotient by the divisor, shifting the par-
		//  tial quotient left or right until the most significant bits align
		//  with the dividend, subtracting the product from the dividend, and
		//  adding the partial quotient to the quotient until the dividend is
		//  reduced to a value less than the divisor.
		//
		//  Note that division (just like multiplication) can be done without a
		//  32-bit multiplier or divider by shifting and subtracting bits. The
		//  processor's multiplier just makes the division operation several
		//  times faster because the dividend is reduced by several bits per
		//  iteration instead of only 1 to 2 bits per iteration. Doing multi-
		//  plication or division by shifting and adding is equivalent to using
		//  a 1-bit multiplier.
		//
		//  To keep the quadDivide method simple, the method does not allow
		//  floating point dividends or divisors because the quadDivide method
		//  is called by the divide method which left shifts the dividend to
		//  the required precision (after equalizing the dividend and divisor
		//  lengths), removes the intpoints and precision, and then sets the
		//  quotient intpoint equal to the difference between the two intpoints.
		//  It would be redundant to replicate all of this code in the quadDivide
		//  method.
		
		
		
		Number dividend = new Number(this);
		
		Number dividend1 = dividend;
		Number divisor1  = divisor;
		
		
		int[] array0 = divisor1 .trim() .toIntArray();
		
		long a, p = array0[0];
		
		Number quotient = new Number(0);
		
		int counter = 1;
		
		
		while (true)
		{
			//  Divide the most significant int of the dividend
			//      by the most significant int of the divisor
			
			final int[] array1 = dividend1 .trim() .toIntArray();
			
			if (array1.length >= 2)
			
			      a = (1L*array1[0] & 0xffffffffL) * 0x100000000L
			        + (1L*array1[1] & 0xffffffffL);
			else  a = (1L*array1[0] & 0xffffffffL) * 0x100000000L;
			
			
			//  Maximize the number of significant digits in the quotient
			//  by left shifting the most significant digits in the dividend
			
			if      ((a & 0xffffffffffff0000L) == 0) a <<= 48;
			else if ((a & 0xffffffffff000000L) == 0) a <<= 40;
			else if ((a & 0xffffffff00000000L) == 0) a <<= 32;
			else if ((a & 0xffffff0000000000L) == 0) a <<= 24;
			else if ((a & 0xffff000000000000L) == 0) a <<= 16;
			else if ((a & 0xff00000000000000L) == 0) a <<=  8;
			
			if (a < 0)  a >>>= 1;
			
			long q = a / p;
			
			while ((q & 0xffffffff00000000L) != 0)
			
			    q >>>= 2;
			
			
			//  Compute the product of the partial quotient and the divisor
			
			Number product = new Number(Math.multiply(divisor1.intarray, (int) q));
			
			//  Calculate the difference between the dividend and product lengths
			//  to left shift or right shift the product so that the most significant
			//  digits align and the dividend gets reduced by subtracting (or adding)
			//  the product.
			
			int d1 = (int) dividend1.bitCount() - 32*dividend.intpoint; // intpoint == 0
			int d2 = (int)   product.bitCount() - 32* product.intpoint; // intpoint == 0
			
			int d = d1 - d2;
			
			
			//  Q is a partial quotient
			
			Number Q = new Number(q);
			
			if      (d > 0) { Q = Q .shiftLeft(d, d); }
			else if (d < 0) { Q = Q .shiftRight((-d) % (32*Q.length())) .trim(); }
			
			
			//  Q x divisor is a partial dividend
			
			//  Recalculate the product = Q x divisor
			//
			//  (with or without using multiplication)
			
			if (d > 0) product = product.shiftLeft(d, d);
			
			////  if (d < 0) product = Q .multiply(divisor1); // using multiplication
			if       (d < 0) product = product .shiftRight((-d) % (32*product.length())) .trim();
			
			
			//  If the reduced dividend is less than the divisor, break out of the loop
			
			//  (Test d first to avoid the second test which is more expensive)
			
			if      ((d <= 0) &&  dividend1.equals(0)) break;
			else if ((d <  0) && (dividend1.bitCount() <= divisor1.bitCount())) break;
			
			
			//  Subtract the product from the dividend if the product is positive or
			//  add the product to the dividend if the product is negative so that the
			//  most significant bits cancel out and the dividend contracts by several
			//  bits per iteration. (The sign may alternate but the magnitude continues
			//  to decrease.) If the remainder or reduced dividend is negative after
			//  breaking out of the loop, then the method subtracts 1 from the quotient
			//  because too much was subtracted from the dividend.
			
			
			if (dividend1 .signum() == product .signum())
			{
				//  Subtract the (positive) product (once or twice) from the dividend
				
				dividend1 = dividend1 .subtract(product);
				
				quotient = quotient .add(Q);
				
				if (dividend1 .subtract(product) .bitCount() < dividend1.bitCount())
				{
					dividend1 = dividend1 .subtract(product);
					
					quotient = quotient .add(Q);
				}
			}
			
			else // if (dividend1 .signum() != product .signum())
			{
				//  Add the (negative) product (once or twice) to the dividend
				
				dividend1 = dividend1 .add(product);
				
				quotient = quotient .subtract(Q);
				
				if (dividend1 .add(product) .bitCount() < dividend1.bitCount())
				{
					dividend1 = dividend1 .add(product);
					
					quotient = quotient .subtract(Q);
				}
			}
			
			if (counter++ > dividend.bitCount())
			{
				break; // error
			}
		}
		
		
		//  The dividend should contract around 16 bits per iteration (except if the quotient is small)
		
		long avg_bits_per_iter = (int) (dividend.bitCount() - dividend1.bitCount()) / counter;
		
		//  if (quotient.bitCount() > 64) System.out.println(
		//
		//    "avg bits / iteration == " + avg_bits_per_iter);
		
		
		//  Correct for any small one-off errors
		
		while (dividend .subtract(quotient.multiply(divisor)) .signum() == -1)
		
		    quotient = quotient .subtract(1);
		
		while (!dividend.subtract(quotient.multiply(divisor)) .isLessThan(divisor.abs()))
		
		    quotient = quotient .add(1);
		
		
		//  Verify the quotient
		
		Number remainder = this.subtract(quotient.multiply(divisor));
		
		if ( (remainder.signum() == -1) || ( ! remainder.isLessThan(divisor)) )
		{
			System.out.println("dividend - quotient x divisor == " + remainder.toString(16));
			
			System.out.println("dividend == " +     this.toString(16));
			System.out.println(" divisor == " +  divisor.toString(16));
			System.out.println("quotient == " + quotient.toString(16));
			
			String message = "quadratic division error";
			
			throw new ArithmeticException(message);
		}
		
		return quotient;
	}
	
	
	
	public static Number random(int digits, int radix)
	{
		//  generates secure random numbers using
		//  random data from different sources
		
		Number rand = new Number(0);
		
		int bits = Math.log2(radix) * digits;
		
		long modulus = 0xfffffffffffffL;
		
		Math.initRng(modulus * System.nanoTime());
		
		for (int i = 0; i < 1 + bits / 256; i++)
		{
			SecureRandom sr = new SecureRandom();
			
			byte[] bytes = new byte[32];
			
			sr.nextBytes(bytes);
			
			long randlong = Math.random(modulus);
			
			randlong += System.nanoTime();
			
			Number n = new Number(bytes).add(randlong);
			
			rand = rand.add(n.shiftLeft(256*i, 256*i));
		}
		
		Number n = new Number(radix).pow(digits);
		
		rand = rand.mod(n);
		
		if (radix == 2)  rand .setBit(digits*1 -1);
		if (radix == 16) rand .setBit(digits*4 -1);
		
		return rand;
	}
	
	
	
	public Number root(int k)
	{
	
		//  the root extractor
		
		//  computes the kth root of a number
		
		//  This method will expand the precision of the number by
		//  the number of integer digits (just like the inverse method)
		//  unless the number is a perfect power such as a perfect square.
		//
		//  For example, the sqrt of the integer 12345678 will return
		//  the real number 3513.6417 because 3513.6417 ^ 2 ~ 12345678
		//  while 3513.641 ^ 2 only equals ~ 12345673.
		
		
		//  Newton's iteration for root extraction
		//
		//  Set r = number of int digits / k, then iterate
		//
		//  r == ((k-1) r + n / r ^ (k-1)) / k  or
		//
		//  r[i+1] == [(k-1) r[i] + n / r[i] ^ (k-1)] / k.
		//
		//  The root r must be initialized to the size of the root
		//  r = n ^ (1/k) or else the iteration will converge linearly
		//  until the root is approximately the size of n ^(1/k) and
		//  then the bits will start converging exponentially or
		//  doubling for each iteration.
		//
		//
		//  Example  Compute the square root r of a number n
		//
		//  (Newton's iteration for square root extraction)
		//
		//  Set k = 2, r ~ sqrt(n), then iterate
		//
		//  r == [(k-1) r + n / r ^ (k-1)] / k
		//    == [(2-1) r + n / r ^ (2-1)] / 2
		//    ==      ( r + n / r ) / 2
		//
		//
		//  Example  Compute the minus one root r of a number n
		//
		//  (Newton's iteration for inversion)
		//
		//  Set k = - 1,  n r ~ 1, then iterate
		//
		//  r ==  [(k-1) r + n / r ^ (k-1)] / k
		//
		//    ==  [(-2) r + n / r ^ (-2)] / -1
		//
		//    ==  [ 2 r - n r ^ 2]
		//
		//    ==  r (2 - n r)
		//
		//
		//  Newton's iteration for k = -1 to 5
		//
		//  inverse root (n = r^-1)   r = (-2 r + n / r^-2) /-1  == r (2 - n r)
		//  zeroth  root (n = r^ 0)   r = (-1 r + n / r^-1) / 0
		//  linear  root (n = r^ 1)   r = ( 0 r + n / r^ 0) / 1
		//  square  root (n = r^ 2)   r = ( 1 r + n / r^ 1) / 2  == (r + n / r) / 2
		//  cube    root (n = r^ 3)   r = ( 2 r + n / r^ 2) / 3
		//  quartic root (n = r^ 4)   r = ( 3 r + n / r^ 3) / 4
		//  quintic root (n = r^ 5)   r = ( 4 r + n / r^ 4) / 5
		//  ...     ...               ...     ...
		//
		//  The inverse of v is computed by initializing u ~ 1 / v
		//  (so that u v ~ 1) and then iterating  u = u (2 - v u).
		//
		//  The square root of n is computed by initializing r ~ sqrt(n)
		//  (so that n ~ r^2) and then iterating  r = (r + n / r) / 2.
		
		
		//  Expand the precision to the number of integer digits plus the precision
		
		int precision = this.precision +
		
		    (int) this.toInteger().bitCount()/4;
		
		if (precision < 8) precision = 8;
		
		Number n0 = new Number(this).setPrecision(precision);
		
		Number zero = new Number("0", 16) .setPrecision(precision * 3/4);
		Number  one = new Number("1", 16) .setPrecision(precision * 3/4);
		
		if (this.equals(zero) || this.equals(zero))
		
		    //  zero and one are idempotent
		
			return new Number(this);
		
		
		//  a ^  minus root == a ^-1 ^ |root|
		//  a ^ zeroth root == a ^ (1/0) == infinity
		//  a ^  first root == a ^ (1/1) == a
		
		if (k <  0)  return this .inverse() .root(-k);
		if (k == 0)  throw new IllegalArgumentException("zeroth root");
		if (k == 1)  return new Number(this);
		
		
		//  Remove the integer point from the number n = a / 2 ^ b
		
		Number n = n0.trim();  n.intpoint = 0;
		
		int b = 32 * n0.intpoint;
		
		
		//  Set the root r approx equal to n ^ (1 / k)
		
		long bits = n.bitCount();
		
		Number r = new Number(1) .shiftLeft(bits/k, bits/k);
		
		
		//  The number of twos must be divisible by k
		//
		//  so that the root of 2 ^ bits == 2 ^ (bits / k)
		
		while ((b++ % k) != 0) { n = n.shiftLeft(1); }
		
		
		//  First iterate a few times at 64 bits precision
		
		int t = Math.max(8, (int) Math.log2(n0.toInteger().bitCount()));
		
		for (int i = 0; i < t; i++) r = r.setPrecision(64) .multiply(k-1)
		
		    .add( n.setPrecision(64).divide(r.pow(k-1)) ) .divide(k) .trim();
		
		
		//  Do a few more iterations doubling the precision for each iteration
		
		//  This is equivalent to 1.5 multiplications at full precision because
		//  all of the iterations except for the last iteration are done at much
		//  smaller precisions and these smaller multiplications are inexpensive
		//  because the sum of (1 / 2^k) ^ (1.58 or 2.00) == ... (1/8) ^ 1.58 +
		//  (1/4) ^ 1.58 + (1/2) ^ 1.58 + (1/1) ^ 1.58 < 1.5. There could be a
		//  hidden constant in the running time that makes it higher than 1.5
		//  multiplications.
		
		int p = precision;
		
		while (true)
		{
			r = r.setPrecision(p) .multiply(k-1) .add( n.setPrecision(p)
			
			    .divide(r.pow(k-1)) ) .divide(k) .setPrecision(p);
			
			if (p > n0.precision + 16) break;  p *= 2;
		}
		
		//  Restore the integer point for the root r
		
		//  the kth root of a (= n x 2^b) == root(n) x 2^(b/k)
		
		r = r .divide( new Number(2) .pow(b/k) );
		
		
		//  Verify that the root is correct
		
		if (!r.pow(k) .subtract(n0) .abs() .equals(zero)
		 || !r.pow(k)   .divide(n0) .abs() .equals(one))
		{
			System.out.println(r.pow(k).divide(this).subtract(1));
			System.out.println(" r^k == " + r.pow(k) .toString(16));
			System.out.println("this == " + this.toString(16));
			
			System.out.println("r^k - this == " + r.pow(k)
			    .subtract(this) .abs() .toString(16));
			System.out.println("r^k / this == " + r.pow(k)
			    .divide(this) .abs() .toString(16));
			
			System.out.println("zero == " + zero.toString(16));
			System.out.println(" one == " +  one.toString(16));
			System.out.println("r^k - this should have at least "
			    + precision + " zero digits");
			
			String message = "root extraction error";
			
			throw new ArithmeticException(message);
		}
		
		//  If the radicand is the power of an integer
		//  (such as a perfect square or perfect cube)
		//  then return the root r as an integer
		
		if (this.toFraction().equals(0) &&
		
		    r.toInteger(true) .pow(k) .equals(this))
		
			return r.toInteger(true);
		
		return r.setPrecision(precision);
	}
	
	
	
	public Number round()
	{
		//  rounds the number to the nearest integer
		
		if (this.isComplex())
		
		    return new Number(
		
			this.toReal().round(),
			this.toImag().round());
		
		if (this.precision == 0)
		
		    return new Number(this);
		
		Number number = this;
		
		if (number.signum() >= 0)
		
		      number = number.add(0.5);
		
		else  number = number.subtract(0.5);
		
		return number.toInteger();
	}
	
	
	
	public Number round(int p)
	{
		//  rounds the number to the specified precision
		//
		//  If p == 0 then this method is the same as round()
		
		if (this.isComplex())
		
		    return new Number(
		
			this.toReal().round(p),
			this.toImag().round(p));
		
		Number number = this;
		
		Number d = new Number(1) .setPrecision(p+1)
		
		    .divide( new Number(2).pow(4*p+1) );
		
		if (number.signum() >= 0)
		
		    number = number.add(d);
		
		else number = number.subtract(d);
		
		return number.setPrecision(p);
	}
	
	
	
	public Number roundBit()
	{
		//  adds a 1 to the least significant bit of the array
		
		int p = this.precision;
		
		while ((p % 8) != 0) p++;
		
		//  Set the precision to expand the left side of the intarray
		
		Number n = this.setPrecision(p);
		
		int d = n.intpoint - p / 8;
		
		int index = n.intarray.length -1 -d;
		
		int[] intarray1 = new int[n.intarray.length];
		
		intarray1[index] = 1;
		
		if (n.intarray[index] == -1)
		
		    n.intarray = Math.add(n.intarray, intarray1);
		
		n.precision = this.precision;
		
		n.sign = this.sign;
		
		return n;
	}
	
	
	public void setBit(long bit)
	{
		//  sets a bit of the number array
		
		if ((bit / 32 + 1) > this.intarray.length)
		{
			//  Expand the array
			
			int[] array = new int[(int) bit/32 + 1];
			
			for (int i = 0; i < this.intarray.length; i++)
			
			    array[array.length -1 -i] = this
			
				.intarray[this.intarray.length -1 -i];
			
			this.intarray = array;
		}
		
		Math.setBit(this.intarray, bit);
	}
	
	
	
	public Number setPrecision(int precision)
	{
		//  sets the number of fractional digits and expands
		//  or truncates the right side of the number
		
		//  A number is represented by an array and an intpoint.
		//  The intpoint is the same as the number of frac ints.
		//
		//  Changing the precision expands or contracts the array
		//  and increases or decreases the intpoint.
		//
		//  Example  2 int ints + 3 frac ints == 5 total ints
		//
		//  xxxxxxxx xxxxxxxx.xxxxxxxx xxxxxxxx xxxxxxxx
		//  |_______________| |________________________|
		
		
		
		if (this.isComplex())
		
		    return new Number(
		
			this.toReal().setPrecision(precision),
			this.toImag().setPrecision(precision));
		
		Number number = new Number(this);
		
		number.precision = precision;
		
		if ((number.precision == 0) && (precision == 0))
		
		    return number;
		
		int totalints, fracints, intints;
		
		totalints = number .intarray.length;
		 fracints = number .intpoint;
		  intints = totalints - fracints;
		
		if (intints < 0) intints = 0;
		
		if (intints <= 0) // int value == 0
		{
			//  Expand the left side of the array to equal 1 + intpoint
			
			int[] new_intarray = new int[1 + number.intpoint];
			
			//  Align the arrays and copy right (to left)
			
			for (int i = 0; i < number.intarray.length; i++)
			
			       new_intarray[   new_intarray.length -1 -i] =
			    number.intarray[number.intarray.length -1 -i];
			
			//  Re-assign the intarray
			
			number.intarray = new_intarray;
			
			totalints = number.intarray.length;
			 fracints = number.intpoint;
			  intints = totalints - fracints;
			
			if (intints < 0) intints = 0;
		}
		
		
		if ((fracints < (precision + 7) / 8) && (precision > 0))
		{
			//  Expand the right side of the array to equal the precision / 8
			
			int newlength = intints + 1 + precision / 8;
			
			int[] newintarray = new int[newlength];
			
			//  Align the intpoints and copy left to right
			
			number.intpoint += newintarray.length - number.intarray.length;
			
			for (int i = 0; i < number.intarray.length; i++)
			
			    newintarray[i] = number.intarray[i];
			
			//  Re-assign the array
			
			number.intarray = newintarray;
			
			totalints = number.intarray.length;
			 fracints = number.intpoint;
			  intints = totalints - fracints;
			
			if (intints < 0) intints = 0;
		}
		
		
		else if (fracints > (precision + 7) / 8)
		{
			//  Truncate the right side of the array to precision / 8
			
			int newlength = intints + 1 + precision / 8;
			
			int[] newintarray = new int[newlength];
			
			int size = Math.min(newintarray.length, number.intarray.length);
			
			//  Align the intpoints and copy left to right
			
			number.intpoint -= (number.intarray.length - newintarray.length);
			
			for (int i = 0; i < size; i++)
			
			    newintarray[i] = number.intarray[i];
			
			//  Re-assign the array
			
			number.intarray = newintarray;
			
			totalints = number.intarray.length;
			 fracints = number.intpoint;
			  intints = totalints - fracints;
			
			if (intints < 0) intints = 0;
		}
		
		
		//  This test slows down the method but was used for debugging
		//
		//  if (!this.toInteger() .equals(number.toInteger()))
		//  {
		//	String message = "set precision error";
		//	
		//	System.out.println("this integer == " + this  .toInteger().toString(16));
		//	System.out.println("   n integer == " + number.toInteger().toString(16));
		//	
		//	System.out.println(message);
		//	
		//	throw new ArithmeticException();
		//  }
		
		return number;
	}
	
	
	public Number shiftLeft(long bits)
	{
		//  shifts left but does not expand
		
		Number n = new Number(this);
		
		n.intarray = Math.shiftLeft(n.intarray, bits);
		
		return n;
	}
	
	
	public Number shiftLeft(long expansion, long bits)
	{
		//  expands and shifts left
		
		Number n = new Number(this);
		
		n.intarray = Math.shiftLeft(n.intarray, expansion, bits);
		
		return n;
	}
	
	
	public Number shiftRight(long bits)
	{
		//  shifts right but does not contract the array
		
		//  To shift right and contract the array, use
		//
		//  shiftRight(bits) .trim() to remove the left zeros.
		
		Number n = new Number(this);
		
		n.intarray = Math.shiftRight(n.intarray, bits);
		
		return n;
	}
	
	
	public int signum()
	{
		//  returns the sign as 1, 0, or -1
		
		if (this.equals(0)) return 0;
		
		return this.sign == '-' ? -1 : 1;
	}
	
	
	public Number sin()
	{
		//  returns the sine of an angle in radians
		
		Number sin = cos_sin()[1];
		
		return sin.setPrecision(Math.max(this.precision, 8));
	}
	
	
	public Number sinh()
	{
		//  returns the hyperbolic sine
		//
		//  sinh(u) = 1/2 ( e^u - e^-u )
		
		//  The hyperbolic sine is related to the sine by
		//
		//  i sin (u) == sinh(i u)  and  i sinh(u) == sin (i u)
		//
		//  where i is the imaginary unit = sqrt(-1)
		
		int p =  this.precision > 0 ? this.precision : 16;
		
		return  e(p).pow(this) .add(e(p).pow(this.negate())) .divide(2);
	}
	
	
	public Number sqrt()
	{
		//  computes the square root
		
		Number sqrt = this.abs().root(2);
		
		//  if the number is negative
		//  then the root is imaginary
		
		if (this.signum() == -1)
		
		    sqrt = new Number(new Number(0), sqrt);
		
		return sqrt;
	}
	
	public Number square()
	{
		//  squares a number
		
		return this.multiply(this);
	}
	
	
	public Number subtract(int subtrahend)
	{
		return this.subtract(new Number(subtrahend));
	}
	
	public Number subtract(long subtrahend)
	{
		return this.subtract(new Number(subtrahend));
	}
	
	public Number subtract(double subtrahend)
	{
		return this.subtract(new Number(subtrahend));
	}
	
	
	public Number subtract(Number subtrahend)
	{
		//  returns the difference of two numbers
		
		if (this.isComplex() || subtrahend.isComplex())
		{
			//  use complex subtraction
			
			Number real1 = this.toReal();
			Number imag1 = this.toImag();
			
			Number real2 = subtrahend.toReal();
			Number imag2 = subtrahend.toImag();
			
			return new Number(real1.subtract(real2),
			                  imag1.subtract(imag2));
		}
		
		//  Negate the subtrahend and add the minuend
		
		Number diff = this.add(subtrahend.negate());
		
		return diff;
	}
	
	
	public static Number[] subtract(Number[] array1, Number[] array2)
	{
		//  returns the difference of two number arrays
		
		if (array1.length != array2.length)
		
		    throw new IllegalArgumentException();
		
		Number[] array3 = new Number[array1.length];
		
		for (int i = 0; i < array3.length; i++)
		
		    array3[i] = array1[i].subtract(array2[i]);
		
		return array3;
	}
	
	
	public static Number[] subtract(Number[] array, Number n)
	{
		//  subtracts a number n from an array
		
		Number[] array1 = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array1[i] = array[i].subtract(n);
		
		return array1;
	}
	
	
	public Number tan()
	{
		//  returns the tangent in radians
		
		//  tan(x) = sin(x) / cos(x)
		
		int p = this.precision;
		
		Number zero = new Number(0) .setPrecision(p);
		
		if (this.cos() .equals(zero))
		{
			String message = // no divide by zero
			
			    "tan(pi/2) == sin(pi/2) / cos(pi/2) == 1 / 0 is undefined";
			
			throw new IllegalArgumentException(message);
		}
		
		//  Compute the tangent of this
		
		return this.sin().divide(this.cos());
	}
	
	
	public Number tanh()
	{
		return sinh().divide(cosh());
	}
	
	
	public boolean testBit(long bit)
	{
		//  tests if an integer bit is set
		
		//  If the bit >= 0 then the method counts the integer bits
		//  from right to left. If the bit < 0 then the method counts
		//  the fractional bits from left to right.
		
		int[] array = this.intarray;
		
		if ((this.precision != 0) && (bit >= 0))
		
		    array = this.toInteger(false).intarray;
		
		if ((this.precision != 0) && (bit < 0))
		
		    array = this.toFraction().intarray;
		
		if ((1 + Math.abs(bit) / 32) > array.length)
		
		    return false;
		
		return Math.testBit(array, bit);
	}
	
	
	
	public String toAlphabeticalString()
	{
	
		//  converts a number to an alphabetic string
		
		//  This can be used for Bitcoin wallets (for values < 1000 vigintillion or
		//  1000 vigintillion - 1) to display the amount numerically and alphabetically
		
		//  Example  Convert the number 314159.26 to an alphabetical string
		//
		//  System.out.println( new Number("314159.26") .toAlphabeticalString() );
		//
		//  three hundred fourteen thousand, one hundred fifty-nine
		//
		//
		//  Example  Convert the number
		//
		//  123456789012345678901234567890123456789012345678901234567890123456
		//
		//  to an alphabetical string
		//
		//  System.out.println( new Number(
		//
		//      "123456789012345678901234567890123456789012345678901234567890123456"
		//
		//  	    .toAlphabeticalString() );
		//
		//  One hundred twenty-three vigintillion, four hundred fifty-six novemdecillion,
		//  seven hundred eighty-nine octodecillion, twelve septendecillion, three hundred
		//  forty-five sexdecillion, six hundred seventy-eight quindecillion, nine hundred
		//  one quattuordecillion, two hundred thirty-four tredecillion, five hundred sixty-
		//  seven duodecillion, eight hundred ninety undecillion, one hundred twenty-three
		//  decillion, four hundred fifty-six nonillion, seven hundred eighty-nine octillion,
		//  twelve septillion, three hundred forty-five sextillion, six hundred seventy-eight
		//  quintillion, nine hundred one quadrillion, two hundred thirty-four trillion, five
		//  hundred sixty-seven billion, eight hundred ninety million, one hundred twenty-three
		//  thousand, four hundred fifty-six
		
		
		
		String[] base0 =
		{
		    " ", "one ", "two ", "three ", "four ",
		    "five ", "six ", "seven ", "eight ", "nine "
		};
		
		
		String[] base1 =
		{
		    "ten ", "eleven ", "twelve ", "thirteen ",
		    "fourteen ", "fifteen ", "sixteen ", "seventeen ",
		    "eighteen ", "nineteen "
		};
		
		
		String[] base2 =
		{
		    " ", " ", "twenty", "thirty", "forty",
		    "fifty", "sixty", "seventy", "eighty", "ninety"
		};
		
		
		String _hundred = "hundred ";
		
		
		String[] base3 =
		{
		    "", "thousand", "million", "billion", "trillion",
		    "quadrillion", "quintillion", "sextillion", "septillion",
		    "octillion", "nonillion", "decillion", "undecillion",
		    "duodecillion", "tredecillion", "quattuordecillion",
		    "quindecillion", "sexdecillion", "septendecillion",
		    "octodecillion", "novemdecillion", "vigintillion",
		};
		
		
		
		//  The numbers
		//
		//  thousand, million, billion, trillion,
		//  quadrillion, quintillion, sextillion, septillion
		//
		//  correspond to the prefixes
		//
		//  kilo  3, mega 6,  giga 9,  tera 12, (kmgt)
		//  peta 15, exa 18, zetta 21, yotta 24 (pezy)
		//
		//
		//  The fractions
		//
		//  thousandth, millionth, billionth, trillionth, quadrillionth,
		//  quintillionth, and sextillionth correspond to the prefixes
		//
		//  milli -3, micro -6, nano -9, pico -12, femto -15, atto -18, and zepto -21
		//
		//  The large prefixes are used for bytes or operations and the
		//  small prefixes are usually used for seconds such as a peta-
		//  byte, a zetta op or yotta op, or a picosecond or femtosecond.
		
		
		
		//  If the number is greater than 999.999... vigintillion
		//
		//  	return the empty string
		
		if (this.isGreaterThan(new Number(
		
		   "999999999999999999999999999999999" +
		   "999999999999999999999999999999999")))
		
			return "";
		
		String n = this.add(0.1).toInteger().toString(10).trim();
		
		while ((n.length() % 3) != 0)  n = "0" + n;
		
		String[] group = new String[n.length() / 3];
		
		StringBuilder[] sbarray = new StringBuilder[n.length() / 3];
		
		for (int i = 0; i < n.length() / 3; i++)
		{
			group[i] = n.substring(3*i, 3*(i+1));
			
			sbarray[i] = new StringBuilder();
			
			char c = group[i].charAt(0);
			
			if (c != '0')
			{
				sbarray[i].append(base0[c-'0']);
				sbarray[i].append(_hundred);
			}
			
			c = group[i].charAt(1);
			
			if (c > '1')
			{
				sbarray[i].append(base2[c-'0']);
				
				if ( (group[i].charAt(2)-'0') == 0 )
				
				      sbarray[i].append(" " + base0[group[i].charAt(2)-'0']);
				else  sbarray[i].append("-" + base0[group[i].charAt(2)-'0']);
			}
			
			else if (c == '1') { sbarray[i].append(base1[group[i].charAt(2)-'0']); }
			else if (c == '0') { sbarray[i].append(base0[group[i].charAt(2)-'0']); }
			
			group[i] = sbarray[i].toString();
		}
		
		StringBuilder sb = new StringBuilder();
		
		for (int i = 0; i < group.length; i++)
		{
			if (!group[i].isBlank())
			{
				if (i != 0) sb.append(", ");
				
				group[i] += base3[(group.length -1 -i)];
				
				sb.append(group[i]);
			}
		}
		
		if ((sb.length() > 0) && (sb.charAt(0) >= 'a') && (sb.charAt(0) <= 'z'))
		
		    sb.setCharAt(0, (char) (sb.charAt(0) - 'a' + 'A'));
		
		String str = sb.toString();
		
		str = str .replaceAll("  ", " ");
		
		return str;
	}
	
	
	public Number[] toArray()
	{
		return this.toArray(0, new Number(2).pow(32));
	}
	
	public Number[] toArray(int radix)
	{
		return this.toArray(0, new Number(radix));
	}
	
	public Number[] toArray(int digits, int radix)
	{
		return this.toArray(digits, new Number(radix));
	}
	
	public Number[] toArray(int digits, Number radix)
	{
		Number[] array = this.toArray(radix);
		
		int d = digits - array.length;
		
		if (d <= 0) return array;
		
		Number[] array1 = new Number[digits];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = new Number(0);
		
		for (int i = 0; i < array.length; i++)
		
		    array1[d + i] = array[i];
		
		return array1;
	}
	
	
	public Number[] toArray(Number radix)
	{
	
		//  converts a number to an array of number in base radix
		
		//  Example  Convert the number
		//
		//  3141592653589793238462643383279502884197169399375105 to base 10 array.
		//
		//  Number n = new Number(
		//
		//      "3141592653589793238462643383279502884197169399375105");
		//
		//  Number radix = new Number(10);
		//
		//  Number[] array = n .toArray(radix);
		//
		//  System.out.println(Arrays.toString(array));
		//
		//  [ 3,  1,  4,  1,  5,  9,  2,  6,  5,  3,  5,  8,  9,
		//    7,  9,  3,  2,  3,  8,  4,  6,  2,  6,  4,  3,  3,
		//    8,  3,  2,  7,  9,  5,  0,  2,  8,  8,  4,  1,  9,
		//    7,  1,  6,  9,  3,  9,  9,  3,  7,  5,  1,  0,  5, ]
		
		
		if (!this.isInteger())
		{
			String message = "non-integer number";
			
			throw new IllegalArgumentException(message);
		}
		
		if (radix.isLessThan(2))
		{
			String message = "radix < 2";
			
			throw new IllegalArgumentException(message);
		}
		
		
		int maxsize = 256;
		
		Number[] array = null;
		
		Number number = this.abs();
		
		
		//  Use a try / finally block to verify that
		//  the array is correct because the if and
		//  else blocks both return the array
		
		try
		{	//  Test before recursion
			
			if (this.length() >= maxsize)
			{
				//  Bifurcate the number
				
				long bits = number.bitCount();
				
				int d = (int)(bits / radix.log2() / 2);
				
				Number divisor = new Number(radix).pow(d);
				
				Number q = number.divide(divisor);
				Number r = number   .mod(divisor);
				
				Number left = q,  right = r;
				
				
				//  Start the recursion
				
				//  Convert the two numbers to arrays of Number
				
				Number[]  leftarray =  left.toArray(radix);
				Number[] rightarray = right.toArray(radix);
				
				
				//  Concatenate the two arrays
				
				array = new Number[leftarray.length + rightarray.length];
				
				for (int i = 0; i < leftarray.length; i++)
				
				    array[i] = new Number(leftarray[i]);
				
				for (int i = 0; i < rightarray.length; i++)
				
				    array[leftarray.length + i] = new Number(rightarray[i]);
				
				return array;
			}
			
			
			else
			{	//  Convert the number to base radix and
				//  store the digits in a Number array
				
				ArrayList<Number> list;
				
				list = new ArrayList<Number>();
				
				while (!number.equals(0))
				{
					//  Compute the "digits"
					
					Number digit = number.mod(radix);
					
					number = number.divide(radix);
					
					list.add(digit);
				}
				
				int s = list.size();
				
				array = new Number[s];
				
				for (int i = 0; i < s; i++)
				
				    array[i] = list.get(s -1 -i);
				
				return array;
			}
		}
		
		
		finally  //  Verify that the number array is correct
		{
			Number sum = new Number(0), base = new Number(1);
			
			for (int i = 0; i < array.length; i++)
			{
				sum = sum .add(array[array.length -1 -i] .multiply(base));
				
				base = base .multiply(radix);
			}
			
			if (!sum.equals(this))
			
			    throw new ArithmeticException();
		}
	}
	
	
	
	public byte[] toByteArray()
	{
		//  converts the int array to a byte array
		
		return Convert.intArrayToByteArray(this.intarray);
	}
	
	public byte[] toByteArray(int bytes)
	{
		//  converts the int array to a padded byte array
		
		return Convert.intArrayToByteArray(this.intarray, bytes);
	}
	
	
	public Number toFraction()
	{
		return toFraction(true);
	}
	
	private Number toFraction(boolean round)
	{
		//  returns the fractional value of a number or the number modulo 1
		//
		//  If round is true, then a 1 is added to the least significant bit
		//  to round the number up before reading and returning the fraction.
		
		return this.subtract(this.toInteger(round));
	}
	
	
	public Number toImag()
	{
		//  returns the imaginary component
		
		if (!this.isComplex()) return new Number(0);
		
		Number number = new Number(this.intarray1);
		
		number.intpoint = this.intpoint1;
		number.precision = this.precision1;
		number.sign = this.sign1;
		
		return number;
	}
	
	
	public int[] toIntArray()
	{
		//  returns a copy of the int array
		
		//  The int array is just the magnitude of the number;
		//  it does not include the intpoint, precision, or sign.
		//
		//  Methods that use twos complement arithmetic can
		//  interpret the sign from the zeroth int.
		
		int[] array = new int[this.intarray.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = this.intarray[i];
		
		return array;
	}
	
	
	public int[] toIntArray(int length)
	{
		//  returns a padded copy of the int array
		
		//  The int array is just the magnitude of the number;
		//  it does not include the intpoint, precision, or sign.
		//
		//  Methods that use twos complement arithmetic can
		//  interpret the sign from the zeroth int.
		
		//  If (length > int array length)
		//  then the array is padded w/zeros
		
		Number n = this .trim();
		
		int ints = Math.max(length, n.length());
		
		int[] array = new int[ints];
		
		int offset = array.length - n.intarray.length;
		
		for (int i = 0; i < n.intarray.length; i++)
		
		    array[offset + i] = n.intarray[i];
		
		if (array.length < length)
		
		    throw new ArithmeticException();
		
		return array;
	}
	
	
	public int[] toIntArray(int digits, long radix)
	{
	
		//  converts a number to an array of int in base radix
		
		//  A number can be converted to any base by divisions and modular reductions.
		
		
		//  Example  Convert the int array { 1, 2, 3, 4 }
		//
		//  from base 2^32 to base 2^32 - 1 and back to base 2^32
		//
		//  long radix = 4L*1024*1024*1024 - 1;
		//
		//  int[] array = new int[] { 1, 2, 3, 4 };
		//
		//  System.out.println("\narray in radix 2^32 = "
		//      + Arrays.toString(array));
		//
		//  array = new Number(array) .toIntArray(radix);
		//
		//  System.out.println("\narray in radix " + radix
		//      + " = " + Arrays.toString(array));
		//
		//  array = new Number(array, radix) .toIntArray();
		//
		//  System.out.println("\narray in radix 2^32 = "
		//      + Arrays.toString(array));
		//
		//
		//  array in radix 2^32     = [1, 2, 3, 4]
		//  array in radix 2^32 - 1 = [1, 5, 10, 10]
		//  array in radix 2^32     = [1, 2, 3, 4]
		
		
		if (radix < 2)
		{
			String message = "radix < 2";
			
			throw new IllegalArgumentException(message);
		}
		
		int maxsize = 256;
		
		Number number = this.abs();
		
		
		//  Test before recursion
		
		if (this.length() >= maxsize)
		{
			//  Bifurcate the number
			
			long bits = number.bitCount();
			
			int d = (int)(bits / Math.log2((double)radix)/2);
			
			Number divisor = new Number(radix).pow(d);
			
			Number q = number.divide(divisor);
			Number r = number   .mod(divisor);
			
			Number left = q,  right = r;
			
			
			//  Start the recursion
			
			//  Convert the two numbers to arrays of int
			
			int[]  leftarray =  left.toIntArray(digits,radix);
			int[] rightarray = right.toIntArray(digits,radix);
			
			
			//  Concatenate the two arrays
			
			int[] array = new int[leftarray.length + rightarray.length];
			
			for (int i = 0; i < leftarray.length; i++)
			
			    array[i] = leftarray[i];
			
			for (int i = 0; i < rightarray.length; i++)
			
			    array[leftarray.length + i] = rightarray[i];
			
			return array;
		}
		
		
		else
		{	ArrayList<Integer> list;
			
			list = new ArrayList<Integer>();
			
			while (!number.equals(0))
			{
				//  Compute the digits
				
				int digit = number.mod(new Number(radix)).intValue();
				
				number = number.divide(new Number(radix));
				
				list.add(digit);
			}
			
			int s = list.size();
			
			int[] array = new int[digits > s ? digits : s];
			
			for (int i = 0; i < s; i++)
			
			    array[array.length -1 -i] = list.get(i);
			
			return array;
		}
	}
	
	
	
	public Number toInteger()
	{
		//  returns the integer value to the left of the intpoint
		//
		//  This integer value is ambiguous because an integer n could
		//  be represented as n + 0.00000000... or as n-1 + 0.99999999.
		
		return toInteger(true);
	}
	
	
	private Number toInteger(boolean round)
	{
		//  returns the integer to the left of the intpoint
		//
		//  If round is true, then a 1 is added to the least significant bit
		//  to round the number up before reading and returning the integer.
		
		
		//  Note that two numbers can be represented differently but should
		//  compare equally even if there are rounding errors from different
		//  operations. For example, 1.0000000000000000 and 0.9999999999999999
		//  should compare equally. In two intarrays the same number could be
		//  written as [12345678, 0, 0] or [12345677, -1, -1] because of the
		//  rounding error.
		//
		//  Adding a 1 to the last bit in the intarray might not round the
		//  number to the next integer because a number could have additional
		//  insignificant integers depending on the implementation of the number
		//  methods. For example, instead of the number [xxxxxxxx, -1, -1] where
		//  the intpoint and precision equal 2*8 or 16, the same number could be
		//  represented as [xxxxxxxx, -1, -1, xxxxxxxx] where the intpoint == 3
		//  and p == 2*8 == 16. In this example a 1 would have to be added to
		//  the element at index 2, not index 3.
		//
		//  To add a 1 to the least significant bit, the index of the element
		//  to add a 1 to is array.length -1 - (intpoint - p/8).
		
		
		int p = precision; while ((p % 8) != 0) p++;
		
		if ((p == 0) && (intpoint == 0))
		
		    return new Number(this);
		
		if (intpoint > this.intarray.length)
		
		    return new Number(0);
		
		Number n = new Number(this);
		
		if (round) n = n.roundBit();
		
		int[] intarray = n.intarray;
		
		n = new Number(Math.shiftRight(
		
		    intarray, 32*intpoint)) .trim();
		
		n.sign = this.sign;
		
		return n;
	}
	
	
	
	public Number toReal()
	{
		//  returns the real component
		
		Number n = new Number(this.intarray);
		
		n.intpoint = this.intpoint;
		n.precision = this.precision;
		n.sign = this.sign;
		
		return n;
	}
	
	
	public String toString()
	{
		return this.toString(0, 10);
	}
	
	public String toString(int radix)
	{
		return this.toString(0, radix);
	}
	
	public String toString(int digits, int radix)
	{
	
		//  converts a number to a string in any base or radix <= 16
		
		//  The base of a number is the digit modulus or the size of a digit.
		
		//  For bases > 16, use the toArray(radix) methods and then concatenate the digits.
		
		
		//  Any number can be converted to string using divisions and modular reductions.
		//  For example, the number 12345 could be converted to a string of digits in base 10
		//  by the following divide and mod (quotient and remainder) operations
		//
		//  mod reduction  digit     subtraction          division
		//
		//  12345 mod 10 == 5;     12345 - 5 == 12340;   12340 / 10 == 1234;
		//  1234  mod 10 == 4;     1234  - 4 == 1230;    1230 / 10 == 123;
		//  123   mod 10 == 3;     123   - 3 == 120;     120 / 10 == 12;
		//  12    mod 10 == 2;     12    - 2 == 10;      10 / 10 == 1;
		//  1     mod 10 == 1;     1     - 1 == 0;       0 / 10 == 0;
		
		
		//  Instead of using divs and mods, this method first divides the number by a
		//  power of the radix to move the integer point to the left of the number, and
		//  then uses multiplications and modular reductions (subtractions) to calculate
		//  each digit in base radix. This makes the string conversion a few times faster
		//  because multiplication is faster than division.
		//
		//  Example  Convert the base-16 number 3.243f6a888 to base 10
		//
		//  Multiply by 10^1 and subtract the integer value for each iteration
		//
		//  3.243f6a88     == 3.243f6a88;  digit == 3
		//  0.243f6a88 * a == 1.6A7A2955;  digit == 1
		//  0.6A7A2955 * a == 4.28C59D20;  digit == 4
		//  0.28C59D20 * a == 1.97B82340;  digit == 1
		//  0.97B82340 * a == 5.ED316080;  digit == 5
		//  0.ED316080 * a == 9.43EDC500;  digit == 9
		//  0.43EDC500 * a == 2.A749B200;  digit == 2
		//  0.A749B200 * a == 6.88E0F400;  digit == 6
		//  0.88E0F400 * a == 5.58C98800;  digit == 5
		//  0.58C98800 * a == 3.77DF5000;  digit == 3
		
		
		if (this.isComplex())
		{
			//  Return the complex number string
			
			Number real = this.toReal();
			Number imag = this.toImag();
			
			String rstring, istring;
			
			rstring = real      .toString(digits,radix).trim();
			istring = imag.abs().toString(digits,radix).trim();
			
			if (imag.sign == '+')
			
			     return rstring + " + " + istring + " i";
			else return rstring + " - " + istring + " i";
		}
		
		
		//  At 64 K digits the pi method still has a running time greater than
		//  the toString method so there is no need to use recursion for strings
		//  less than or equal to 64 K digits to convert pi to base 10, but for
		//  strings greater than 64 K the O(n^2) running time of the toString
		//  method will exceed the O(n log n) time of the pi method.
		
		int maxsize = 8*1024; // 8 K ints x 8 digits / int == 64 K digits
		
		
		//  Set the max size to infinity until the
		//  recursive toString1 method is finished
		
		/////////////////////////
		maxsize = 1024*1024*1024;
		/////////////////////////
		
		//  If the number of digits is greater than maxsize, this method
		//  will call another toString method to convert the number to string
		
		
		Number number = new Number(this);
		
		//  System.out.println(Arrays.toString(number.intarray));
		
		if (number.intpoint > number.intarray.length)
		
		    number = number .shiftLeft(32 *
		
			(1 + number.intpoint - number.intarray.length), 0);
		
		//  System.out.println(Arrays.toString(number.intarray));
		
		
		//  This method can convert numbers up to base 16
		//  (It may work for larger bases up to base 27)
		
		if ((radix < 2) || (radix > 16))
		{
			String message = "radix == " + radix;
			
			message += "\n\nuse the toArray(radix) method for"
			        +  " bases > 16 and concatenate the digits";
			
			throw new IllegalArgumentException(message);
		}
		
		String integerstr = "0", fractionstr = "0";  int index = 0;
		
		
		String str = new String(
		
		    Convert.byteArrayToCharArray(
		
		       Convert.byte256ArrayToByte16Array(
		
		          Convert.intArrayToByteArray(
		
		             number.intarray))) );
		
		
		
		if (radix == 16)
		{
		
			integerstr = str.substring(0, str.length() - 8 * number.intpoint);
			
			if ((integerstr == null) || integerstr.isEmpty()) integerstr = "0";
			
			fractionstr = str.substring(str.length() - 8 * number.intpoint, str.length());
			
			//  System.out.println(" integerstr16 = " +  integerstr);
			//  System.out.println("fractionstr16 = " + fractionstr);
			
			
			//  Set the precision
			
			if ((this.precision > 0) && (this.precision < fractionstr.length()))
			
			    fractionstr = fractionstr .substring(0, this.precision);
			
			
			//  Remove fraction string zeros
			
			index = 0;
			
			while ( (fractionstr.length() -1 - index >= 0)
			
			     && (fractionstr.charAt(
				 fractionstr.length() -1 - index) == '0')
			
			     && (fractionstr.length() - index > number.precision) )
			
				index += 1;
			
			fractionstr = fractionstr.substring(
			
			    0, fractionstr.length() - index);
			
			
			//  Add fraction string zeros
			
			index = this.precision - fractionstr.length();
			
			StringBuilder sb = new StringBuilder(fractionstr);
			
			while ((index / 8) > 0) { sb.append("00000000"); index -= 8; }
			while ((index / 1) > 0) { sb.append("0");        index -= 1; }
			
			fractionstr = sb.toString();
		}
		
		
		
		else if (radix != 16)
		{
		
			integerstr = "0"; fractionstr = "0";
			
			if ((str.length() - number.intpoint * 8) <= 0) integerstr = "0";
			
			else integerstr = str.substring(0, str.length() - number.intpoint * 8);
			
			
			if (this.intpoint != 0)
			{
				fractionstr = str.substring(
				
				    str.length() - number.intpoint * 8, str.length());
				
				String fractionstr1 = new String(fractionstr.toCharArray());
			}
			
			
			//  Convert radix-16 integer or fraction string to radix-n string
			
			
			if (!integerstr.isEmpty() && !new Number(integerstr, 16).equals(0))
			{
			
				while (true)
				{
				
					//  If radix is not a power of 2, add 1 to the number
					
					//  2^k & (2^k - 1) == 10000... & 01111... == 0
					
					if ((radix & (radix -1)) != 0) // radix != power of 2
					
					    integerstr = new Number(integerstr, 16)
					
						.add(1) .toString(16);
					
					
					if (integerstr.length() / 8 > maxsize)
					{
						//  Use recursion to convert the string
						
						integerstr = new Number(integerstr, 16)
						
						    .subtract(1) .toString1(radix);
						
						break;
					}
					
					
					//  Move the integer point to the left of the integer
					//  so multiplication can be used instead of division
					
					int length = 4 + (int) (integerstr.length()
					
					    * (Math.log(16.0) / Math.log(radix)));
					
					number = new Number(integerstr, 16)
					
					    .setPrecision(length) .divide(
					
						new Number(radix) .pow(length));
					
					
					//  Remove trailing zeros
					
					while (number.multiply(radix).intValue(false) == 0)
					{
						number = number.multiply(radix);
						
						length = length - 1;
					}
					
					
					//  Convert each digit to char and append to string
					
					String integerstr1 = "";
					
					Number number0 = number;
					
					for (int i = 0; i < length; i++)
					{
						number0 = number0 .multiply(radix);
						
						int digit = number0 .intValue(false);
						
						if (digit >= radix) throw new ArithmeticException();
						
						if (digit < 10)
						
						      integerstr1 += (char) (digit - 0 + '0');
						else  integerstr1 += (char) (digit -10 + 'a');
						
						number0 = number0 .subtract(digit);
					}
					
					
					//  Verify that the integer string is correct
					
					Number number1, number2;
					
					number1 = new Number(integerstr1, radix);
					number2 = new Number(integerstr, 16);
					
					//  2^k & (2^k -1) == 10000... & 01111... == 0
					
					if ((radix & (radix -1)) != 0) number1 = number1.add(1);
					
					if (!number1.equals(number2))
					{
						number = new Number(integerstr, 16) .setPrecision(length);
						
						Number divisor = new Number(radix) .pow(length);
						
						number = number .divide(divisor);
						
						String message = "error in toString() method";
						
						message += "\nnumber1 = " + number1 .toString(16);
						message += "\nnumber2 = " + number2 .toString(16);
						
						throw new ArithmeticException(message);
					}
					
					integerstr = integerstr1;
					
					break;
				}
			}
			
			
			
			if (!fractionstr.isEmpty() && !new Number(fractionstr, 16).equals(0))
			{
			
				while (true)
				{
					int length = fractionstr.length();
					
					if (length / 8 > maxsize)
					{
						//  Use recursion to convert the string to base radix
						
						System.out.println("\nfraction string == " + fractionstr);
						
						Number fraction = new Number(fractionstr, 16);
						
						fractionstr = fraction .toString1(radix);
						
						System.out.println("\nfraction string == " + fractionstr);
						
						break;
					}
					
					number = new Number(fractionstr, 16) .setPrecision(length)
					
					    .divide( new Number(16).pow(length) );
					
					fractionstr = "";
					
					for (int i = 0; i < this.precision + 4; i++)
					{
						number = number .multiply(radix);
						
						int digit = number.intValue(false);
						
						if (digit < 10)
						
						      fractionstr += (char) (digit - 0 + '0');
						else  fractionstr += (char) (digit -10 + 'a');
						
						number = number .subtract(digit);
					}
					
					break;
				}
			}
			
			number.sign = this.sign;
		}
		
		
		//  Set the length of the fraction string equal to the precision
		
		if ((this.precision > 0) && (this.precision + 1 < fractionstr.length()))
		
		    fractionstr = fractionstr.substring(0, this.precision + 1);
		
		
		//  Remove leading zeros from the integer string
		
		while (integerstr.startsWith("0"))
		
		    integerstr = integerstr.substring(1);
		
		
		//  Join the integer and fraction strings
		
		str = (integerstr.isEmpty() ? "0" : integerstr)
		
		    + (((this.precision == 0) || fractionstr.isEmpty()) ?
		
			"" : "." + fractionstr);
		
		if (str.startsWith("."))  str = "0" + str;
		
		if (str.isBlank())  str = "0";
		
		
		
		//  Pad the left side of the integer to the minimum number of digits
		
		//  If the radix == 16 or a power of 2, the number will be padded with
		//  zeros because base 16 is read by computers and is used for cryptog-
		//  raphy. If the radix is not a power of 2, the number will be padded
		//  with spaces.
		
		int length = str.length();
		
		if (digits > length)
		{
			index = 0;
			
			StringBuilder sb = new StringBuilder();
			
			while (digits - index++ > length)
			
			    sb.append(((radix == 16) || Math
			
				.isPowerOf2(radix)) ? "0" : " ");
			
			sb.append(str);
			
			str = sb.toString();
		}
		
		
		//  Remove the last fraction digit
		
		if (this.precision > 0)
		
		    str = str.substring(0, str.length() -1);
		
		
		//  Round the fraction up one digit before padding the right side
		
		if ((radix <= 16) && (this.precision > 0) &&
		
		    (this.intarray[this.intarray.length -1] != 0) )
		{
			StringBuilder sb = new StringBuilder(str);
			
			sb.insert(0, " "); // space for carry bit
			
			length = sb.length();  boolean carry = false;
			
			for (int i = length - 1; i >= 1; i--)
			{
				int c = sb.charAt(i);
				
				if (c == '.') continue;
				
				//  Roll the digit over to 0 or add 1 and break
				
				if ( ((c +  0 - '0') == (radix -1))
				  || ((c + 10 - 'a') == (radix -1)) )
				
				     { sb.setCharAt(i, '0');  carry = true; }
				
				else
				{	if (c != '9') sb.setCharAt(i, (char) (c + 1));
					
					else if (c == '9') sb.setCharAt(i, 'a');
					
					carry = false;
				}
				
				if (!carry) break;
			}
			
			if (carry)  sb.setCharAt(0, '1');
			
			str = sb.toString().trim();
		}
		
		
		//  Pad the right side of the number to precision + 1 digits
		
		length = fractionstr.length(); index = 0;
		
		if ((this.precision > 0) && (this.precision + 1 > length))
		{
			if (!str.contains("."))  str = str + ".";
			
			StringBuilder sb = new StringBuilder();  sb.append(str);
			
			while (this.precision + 1 - index++ > length)  sb.append("0");
			
			str = sb.toString();
		}
		
		
		//  Prepend the sign
		
		//  By convention the plus sign is omitted
		
		if (this.sign == '+')
		{
			//  Prepend a space so the positive
			//  and negative numbers are aligned
			
			if ((radix != 16) && (radix == 10))
			
			    str = " " + str;
		}
		
		else  //  if (this.sign == '-')
		{
			//  Zero can be plus or minus because multiplying zero by
			//  1 or -1 is still zero, but no sign is used for zero
			
			if (!str.trim().replace(".", "") .replaceAll("0", "") .isEmpty())
			
			    str = "-" + str;
		}
		
		//  Verify that abs | Number(str, radix) - this | < 1
		
		Number str_value_minus_this = new Number(str, radix) .subtract(this.toInteger());
		
		Number error = str_value_minus_this .abs() .round();
		
		if (!error .isLessThan(2))
		{
			System.out.println("this == " + Arrays.toString(this.intarray));
			System.out.println("this.intpoint == " + this.intpoint + " this.sign == " + this.sign);
			System.out.println("integer string == " + str);
			System.out.println("error == " + error);
			
			String message = "toString integer conversion error";
			
			throw new ArithmeticException(message);
		}
		
		//  Return the number string
		
		return str;
	}
	
	
	
	
	
	private String toString1(int radix)
	{
	
		//  converts a large integer to string using recursion
		
		//  This method is required for Numbers larger than 256 K chars because the
		//  toString conversion time increases by O(n^2) but multiplication time only
		//  increases by O(n^1.58) or O(n log n).
		//
		//  This method converts a large integer to string by recursively bifurcating
		//  the number into smaller parts until the numbers are small enough for the
		//  toString method, and then converting the numbers to string by the toString
		//  method and concatenating the string by the StringBuilder append method.
		//  The recursion can also be done as an iteration for efficiency.
		//
		//  Example  Print a 256 K bit number (in base 10)
		//
		//  int bits = 256*1024;
		//
		//  Number a = new Number(1) .shiftLeft(bits, bits);
		//
		//  System.out.println(a);
		
		
		if (!this.isInteger())
		
		    throw new IllegalArgumentException();
		
		String str = this.toString2(this.split(radix), radix);
		
		//  Verify that the conversion is correct
		
		if (!new Number(str, radix) .equals(this))
		
		    throw new ArithmeticException();
		
		return str;
	}
	
	
	
	private String toString2(Number[] left_right_digits, int radix)
	{
		//  converts a large fraction number to string using recursion
		
		//  Verify that the argument is an integer and power of 2
		
		if (!this.isInteger() || !this.isPowerOf(2))
		
		    throw new IllegalArgumentException();
		
		//  Test before recursion
		
		int maxsize = 4096 / 8;
		
		if (this.length() >= maxsize)
		{
			//  Bifurcate the number and call the toString2() method
			
			return toString2(this.split(radix), radix);
		}
		
		//  else if (this.length() < maxsize)
		
		//  Convert the numbers to padded strings and concatenate the strings
		
		Number   left = left_right_digits[0];
		Number  right = left_right_digits[1];
		int    digits = left_right_digits[2].intValue();
		
		String  leftstr =  left .toString(radix).trim();
		String rightstr = right .toString(radix).trim();
		
		while ( leftstr.length() != digits/2)  leftstr = "0" +  leftstr;
		while (rightstr.length() != digits/2) rightstr = "0" + rightstr;
		
		String leftright = leftstr + rightstr;
		
		return leftright;
	}
	
	
	private Number[] split(int radix)
	{
		//  This method is used by the toString1 and toString2 methods
		
		Number number = new Number(this);
		
		//  Calculate the digits in the new radix
		
		//  The number of digits is larger for smaller radixes
		//  For example, if a string is converted from hex to binary,
		//  the number of digits is multiplied by log 16 / log 2 == 4.
		
		int rdigits = (int) (this.length() * 8
		
		    * Math.log(16) / Math.log(radix));
		
		Number multiplier = new Number(radix) .pow(rdigits/2);
		
		//  Move the integer / fraction point to the middle
		
		number = number .multiply(multiplier);
		
		//  Read the left and right (integer and fractional) values
		
		Number left = number.toInteger();
		
		Number number1 = number .subtract(left) .multiply(multiplier);
		
		Number right = number1 .round();
		
		//  Verify that the left and right numbers are correct
		
		if (!left .multiply(multiplier) .add(right) .equals(number))
		{
			String message = "div mod error";
			
			throw new ArithmeticException(message);
		}
		
		return new Number[] { left, right, new Number(rdigits) };
	}
	
	
	public static String toString(Number[] array)
	{
		return toString(array, 0, 10);
	}
	
	public static String toString(Number[] array, int radix)
	{
		return toString(array, 0, radix);
	}
	
	
	public static String toString(Number[] array, int digits, int radix)
	{
		//  converts an array of numbers to
		//  an array of strings in any radix
		
		StringBuilder sb = new StringBuilder("[ ");
		
		for (int i = 0; i < array.length; i++)
		{
			sb.append(array[i].toString(digits, radix));
			
			if (i < array.length -1)  sb.append(", ");
		}
		
		sb.append(" ]");
		
		return sb.toString();
	}
	
	
	public Number trim()
	{
		//  trims the leading zeros
		
		int[] array = Math.trim(this.intarray);
		
		Number n = new Number(this);
		
		n.intarray = array;
		
		if (!this.isComplex()) return n;
		
		else
		{	int[] array1 = Math.trim(this.intarray1);
			
			n.intarray1 = array1;
			
			return n;
		}
	}
	
	
	public Number xor(Number val)
	{
		//  xors two numbers
		
		return new Number(Math.xor(this.intarray, val.intarray));
	}
}


//  End class Number



















class Matrix
{



	//  Instance member
	
	private Number[][] matrix;
	
	
	
	//  Matrix constructors
	
	
	public Matrix(int[][] matrix)
	{
		this.matrix = new Number[matrix.length][matrix[0].length];
		
		for (int i = 0; i < matrix   .length; i++)
		for (int j = 0; j < matrix[i].length; j++)
		
		    this.matrix[i][j] = new Number(matrix[i][j]);
	}
	
	
	public Matrix(double[][] matrix)
	{
		this.matrix = new Number[matrix.length][matrix[0].length];
		
		for (int i = 0; i < matrix   .length; i++)
		for (int j = 0; j < matrix[i].length; j++)
		
		    this.matrix[i][j] = new Number(matrix[i][j]);
	}
	
	
	public Matrix(Number[][] matrix)
	{
		this.matrix = new Number[matrix.length][matrix[0].length];
		
		for (int i = 0; i < matrix   .length; i++)
		for (int j = 0; j < matrix[i].length; j++)
		
		    this.matrix[i][j] = matrix[i][j];
	}
	
	
	
	public Matrix(int[] matrix, int rotation)
	{
		//  creates a circulant matrix from an array
		
		//  rotation =  0, +1, -1
		
		this.matrix = new Number[matrix.length][matrix.length];
		
		Number[] matrix1 = new Number[matrix.length];
		
		for (int i = 0; i < matrix1.length; i++)
		
		    matrix1[i] = new Number(matrix[i]);
		
		for (int i = 0; i < matrix1.length; i++)
		{
			this.matrix[i] = matrix1;
			
			matrix1 = rotate(matrix1, rotation);
		}
	}
	
	
	public Matrix(Number[] matrix, int rotation)
	{
		//  creates a circulant matrix from an array
		
		//  rotation =  0, +1, -1
		
		this.matrix = new Number[matrix.length][matrix.length];
		
		for (int i = 0; i < matrix.length; i++)
		{
			this.matrix[i] = matrix;
			
			matrix = rotate(matrix, rotation);
		}
	}
	
	
	
	public Matrix(double[] array)
	{
		//  creates a horizontal / row matrix from an array
		
		//  Use new Matrix(array) .transpose()
		//  to get a vertical / column matrix
		
		this.matrix = new Number[1][array.length];
		
		for (int j = 0; j < array.length; j++)
		
		    this.matrix[0][j] = new Number(array[j]);
	}
	
	
	public Matrix(int[] array)
	{
		//  creates a horizontal / row matrix from an array
		
		//  Use new Matrix(array) .transpose()
		//  to get a vertical / column matrix
		
		this.matrix = new Number[1][array.length];
		
		for (int j = 0; j < array.length; j++)
		
		    this.matrix[0][j] = new Number(array[j]);
	}
	
	
	public Matrix(Number[] array)
	{
		//  creates a horizontal / row matrix from an array
		
		//  Use new Matrix(array) .transpose()
		//  to get a vertical / column matrix
		
		this.matrix = new Number[1][array.length];
		
		for (int j = 0; j < array.length; j++)
		
		    this.matrix[0][j] = array[j];
	}
	
	
	public Matrix(int rows, int cols)
	{
		//  creates an empty matrix
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    this.matrix[i][j] = null;
	}
	
	
	public Matrix(int n, int rows, int cols)
	{
		//  creates a matrix initialized to n
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    this.matrix[i][j] = new Number(n);
	}
	
	
	public Matrix(int[] matrix, int rows, int cols)
	{
		//  converts an array of elements to a matrix
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    this.matrix[i][j] = new Number(matrix[i * cols + j]);
	}
	
	
	public Matrix(double[] matrix, int rows, int cols)
	{
		//  converts an array of elements to a matrix
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    this.matrix[i][j] = new Number(matrix[i * cols + j]);
	}
	
	
	public Matrix(Number[] array, int rows, int cols)
	{
		//  converts an array of elements to a public key / matrix
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    if (array[i * cols + j] != null)
		
			this.matrix[i][j] = new Number(array[i * cols + j]);
	}
	
	
	public Matrix(String str, int radix, int rows, int cols)
	{
		//  converts a public key string to a public key / matrix
		
		str = str .replaceAll(" ", "");
		
		if (   ( str.length() < (rows*cols) )
		  || ( ( str.length() % (rows*cols) ) != 0 ) )
		{
			String message = "\nmatrix string length"
			
			    + " is not a multiple of rows x cols\n";
			
			throw new IllegalArgumentException(message);
		}
		
		int digits = str.length() / (rows*cols);
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			String substring = str.substring(
			
			    (i*cols + j + 0) * digits,
			    (i*cols + j + 1) * digits);
			
			Number number = new Number(substring, radix);
			
			this.matrix[i][j] = number;
		}
	}
	
	
	public Matrix(String str, String str1, int radix, int rows, int cols)
	{
		//  converts a complex public key string to a complex public key / matrix
		
		//  str1 is not used
		
		str = str .replaceAll(" ", "");
		
		if (   ( str.length() < (rows*cols) )
		  || ( ( str.length() % (rows*cols) ) != 0 ) )
		{
			String message = "\nmatrix string length"
			
			    + " is not a multiple of rows x cols\n";
			
			throw new IllegalArgumentException(message);
		}
		
		int digits = str.length() / (rows * cols) / 2;
		
		this.matrix = new Number[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			String substring1 = str.substring(
			
			    (i*cols + j + 0) * digits,
			    (i*cols + j + 1) * digits);
			
			String substring2 = str.substring(
			
			    (i*cols + j + 2) * digits,
			    (i*cols + j + 3) * digits);
			
			Number number = new Number(
			
			    new Number(substring1, radix),
			    new Number(substring2, radix) );
			
			this.matrix[i][j] = number;
		}
	}
	
	
	public Matrix(Matrix matrix)
	{
		//  the matrix copy constructor
		
		this.matrix = new Number[
		
		    matrix.matrix.length][matrix.matrix[0].length];
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
			this.matrix[i][j] = matrix.matrix[i][j];
	}
	
	
	
	
	
	
	//  Matrix methods
	
	
	
	public Matrix abs()
	{
		//  returns the abs value
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = this.matrix[i][j].abs();
		
		return matrix;
	}
	
	
	public Matrix add(int number)
	{
		//  adds a number to a matrix M
		
		return add(new Number(number));
	}
	
	
	public Matrix add(Number n)
	{
		//  adds a number to a matrix M
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] =
		    matrix.matrix[i][j] .add(n);
		
		return matrix;
	}
	
	
	public Matrix add(Matrix matrix)
	{
		//  adds two matrices
		
		Matrix matrix1 = new Matrix(this);
		
		if ((matrix1.matrix   .length != matrix.matrix   .length)
		 || (matrix1.matrix[0].length != matrix.matrix[0].length))
		
		    throw new IllegalArgumentException();
		
		for (int i = 0; i < matrix1.matrix   .length; i++)
		for (int j = 0; j < matrix1.matrix[i].length; j++)
		
		    matrix1.matrix[i][j] = matrix1.matrix[i][j]
		
			.add(matrix.matrix[i][j]);
		
		return matrix1;
	}
	
	
	public static Matrix add(Matrix[] M)
	{
		//  returns the sum of M[]
		
		Matrix S = new Matrix(
		
		    M[0].rowCount(), M[0].columnCount());
		
		for (int i = 0; i < M.length; i++)
		
		    S = S .add(M[i]);
		
		return S;
	}
	
	
	public Matrix and(Number n)
	{
		//  ands a matrix and a number
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = this.matrix[i][j].and(n);
		
		return matrix;
	}
	
	
	public Matrix augment(int[] b)
	{
		Number[] B = new Number[b.length];
		
		for (int i = 0; i < B.length; i++)
		
		    B[i] = new Number(b[i]);
		
		return augment(B);
	}
	
	
	public Matrix augment(Number[] B)
	{
		//  forms the augmented matrix [ A | B ]
		
		return this.augment(new Matrix(B).transpose());
	}
	
	
	public Matrix augment(Matrix B)
	{
		//  forms the augmented matrix [ A | B ]
		
		Matrix A = new Matrix(this);
		
		if (A.rowCount() != B.rowCount())
		{
			String message =
			
			    "number of rows in Matrix B != A";
			
			throw new IllegalArgumentException(message);
		}
		
		Matrix matrix = new Matrix(A.rowCount(),
		
		    A.columnCount() + B.columnCount());
		
		for (int i = 0; i < A.matrix   .length; i++)
		for (int j = 0; j < A.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = A.matrix[i][j];
		
		for (int i = 0; i < B.matrix   .length; i++)
		for (int j = 0; j < B.matrix[i].length; j++)
		
		    matrix.matrix[i][A.matrix[i].length + j] = B.matrix[i][j];
		
		return matrix;
	}
	
	
	public int columnCount()
	{
		//  counts the number of columns
		
		if (this.matrix.length == 0)
		{
			String message = "empty matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		for (int i = 1; i < this.matrix.length; i++)
		{
			if (this.matrix[i].length != this.matrix[i-1].length)
			{
				String message = "row lengths are unequal";
				
				throw new IllegalArgumentException(message);
			}
		}
		
		return this.matrix[0].length;
	}
	
	
	public boolean commutesWith(Matrix matrix)
	{
		//  tests if two matrices commute
		
		//  return (A B == B A);
		
		return this.multiply(matrix) .equals(
		
		    matrix.multiply(this));
	}
	
	
	public Matrix complexConjugate()
	{
		//  returns the complex conjugate
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		{
			if (matrix.matrix[i][j].isComplex())
			
			    matrix.matrix[i][j] =
			    matrix.matrix[i][j] .complexConjugate();
		}
		
		return matrix;
	}
	
	
	public Matrix deleteColumn(int column)
	{
		//  deletes a column and reduces the column count
		
		int rows = this.matrix   .length;
		int cols = this.matrix[0].length;
		
		Matrix matrix = new Matrix(rows, cols -1);
		
		for (int i = 0;        i < rows;    i++)
		for (int j = 0, k = 0; j < cols -1; j++, k++)
		{
			if (j == column)  k++;
			
			matrix.matrix[i][j] = this.matrix[i][k];
		}
		
		return matrix;
	}
	
	
	public Matrix deleteRow(int row)
	{
		//  deletes a row and reduces the row count
		
		//  Delete row is used by the determinant and trim methods
		
		int rows = this.matrix.length;
		
		Number[][] arrays = new Number[rows - 1][];
		
		for (int i = 0, j = 0; i < rows-1; i++, j++)
		{
			if (i == row)  j++;
			
			arrays[i] = this.matrix[j];
		}
		
		return new Matrix(arrays);
	}
	
	
	
	//  Determinants are used to compute the product of three vectors.
	//
	//  The product of three vectors is the volume of a parallelepiped
	//
	//           |  x1   y1  z1  |
	//     V  =  |  x2   y2  z2  |
	//           |  x3   y3  z3  |
	//
	//  where the vectors (x1, y1, z1), (x2, y2, z2), and (x3, y3, z3) are three sides
	//  starting from the same corner or vertex as the basis vectors i, j, k of the rec-
	//  tilinear coordinate system. The volume V is a scalar because the determinant is
	//  a number instead of a matrix or a vector.
	//
	//
	//  If one of the three vectors is the basis vector (i, j, k), then the determinant
	//  is the area of a parallelogram or the cross product of two vectors C = A (x) B.
	//
	//  The area of the parallelogram is defined by
	//
	//            |   i    j    k  |
	//     A  =   |  x1   y1   z1  |
	//            |  x2   y2   z2  |
	//
	//  where the vectors (x1, y1, z1) and (x2, y2, z2) are two sides starting from the
	//  same vertex and i, j, k are the three basis vectors of the coordinate system.
	//
	//  The cross product C = A (x) B is the product of the magnitudes of A and B times
	//  the sine of the angle between the two vectors. The vector C which represents the
	//  area of the parallelogram is perpendicular to the plane containing the vectors A
	//  and B. The product C is a vector instead of a scalar because i, j, and k are let-
	//  ters instead of numbers.
	//
	//
	//  Determinants can be used also to compute the area of a triangle
	//
	//                |  1   x1   y1  |
	//     A  =  1/2  |  1   x2   y2  |
	//                |  1   x3   y3  |
	//
	//  where (x1, y1), (x2, y2), and (x3, y3) are the coordinates of the vertices.
	//
	//  Expanding the determinant into minors and adding the cofactors gives the formula
	//
	//  A  = 1/2 [ 1 (x2 y3 - y2 x3) - x1 (y3 - y2) + y1 (x3 - x2) ]
	//
	//    == 1/2 [ x2 y3 - x3 y2 - x1 y3 + x1 y2 + x3 y1 - x2 y1 ].
	//
	//  This formula should equal 1/2 the base times the height of the triangle.
	//
	//  If we place two of the three vertices along the x-axis, then y1 = y2 = 0 and
	//
	//  A == 1/2 [ x2 y3 - x1 y3 ] == 1/2 [ (x2 - x1) y3 ] == 1/2 the base x the height.
	
	
	
	//  Properties of determinants
	//
	//  The determinant of the product of two matrices A and B is the product of the
	//  determinants of A and B, or | A B | == | A || B |. (The determinant of the
	//  product equals the product of the determinants.)
	//
	//  If the rows and columns of a matrix are transposed, the determinant is un-
	//  changed. (| A | == | A^T |)
	//
	//  If any two rows (columns) of a matrix are interchanged then the value of the
	//  determinant is negated. (For a 2x2 matrix { { a, b }, { c, d } } the deter-
	//  minant is a d - b c, therefore swapping the two rows gives the determinant
	//  c b - d a  or  b c - a d  which is the negative of  a d - b c.)
	//
	//  If any row (column) of a matrix is multiplied by a number k, then the value
	//  of the determinant is also multiplied by k. (For a 1x1 matrix { a } the de-
	//  terminant is | a | == a, therefore | k a | == k a.)
	//
	//  If any row (column) of a matrix is multiplied and added to another row (col-
	//  umn), the determinant is unchanged. (For a 2x2 matrix { { a, b }, { c, d } }
	//  the determinant is  a d - b c, therefore a (d + b) - b (c + a) == a d - b c
	//  + (a b - a b) == a d - b c.)
	//
	//  If all elements of any row (column) of a matrix equal zero, then the value
	//  of the determinant is zero. (Multiplying a row by zero multiplies the deter-
	//  minant by zero because for a 1x1 matrix | k a | == k a; similarly, for a 2x2
	//  matrix { { a, b }, { c, d } }, the determinant  a d - b c  is  0 d - 0 c  or
	//  a 0 - b 0  which is 0 if either row { a, b } or { c, d } == { 0, 0 })
	//
	//  If any two rows (columns) of a matrix are identical, then the value of the
	//  determinant is zero. (All rows or equations have to be linearly independent
	//  for a matrix to be reducible, solvable, or invertible.)
	//
	//  If the determinant of a matrix is zero, then the matrix is singular or non-
	//  invertible. Conversely, if a matrix is singular or non-invertible, then the
	//  determinant of the matrix is zero.
	//
	//  If a matrix is in echelon (upper or lower triangular) form, then the deter-
	//  minant equals the product of the diagonal elements. For the 2x2 matrix
	//  { { a, b }, { c = 0, d } } in echelon form, the determinant is a d - b c ==
	//  a d - 0 b == a d which is the product of the diagonal elements. For the 1x1
	//  matrix { a } which is always in echelon form, the product of the diagonal
	//  elements equals a because there is only one element.
	//
	//  If a matrix is reduced to echelon form and any of the diagonal elements is
	//  missing or zero, then the determinant is zero because the product of the
	//  diagonal elements equals zero.
	//
	//  If the determinant of a matrix is non-zero, then there is a unique solution
	//  to the equation A X == B. (For the 1x1 equation a x == b, x == b / a.)
	//
	//  If the determinant of a matrix A is zero, then there is no solution or there
	//  are multiple solutions to the equation A X == B, and there are non-trivial or
	//  non-zero solutions for A X == 0. (For the 1x1 equation a x == 0 where a == 0
	//  because the determinant is zero, x == 0 / 0 which is undefined.)
	
	
	public Number determinant()
	{
		//  returns the determinant of a matrix
		
		//  This method evaluates the determinant of a matrix by reducing the
		//  matrix to echelon (upper triangular) form and then computing the
		//  product of the diagonal elements divided by the product of the
		//  multipliers and multiplied by (-1) ^ the number of swaps modulo 2.
		
		//  This method requires only O(n^3) steps or operations (the cost of
		//  one matrix multiplication), compared to the recursive method of
		//  expanding the matrix into minors which requires O(n!)! (factorial
		//  operator! and exclamation point!) steps or operations.
		
		
		Matrix matrix = new Matrix(this);
		
		int rows = matrix.matrix.length;
		int cols = matrix.matrix[0].length;
		
		
		//  Set a minimum precision
		
		int p = matrix.getPrecision();
		
		if (p == 0) p = 8;
		
		
		//  Set the inverse precision
		
		int invp = 0;
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			int invp1 = matrix.get(i,j)
			
			    .inverse().getPrecision();
			
			if (invp1 > invp) invp = invp1;
		} 
		
		//  Define the precision of zero
		
		Number zero = new Number(0).setPrecision(p);
		
		if (matrix.matrix.length != matrix.matrix[0].length)
		{
			String message = "non-square matrix determinant";
			
			throw new IllegalArgumentException(message);
		}
		
		if (matrix.matrix.length == 1)
		
		    return matrix.matrix[0][0];
		
		if (this.matrix.length == 2)
		
		    return determinant1();
		
		
		////////////////////////////////////////////////////////////////
		
		
		//  Reduce the matrix to echelon form
		
		//  For computing determinants, count the number of swaps modulo 2
		//  to determine the sign and accumulate the product of the m's
		//  because multiplying any row by a scalar also multiplies the
		//  determinant.
		
		boolean swap = false;
		
		Number m_product = new Number(1);
		
		
		//  Reduce the matrix to echelon form
		
		for (int r = 0; r < rows - 1; r++)
		{
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				
				    if (!matrix.matrix[i][j].equals(zero))
				
					{ bool = true;  break; }
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			//  Swap rows i and r if element[r][j] equals zero
			
			if (i != r)
			{
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
				
				swap = !swap;
			}
			
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				Number m1 = matrix.matrix[r][j];
				Number m2 = matrix.matrix[i][j];
				
				if (m1.equals(zero)) continue;
				if (m2.equals(zero)) continue;
				
				//  Compute the inverse of m1 and m2
				//
				//  (allow the precision or size of the inverse to expand
				//  or else the product of m and inv m will not equal 1)
				
				Number inv_m1 = m1.setPrecision(invp).inverse();
				Number inv_m2 = m2.setPrecision(invp).inverse();
				
				//  Multiply row r by m1 and row i by m2 so that
				//  the first element of both rows equals 1
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				{
					matrix.matrix[r][k] = matrix.matrix[r][k] .multiply(inv_m1);
					matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(inv_m2);
				}
				
				//  Subtract row r from row i to eliminate the first element of i
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				
				    matrix.matrix[i][k] = matrix.matrix[i][k]
				
					.subtract(matrix.matrix[r][k]);
				
				//  Set the precision of the matrix after each iteration
				
				matrix = matrix.setPrecision(invp);
				
				//  Accumulate the product of the row multipliers
				
				m_product = m_product .multiply(inv_m1) .multiply(inv_m2);
			}
		}
		
		
		////////////////////////////////////////////////////////////////
		
		
		//  Calculate the product of the diagonal elements
		
		Number d = new Number(1);
		
		for (int k = 0; k < matrix.matrix.length; k++)
		
		    d = d .multiply(matrix.matrix[k][k]);
		
		
		//  Negate the sign if the number of swaps == 1 mod 2
		
		if (swap) d = d .negate();
		
		
		//  Remove the product of the row multipliers
		
		d = d .divide(m_product) .setPrecision(p);
		
		
		//  Round the number only if the fraction digits are zero
		//  or if the elements of the original matrix are all zero
		
		if ((this.getPrecision() == 0)
		
		    || d.toFraction().equals(zero))
		
			d = d.round();
		
		return d;
	}
	
	
	public Number determinant(int modulus)
	{
		return determinant(new Number(modulus));
	}
	
	
	public Number determinant(Number modulus)
	{
		//  returns the determinant of a matrix
		
		//  This method evaluates the determinant of a matrix by
		//  reducing the matrix to echelon (upper triangular) form
		//  and then computing the product of the diagonal elements.
		
		//  This method requires only O(n^3) steps or operations (the
		//  cost of one matrix multiplication), compared to the recursive
		//  method of expanding the matrix into minors which requires O(n!)!
		//  (factorial operator! and exclamation point!) steps or operations.
		
		
		Number n = modulus, n2 = n.square();
		
		Matrix matrix = new Matrix(this);
		
		if (matrix.matrix.length != matrix.matrix[0].length)
		{
			String message = "non-square matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		if (matrix.matrix.length == 1)
		
		    return matrix.matrix[0][0];
		
		if (this.matrix.length == 2)
		
		    return determinant1(modulus);
		
		
		////////////////////////////////////////////////////////////////
		
		
		//  Reduce the matrix to echelon form
		
		
		//  Forward Elimination
		//
		//  Reduce the matrix to (upper) echelon form
		//
		//  (put zeros below each pivot)
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		int digits = (int) n.bitCount() / 4;
		
		Number invn  = n  .setPrecision(2*digits) .inverse();
		Number invn2 = n2 .setPrecision(4*digits) .inverse();
		
		
		//  For computing determinants, count the number of swaps modulo 2
		//  to determine the sign and accumulate the product of the m1's
		//  because multiplying any row by a scalar multiplies the deter-
		//  minant by the same amount.
		
		boolean swap = false;
		
		Number m1_product = new Number(1);
		
		
		int base = 1, exp = 0;
		
		if (n.isPrimePower())
		
		    for (int i = 2; i < 1024*1024; i++)
		
			if (n.isDivisibleBy(i))
		
			    { base = i; break; }
		
		
		int rows = matrix.matrix.length;
		
		for (int r = 0; r < rows - 1; r++)
		{
			if (matrix.matrix.length > 256) System.out.print(r + " ");
			
			//  Reduce the augmented matrix [ A | B ] to echelon form
			
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				{
					if ( matrix.matrix[i][j].equals(0)) continue;
					if (!matrix.matrix[i][j].equals(0))
					
					    { bool = true;  break; }
				}
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			
			//  Swap rows i and r if element [r][j] equals zero
			
			if (i != r)
			{
				swap = !swap;
				
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
			}
			
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = [r][j],  m2 = - [i][j],
				//
				//  instead of  m = - [i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m3 == [i][j][r][j] - [i][j][r][j] == 0
				
				Number m1 = matrix.matrix[r][j];
				Number m2 = matrix.matrix[i][j];
				
				if (m2.equals(0)) continue;
				
				//  Remove the common factor from the multipliers before multiplying
				//  and subtracting the rows because the common factor is not subtracted
				
				Number gcd = m1.gcd(m2);
				
				m1 = m1.divide(gcd);
				m2 = m2.divide(gcd);
				
				//  Negate the value of m1
				
				m1 = m1 .negate();
				
				
				//  Multiply row r by m2, and add to row i multiplied by m1
				
				//  For prime power moduli, the method uses the modulus squared
				//  instead of the modulus to reduce the elements of the matrix.
				
				Number    n1 = (base <= 1) ?    n :    n2;
				Number invn1 = (base <= 1) ? invn : invn2;
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				
				    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m1)
				
					.add( matrix.matrix[r][k] .multiply(m2) ) .mod(n1, invn1);
				
				
				//  Accumulate the product of m1 and remove the base
				
				m1_product = m1_product .multiply(m1);
				
				if (base >= 2) while (m1_product.isDivisibleBy(base))
				
				    { m1_product = m1_product.divide(base); exp++; }
				
				m1_product = m1_product.mod(n);
			}
		}
		
		
		////////////////////////////////////////////////////////////////
		
		
		//  Calculate the product of the diagonal elements
		
		Number d = new Number(1);
		
		for (int k = 0; k < matrix.matrix.length; k++)
		{
			d = d .multiply(matrix.matrix[k][k]);
			
			if (base >= 2)
			
			    while (d.isDivisibleBy(base) && (exp > 0))
			
				{ d = d.divide(base); exp--; }
		}
		
		
		//  Negate the sign if the number of swaps == 1 mod 2
		
		if (swap) d = d.negate(n);
		
		//  Remove the product of the m1's
		
		d = d .modDivide(m1_product, n);
		
		return d;
	}
	
	
	public Number determinant1()
	{
		return this.determinant1(null);
	}
	
	public Number determinant1(int modulus)
	{
		return this.determinant1(new Number(modulus));
	}
	
	public Number determinant1(Number modulus)
	{
		//  This method evaluates the determinant of a matrix recursively
		//  by expanding the matrix into minors and adding the cofactors
		
		//  This alternate method was used to verify the determinant by
		//  expanding the matrix into minors instead of reducing the matrix
		//  to echelon form and taking the product of the diagonal elements.
		//
		//  This method is inefficient for large matrices because it re-
		//  quires O(n!) or n factorial steps or operations.
		
		
		//  Compute the determinant by recursion
		//
		//  using the definitions | a11 | == a11  and
		//
		//  | a11  a12 |
		//  |          | == a11 a22 - a12 a21.
		//  | a21  a22 |
		
		
		Number n = modulus;
		
		if (!this.isSquare())
		{
			String message = "non-square matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		Matrix matrix = new Matrix(this);
		
		if (n != null) matrix = matrix.mod(n);
		
		
		//  Test before recursion
		
		if (matrix.matrix.length == 1) // | a | = a
		
		    return matrix.matrix[0][0];
		
		
		//  Test before recursion
		
		if (matrix.matrix.length == 2)
		{
			//  | A | == a[1][1] a[2][2] - a[1][2] a[2][1]
			
			Number d = matrix.matrix[0][0]
			
			   .multiply(matrix.matrix[1][1])
			
			      .subtract(matrix.matrix[0][1]
			
				 .multiply(matrix.matrix[1][0]));
			
			if (modulus != null)
			
			    d = d .mod(n);
			
			return d;
		}
		
		//  Start the recursion
		
		//  determinant = the sum of A[0][j] *
		//
		//     ( the determinant of A.deleteRow(0) .deleteColumn(j) )
		
		Number d = new Number(0);
		
		for (int j = 0; j < this.matrix[0].length; j++)
		{
			Number d1 = matrix.matrix[0][j] .multiply(
			
			    matrix.deleteRow(0).deleteColumn(j) .determinant1(n) );
			
			if ((j % 2) == 1)  d1 = d1 .negate();
			
			d = d .add(d1);
			
			if (modulus != null)
			
			    d = d .mod(n);
		}
		
		return d;
	}
	
	
	
	public Matrix[] diagonalize()
	{
		return diagonalize(null);
	}
	
	
	public Matrix[] diagonalize(Number p)
	{
		//  Finds a matrix P such that P^-1 A P == D so that A can be
		//  factored as P D P^-1 and returns the array { P, D, P^-1 }
		//  if the matrix is diagonalizable or else returns null.
		//
		//  Diagonalization is useful for exponentiation because it
		//  is faster to compute D^x than to compute A^x, except for
		//  2x2 Latin squares or circulant matrices which only require
		//  three multiplications per iteration.
		//
		//  Some matrices are not diagonalizable but matrices that are
		//  real and symmetric can always be diagonalized.
		
		
		//  Factor a matrix A into P D P^-1 using eigen decomposition
		
		Matrix A = new Matrix(this);
		
		if (A.matrix.length == 1) return // [1] A [1]^-1
		
		    new Matrix[] { Matrix.identityMatrix(1), A,
		                   Matrix.identityMatrix(1) };
		
		if (A.matrix.length == 2)
		{
			//  Find the eigenvalues and eigenvectors
			
			Number t = A.trace();
			
			if (p != null) t = t.mod(p);
			
			Number d = A.determinant(p);
			
			//  Use the formula x^2 - trace(A) x + | A | == 0, or
			//
			//  x == [ trace(A) + sqrt( trace(A)^2 - 4 | A | ) ] / 2
			
			Number discriminant = t.square() .subtract(d.multiply(4));
			
			if (p != null)
			{
				//  If the discriminant is a quadratic non-residue
				//  then the matrix is not diagonalizable
				
				discriminant = discriminant .mod(p);
				
				if (!discriminant.isQuadraticResidue(p)) return null;
			}
			
			Number sqrt;
			
			if (p != null) sqrt = discriminant.modSqrt(p);
			else           sqrt = discriminant.sqrt();
			
			if (sqrt == null)
			{
				System.out.println("mod sqrt error");
				
				return null;
			}
			
			Number u1, u2;
			
			if (p != null)
			{
				u1 = t      .add(sqrt) .modDivide(2, p);
				u2 = t .subtract(sqrt) .modDivide(2, p);
			}
			
			else
			{	u1 = t      .add(sqrt) .divide(2);
				u2 = t .subtract(sqrt) .divide(2);
			}
			
			Matrix M1 = A .subtract(Matrix.identityMatrix(2).multiply(u1));
			Matrix M2 = A .subtract(Matrix.identityMatrix(2).multiply(u2));
			
			if (p != null)
			{
				M1 = M1 .mod(p);
				M2 = M2 .mod(p);
			}
			
			//  a1 u1 + b1 v1 == 0;  b1 v1 == - a1 u1;  v1 == - (a1 / b1) u1
			//  a2 u2 + b2 v2 == 0;  b2 v2 == - a2 u2;  v2 == - (a2 / b2) u2
			
			//  Set u1 and u2 == 1 and then calculate v1 and v2
			
			u1 = new Number(1);
			u2 = new Number(1);
			
			Number v1, v2;
			
			if (p != null)
			{
				v1 = M1.get(0, 0).modDivide(M1.get(0, 1), p).negate(p);
				v2 = M2.get(0, 0).modDivide(M2.get(0, 1), p).negate(p);
			}
			
			else
			{	v1 = M1.get(0, 0).divide(M1.get(0, 1)).negate();
				v2 = M2.get(0, 0).divide(M2.get(0, 1)).negate();
			}
			
			Matrix P, D, P1;
			
			//  Normalize the eigenvectors
			//  { u1, v1 } and { u2, v2 }
			
			//  Compute the sums of the squares
			
			Number sum1 = u1.square() .add(v1.square());
			Number sum2 = u2.square() .add(v2.square());
			
			//  Divide the vectors by the sums of the squares
			
			if (p != null)
			{
				sum1 = sum1 .mod(p);
				sum2 = sum2 .mod(p);
				
				u1 = u1.modDivide(sum1, p);
				v1 = v1.modDivide(sum1, p);
				u2 = u2.modDivide(sum2, p);
				v2 = v2.modDivide(sum2, p);
			}
			
			else
			{	u1 = u1.divide(sum1);
				v1 = v1.divide(sum1);
				u2 = u2.divide(sum2);
				v2 = v2.divide(sum2);
			}
			
			//  The Matrix P is the transpose of
			//  the vectors { u1, v1 }, { u2, v2 }
			
			P = new Matrix( new Number[][]
			
			   { { u1, u2 }, { v1, v2 } } );
			
			if (p != null)	P1 = P.modInverse(p);
			else		P1 = P.   inverse();
			
			D = P1 .multiply(A) .multiply(P);
			
			if (p != null) D = D .mod(p);
			
			return D.isDiagonal() ? new
			
			    Matrix[] { P, D, P1 } : null;
		}
		
		
		if (A.matrix.length == 3)
		{
		
			//  Use the formula x^3 - trace(A) x^2 + (A11 + A22 + A33) x - | A | == 0
			//
			//  where Aii denotes the cofactor of aii in the matrix A = aij.
			//
			//         | a11--a12--a13 |         | a11  a12  a13 |         | a11  a12  a13 |
			//      __ |  |            |      __ |       |       |      __ |            |  |
			//  A11 __ | a21  a22  a23 |  A22 __ | a21--a22--a23 |  A33 __ | a21  a22  a23 |
			//         |  |            |         |       |       |         |            |  |
			//         | a31  a32  a33 |         | a31  a32  a33 |         | a31--a32--a33 |
			//
			//
			//           | a22  a23 |              | a11  a13 |              | a11  a12 |
			//  A11  ==  |          |     A22  ==  |          |     A33  ==  |          |
			//           | a32  a33 |              | a31  a33 |              | a21  a22 |
			//
			
			//  Set C1 = - trace(A);  C2 = (A11 + A22 + A33);  C3 = - | A |;
			//
			//  Number[] coefficients = new Number[] { C1, C2, C3 }; then use the
			//  solveCubicEquation method to find the three roots of the cubic
			//  equation x^3 - trace(A) x^2 + (A11 + A22 + A33) x - | A | == 0.
			
			//  ...
			
			//  ...
		}
		
		else if (A.matrix.length > 3)
		{
			//  Use a different method for diagonalizing large matrices
			
			//  ...
			
			//  ...
		}
		
		return null;
	}
	
	
	private static Number[] solveCubicEquation(Number[] coefficients, Number modulus)
	{
	
		//  This method solves a cubic equation
		//  and returns three solutions
		
		
		//  Example  Solve the cubic equation
		//
		//  x^3 + [ a x^2 + b x + c ] == 0
		//
		//
		//  A = (3 b - a^2) / 9;
		//
		//  B = (9 a b - 27 c - 2 a^3) / 54;
		//          _______________
		//      3  /   2  _________
		//  C =  \/ B + \/A^3 + B^2;
		//          _______________
		//      3  /   2  _________
		//  D =  \/ B - \/A^3 + B^2;
		//
		//  then the three solutions are
		//
		//  x1 == + (C + D)/1 - a/3 + i 0;  (real solution)
		//                                _
		//  x2 == - (C + D)/2 - a/3 + i \/3/2 (C - D);
		//                                _
		//  x3 == - (C + D)/2 - a/3 - i \/3/2 (C - D);
		//
		//  where x1 is the real solution and x2 and x3 are
		//  the imaginary and complex conjugate solutions.
		
		
		if (coefficients.length != 3)
		
		    throw new IllegalArgumentException();
		
		Number a = coefficients[0];
		Number b = coefficients[1];
		Number c = coefficients[2];
		
		int p = a.getPrecision() >= b.getPrecision() ?
		        a.getPrecision() :  b.getPrecision();
		
		p = c.getPrecision() >= p ? c.getPrecision() : p;
		
		if (p == 0) p = 8;
		
		a = a.setPrecision(p);
		b = b.setPrecision(p);
		c = c.setPrecision(p);
		
		
		Number A, B, C, D;
		
		A = b.multiply(3) .subtract(a.square()) .divide(9);
		B = a.multiply(b) .multiply(9) .subtract(c.multiply(27))
		    .subtract(a.cube().multiply(2)) .divide(54);
		
		Number A3plusB2 = A.cube() .add(B.square());
		if (A3plusB2 .signum() == -1) return null;
		
		C = B      .add( A3plusB2 .sqrt() ) .root(3);
		D = B .subtract( A3plusB2 .sqrt() ) .root(3);
		
		
		//  Compute the real and imaginary components
		
		Number x1r = C .add(D)           .divide(1) .subtract(a.divide(3));
		Number x2r = C .add(D) .negate() .divide(2) .subtract(a.divide(3));
		Number x3r = C .add(D) .negate() .divide(2) .subtract(a.divide(3));
		
		Number x2i = C .subtract(D) .multiply(new Number(3).sqrt().divide(2));
		Number x3i = C .subtract(D) .multiply(new Number(3).sqrt().divide(2));
		
		
		Number[] x = new Number[3];
		
		x[0] = new Number(x1r, new Number(0));
		x[1] = new Number(x2r, x2i);
		x[2] = new Number(x3r, x3i .negate());
		
		
		//  Verify that x^3 + [ a x^2 + b x + c ] == 0.
		
		Number zero = new Number(0) .setPrecision(p);
		
		for (int i = 0; i < x.length; i++)
		
		   if (!x[i].cube() .add( a.multiply(x[i].square())
		
		      .add(b.multiply(x[i])) .add(c) ) .equals(zero))
		
		         throw new ArithmeticException();
		
		return new Number[] { x[0], x[1], x[2] };
	}
	
	
	
	public Matrix divide(int n)
	{
		//  divides the elements by an int
		//  and returns the quotient matrix
		
		return divide(new Number(n));
	}
	
	
	public Matrix divide(Number number)
	{
		//  divides the elements by a number
		//  and returns the quotient matrix
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = this.matrix[i][j] .divide(number);
		
		return matrix;
	}
	
	
	private Matrix enumerate()
	{
		//  enumerates the elements in a matrix by replacing the
		//  element value with the index of the element
		//
		//  This method is used to create Latin squares that contain
		//  thousands of elements. The numbers could be replaced with
		//  other characters or symbols.
		
		Matrix matrix = new Matrix(this);
		
		ArrayList<Number> list = new ArrayList<Number>();
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		{
			int index = -1;
			
			Number element = this.matrix[i][j];
			
			for (int k = 0; k < list.size(); k++)
			
			    if (list.get(k).equals(element)) index = k;
			
			if (index != -1) matrix.matrix[i][j] = new Number(index);
			
			else // if (index == -1)
			{
				matrix.matrix[i][j] = new Number(list.size());
				
				list.add(element);
			}
		}
		
		return matrix;
	}
	
	
	
	public boolean equals(Matrix matrix)
	{
		//  tests if two matrices are equal
		
		//  This method throws an exception if the matrices are not comparable
		//  because the equality test is undefined if the matrices have differ-
		//  ent dimensions. (Returning false instead of throwing an exception
		//  could cause a bug in a program that would be difficult to find.)
		
		if ( (this.matrix   .length != matrix.matrix   .length)
		  || (this.matrix[0].length != matrix.matrix[0].length) )
		{
			String message = "matrices are not comparable";
			
			throw new IllegalArgumentException(message);
		}
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    if (!this.matrix[i][j].equals(
		       matrix.matrix[i][j]))
		
			return false;
		
		return true;
	}
	
	
	
	public static Matrix exp(Matrix Z)
	{
	
		//  Computes the matrix exponential
		//
		//    Z
		//  e   ==  I + Z + Z^2 / 2! + Z^3 / 3! + ...
		//
		//  which is the same as the number formula
		//
		//    z
		//  e   ==  1 + z + z^2 / 2! + z^3 / 3! + ...
		//
		//        z       n
		//  or  e   ==  z  / n!  where e == 1 / n!
		//
		//  is the base of the natural logarithm and
		//
		//  Z = X + i Y  is a real, imaginary, or complex matrix
		
		
		//  If  Z = i X  then the exponent is imaginary and the function
		//
		//    Z = i X
		//  e         == I + i X - X^2 / 2! - i X^3 / 3! + X^4 / 4! + ...
		//
		//            ==  X^0 / 0! - X^2 / 2! + X^4 / 4! + ...)
		//
		//            +  i (X^1 / 1! - X^3 / 3! + X^5 / 5! + ...)
		//
		//            ==  cos X + i sin X
		//
		//  is oscillatory because the imaginary number
		//
		//     0,1,2,3,..
		//   i           == 1, i, -1, -i,  1, i, -1, -i,  ...
		//
		//  alternates the signs of the terms so that exp(i X) becomes
		//  a rotating vector a + i b on a circle in the complex number
		//  plane where the length of the vector is the sqrt of a^2 + b^2
		//  or sqrt(cos^2 X + sin^2 X).
		
		
		//  The matrix exponential function will converge for any z or Z
		//  because the denominator n! grows faster than z^n or Z^n, but
		//  the value of Z has to be close to 1 for the function to con-
		//  verge at ~ 1 bit per iteration.
		//
		//  Both terms are exponential but the factorial term is more than
		//  exponential because the multiplier grows (linearly) while the
		//  Z^n multiplier (or base) remains constant. This is why the ap-
		//  proximation for the factorial function is (n / e) ^ n instead
		//  of e ^ n.
		
		
		if (Z.rowCount() != Z.columnCount())
		
		    throw new IllegalArgumentException();
		
		//           0        1        2
		//  Compute Z / 0! + Z / 1! + Z / 2! + ...
		
		Matrix Z_ = Z.pow(0);
		
		if (Z_.getPrecision() < 8)
		
		    Z_ = Z_.setPrecision(8);
		
		Matrix result = new Matrix(Z_);
		
		Number fact = new Number(1);
		
		Matrix prev = result;
		
		for (int i = 1;  ; i++)
		{
			Z_ = Z_ .multiply(Z);
			
			fact = fact.multiply(i);
			
			prev = result;
			
			result = result .add(Z_.divide(fact));
			
			if (result.equals(prev)) break;
			
			//  System.out.println();
			
			//  System.out.println(result);
		}
		
		return result;
	}
	
	
	public Number gcd()
	{
		//  returns the gcd or greatest common divisor of the elements;
		//  the matrix can have zeros and have a gcd > 1 but it cannot
		//  have a 1 and have a gcd > 1.
		
		Number gcd = new Number(0);
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		{
			Number element = this.matrix[i][j];
			
			gcd = this.matrix[i][j].gcd(gcd);
			
			System.out.print(element + " " + gcd + "    ");
		}
		
		return  gcd;
	}
	
	
	public Number get(int i, int j)
	{
		//  returns one element
		
		return this.matrix[i][j];
	}
	
	
	public Matrix get(int row, int column, int rows, int cols)
	{
		//  copies a sub matrix from a (super) matrix
		
		//  Row and column are the offsets from 0, 0
		//  Rows and columns are the size of the sub matrix
		
		if ( (   row + rows > this.matrix   .length)
		  || (column + cols > this.matrix[0].length) )
		{
			String message = "rows or columns of sub matrix"
			    + " + offset exceed super matrix dimensions";
			
			throw new IllegalArgumentException(message);
		}
		
		Matrix matrix = new Matrix(rows, cols);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[0].length; j++)
		
		    matrix.set(this.matrix[row + i][column + j], i, j);
		
		return matrix;
	}
	
	
	public Number[] getColumn(int column)
	{
		//  returns one column
		
		Number[] array = new Number[this.matrix.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = this.matrix[i][column];
		
		return array;
	}
	
	
	public Number[] getDiagonals()
	{
		//  returns the diagonal elements
		
		int rows = matrix.length, cols = matrix[0].length;
		
		int t = cols -1; if (rows < cols -1) t = rows;
		
		Number[] diagonals = new Number[t];
		
		for (int i = 0; i < t; i++)
		
		    diagonals[i] = matrix[i][i];
		
		return diagonals;
	}
	
	
	public int getPrecision()
	{
		//  returns the precision of the elements
		
		int precision = 0;
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		{
			Number n = this.matrix[i][j];
			
			if (n == null) continue;
			
			if (n.getPrecision() > precision)
			
			    precision = n.getPrecision();
		}
		
		return  precision;
	}
	
	
	public Number[] getRow(int row)
	{
		//  returns one row
		
		Number[] array = new Number[this.matrix[row].length];
		
		for (int j = 0; j < array.length; j++)
		
		    array[j] = this.matrix[row][j];
		
		return array;
	}
	
	
	
	public static Matrix identityMatrix(int size)
	{
	
		//  returns the unit matrix
		//
		//  | 1                    |
		//  |    1                 |
		//  |       1              |
		//  |          1           |
		//  |             1        |
		//  |                .     |
		//  |                   .  |
		
		
		Number[][] array = new Number[size][size];
		
		for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
		{
			if (j != i)
			
			     array[i][j] = new Number(0);
			else array[i][j] = new Number(1);
		}
		
		return new Matrix(array);
	}
	
	
	
	
	public Matrix inverse()
	{
	
		//  computes the inverse of a matrix
		
		//  The inverse of a matrix A is the solution to the equation
		//  A X == I where X is the inverse and I is the unit matrix.
		//
		//  To solve the equation A X == I, form the augmented matrix
		//  M = [ A , I ] and solve the system by reducing the matrix
		//  M to echelon (triangular) form and then to row canonical
		//  (diagonal) form.
		//
		//  This gives the reduced matrix M' == [ I, A^-1 ]. The right
		//  half of the reduced matrix M' is the inverse of A.
		
		
		Matrix matrix = new Matrix(this);
		
		int rows = matrix.matrix   .length;
		int cols = matrix.matrix[0].length;
		
		if (!matrix .isSquare())
		{
			String message = "non-square matrix inversion";
			
			throw new IllegalArgumentException(message);
		}
		
		
		//  Augment the matrix with the identity matrix
		
		Matrix I = identityMatrix(rows);
		
		matrix = matrix .augment(I);
		
		
		//  Use Gaussian elimination to invert the matrix
		
		
		//  Forward elimination
		//
		//  Reduce the matrix to upper echelon form
		//
		//  (put zeros below each pivot element)
		
		matrix = matrix.toEchelonForm();
		
		if (!matrix.isEchelonForm() || this.determinant().equals(0))
		{
			//  non-invertible matrix
			
			throw new NullPointerException();
		}
		
		//  Back substitution
		//
		//  (put zeros above each pivot element)
		
		matrix = matrix.toRowCanonicalForm();
		
		
		//  The right half of the matrix is the inverse
		
		Matrix inv_matrix = matrix.get(0, cols, rows, cols);
		
		return inv_matrix;
	}
	
	
	
	public boolean isComplex()
	{
		//  tests if a matrix is complex
		
		//  isComplex() could be changed to isReal()
		//  because other math programs use isReal()
		//  instead of isComplex()
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    if (this.matrix[i][j].isComplex()) return true;
		
		return false;
	}
	
	
	public boolean isDiagonal()
	{
		//  tests if a matrix is diagonal
		
		Number zero = new Number(0);
		
		boolean isInteger = this.matrix[0][0].isInteger();
		
		if (!isInteger)
		{
			int p = this.matrix[0][0].getPrecision();
			
			zero = zero .setPrecision(p);
		}
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    if ((i != j) && !this.matrix[i][j]
		
			.equals(zero)) return false;
		
		return true;
	}
	
	
	public boolean isEchelonForm()
	{
		//  tests if a matrix is in echelon form
		//
		//  If a matrix is in echelon form, the first non-zero
		//  element of each row is to the right of the first
		//  non-zero element of the preceding row.
		
		Matrix matrix = this;
		
		Number zero = new Number(0);
		
		int p = matrix.getPrecision();
		
		zero = zero.setPrecision(p);
		
		int index = -1;
		
		for (int i = 0; i < matrix   .rowCount();    i++)
		for (int j = 0; j < matrix.columnCount() -1; j++)
		{
			if (matrix.matrix[i][j] == null) return false;
			
			if (!matrix.matrix[i][j] .equals(zero))
			{
				if (j <= index) return false;
				
				index = j;  break;
			}
		}
		
		return true;
	}
	
	
	public boolean isIdentityMatrix()
	{
		//  tests if a matrix is the unit matrix
		
		if (!this.isSquare()) return false;
		
		Number one  = new Number(1);
		Number zero = new Number(0);
		
		boolean isInteger = this.matrix[0][0].isInteger();
		
		if (!isInteger)
		{
			int p = this.matrix[0][0].getPrecision();
			
			one  = one  .setPrecision(p);
			zero = zero .setPrecision(p);
		}
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		{
		    if      ((i == j) && !this.matrix[i][j].equals(one))  return false;
		    else if ((i != j) && !this.matrix[i][j].equals(zero)) return false;
		}
		
		return true;
	}
	
	
	
	public boolean isLatinSquare()
	{
		//  tests if a matrix is a Latin square
		//
		//  A Latin square has O(n) elements and can only
		//  have one of each element in each row and column
		//
		//  Circulant matrices are always Latin squares but
		//  Latin squares are not always circulant matrices be-
		//  cause there are O(n!) permutations of Latin squares
		//  but only O(n) permutations of circulant matrices.
		
		if (!this.isSquare()) return false;
		
		if (this.rowCount() == 1) return true;
		
		if (this.rowCount() == 2
		
		 && this.matrix[0][0].equals(this.matrix[1][1])
		 && this.matrix[1][0].equals(this.matrix[0][1]))
		
		    return true;
		
		
		//  This method is not finished
		
		//  ...
		
		//  ...
		
		
		return false;
	}
	
	
	
	public boolean isRowCanonicalForm()
	{
		//  tests if a matrix is in row canonical form
		
		//  If a matrix is in row canonical form, the diagonal elements
		//  equal 1 and the non-diagonal elements equal 0 except for the
		//  last column (for an n, n + 1 matrix) or the right half of
		//  the matrix (for an n, 2 n matrix).
		
		Matrix matrix = this;
		
		Number zero = new Number(0);
		Number one  = new Number(1);
		
		if (matrix.getPrecision() != 0)
		{
			zero = zero .setPrecision(matrix.getPrecision());
			one  = one  .setPrecision(matrix.getPrecision());
		}
		
		//  Verify that the diagonal elements equal 1
		
		Number[] diagonals = matrix.getDiagonals();
		
		for (Number d : diagonals)
		
		    if ((d == null) || !d .equals(one)) return false;
		
		//  Verify that the elements above and below
		//  the diagonal elements are all nonzero
		
		for (int j = 0; j < matrix.matrix.length; j++)
		for (int i = 0; i < matrix.matrix.length; i++)
		
		    if ((i != j) && !matrix.matrix[i][j] .equals(zero))
		
			return false;
		
		return true;
	}
	
	
	public boolean isSingular()
	{
		//  tests if the determinant equals zero
		
		int p = this.getPrecision();
		
		Number zero = new Number(0) .setPrecision(p);
		
		return this.determinant().abs().equals(zero);
	}
	
	
	public boolean isSingular(Number n)
	{
		//  tests if the determinant equals zero modulo n
		
		return this.determinant(n).equals(0);
	}
	
	
	public boolean isSquare()
	{
		//  tests if the number of rows and columns are equal
		
		int rows = this.rowCount();
		
		for (int i = 0; i < rows; i++)
		
		    if (this.matrix[i].length != rows)
		
			return false;
		
		return true;
	}
	
	
	public boolean isSymmetric()
	{
		//  tests if a matrix is symmetric
		
		//  A symmetric matrix equals its transpose A^T
		
		return this.transpose().equals(this);
	}
	
	
	
	public static Matrix LatinSquare(Matrix A1, Matrix A2, Matrix A3)
	{
	
		//  creates a symmetric Latin square from two
		//  smaller symmetric Latin squares A1, A2,
		//  and one smaller Latin square A3.
		
		
		//  Symmetric Latin square
		//
		//   |        |        |
		//   |   A1   |   A2   |
		//   |        |        |
		//   |--------+--------|
		//   |     T  |        |
		//   |   A2   |   A3   |
		//   |        |        |
		
		
		if (!A1.isSymmetric() || !A2.isSymmetric())
		{
			String message = "A1 or A2 is not symmetric";
			
			throw new IllegalArgumentException(message);
		}
		
		return LatinSquare(A1, A2, A3, null);
	}
	
	
	public static Matrix LatinSquare(Matrix A1, Matrix A2, Matrix A3, Matrix A4)
	{
	
		//  creates a symmetric Latin square from
		//  four smaller Latin squares A1, A2, A3, A4.
		//
		//  If A1 and A2 are symmetric, then the Latin square
		//  { { A1, A2 }, { A2^T, A3 } } is also symmetric.
		//
		//  This method can be used recursively to create any
		//  size Latin square.
		
		
		//         symmetric               asymmetric
		// 
		//    |        |        |      |        |        |
		//    |   A1   |   A2   |      |   A1   |   A2   |
		//    |        |        |      |        |        |
		//    |--------+--------|  or  |--------+--------|
		//    |     T  |        |      |        |        |
		//    |   A2   |   A3   |      |   A3   |   A4   |
		//    |        |        |      |        |        |
		
		
		if ( !A1.isLatinSquare() || !A2.isLatinSquare() || !A3.isLatinSquare() )
		{
			String message = "A1, A2, or A3 is not a Latin square";
			
			throw new IllegalArgumentException(message);
		}
		
		if ( (A1.rowCount() != A2.rowCount())
		  || (A2.rowCount() != A3.rowCount()) )
		{
			String message = "unequal row count";
			
			throw new IllegalArgumentException(message);
		}
		
		int size = A1.rowCount();
		
		A1 = A1.enumerate();
		A2 = A2.enumerate();
		A3 = A3.enumerate();
		
		if  (A4 != null) A4 = A4.enumerate();
		
		for (int i = 0; i < size; i++)
		for (int j = 0; j < size; j++)
		{
			A3.matrix[i][j] = A3.matrix[i][j].add(size);
			
			if (A4 == null) continue;
			
			A4.matrix[i][j] = A4.matrix[i][j] .add(size);
		}
		
		Matrix matrix = new Matrix(2*size, 2*size);
		
		matrix.set(A1,    0,    0);
		matrix.set(A2, size, size);
		matrix.set(A3,    0, size);
		
		if (A4 != null)  matrix.set(A4, size, 0);
		
		else if (A4 == null)
		
		    matrix.set(A3.transpose(), size, 0);
		
		return matrix.enumerate();
	}
	
	
	public static Matrix lcr(Matrix[] r, Number[] n)
	{
		//  computes a composite matrix R from a set of reduced
		//  matrices r[] and a set of coprime moduli n[]
		
		if (r.length != n.length) throw
		
		    new IllegalArgumentException();
		
		int t = r.length;
		
		int rows = r[0].rowCount();
		int cols = r[0].columnCount();
		
		Matrix R = new Matrix(rows, cols);
		
		//  For each i, j in all k matrices
		//  compute the composite element
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			Number[] array = new Number[t];
			
			for (int k = 0; k < t; k++)
			
			    array[k] = r[k].matrix[i][j];
			
			Number composite = Math.lcr(array, n);
			
			R .set(composite, i, j);
		}
		
		return R;
	}
	
	
	
	public Matrix[] LU()
	{
		//  L U decomposition
		
		return LU(null);
	}
	
	
	public Matrix[] LU(Number modulus)
	{
	
		//  decomposes a square matrix into upper and lower
		//  triangular matrices
		//
		//  The upper triangular matrix U is computed from
		//  a matrix by reducing the matrix to echelon form.
		//
		//  The lower triangular matrix L is defined
		//  (on, above, and below the diagonal) by
		//
		//  L[i][j] =   1          i == j,
		//  L[i][j] =   0          i <  j,
		//  L[i][j] = - m[i][j]    i >  j,
		//
		//  where m[i][j] are the multipliers used to reduce
		//  the matrix to echelon or upper triangular form U.
		
		
		Number n = modulus;
		
		Matrix A = new Matrix(this);
		
		if (A.rowCount() != A.columnCount())
		{
			String message =
			
			  "LU factorization non-square matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		
		//  Compute the upper triangular matrix U
		//  by reducing A to echelon form
		
		Matrix U = null;
		
		if (n == null) U = A.toEchelonForm();
		if (n != null) U = A.toEchelonForm(n);
		
		
		//  Compute the lower triangular matrix L
		
		//  Since  A == L U  or  L U == A, the lower
		//  triangular matrix can be computed by post-
		//  multiplying A by U^-1 to get L == A U^-1
		
		Matrix L = A.multiply(U.inverse());
		
		if (n != null) L = L .mod(n);
		
		//  Verify that A == L U
		
		if (!A.equals(L.multiply(U))) throw
		
		    new ArithmeticException();
		
		return new Matrix[] { L, U };
	}
	
	
	public Matrix mod(double d)
	{
		return mod(new Number(d));
	}
	
	public Matrix mod(int n)
	{
		return mod(new Number(n));
	}
	
	public Matrix mod(Number n)
	{
		//  returns the value of this mod n
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = matrix.matrix[i][j] .mod(n);
		
		return matrix;
	}
	
	
	public Matrix mod(Number n, Number inv)
	{
		//  returns the value of this mod n
		
		//  This method is used for fast modular reduction
		//  (if the same divisor is used more than once)
		//  because the inverse of n can be pre-computed
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = matrix.matrix[i][j] .mod(n, inv);
		
		return matrix;
	}
	
	
	public Matrix modDivide(int divisor, Number n)
	{
		return modDivide(new Number(divisor), n);
	}
	
	public Matrix modDivide(Number divisor, Number n)
	{
		//  returns the modular quotient of a matrix and number
		
		Matrix a = this.mod(n);
		
		if (!divisor.isInteger() || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		if (!divisor.isCoprimeWith(n)) return null;
		
		Matrix quotient = a .multiply( divisor.modInverse(n) ) .mod(n);
		
		if (! quotient .multiply(divisor) .mod(n) .equals(a) )
		
		    throw new ArithmeticException();
		
		return quotient;
	}
	
	
	public Matrix modDivide(Matrix divisor, Number n)
	{
		//  returns the modular quotient of two matrices
		
		//  If the divisor matrix is non-square, then the matrix is non-invertible
		
		if (!divisor.isSquare() || !n.isInteger())
		
		    throw new IllegalArgumentException();
		
		Matrix a = this.mod(n);
		
		Matrix quotient = a .multiply( divisor.modInverse(n) ) .mod(n);
		
		if (! quotient .multiply(divisor) .mod(n) .equals(a) )
		
		    throw new ArithmeticException();
		
		return quotient;
	}
	
	
	
	public Matrix modInverse(int modulus)
	{
		return modInverse(new Number(modulus));
	}
	
	
	public Matrix modInverse(Number modulus)
	{
		//  returns the modular inverse
		
		//  This method computes the inverse of a matrix A modulo n
		//  or solves the equation A X == I (mod n) where X is the
		//  inverse and I is the identity matrix.
		//
		//  To solve the equation A X == I, form the augmented matrix
		//  M = [ A , I ] and solve the system by reducing the matrix
		//  M to echelon form and then to row canonical form.
		//
		//  This gives the reduced matrix M == [ I, A^-1 ]. The right
		//  half of the reduced matrix M is the inverse of A.
		
		
		Number n = modulus;
		
		Matrix matrix = new Matrix(this) .mod(n);
		
		if (!matrix.isSquare())
		{
			String message = "non-square matrix inversion";
			
			throw new IllegalArgumentException(message);
		}
		
		int rows = matrix.matrix   .length;
		int cols = matrix.matrix[0].length;
		
		if (this.determinant(n).equals(0))
		{
			String message = "non-invertible matrix";
			
			throw new NullPointerException(message);
		}
		
		
		//  Augment the matrix with the identity matrix
		
		Matrix I = identityMatrix(rows);
		
		matrix = matrix .augment(I);
		
		
		//  Use Gaussian elimination to invert the matrix
		
		//  Forward elimination (upper triangularization)
		//
		//  Reduce the matrix to (upper) echelon form
		//  (put zeros below each pivot variable)
		
		if (modulus.trim().length() > 1)
		
		     matrix = matrix.toEchelonForm(n);
		else matrix = matrix.toEchelonForm(n.intValue());
		
		
		//  Backward elimination (lower triangularization)
		//
		//  Reduce the matrix to row canonical form
		//  (put zeros above each pivot variable)
		
		matrix = matrix.toRowCanonicalForm(n);
		
		
		//  Copy the inverse of M from the right half of the augmented matrix
		
		Matrix inv_matrix = matrix.get(0, cols, rows, cols);
		
		
		//  Verify the modular inverse
		
		if (!this.multiply(inv_matrix) .mod(n) .equals(I))
		
		    throw new ArithmeticException();
		
		return inv_matrix;
	}
	
	
	public Matrix modPow(int exp, int n)
	{
		return modPow(new Number(exp), new Number(n));
	}
	
	public Matrix modPow(int exp, Number n)
	{
		return modPow(new Number(exp), n);
	}
	
	public Matrix modPow(Number exp, int n)
	{
		return modPow(exp, new Number(n));
	}
	
	public Matrix modPow(Number exp, Number n)
	{
		//  computes the modular power A^x (mod n)
		
		if (this.matrix.length != this.matrix[0].length)
		{
			String message = "non-square matrix exponentiation";
			
			throw new IllegalArgumentException(message);
		}
		
		Matrix A = new Matrix(this).mod(n);
		
		Number x = new Number(exp);
		
		Matrix Y = identityMatrix(A.matrix.length);
		
		boolean latinsquare = this.isLatinSquare();
		
		if (this.isDiagonal())
		{
			for (int i = 0; i < A.matrix.length; i++)
			
			Y .set( A.get(i, i).modPow(x, n), i, i );
			
			return Y;
		}
		
		
		//  Find a matrix P such that P^-1 A P == D
		//  so Y = A^x can be computed from P D^x P^-1
		//
		//  This makes the matrix modPow method several times faster
		//  for matrices; for example, for a 2x2 matrix and a 160-bit
		//  modulus the modPow method is ~ 8 times faster if Tonelli's
		//  algorithm is used for modular square roots.
		//
		//  Diagonalization is not used in this program for exponentiation
		//  because for Latin squares the method uses multiplyLs() which
		//  is very fast. If diagonalization were used, it would make the
		//  signature algorithm 2 to 3 times slower because the square root
		//  algorithm has to do a modular exponentiation using complex
		//  arithmetic which requires 4 multiplications per bit instead of
		//  one multiplication per bit for real integers.
		
		
		Matrix[] PDP1 = null;
		
		//  Diagonalization is not used for 2x2 matrices or
		//  Latin squares because it makes exponentiation slower
		
		if ((this.rowCount() > 2) && !latinsquare)
		
		    PDP1 = A.diagonalize(n);
		
		if (PDP1 != null)
		{
			Matrix P  = PDP1[0];
			Matrix D  = PDP1[1];
			Matrix P1 = PDP1[2];
			
			int k = D.rowCount();
			
			Number[] d2x_array = new Number[k];
			
			for (int i = 0; i < k; i++)
			
			    d2x_array[i] = D.get(i, i).modPow(x, n);
			
			Matrix D2x = new Matrix(k, k);
			
			for (int i = 0; i < k; i++)
			for (int j = 0; j < k; j++)
			
			    if (i == j) D2x.set(d2x_array[i], i, j);
			
			    else D2x.set(new Number(0), i, j);
			
			if (D.isDiagonal())
			{
				//  System.out.println("Diagonalized");
				
				//  Y = A^x == P D^x P^-1
				
				Y = P .multiply(D2x) .mod(n)
				
				  .multiply(P1) .mod(n);
				
				return Y;
			}
		}
		
		
		//  Use the square and multiply method
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		int digits = (int) n.bitCount() / 4;
		
		Number invn = n .setPrecision(2*digits) .inverse();
		
		
		while (!x.equals(0))
		{
			if (!latinsquare)
			{
				if (x.testBit(0))
				
				    Y = A .multiply(Y) .mod(n, invn);
				
				A = A .square(). mod(n, invn);
			}
			
			else if (latinsquare)
			{
				if (x.testBit(0))
				
				    Y = A .multiplyLs(Y) .mod(n, invn);
				
				A = A .multiplyLs(A). mod(n, invn);
			}
			
			//  Shift the exponent to the next bit
			
			x = x .shiftRight(1);
		}
		
		return Y;
	}
	
	
	
	public Matrix multiply(int val)
	{
		//  multiplies a matrix by an int
		
		return multiply(new Number(val));
	}
	
	public Matrix multiply(Number number)
	{
		//  multiplies a matrix by a number
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = matrix.matrix[i][j] .multiply(number);
		
		return matrix;
	}
	
	public Matrix multiply(Matrix matrix)
	{
		//  multiplies a matrix by a matrix
		
		if (this.matrix[0].length != matrix.matrix.length)
		{
			String message = "number of columns of first matrix "
			
			    + "does not equal rows of second matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		if (matrix.isIdentityMatrix())
		{
			return this;
		}
		
		int rows =   this.matrix.length;
		int cols = matrix.matrix[0].length;
		
		Number[][] array = new Number[rows][cols];
		
		for (int i = 0; i < array   .length; i++)
		for (int j = 0; j < array[i].length; j++)
		
		    array[i][j] = new Number(0);
		
		Matrix product = new Matrix(array);
		
		for (int i = 0; i < product.matrix   .length; i++)
		for (int j = 0; j < product.matrix[i].length; j++)
		for (int k = 0; k <    this.matrix[i].length; k++)
		
		    product.matrix[i][j] = product.matrix[i][j] .add(
		
			this.matrix[i][k] .multiply(matrix.matrix[k][j]));
		
		return product;
	}
	
	
	public Number[] multiply(Number[] x)
	{
		//  multiplies a matrix by a vector
		//
		//  This is used to verify the equation A x == b.
		
		Matrix A = this;
		
		Matrix Y = A.multiply(new Matrix(x)
		
		    .transpose()) .transpose();
		
		Number[] y = Y.getRow(0);
		
		return y;
	}
	
	
	
	public Matrix multiply(Matrix matrix, int r)
	{
		//  multiplies the first r rows of a matrix by a matrix
		
		if (this.matrix[0].length != matrix.matrix.length)
		{
			String message = "number of columns of first matrix "
			
			    + "does not equal rows of second matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		Number[][] array = new Number[
		
		    this.matrix.length][matrix.matrix[0].length];
		
		for (int i = 0; i < array   .length; i++)
		for (int j = 0; j < array[i].length; j++)
		
		    array[i][j] = new Number(0);
		
		Matrix product = new Matrix(array);
		
		for (int i = 0; i < r; i++)
		
		for (int j = 0; j < product.matrix[i].length; j++)
		for (int k = 0; k <    this.matrix[i].length; k++)
		
		    product.matrix[i][j] = product.matrix[i][j] .add(
		
			this.matrix[i][k] .multiply(matrix.matrix[k][j]));
		
		return product;
	}
	
	
	public Matrix multiplyLs(Matrix matrix)
	{
		//  multiplies two Latin squares in O(n^2) time
		
		//  This method multiplies the first row of a Latin square
		//  by the columns of a second Latin square and then rotates
		//  the first row to compute the product.
		
		//  + diagonal x + diagonal == + diagonal
		//  + diagonal x - diagonal == - diagonal
		//  - diagonal x - diagonal == + diagonal
		
		//  | a1 a2 a3 a4 | | b1 b2 b3 b4 |      | c1 c2 c3 c4 |
		//  | a4 a1 a2 a3 | | b4 b1 b2 b3 |  __  | c4 c1 c2 c3 |
		//  | a3 a4 a1 a2 | | b3 b4 b1 b2 |  __  | c3 c4 c1 c2 |
		//  | a2 a3 a4 a1 | | b2 b3 b4 b1 |      | c2 c3 c4 c1 |
		
		//  | a1 a2 a3 a4 | | b1 b2 b3 b4 |      | c1 c2 c3 c4 |
		//  | a4 a1 a2 a3 | | b2 b3 b4 b1 |  __  | c2 c3 c4 c1 |
		//  | a3 a4 a1 a2 | | b3 b4 b1 b2 |  __  | c3 c4 c1 c2 |
		//  | a2 a3 a4 a1 | | b4 b1 b2 b3 |      | c4 c1 c2 c3 |
		
		//  | a1 a2 a3 a4 | | b1 b2 b3 b4 |      | c1 c2 c3 c2 |
		//  | a2 a3 a4 a1 | | b2 b3 b4 b1 |  __  | c2 c1 c2 c3 |
		//  | a3 a4 a1 a2 | | b3 b4 b1 b2 |  __  | c3 c2 c1 c2 |
		//  | a4 a1 a2 a3 | | b4 b1 b2 b3 |      | c2 c3 c2 c1 |
		
		
		if (matrix.matrix.length == 2)
		{
			//  | a  b | | c | d | __ | a c + b d | a d + b c |
			//  | ---- | |   |   | __ | ----------+---------- |
			//  | b  a | | d | c |    | a d + b c | a c + b d |
			
			Number a =   this.matrix[0][0], b =   this.matrix[0][1];
			Number c = matrix.matrix[0][0], d = matrix.matrix[0][1];
			
			Number acbd = a.multiply(c) .add(b.multiply(d));
			Number adbc = a.multiply(d) .add(b.multiply(c));
			
			return new Matrix( new Number[][]
			
			    { { acbd, adbc }, { adbc, acbd } } );
		}
		
		
		//  Multiply the first row of the first matrix
		//  by all the columns of the second matrix
		
		Number[] array = new Number[this.matrix.length];
		
		for (int i = 0; i < array.length; i++) array[i] = new Number(0);
		
		for (int i = 0; i < array.length; i++)
		for (int j = 0; j < array.length; j++)
		
		    array[i] = array[i] .add ( this.matrix[0][j]
		
			.multiply(matrix.matrix[j][i]) );
		
		
		//  Determine if the first and second Latin
		//  squares are diagonal or non-diagonal
		
		boolean bool1 = true, bool2 = true;
		
		for (int i = 1; i < array.length; i++)
		
		    if (!this.matrix[i-1][i-1] .equals(this.matrix[i][i]))
		
			bool1 = false;
		
		for (int i = 1; i < array.length; i++)
		
		    if (!matrix.matrix[i-1][i-1] .equals(matrix.matrix[i][i]))
		
			bool2 = false;
		
		
		//  Rotate the first row to set the other rows
		
		Number[] row0 = new Number[array.length];
		
		for (int i = 0; i < row0.length; i++)
		
		    row0[i] = new Number(array[i]);
		
		Matrix product = new Matrix(array.length, array.length);
		
		product.setRow(row0, 0);
		
		for (int i = 1; i < this.rowCount(); i++)
		{
			Number[] row;
			
			if (bool1 == bool2)
			
			     row = rotate(row0, +i);
			else row = rotate(row0, -i);
			
			product.matrix[i] = row;
		}
		
		return product;
	}
	
	
	public Matrix negate()
	{
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = matrix.matrix[i][j].negate();
		
		return matrix;
	}
	
	public Matrix negate(int n)
	{
		return negate(new Number(n));
	}
	
	public Matrix negate(Number n)
	{
		//  negates the elements
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = matrix.matrix[i][j].negate(n);
		
		return matrix;
	}
	
	
	public Matrix[][] partition(int m, int n)
	{
		//  partitions a matrix into an m x n block matrix
		//
		//  | A11 | A12 | A13 | ... | A1n |
		//  |-----+-----+-----+-----+-----|
		//  | A21 | A22 | A23 | ... | A2n |
		//  |-----+-----+-----+-----+-----|
		//  | A31 | A32 | A33 | ... | A3n |
		//  |-----+-----+-----+-----+-----|
		//  | ... | ... | ... | ... | ... |
		//  |-----+-----+-----+-----+-----|
		//  | Am1 | Am2 | Am3 | ... | Amn |
		
		int rows = matrix   .length;
		int cols = matrix[0].length;
		
		int row_unit = rows / m;
		int col_unit = cols / n;
		
		Matrix[][] A = new Matrix[m][n];
		
		for (int i = 0; i < m; i++)
		for (int j = 0; j < n; j++)
		
		    A[i][j] = this.get(
		
			i*row_unit, j*col_unit,
			  row_unit,   col_unit);
		
		return A;
	}
	
	
	public Matrix pow(int exp)
	{
		return pow(new Number(exp));
	}
	
	public Matrix pow(Number exp)
	{
		//  computes the power A ^ x
		
		if (this.matrix.length != this.matrix[0].length)
		{
			String message = "non-square matrix exponentiation";
			
			throw new IllegalArgumentException(message);
		}
		
		//  Define the square matrix a and exponent x
		
		Matrix a = new Matrix(this);
		
		Number x = new Number(exp);
		
		//  Define the output matrix y and initialize to one
		
		Matrix y = identityMatrix(this.matrix.length);
		
		//  Use the square and multiply method
		
		while (!x.equals(0))
		{
			//  Accumulate squares for each 1-bit
			
			if (x.testBit(0))
			
			    y = a .multiply(y);
			
			//  Square the square
			
			a = a .square();
			
			//  Shift the exponent to the next bit
			
			x = x .shiftRight(1);
		}
		
		return y;
	}
	
	
	public int rank()
	{
		//  returns the rank of a matrix
		
		//  The rank of a matrix is the number of linearly independent
		//  equations or rows.
		//
		//  To compute the rank of a matrix, reduce the matrix to echelon form
		//  and count the number of non-zero rows.
		//
		//  If all equations are linearly independent, then the rank equals the
		//  size of the matrix. If some of the equations are linearly dependent,
		//  then rows of zeros will appear at the bottom of the matrix when the
		//  matrix is reduced to echelon form because the echelon method swaps
		//  rows to find a non-zero pivot or diagonal element for each row.
		
		return toEchelonForm() .trim() .matrix.length;
	}
	
	
	public Matrix rotate() { return rotate(1); }
	
	public Matrix rotate(int dir)
	{
		if (dir == 1) return rotate1();
		
		else if (dir == -1)
		
		    return rotate1().rotate1().rotate1();
		
		else throw new IllegalArgumentException();
	}
	
	private Matrix rotate1()
	{
		int rows = this.rowCount();
		int cols = this.columnCount();
		
		Matrix R = new Matrix(cols, rows);
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    R.set(this.get(i, j), cols -1 -j, i);
		
		return R;
	}
	
	
	public static Number[] rotate(Number[] array, int j)
	{
		//  rotates the elements in an array
		
		//  Example  rotate(array, -1)
		
		//  [ 1 2 3 4 5 6 7 8 ] => [ 2 3 4 5 6 7 8 1 ]
		
		Number[] array1 = new Number[array.length];
		
		int m = array.length;
		
		for (int i = 0; i < array.length; i++)
		
		    array1[((((i + j) % m) + m) % m)] = array[i];
		
		return array1;
	}
	
	
	public Matrix round()
	{
		//  rounds the elements to the nearest integers
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    matrix.matrix[i][j] =
		    matrix.matrix[i][j]  .round();
		
		return matrix;
	}
	
	
	public Matrix round(int p)
	{
		//  rounds the elements to the specified precision
		//
		//  If p == 0 then this method is the same as round()
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    matrix.matrix[i][j] =
		    matrix.matrix[i][j]  .round(p);
		
		return matrix;
	}
	
	
	public int rowCount()
	{
		//  counts the number of rows
		
		return this.matrix.length;
	}
	
	
	public void set(int n, int i, int j)
	{
		//  sets an element
		
		set(new Number(n), i, j);
	}
	
	
	public void set(Number n, int i, int j)
	{
		//  sets an element
		
		this.matrix[i][j] = n;
	}
	
	
	public void setColumn(int[] array, int column)
	{
		//  sets a column
		
		Number[] narray = new Number[array.length];
		
		for (int i = 0; i < narray.length; i++)
		
		    narray[i] = new Number(array[i]);
		
		setColumn(narray, column);
	}
	
	
	public void setColumn(Number[] array, int column)
	{
		//  sets a column
		
		int j = column;
		
		for (int i = 0; i < this.matrix.length; i++)
		
		    this.matrix[i][j] = array[i];
	}
	
	
	public void set(Matrix m, int i, int j)
	{
		//  pastes a smaller matrix into a
		//  larger matrix starting at (i, j)
		
		//  The size of the sub matrix plus the offset
		//  cannot exceed the size of the super matrix
		
		if ( ((i + m.   rowCount()) > this.   rowCount())
		  || ((j + m.columnCount()) > this.columnCount()))
		
		    throw new IllegalArgumentException();
		
		for (int r = 0; r < m.matrix   .length; r++)
		for (int s = 0; s < m.matrix[r].length; s++)
		
		    this.matrix[i+r][j+s] = m.matrix[r][s];
	}
	
	
	public Matrix setPrecision(int precision)
	{
		//  sets the precision of the elements
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < this.matrix   .length; i++)
		for (int j = 0; j < this.matrix[i].length; j++)
		
		    if (matrix.matrix[i][j] != null)
		
			matrix.matrix[i][j] =
			matrix.matrix[i][j]
			
			    .setPrecision(precision);
		
		return matrix;
	}
	
	
	public void setRow(int[] array, int row)
	{
		//  sets a row
		
		Number[] narray = new Number[array.length];
		
		for (int i = 0; i < narray.length; i++)
		
		    narray[i] = new Number(array[i]);
		
		setRow(narray, row);
	}
	
	
	public void setRow(Number[] array, int row)
	{
		//  sets a row
		
		Number[] temp = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    temp[i] = array[i];
		
		this.matrix[row] = temp;
	}
	
	
	public int[] size()
	{
		//  returns the size (rows, cols)
		
		return new int[] { matrix.length, matrix[0].length };
	}
	
	public Number[] solve()
	{
		Number mod = null;
		
		return this.solve(mod);
	}
	
	
	public Number[] solve(int n)
	{
		return this.solve(new Number(n));
	}
	
	
	public Number[] solve(Number n)
	{
	
		//  Solves the matrix equation A x == b for the
		//  variable x == A^-1 b where b and x are vectors.
		//  This requires O(n^3) multiplications to invert
		//  the matrix A and then to post-multiply by b.
		
		//  Note that A^-1 only has to be computed once to
		//  solve an array of matrix equations A x[] == b[].
		//  Then each solution x[i] == A^-1 b[i] can be com-
		//  puted in O(n^2) operations because b[i] is an n
		//  by 1 matrix or a column vector. Solving an array
		//  of n matrix equations takes the same amount of
		//  time as solving a single matrix equation.
		
		
		Matrix M = new Matrix(this);
		
		int rows = M.rowCount();
		int cols = M.columnCount();
		
		if (cols != rows + 1)
		
		    throw new IllegalArgumentException();
		
		if ((n == null) || n.equals(0))
		
		     M = M.toEchelonForm( ).toRowCanonicalForm( );
		else M = M.toEchelonForm(n).toRowCanonicalForm(n);
		
		Number[] x = M.getColumn(M.columnCount()-1);
		
		return x;
	}
	
	
	public Matrix square()
	{
		//  squares a matrix
		
		return this.multiply(this);
	}
	
	
	public Matrix subtract(Number n)
	{
		//  subtracts a number from a matrix
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] =
		    matrix.matrix[i][j] .subtract(n);
		
		return matrix;
	}
	
	
	public Matrix subtract(Matrix matrix)
	{
		//  subtracts two matrices
		
		Matrix matrix1 = new Matrix(this);
		
		if ((matrix1.matrix   .length != matrix.matrix   .length)
		 || (matrix1.matrix[0].length != matrix.matrix[0].length))
		
		    throw new IllegalArgumentException();
		
		for (int i = 0; i < matrix1.matrix   .length; i++)
		for (int j = 0; j < matrix1.matrix[i].length; j++)
		
		    matrix1.matrix[i][j] = matrix1.matrix[i][j]
		
			.subtract(matrix.matrix[i][j]);
		
		return matrix1;
	}
	
	
	
	
	//  The toEchelonForm() methods do not test if the result is in echelon form.
	//  The calling method has to test if the result is in echelon form using the
	//  isEchelonForm() method. If some of the rows or equations are not linearly
	//  independent or are just multiples of another row or equation, then rows of
	//  zeros will appear at the bottom of the matrix which make the system unsolv-
	//  able. For sparse matrices, even if the rows or equations are all independent,
	//  one or more diagonal elements could be missing from the reduced matrix unless
	//  there are many more rows than there are variables. The isEchelonForm method
	//  will verify that the reduced matrix is in upper triangular form or that the
	//  first element of each row is to the right of the previous row, but it may not
	//  verify that the diagonal elements are all non-zero. The diagonal elements of
	//  a matrix in echelon form can be set to 1 by multiplying each row by the in-
	//  verse of its diagonal element so that the result of the matrix reduction is
	//  unambiguous, or else the result would be implementation dependent. A matrix
	//  in echelon form in which the diagonals are all equal to 1 could be called a
	//  standard or canonical form of the matrix similar to row canonical form.
	
	
	
	public Matrix toEchelonForm()
	{
	
		//  reduces a matrix to echelon form
		
		//  The running time is O(n^3) where n is the rank, size or dimension of
		//  the matrix. This is the same running time as a matrix multiplication.
		//
		//  The matrix can be square or rectangular (as in solving the determinant
		//  of a square matrix (n, n), computing the inverse of a rectangular matrix
		//  A X == I (n, 2 n), or solving the linear system A X == B  (n, n + 1)).
		//
		//  A matrix in echelon or triangular form is a matrix in which the first
		//  non-zero element of each row is to the right of the first non-zero
		//  element in the preceding row.
		
		
		//  Example of an n, n+1 matrix in echelon form
		//
		//  | 3  1  4  1  5  9  2  6  5  3 | 5 |
		//  |    8  9  7  9  3  2  3  8  4 | 6 |
		//  |       2  6  4  3  3  8  3  2 | 7 |
		//  |          9  5  0  2  8  8  4 | 1 |
		//  |             9  7  1  6  9  3 | 9 |
		//  |                9  3  7  5  1 | 0 |
		//  |                   5  8  2  0 | 9 |
		//  |                      7  4  9 | 4 |
		//  |                         4  5 | 9 |
		//  |                            2 | 3 |
		
		
		
		//  Example of an n, 2 n matrix in echelon form
		//
		//  | 3  1  4  1  5  9 | 2  6  5  3  5  8 |
		//  |    9  7  9  3  2 | 3  8  4  6  2  6 |
		//  |       4  3  3  8 | 3  2  7  9  5  0 |
		//  |          2  8  8 | 4  1  9  7  1  6 |
		//  |             9  3 | 9  9  3  7  5  1 |
		//  |                5 | 8  2  0  9  7  4 |
		
		
		
		Matrix matrix = new Matrix(this);
		
		int rows = matrix.matrix.length;
		int cols = matrix.matrix[0].length;
		
		
		//  Set a minimum precision
		
		int p = matrix.getPrecision();
		
		if (p == 0) p = 8;
		
		
		//  Define the precision of zero
		
		Number zero = new Number(0).setPrecision(p);
		
		
		//  Set the inverse precision
		
		int invp = 0;
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			if (matrix.get(i, j).equals(zero)) continue;
			
			int invp1 = matrix.get(i, j)
			
			    .inverse().getPrecision();
			
			if (invp1 > invp) invp = invp1;
		} 
		
		
		//  Reduce the matrix to echelon form
		
		for (int r = 0; r < rows - 1; r++)
		{
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				
				    if (!matrix.matrix[i][j].equals(zero))
				
					{ bool = true;  break; }
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			//  Swap rows i and r if element[r][j] equals zero
			
			if (i != r)
			{
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
			}
			
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				Number m1 = matrix.matrix[r][j];
				Number m2 = matrix.matrix[i][j];
				
				if (m2.equals(zero)) continue;
				
				//  Compute the inverse of m1 and m2
				//
				//  (allow the precision or size of the inverse to expand
				//  or else the product of m and inv m will not equal 1)
				
				m1 = m1.setPrecision(invp).inverse();
				m2 = m2.setPrecision(invp).inverse();
				
				//  Multiply row r by m1 and row i by m2 so that
				//  the first element of both rows equals 1
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				{
					matrix.matrix[r][k] = matrix.matrix[r][k] .multiply(m1);
					matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m2);
				}
				
				//  Subtract row r from row i to eliminate the first element of i
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				
				    matrix.matrix[i][k] = matrix.matrix[i][k]
				
					.subtract(matrix.matrix[r][k]);
				
				//  Set the precision of the matrix after each iteration
				
				matrix = matrix.setPrecision(invp);
			}
		}
		
		//  Set the diagonal elements equal to 1
		
		for (int i = 0; i < Math.min(rows, cols); i++)
		{
			Number m = matrix.matrix[i][i];
			
			if (m.equals(zero)) continue;
			
			m = m.inverse().setPrecision(p);
			
			for (int k = i; k < matrix.matrix[rows-1].length; k++)
			
			    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m);
		}
		
		matrix = matrix.setPrecision(p);
		
		return matrix;
	}
	
	
	
	public Matrix toEchelonForm(int n)
	{
	
		//  Forward Elimination
		//
		//  Reduce the matrix to (upper) echelon form
		//
		//  (put zeros below each pivot)
		
		
		Matrix matrix = new Matrix(this) .mod(n);
		
		int rows = matrix.matrix   .length;
		int cols = matrix.matrix[0].length;
		
		
		long n2 = (1L*n)*(1L*n);
		
		int base = 1, exp = 0;
		
		if (new Number(n).isPrimePower())
		
		    for (int i = 2; i < 1024*1024; i++)
		
			if (new Number(n).isDivisibleBy(i))
		
			    { base = i; break; }
		
		
		for (int r = 0; r < rows - 1; r++)
		{
			//  Reduce the augmented matrix [ A | B ] to echelon form
			
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				{
					if ( matrix.matrix[i][j].mod(n)
					
					    .intValue() == 0) continue;
					
					if (!matrix.matrix[i][j].equals(0))
					
					    { bool = true;  break; }
				}
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			//  Swap rows i and r if element [r][j] equals zero
			
			if (i != r)
			{
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
			}
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = [r][j],  m2 = - [i][j]
				//
				//  instead of  m = - [i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m1 == [i][j][r][j] - [i][j][r][j] == 0
				
				Number m1 = matrix.matrix[r][j];
				Number m2 = matrix.matrix[i][j];
				
				if (m2.equals(0)) continue;
				
				//  Remove the common factor from the multipliers before multiplying
				//  and subtracting the rows because the common factor is not subtracted
				
				Number gcd = m1.gcd(m2);
				
				m1 = m1.divide(gcd);
				m2 = m2.divide(gcd);
				
				//  Negate the value of m1
				
				m1 = m1 .negate(n);
				
				int m1int = m1.intValue();
				int m2int = m2.intValue();
				
				//  Multiply row r by m2, and add to row i multiplied by m1
				
				//  For prime power moduli, the method uses the modulus squared
				//  instead of the modulus to reduce the elements of the matrix.
				
				long n1 = (base <= 1) ? n : n2;
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				
				    matrix.matrix[i][k] = new Number(
				
					( 1L*matrix.matrix[r][k] .intValue() * (m2int) +
					( 1L*matrix.matrix[i][k] .intValue() * (m1int) ) ) % n1 );
			}
		}
		
		//  Set the diagonal elements equal to 1
		
		for (int i = 0; i < Math.min(rows, cols); i++)
		{
			Number m = matrix.matrix[i][i];
			
			if (m.equals(0)) continue;
			
			m = m.modInverse(n);
			
			for (int k = i; k < matrix.matrix[rows-1].length; k++)
			
			    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m) .mod(n);
		}
		
		return matrix.mod(n);
	}
	
	
	
	public Matrix toEchelonForm(Number n)
	{
	
		//  reduces a matrix to echelon form modulo n
		
		//  If the matrix is large use the multi-threaded version;
		//  else if the modulus is an int, use the int method
		
		Matrix matrix = new Matrix(this) .mod(n);
		
		if (this.columnCount() >= 128) return toEchelonForm1(n);
		
		if (n.length() == 1) return toEchelonForm(n.intValue());
		
		
		//  Forward Elimination
		//
		//  Reduce the matrix to (upper) echelon form
		//
		//  (put zeros below each pivot)
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		Number n2 = n.square();
		
		int digits = (int) n.bitCount() / 4;
		
		Number invn  = n          .setPrecision(2*digits) .inverse();
		Number invn2 = n.square() .setPrecision(4*digits) .inverse();
		
		
		int base = 1, exp = 0;
		
		if (n.isPrimePower())
		
		    for (int i = 2; i < 1024*1024; i++)
		
			if (n.isDivisibleBy(i))
		
			    { base = i; break; }
		
		
		int rows = matrix.matrix   .length;
		int cols = matrix.matrix[0].length;
		
		for (int r = 0; r < rows - 1; r++)
		{
			if (matrix.matrix.length > 256) System.out.print(r + " ");
			
			//  Reduce the augmented matrix [ A | B ] to echelon form
			
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				{
					if ( matrix.matrix[i][j].equals(0)) continue;
					if (!matrix.matrix[i][j].equals(0))
					
					    { bool = true;  break; }
				}
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			
			//  Swap rows i and r if element [r][j] equals zero
			
			if (i != r)
			{
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
			}
			
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = [r][j],  m2 = - [i][j]
				//
				//  instead of  m = - [i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m1 == [i][j][r][j] - [i][j][r][j] == 0
				
				Number m1 = matrix.matrix[r][j];
				Number m2 = matrix.matrix[i][j];
				
				if (m2.equals(0)) continue;
				
				
				//  Remove the common factor from the multipliers before multiplying
				//  and subtracting the rows because the common factor is not subtracted
				
				Number gcd = m1.gcd(m2);
				
				m1 = m1.divide(gcd);
				m2 = m2.divide(gcd);
				
				//  Negate the value of m1
				
				m1 = m1 .negate(n);
				
				
				//  Multiply row r by m2, and add to row i multiplied by m1
				
				//  For prime power moduli, the method uses the modulus squared
				//  instead of the modulus to reduce the elements of the matrix.
				
				Number    n1 = (base <= 1) ?    n :    n2;
				Number invn1 = (base <= 1) ? invn : invn2;
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				
				    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m1)
				
					.add( matrix.matrix[r][k] .multiply(m2) ) .mod(n1, invn1);
			}
		}
		
		//  Set the diagonal elements equal to 1
		
		for (int i = 0; i < Math.min(rows, cols); i++)
		{
			Number m = matrix.matrix[i][i];
			
			if (m.equals(0)) continue;
			
			m = m.modInverse(n);
			
			for (int k = i; k < matrix.matrix[rows-1].length; k++)
			
			    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m) .mod(n);
		}
		
		return matrix.mod(n);
	}
	
	
	
	private Matrix toEchelonForm1(Number n)
	{
	
		//  This is the multi-threaded version
		//
		//  of the toEchelonForm(Number n) method
		
		
		//  Forward Elimination
		//
		//  Reduce the matrix to (upper) echelon form
		//
		//  (put zeros below each pivot)
		
		
		//  Pre-compute the inverse of n for fast modular reduction
		
		Number n2 = n.square();
		
		int digits = (int) n.bitCount() / 4;
		
		Number invn  = n          .setPrecision(2*digits) .inverse();
		Number invn2 = n.square() .setPrecision(4*digits) .inverse();
		
		
		int base1 = 1, exp = 0;
		
		if (n.isPrimePower())
		
		    for (int i = 2; i < 1024*1024; i++)
		
			if (n.isDivisibleBy(i))
		
			    { base1 = i; break; }
		
		final int base = base1;
		
		
		Matrix matrix = new Matrix(this) .mod(n);
		
		int rows = matrix.matrix   .length;
		int cols = matrix.matrix[0].length;
		
		for (int r = 0; r < rows - 1; r++)
		{
			if ((r % 16) == 0) System.out.print(r + " ");
			
			//  Create a new executor for each row r
			
			int numberofthreads = Math.numberofthreads;
			
			int corepoolsize = numberofthreads;
			
			ScheduledThreadPoolExecutor executor;
			
			executor = new ScheduledThreadPoolExecutor(corepoolsize);
			
			
			//  Find the row i and column j of the first non-zero element
			
			boolean bool = false;
			
			int i = 0, j = 0;
			
			for (j = r; j < matrix.matrix[r].length; j++)
			{
				for (i = r; i < matrix.matrix.length; i++)
				{
					if ( matrix.matrix[i][j].equals(0)) continue;
					if (!matrix.matrix[i][j].equals(0))
					
					    { bool = true;  break; }
				}
				
				if (bool)  break;
			}
			
			if (j >= matrix.matrix[r].length) continue;
			
			
			//  Swap rows i and r if element [r][j] equals zero
			
			if (i != r)
			{
				Number[] tempi = matrix.matrix[i];
				Number[] tempr = matrix.matrix[r];
				
				matrix.matrix[i] = tempr;
				matrix.matrix[r] = tempi;
			}
			
			
			//  Put zeros below the pivot for each row i below r
			
			for (i = r + 1; i < rows; i++)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = - [i][j],  m2 = [r][j]
				//
				//  instead of  m = - [i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m1 == [i][j][r][j] - [i][j][r][j] == 0
				
				
				//  Create a new runnable object R for each row i below r
				
				final int i1 = i, j1 = j, r1 = r;
				
				Runnable R = ( new Runnable()
				{
					public void run()
					{
						//  Compute the multipliers to avoid the modular inversion
						
						Number m1 = matrix.matrix[i1][j1] .negate(n);
						Number m2 = matrix.matrix[r1][j1];
						
						//  Remove the greatest common factor from the multipliers
						//  because the gcd is not subtracted
						//
						//  This is required if the modulus is a small prime power such as 2^k.
						//  For a composite modulus the matrix can be solved modulo the prime factors
						//  and then the composite matrix can be computed using a remainder algorithm.
						
						//  Number gcd = m1.gcd(m2); m1 = m1.divide(gcd); m2 = m2.divide(gcd);
						
						//  Multiply row r by m1, and add to row i multiplied by m2
						
						Number    n1 = (base <= 1) ?    n :    n2;
						Number invn1 = (base <= 1) ? invn : invn2;
						
						for (int k = j1; k < matrix.matrix[i1].length; k++)
						
						    matrix.matrix[i1][k] = matrix.matrix[i1][k] .multiply(m2)
						
							.add( matrix.matrix[r1][k] .multiply(m1) ) .mod(n1, invn1);
					}
				});
				
				//  If the element at [i1][j1] != 0  execute the runnable object
				
				while (executor.getActiveCount() > numberofthreads) ;
				
				if (!matrix.matrix[i1][j1] .equals(0))
				
				    executor.execute(R);
				
				//  else if (matrix[i1][j1]) .equals(0)) continue;
			}
			
			//  Wait for each column below r to be zeroed out before starting
			//  the next column or else the threads will overwrite each other.
			//
			//  This is done by shutting down the executor and then testing
			//  the active thread count until the executor is terminated.
			//
			//  Shutdown "initiates an orderly shutdown in which previously
			//  submitted tasks are executed, but no new tasks will be accepted."
			
			executor .shutdown();
			
			//  Wait here until all tasks have completed
			
			while (!executor.isTerminated()) ;
		}
		
		//  Set the diagonal elements equal to 1
		
		for (int i = 0; i < Math.min(rows, cols); i++)
		{
			Number m = matrix.matrix[i][i];
			
			if (m.equals(0)) continue;
			
			m = m.modInverse(n);
			
			for (int k = i; k < matrix.matrix[rows-1].length; k++)
			
			    matrix.matrix[i][k] = matrix.matrix[i][k] .multiply(m) .mod(n);
		}
		
		return matrix;
	}
	
	
	
	public Matrix toFraction()
	{
		//  converts matrix elements to fractional numbers
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = this.matrix[i][j] .toFraction();
		
		return matrix;
	}
	
	
	public Matrix toImag()
	{
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
			matrix.matrix[i][j] =
			matrix.matrix[i][j].toImag();
		
		return matrix;
	}
	
	
	
	public Matrix toInteger()
	{
		//  converts matrix elements to integers
		
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
		    matrix.matrix[i][j] = this.matrix[i][j] .toInteger();
		
		return matrix;
	}
	
	
	public String toIntegerString(int digits, int radix)
	{
	
		//  converts a matrix to an integer string by padding
		//  and concatenating the elements
		
		//  This method is used for cryptography to convert a
		//  public key / matrix to a public key string.
		
		//  The digits variable is the minimum number of digits.
		//  The left side will be padded with zeros if necessary.
		
		//  This method is the inverse of the constructor
		//  Matrix(String str, int radix, int rows, int cols).
		
		
		Matrix matrix = new Matrix(this);
		
		int rows = this.matrix   .length;
		int cols = this.matrix[0].length;
		
		String[][] y = new String[rows][cols];
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		{
			Number n = matrix.matrix[i][j];
			
			if (n.isComplex())
			{
				Number real = n.toReal();
				Number imag = n.toImag();
				
				y[i][j] = real.toString(digits, radix) .replaceAll(" ", "")
				        + imag.toString(digits, radix) .replaceAll(" ", "");
			}
			
			else // if (!n.isComplex())
			
			    y[i][j] = matrix.matrix[i][j].toString(
			
				digits, radix) .replaceAll(" ", "");
			
			//  the toString method is guaranteed to prepend zeros
			//  if radix == 16 unless the implementation changes
			
			//  Replace spaces with zeros
			
			if (digits == 0) continue;
			
			while (y[i][j].length() < digits)
			
			       y[i][j] = "0" + y[i][j];
		}
		
		String numberstr = "";
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    numberstr += y[i][j];
		
		return numberstr;
	}
	
	
	public String toMatrixString()
	{
		return toMatrixString(10);
	}
	
	public String toMatrixString(int radix)
	{
		return toMatrixString(0, radix);
	}
	
	public String toMatrixString(int digits, int radix)
	{
		//  converts a matrix to a string that can be
		//  displayed as a rectangular matrix
		//
		//      | a11  a12  a13  a14  ... |
		//      | a21  a22  a23  a24  ... |
		//      | a31  a32  a33  a34  ... |
		//      | a41  a42  a43  a44  ... |
		//      | ...  ...  ...  ...  ... |
		//
		//  instead of the toString() method
		//  which converts the matrix to
		//
		//  { { a11, a12, ... }, { a21, a22, ... }, ... }.
		
		
		Matrix matrix = new Matrix(this);
		
		boolean isechelonform      = matrix.isEchelonForm();
		boolean isrowcanonicalform = matrix.isRowCanonicalForm();
		
		if (isechelonform)
		{
			//  If one or more diagonal elements equals zero
			//  set isechelonform to false so that a zero matrix
			//  is not displayed in echelon form
			
			Number[] diagonals = matrix.getDiagonals();
			
			Number zero = new Number(0)
			
			    .setPrecision(this.getPrecision());
			
			for (Number d : diagonals)
			
			    if ((d == null) || d.equals(zero))
			
				isechelonform = false;
		}
		
		int rows = matrix.rowCount();
		int cols = matrix.columnCount();
		
		
		//  Reduce the precision to the largest number of significant digits
		
		int[] colprecision = new int[cols];
		
		for (int j = 0; j < cols; j++)
		{
			int precision = 0;
		
			for (int i = 0; i < rows; i++)
			{
				Number n = matrix.matrix[i][j];
				
				if (n == null) continue;
				
				int digits1 = n.countSignificantDigits(radix);
				
				if (precision < digits1) precision = digits1;
			}
			
			colprecision[j] = precision;
			
			//  Set the precision of each column
			
			for (int i = 0; i < rows; i++)
			{
				if (matrix.matrix[i][j] != null)
				
				    matrix.matrix[i][j] = matrix.matrix[i][j]
				
					.roundBit().setPrecision(precision);
			}
		}
		
		
		//  Make a list of the zero rows and columns
		
		boolean[] zerorows = new boolean[rows];
		boolean[] zerocols = new boolean[cols];
		
		zerorows[zerorows.length -1] = false;
		zerocols[zerocols.length -1] = false;
		
		for (int i = 0; i < zerorows.length; i++)
		{
			boolean iszero = true;
			
			for (int j = 0; j < cols; j++)
			{
				Number element = matrix.matrix[i][j];
				
				if ((element == null) || !element.equals(new
				
				    Number(0).setPrecision(element.getPrecision())))
				
					{ iszero = false;  break; }
			}
			
			zerorows[i] = iszero;
		}
		
		for (int j = 0; j < zerocols.length -1; j++)
		{
			boolean iszero = true;
			
			for (int i = 0; i < rows; i++)
			{
				Number element = matrix.matrix[i][j];
				
				if ((element == null) || !element.equals(new
				
				    Number(0).setPrecision(element.getPrecision())))
				
					{ iszero = false; break; }
			}
			
			zerocols[j] = iszero;
		}
		
		
		int[] mindigits = new int[cols];
		
		int mindigits1 = 0, digitsize = 0;
		
		for (int j = 0; j < cols; j++)
		for (int i = 0; i < rows; i++)
		{
			if (i == 0) { mindigits1 = 0; digitsize = 0; }
			
			if (matrix.matrix[i][j] == null) // null == 4 digits
			
			    { if (mindigits1 < 4) mindigits1 = 4; continue; }
			
			digitsize = matrix.matrix[i][j] .toString(radix).length()
			
			    + ((matrix.matrix[i][j].signum() == -1) ? 1 : 0);
			
			//  Set mindigits1 to the largest element digit size
			
			if (digitsize > mindigits1) mindigits1 = digitsize;
			
			if (i == rows -1) mindigits[j] = mindigits1;
		}
		
		if (isrowcanonicalform)
		
		    for (int i = 0; i < rows; i++)
		
			mindigits[i] = 2;
		
		StringBuilder sb = new StringBuilder();
		
		for (int i = 0; i < rows; i++)
		{
			if      (i == 0)       sb.append((char) 9121);
			else if (i == rows -1) sb.append((char) 9123);
			else                   sb.append((char) 9122);
			
			for (int j = 0; j < cols; j++)
			{
				//  Convert the element to a number string
				
				String numberstr = null;
				
				if (matrix.matrix[i][j] != null)
				
				    numberstr = matrix.matrix[i][j]
				
					.toString(digits, radix);
				
				else numberstr = "null";
				
				
				if (isrowcanonicalform && (i == j))
				
				    numberstr = new Number(1).toString(radix);
				
				
				if (isechelonform      && (i > j)) numberstr = " ";
				if (isrowcanonicalform && (i < j)
				
				    && (j < matrix.matrix.length)) numberstr = " ";
				
				
				//  Prepend spaces to pad the number
				
				StringBuilder sbdigit = new StringBuilder();
				
				if (!zerorows[i] && !zerocols[j])
				
				    sbdigit.append(numberstr);
				
				else sbdigit.append(" ");
				
				
				while (sbdigit.length() < mindigits[j])
				
				    sbdigit.insert(0, " ");
				
				numberstr = sbdigit.toString();
				
				
				sbdigit = new StringBuilder();
				
				sbdigit .append(numberstr);
				
				
				//  Append one or two spaces
				
				sb.append(sbdigit);
				
				int spaces = mindigits[j] - (numberstr != null ?
				
				    numberstr.length() : 4);
				
				if (j < matrix.matrix[i].length -1) sb.append("  ");
				
				for (int k = 0; k < spaces; k++) sb.append(" ");
			}
			
			if      (i == 0)       { sb.append(" "); sb.append((char) 9124); sb.append("\n"); }
			else if (i == rows -1) { sb.append(" "); sb.append((char) 9126); sb.append("\n"); }
			else                   { sb.append(" "); sb.append((char) 9125); sb.append("\n"); }
		}
		
		return sb.toString().trim();
	}
	
	
	
	public Number[][] toNumberArray()
	{
		//  returns a copy of the number array
		
		Number[][] matrix = new Number[this.matrix.length][];
		
		for (int i = 0; i < matrix.length; i++)
		
		    matrix[i] = this.matrix[i];
		
		return matrix;
	}
	
	
	
	public Matrix toReal()
	{
		Matrix matrix = new Matrix(this);
		
		for (int i = 0; i < matrix.matrix   .length; i++)
		for (int j = 0; j < matrix.matrix[i].length; j++)
		
			matrix.matrix[i][j] =
			matrix.matrix[i][j].toReal();
		
		return matrix;
	}
	
	
	public Matrix toRowCanonicalForm()
	{
		return this.toRowCanonicalForm(null);
	}
	
	
	public Matrix toRowCanonicalForm(int n)
	{
		return toRowCanonicalForm(new Number(n));
	}
	
	
	public Matrix toRowCanonicalForm(Number n)
	{
		//  reduces a matrix in echelon form to row canonical form
		
		//  If the matrix is augmented with a vector, use toRowCanonicalForm1
		//  If the matrix is augmented with a matrix, use toRowCanonicalForm2
		
		if (!this.isEchelonForm()) throw
		
		    new IllegalArgumentException();
		
		int rows = this.trim().   rowCount();
		int cols = this.trim().columnCount();
		
		int method = (cols <= rows + 1) ? 1 : 2;
		
		if   (method == 1) return toRowCanonicalForm1(n);
		else               return toRowCanonicalForm2(n);
	}
	
	
	private Matrix toRowCanonicalForm1(Number n)
	{
	
		//  reduces a matrix to row canonical form using back substitution
		
		//  This method requires only O(n^2) instead of O(n^3) multiplications.
		
		//  A matrix in row canonical form is a matrix in echelon form where each
		//  pivot is equal to one and the pivot is the only non-zero element in
		//  its column. (A pivot is the first non-zero element in a row.)
		//
		//  A matrix in row canonical form is in upper and lower triangular form
		//  because the elements above and below the diagonal are all zero.
		//
		//  Row canonical form is used to solve the matrix equation A X == B.
		
		
		Matrix matrix = new Matrix(this);
		
		if (n != null) matrix = matrix .mod(n);
		
		int rows = matrix.rowCount();
		int cols = matrix.columnCount();
		
		if (rows >= cols) rows = cols - 1;
		
		int p = matrix .getPrecision();
		
		
		//  Back Substitution
		
		//  Working backward from i = (rows -1) to i = 1
		//
		//  x[i] = b[i] - (a[i][j] x[j]) / a[i][i].
		
		Number[] x = new Number[rows];
		Number[] B = new Number[rows];
		
		Number[] temp = matrix.getColumn(cols - 1);
		
		for (int i = 0; i < B.length; i++) B[i] = temp[i];
		for (int i = 0; i < x.length; i++) x[i] = new Number(0);
		
		for (int i = x.length - 1; i >= 0; i--)
		{
			Number sum = new Number(0);
			
			for (int j = i + 1; j < rows; j++)
			{
				sum = sum .add(matrix.matrix[i][j] .multiply(x[j]));
				
				if (n != null)  sum = sum .mod(n);
			}
			
			Number B1 = B[i] .subtract(sum);
			
			if (n != null) B1 = B1 .mod(n);
			
			try
			{	Number inverse = null, n1 = null;
				
				//  Test for zeros on the diagonal
				
				if (matrix.matrix[i][i].equals(0)) continue;
				
				if (n != null)
				{
					//  Remove the common factor from m[i][i], B[i], n
					
					Number gcd = matrix.matrix[i][i] .gcd(n);
					
					if (!B1.equals(0) && !B1.isDivisibleBy(gcd))
					
					    throw new ArithmeticException();
					
					matrix.matrix[i][i] = matrix.matrix[i][i] .divide(gcd);
					
					n1 = n.divide(gcd);  B1 = B1 .divide(gcd);
				}
				
				try
				{	if (n != null)  inverse = matrix.matrix[i][i] .modInverse(n1);
					else            inverse = matrix.matrix[i][i]    .inverse();
				}
				
				catch (NullPointerException ex) { return null; }
				
				
				if (n != null)  x[i] = B1 .multiply(inverse) .mod(n1);
				else            x[i] = B1 .multiply(inverse);
				
				if (n != null)  x[i] = x[i] .mod(n1) .add(n1) .mod(n1);
			}
			
			catch (NullPointerException ex)
			{
				//  The inverse method can throw a null pointer exception
				
				//  If an element is non-invertible modulo n, then the
				//  matrix is not reducible to row canonical form.
				
				return null;
			}
		}
		
		//  Restore the precision of x because the
		//  inverse method may increase the precision
		
		for (int i = 0; i < rows; i++) x[i] = x[i] .setPrecision(p);
		
		//  Return the augmented identity matrix
		
		return  identityMatrix(rows) .augment(x);
	}
	
	
	
	private Matrix toRowCanonicalForm2(int n)
	{
	
		//  reduces a matrix to row canonical form using back elimination
		
		//  Back elimination is required if A X == B is a square matrix
		//  instead of a column or vector.
		
		
		Matrix matrix = new Matrix(this).trim().mod(n);
		
		//  if (!matrix.isEchelonForm()) throw new IllegalArgumentException();
		
		if (matrix.columnCount() != matrix.rowCount() + 1)
		
		    throw new IllegalArgumentException(); // wrong method
		
		
		Number zero = new Number(0);
		
		Matrix temp = matrix .get(0, 0,
		
		     matrix.rowCount(), matrix.rowCount());
		
		
		//  Divide each row so the first non-zero element equals one
		
		for (int r = matrix.matrix.length -1, j = 0; r >= 0; r--)
		{
			//  Find the column of the first non-zero element
			
			for (j = 0; j < matrix.matrix[r].length -1; j++)
			
			    if (!matrix.matrix[r][j].equals(zero))  break;
			
			if (j >= matrix.matrix[r].length -1)  continue;
			
			
			if (matrix.matrix[r][j] .mod(n) .equals(zero)) continue;
			
			
			//  Compute the multiplier m = 1 / pivot
			
			Number inv = null;
			
			try { inv = matrix.matrix[r][j] .modInverse(n); }
			
			catch (NullPointerException ex) { return null; }
			
			
			//  Multiply row r by the multiplier so the pivot equals one
			
			for (int k = 0; k < matrix.matrix[r].length; k++)
			
			    matrix.matrix[r][k] = matrix.matrix[r][k].multiply(inv).mod(n);
			
			
			//  Put zeros above the pivot for each row above r
			
			for (int i = r-1; i >= 0; i--)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = - [i][j],  m2 = [r][j]
				//
				//  instead of  m = -[i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m1 == [i][j][r][j] - [i][j][r][j] == 0
				
				
				int m1 = matrix.matrix[i][j] .intValue();
				int m2 = matrix.matrix[r][j] .intValue();
				
				m1 = n - m1;
				
				
				//  Multiply row r by m1, and add to row i multiplied by m2
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				{
					matrix.matrix[i][k] = new Number(
					
					    1L*matrix.matrix[i][k] .intValue() * m2
					
					      + ( 1L*matrix.matrix[r][k] .intValue() * m1 ) );
					
					matrix.matrix[i][k] = matrix.matrix[i][k] .mod(n);
				}
			}
		}
		
		matrix = matrix .mod(n);
		
		return matrix;
	}
	
	
	
	private Matrix toRowCanonicalForm2(Number n)
	{
	
		//  reduces a matrix to row canonical form using back elimination
		
		//  Back elimination is required if A X == B is a square matrix
		//  instead of a column vector.
		
		final int minprecision = 8;
		
		Matrix matrix = new Matrix(this);
		
		if (n != null) matrix = matrix.mod(n);
		
		int p = matrix.getPrecision();
		
		if (p < minprecision)
		    p = minprecision;
		
		if (n == null) matrix = matrix.setPrecision(p);
		
		Number zero = new Number(0);
		
		int precision = matrix.getPrecision();
		
		if (precision > 0) zero = zero .setPrecision(precision);
		
		
		//  Divide each row so the first non-zero element equals one
		
		for (int r = matrix.matrix.length -1, j = 0; r >= 0; r--)
		{
			//  Find the column of the first non-zero element
			
			for (j = 0; j < matrix.matrix[r].length -1; j++)
			
			    if (!matrix.matrix[r][j].equals(zero))  break;
			
			if (j >= matrix.matrix[r].length -1)  continue;
			
			
			if ((n != null) && matrix.matrix[r][j] .mod(n) .equals(zero)) continue;
			if ((n == null) && matrix.matrix[r][j]         .equals(zero)) continue;
			
			//  Compute the multiplier m = 1 / pivot
			
			Number inv = null;
			
			try
			{	if (n != null) inv = matrix.matrix[r][j] .modInverse(n);
				if (n == null) inv = matrix.matrix[r][j]    .inverse();
			}
			
			catch (Exception ex)
			{
				return null;
			}
			
			
			//  Multiply row r by the multiplier so the pivot equals one
			
			for (int k = 0; k < matrix.matrix[r].length; k++)
			{
				matrix.matrix[r][k] = matrix.matrix[r][k].multiply(inv);
				
				if (n != null) matrix.matrix[r][k] = matrix.matrix[r][k].mod(n);
			}
			
			
			//  Put zeros above the pivot for each row above r
			
			for (int i = r-1; i >= 0; i--)
			{
				//  For each row i compute the multipliers
				//
				//  m1 = - [i][j],  m2 = [r][j]
				//
				//  instead of  m = -[i][j] / [r][j]
				//
				//  to avoid the modular inversion.
				//
				//  [i][j] m2 + [r][j] m1 == [i][j][r][j] - [i][j][r][j] == 0
				
				
				Number m1, m2;
				
				m1 = matrix.matrix[i][j];
				m2 = matrix.matrix[r][j];
				
				if (n != null) m1 = m1 .negate(n);
				if (n == null) m1 = m1 .negate();
				
				
				//  Multiply row r by m1, and add to row i multiplied by m2
				
				for (int k = j; k < matrix.matrix[i].length; k++)
				{
					matrix.matrix[i][k] =
					
					      matrix.matrix[i][k] .multiply(m2)
					.add( matrix.matrix[r][k] .multiply(m1) );
					
					if (n != null) matrix.matrix[i][k]
					             = matrix.matrix[i][k] .mod(n);
				}
			}
		}
		
		if (n != null) matrix = matrix.mod(n);
		
		if (n == null) matrix = matrix.setPrecision(p);
		
		return matrix;
	}
	
	
	public String toString()
	{
		return toString(10);
	}
	
	public String toString(int radix)
	{
		return toString(0, radix);
	}
	
	public String toString(int digits, int radix)
	{
		//  converts a matrix to string
		
		StringBuilder sb = new StringBuilder("{");
		
		for (int i = 0; i < this.matrix.length; i++)
		{
			sb.append(" { ");
			
			for (int j = 0; j < this.matrix[i].length; j++)
			{
				Number n = this.matrix[i][j];
				
				sb.append((n != null) ? n.toString(digits, radix) : "null");
				
				if (j < this.matrix[i].length -1)  sb.append(", ");
			}
			
			sb.append(" }");
			
			if (i < this.matrix.length -1) sb.append(",");
		}
		
		sb.append(" }");
		
		return sb.toString();
	}
	
	
	public Number trace()
	{
		//  computes the trace of a matrix
		
		//  The trace is the sum of the diagonal elements
		
		if (this.matrix.length != this.matrix[0].length)
		{
			String message = "non-square matrix";
			
			throw new IllegalArgumentException(message);
		}
		
		Number trace = new Number(0);
		
		for (int i = 0; i < this.matrix.length; i++)
		
		    trace = trace .add(this.matrix[i][i]);
		
		return trace;
	}
	
	
	public Matrix transpose()
	{
		//  swaps the rows and columns
		
		int rows = this.matrix   .length;
		int cols = this.matrix[0].length;
		
		Matrix matrix = new Matrix(cols, rows);
		
		for (int i = 0; i < rows; i++)
		for (int j = 0; j < cols; j++)
		
		    matrix.matrix[j][i] = this.matrix[i][j];
		
		return matrix;
	}
	
	
	public Matrix trim()
	{
		//  removes rows of zeros from the bottom of the matrix
		
		Matrix matrix = new Matrix(this);
		
		int rows = matrix.rowCount(), cols = matrix.columnCount();
		
		int deletedrows = 0;
		
		for (int i = matrix.matrix.length -1; i >= 0; i--)
		{
			Number[] row = matrix.getRow(i);
			
			boolean zero = true;
			
			for (int j = 0; j < row.length; j++)
			
			    if (!row[j].equals(0))
			
				{ zero = false;  break; }
			
			if (zero) deletedrows++;
			
			else break;
		}
		
		int rows1 = rows - deletedrows;
		
		return matrix.get(0, 0, rows1, cols);
	}
}

//  End class Matrix














class Convert
{


	//  This class provides conversion methods for arrays and other primitive types.
	//  These methods are used for cryptography.
	
	//  To convert from one type to another if no direct conversion method is avail-
	//  able, convert the first array type to byte array, and then convert from byte
	//  array to the second array type. This reduces the number of methods from O(n^2)
	//  to O(n) where n is the number of types.
	
	
	//  For example, to convert from byte[] to String
	//  and from String to byte[] for random data use
	//
	//  String str = new String(Convert.byteArrayToCharArray(array));
	//  byte[] array1 = Convert.charArrayToByteArray(str.toCharArray());
	//
	//  Don't use String(byte[]) and getBytes()
	//  String str = new String(array);
	//  byte[] array1 = str.getBytes();
	//  because it doesn't convert correctly
	//  for random data; it only converts byte
	//  array to String and String to byte array
	//  for ascii / unicode / base-64 text
	//
	//  This code shows that the conversion is correct
	//
	//  byte[] array = new byte[256];
	//  for (int i = 0; i < array.length; i++)
	//    array[i] = (byte) Math.random(256);
	//  String str = new String(Convert.byteArrayToCharArray(array));
	//  byte[] array1 = Convert.charArrayToByteArray(str.toCharArray());
	//  boolean bool = Arrays.equals(array, array1);
	//  System.out.println(bool);
	
	
	
	
	//  private Convert constructor
	//
	//  no instantiation from outside of class
	
	private Convert() {  }
	
	
	
	//  static class methods
	
	
	public static final String base16Separator = "0123456789abcdef";
	
	
	public static final char[] intToBase64 =
	{
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
		'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
		'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
		'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/',
	};
	
	
	public static final byte[] base64ToInt =
	{
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
		-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
		-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
	};
	
	
	
	public static String base64ToString(String str)
	{
		//  decodes a string from base 64
		
		if (!Number.isBase64(str)) throw new IllegalArgumentException();
		
		return new String(byteArrayToCharArray(base64ToByteArray(str)));
	}
	
	public static String stringToBase64(String str)
	{
		//  encodes a string in base 64
		
		return byteArrayToBase64(charArrayToByteArray(str.toCharArray()));
	}
	
	
	
	public static String byteArrayToBase64(byte[] array)
	{
		//  converts a byte array to a base-64 string
		
		byte[] byte64array = byte256ArrayToByte64Array(array);
		
		char[] charray = new char[byte64array.length];
		
		for (int i = 0; i < charray.length; i++)
		
		    charray[i] = intToBase64[byte64array[i]];
		
		String str = new String(charray);
		
		while ((str.length() % 4) != 0)  str += "=";
		
		return str;
	}
	
	
	
	public static byte[] base64ToByteArray(String str)
	{
		//  converts a base-64 string to a byte array
		
		byte[] array = new byte[str.length()];
		
		for (int i = 0; i < array.length; i++)
		{
			array[i] = base64ToInt[str.charAt(i)];
			
			if ((array[i] < 0) && (i < array.length - 2))
			
			    throw new IllegalArgumentException();
		}
		
		array = byte64ArrayToByte256Array(array);
		
		return array;
	}
	
	
	
	public static String byteArrayToBase16(byte[] array)
	{
		//  converts a byte array to a base-16 string
		
		byte[] byte16array = byte256ArrayToByte16Array(array);
		
		return new String(byte16array);
	}
	
	
	public static byte[] base16ToByteArray(String str)
	{
		//  converts a base-16 string to a byte array
		
		return byte16ArrayToByte256Array(str.getBytes());
	}
	
	
	public static byte[] byte64ArrayToByte256Array(byte[] array)
	{
		//  converts a 6-bit-byte array to an 8-bit-byte array
		
		for (int i = 0; i < array.length -2; i++)
		{
			if ((array[i] & 0xc0) != 0)
			{
				String message = "array is not in base 64";
				
				throw new NumberFormatException(message);
			}
		}
		
		//  Two equal chars == 1 byte  == 1 x 6 + 2 bits modulo 3
		//  One equal char  == 2 bytes == 2 x 6 + 4 bits modulo 3
		//   No equal char  == 3 bytes == 3 x 6 + 6 bits modulo 3
		
		//  Count the equals chars
		
		int equals = 0;
		
		for (int i = 0; i < 2; i++)
		
		    if (      array.length -1 -i >= 0)
		    if (array[array.length -1 -i] == -1) equals++;
		
		byte[] byte64array = new byte[array.length];
		
		for (int i = 0; i < byte64array.length; i++)
		
		    byte64array[i] = array[i];
		
		byte[] byte256array = new byte[byte64array.length*3/4 - equals];
		
		//  Example  Convert 4 sextets into 3 octets
		//
		//  XX101101 XX010101 XX111111 XX001100
		//    101101   01|0101  1111|11  001100
		//    10110101    01011111   11001100
		
		for (int i = 0, j = 0; i < (4 + byte256array.length/3); i++, j++)
		{
			byte[] barray = new byte[3];
			
			if ((4*j + 0) < byte64array.length)
			
			    barray[0] = (byte)(byte64array[4*j + 0] << 2);
			
			if ((4*j + 1) < byte64array.length)
			{
				barray[0] +=      ((byte64array[4*j + 1] >> 4) & 0x3f);
				barray[1] = (byte) (byte64array[4*j + 1] << 4);
			}
			
			if ((4*j + 2) < byte64array.length)
			{
				barray[1] +=      ((byte64array[4*j + 2] >> 2) & 0x0f);
				barray[2] = (byte) (byte64array[4*j + 2] << 6);
			}
			
			if ((4*j + 3) < byte64array.length)
			
			    barray[2] += ((byte64array[4*j + 3] >> 0) & 0x3f);
			
			for (int k = 0; k < 3; k++)
			
			    if ((3*i + k) < byte256array.length)
			
				byte256array[3*i + k] += barray[k];
		}
		
		return byte256array;
	}
	
	
	
	public static byte[] byte256ArrayToByte64Array(byte[] array)
	{
		//  converts an 8-bit-byte array to a 6-bit-byte array
		
		byte[] byte256array = new byte[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    byte256array[i] = array[i];
		
		int r = byte256array.length % 3;
		
		int length = (byte256array.length -r) * 4/3;
		
		if (r == 1) length += 2; // 8 bits == 1x6 + 2 bits
		
		else if (r == 2) length += 3; // 16 bits == 2 x 6 + 4 bits
		
		byte[] byte64array = new byte[length];
		
		
		//  Example  Convert 3 octets into 4 sextets (3*8 == 4*6)
		//
		//    10110101    01011111     11001100
		//    101101   01|0101  1111|11  001100
		//  XX101101 XX010101 XX111111 XX001100
		
		//  byte256  0 1 2    3 4 5    6 7 8       9 10 11 ...
		//  byte64   0 1 2 3  4 5 6 7  8 9 10 11  12 13 14 15 ...
		
		for (int i = 0, j = 0; i < 1 + byte64array.length/4; i++, j++)
		{
			byte[] barray = new byte[4];
			
			if ((3*j + 0) < byte256array.length)
			{
				barray[0] =  (byte)((byte256array[3*j + 0] >> 2) & 0x3f);
				barray[1] =  (byte)((byte256array[3*j + 0] << 4) & 0x30);
			}
			
			if ((3*j + 1) < byte256array.length)
			{
				barray[1] +=       ((byte256array[3*j + 1] >> 4) & 0x0f);
				barray[2] =  (byte)((byte256array[3*j + 1] << 2) & 0x3c);
			}
			
			if ((3*j + 2) < byte256array.length)
			{
				barray[2] += (byte)((byte256array[3*j + 2] >> 6) & 0x03);
				barray[3] =  (byte)((byte256array[3*j + 2] << 0) & 0x3f);
			}
			
			for (int k = 0; k < 4; k++)
			
			    if ((4*i + k) < byte64array.length)
			
				byte64array[4*i + k] += barray[k];
		}
		
		return byte64array;
	}
	
	
	
	public static byte[] byte16ArrayToByte256Array(byte[] array)
	{
		//  converts a 4-bit-byte array to an 8-bit-byte array
		//  and halves the size of the array
		
		byte[] byte16array = new byte[((array.length & 1) == 0) ?
		
		    array.length : 1 + array.length ];
		
		for (int i = 0; i < array.length; i++)
		
		    byte16array[i+byte16array.length-array.length] = array[i];
		
		byte[] byte256array = new byte[byte16array.length / 2];
		
		for (int i = 0; i < byte16array.length; i++)
		{
			if (byte16array[i] >= 'a')
			{
				byte16array[i] -= 'a';
				byte16array[i] += 10;
			}
			
			else byte16array[i]-='0';
		}
		
		for (int i = 0; i < byte256array.length; i++)
		{
			int temp = 0;
			temp += byte16array[2*i];
			temp &= 0xf;
			
			byte256array[i] += temp;
			byte256array[i] <<= 4;
			
			temp = 0;
			temp += byte16array[2*i + 1];
			temp &= 0xf;
			
			byte256array[i] += temp;
		}
		
		return byte256array;
	}
	
	
	
	public static byte[] byte256ArrayToByte16Array(byte[] array)
	{
		//  converts an 8-bit-byte array to a 4-bit-byte array
		//  and doubles the size of the array
		
		byte[] byte256array = new byte[array.length];
		
		for (int i = 0; i < byte256array.length; i++)
		
		    byte256array[i] = array[i];
		
		byte[] byte16array = new byte[byte256array.length*2];
		
		for (int i = 0; i < byte256array.length; i++)
		{
			byte16array[2*i + 1] += byte256array[i];
			byte16array[2*i + 1] &= 0xf;
			
			byte256array[i] >>>= 4;
			
			byte16array[2*i + 0] += byte256array[i];
			byte16array[2*i + 0] &= 0xf;
		}
		
		for (int i = 0; i < byte16array.length; i++)
		{
			if (byte16array[i] >= 10)
			{
				byte16array[i] -= 10;
				byte16array[i] += 'a';
			}
			
			else byte16array[i]+='0';
		}
		
		return byte16array;
	}
	
	
	
	public static byte[] intToByteArray(int intdata)
	{
		//  converts an int to four bytes
		
		byte[] array = new byte[4];
		
		for (int i = 3; i >= 0; i--)
		{
			array[i] += intdata;
			
			intdata >>>= 8;
		}
		
		return array;
	}
	
	
	
	public static int byteArrayToInt(byte[] array)
	{
		//  converts four bytes to an int
		
		int intdata = 0;
		
		int temp = 0;
		
		for (int i = 0; i < 4; i++)
		{
			intdata <<= 8; temp = 0;
			
			intdata += ((temp + array[i]) & 0xff);
		}
		
		return intdata;
	}
	
	
	
	public static char[] byteArrayToCharArray(byte[] array)
	{
		//  converts an Ascii byte array to a char array
		
		char[] charray = new char[array.length];
		
		for (int i = 0; i < array.length; i++)
		{
			charray[i] += array[i];
			charray[i] &= 0xff;
		}
		
		return charray;
	}
	
	
	
	public static byte[] charArrayToByteArray(char[] array)
	{
		//  converts a unicode char array to a byte array
		
		byte[] barray = new byte[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    barray[i] += array[i];
		
		return barray;
	}
	
	
	
	public static int[] byteArrayToIntArray(byte[] array)
	{
		//  converts a byte array to an int array
		
		int r = array.length % 4;
		
		if (r != 0)
		{
			byte[] temp = new byte[array.length + 4 - r];
			
			for (int i = 0; i < array.length; i++)
			
			    temp[i + (4 - r)] = array[i];
			
			array = temp;
		}
		
		int[] intarray = new int[array.length / 4];
		
		for (int i = 0; i < intarray.length; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				int temp = 0;
				temp += array[4*i + j];
				temp &= 0xff;
				intarray[i] += temp;
				if (j < 3) intarray[i] <<= 8;
			}
		}
		
		return intarray;
	}
	
	
	
	public static byte[] intArrayToByteArray(int[] array)
	{
		//  converts an int array to a byte array
		
		int[] iarray = new int[array.length];
		
		for (int i = 0; i < iarray.length; i++)
		
		    iarray[i] = array[i];
		
		byte[] barray = new byte[iarray.length*4];
		
		for (int i = 0; i < iarray.length; i++)
		{
			barray[4*i + 3] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 2] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 1] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 0] += iarray[i];
		}
		
		return barray;
	}
	
	
	
	public static byte[] intArrayToByteArray(int[] array, int bytes)
	{
		//  converts an int array to a byte array
		//  and quadruples the size of the array
		
		if ((bytes % 4) != 0) bytes += (4 - (bytes % 4));
		
		int[] iarray = new int[bytes / 4];
		
		for (int i = 0; i < ((array.length < iarray.length) ?
		
		    array.length : iarray.length); i++)
		
			iarray[iarray.length -1 -i]
		       = array[ array.length -1 -i];
		
		byte[] barray = new byte[iarray.length*4];
		
		for (int i = 0; i < iarray.length; i++)
		{
			barray[4*i + 3] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 2] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 1] += iarray[i];  iarray[i] >>>= 8;
			barray[4*i + 0] += iarray[i];
		}
		
		return barray;
	}
	
	
	public static float[] doubleArrayToFloatArray(double[] array)
	{
		//  converts a double array to a float array
		
		float[] farray = new float[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    farray[i] = (float) array[i];
		
		return farray;
	}
	
	
	public static int[] doubleArrayToIntArray(double[] array)
	{
		//  converts a double array to an int array
		
		int[] iarray = new int[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    iarray[i] = (int) array[i];
		
		return iarray;
	}
	
	
	
	public static Number[] intArrayToNumberArray(int[] intarray)
	{
		//  converts an int array to a number array
		
		Number[] array = new Number[intarray.length];
		
		for (int i = 0; i < array.length; i++)
		
		    array[i] = new Number(intarray[i]);
		
		return array;
	}
	
	
	
	public static int[] realArrayToComplexArray(int[] array)
	{
		//  converts ints from real to complex
		
		int[] complex_array = new int[2*array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    complex_array[2*i] = array[i];
		
		return complex_array;
	}
	
	
	public static double[] realArrayToComplexArray(double[] array)
	{
		//  converts doubles from real to complex
		
		double[] d_array = new double[2*array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    d_array[2*i] = array[i];
		
		return d_array;
	}
	
	
	
	public static String partition(String str, String delimiter, int linewidth)
	{
		//  partitions a string into groups of partition size
		//
		//  If the linewidth is positive, the method partitions from left to right.
		//  If the linewidth is negative, the method partitions from right to left.
		
		//  There is no String method in Java to partition a string.
		
		
		//  Example  Partition a string into quartets / quaternions
		//
		//  Convert.partition("0123456789abcdef", " ", 4);
		//
		//  0123 4567 89ab cdef
		//
		//  Example  Partition the string 1234567890 into 1,234,567,890
		//
		//  Convert.partition("1234567890", ",", -3);
		
		
		if (str.length() == 0) return str;
		
		int direction = 1;
		
		if (linewidth == 0) return new String(str);
		
		if (linewidth < 0) { linewidth *= -1; direction = -1; }
		
		int size1 = str.length();
		
		int size2 = size1 + (size1 / linewidth) * delimiter.length();
		
		if ((size1 % linewidth) == 0)
		
		     size2 -= delimiter.length();
		
		char[] charray1 = str.toCharArray();
		char[] charray2 = new char[size2];
		
		char[] delimarray = delimiter.toCharArray();
		
		if (direction == 1)
		
		for (int i1 = 0, i2 = 0; i1 < charray1.length; i1++, i2++)
		{
			if ((i1 > 0) && ((i1 % linewidth) == 0))
			
			    for (int s = 0; s < delimarray.length; s++)
			
				charray2[i2++] = delimarray[s];
			
			charray2[i2] = charray1[i1];
		}
		
		else if (direction == -1)
		
		for (int i1 = 0, i2 = 0; i1 < charray1.length; i1++, i2++)
		{
			if ((i1 > 0) && ((i1 % linewidth) == 0))
			
			    for (int s = 0; s < delimarray.length; s++)
			
				charray2[charray2.length -1 -i2++] = delimarray[s];
			
			charray2[charray2.length -1 -i2] =
			charray1[charray1.length -1 -i1];
		}
		
		return new String(charray2);
	}
}


//  End class Convert











class Fourier
{



	//  The Discrete Fourier Transform
	//
	//  Any periodic function, curve, or set of numbers x(n) can be represented as the sum
	//  of the sine and cosine functions over all the frequencies using the infinite series
	//
	//  a0 cos 0 x + b0 sin 0 x + a1 cos 1 x + b1 sin 1 x + ... + ak cos k x + sin k x
	//
	//  == a[k] cos k x + b[k] sin k x  where the k = 0,1,2,3,...,N-1 for a finite series.
	//
	//  The series a[k] cos(2 pi/N k x) + b[k] sin(2 pi/N k x) is called the Fourier series
	//  of the function x(n) and the constants a[] and b[] are called the Fourier coefficients.
	//  (The number 2 pi/N is the step size because 2 pi is the circumference of a unit circle
	//  and N is the number of elements in the array.)
	//
	//  The Fourier coefficients a[] and b[] represent the amplitudes of the sine and cosine
	//  terms in the series, and the indexer k represents the integer multiples of the fre-
	//  quencies of the sine and cosine functions which range from 0 to N-1 where N is the
	//  size of the array. The zeroth frequency or Fourier coefficient x[k = 0] is the sum or
	//  average of all the values of x[n] which are the amplitudes of the function or curve.
	//
	//  The discrete Fourier transform decomposes an array of values x[n] into an array of
	//  amplitudes of sines and cosines x[k], and the inverse Fourier transforms recomposes
	//  or reconstructs the function x[n] from the amplitudes or coefficients of the sine
	//  and cosine terms x[k]. The Fourier transform is useful for extracting the frequency
	//  components of a function or curve.
	//
	//  The formulas for computing the Fourier transform and inverse transform are
	//
	//  x[k] = the sum of x[n] w ^ [k n] where w = exp(i 2 pi/N)
	//
	//  ==  [ x[n] real cos(2 pi/N k n) - x[n] imag sin(2 pi/N k n) ]
	//  + i [ x[n] real sin(2 pi/N k n) + x[n] imag cos(2 pi/N k n) ]
	//
	//  x[n] = the sum of 1/N x[k] w ^ [-k n] where w = exp(i 2 pi/N)
	//
	//  ==  [ x[k] real cos(-2 pi/N k n) - x[k] imag sin(-2 pi/N k n) ]
	//  + i [ x[k] real sin(-2 pi/N k n) + x[k] imag cos(-2 pi/N k n) ]
	//
	//  ==  [ x[k] real cos(2 pi/N k n) + x[k] imag sin(2 pi/N k n) ]
	//  + i [-x[k] real sin(2 pi/N k n) + x[k] imag cos(2 pi/N k n) ]
	//
	//  Some implementations divide the transform and inverse transform by 1/sqrt(N) in-
	//  stead of dividing the inverse transform by 1/N to make the formulas symmetrical.
	//  
	//  Computing the Fourier transform requires a quadratic number of multiplications
	//  because for each x[k] the index n has to be iterated from 0 to N-1, and for each
	//  x[n] the index k has to be iterated from 0 to N-1. This means that there are two
	//  iterators or a double loop for computing the Fourier transform. The Danielson-
	//  Lanczos lemma can be used to reduce the time complexity from O(n^2) to O(n log n)
	//  where n is the number of elements in the array.
	
	
	
	
	//  The only two public methods in the Fourier class
	//  are the transform and multiply methods
	
	
	//  The fft method is faster than the dft method if the number
	//  of elements is > 64 but it may depend on the implementation.
	//  (At 1024 elements, the fft is 16 times as fast and at 1 M
	//  elements the fft is 16 K times as fast as the dft.)
	//
	//  Programs that use recursion instead of iteration set the min
	//  size or threshold = 1 because the Fourier transform of a one-
	//  element array or a single number equals itself. This avoids
	//  using the dft method since the transform does not have to be
	//  computed for a single number, but the dft is still required
	//  for array lengths that are not a power of 2.
	
	//  Iteration is used instead of recursion because it is twice as
	//  fast and it doesn't require any function calls, but recursion
	//  can be enabled for testing by commenting the return ffti (x,
	//  sign) and uncommenting the return fftr(x, sign).
	//
	//  Testing the ffti and fftr methods using the following code
	//  shows that iteration is only twice as fast as recursion.
	//  Setting the minsize = 1 requires as many function calls as
	//  the number of elements in the array but the code is just as
	//  fast even for large array sizes.
	//
	//  final int size = 1024*1024;
	//  double[] array = new double[size];
	//  for (int i = 0; i < array.length; i++) array[i] = i;
	//  array = Convert.realArrayToComplexArray(array);
	//  for (int i = 0; i < 16; i++) Fourier.transform(array, 1);
	
	
	
	//  Set the minimum size or threshold for recursion
	//  and for using the dft instead of the fft
	
	private static int minsize = 1;
	
	
	
	//  Example  Test the slow / quadratic discrete fourier
	//           transform and inverse transform method
	//
	//     int[] intarray    = new    int[] { 1, 2, 3, 4 };
	//  double[] doublearray = new double[] { 1, 2, 3, 4 };
	//
	//     int[] x1_ = Convert.realArrayToComplexArray(intarray);
	//  Number[] x1  = Convert.intArrayToNumberArray(x1_);
	//  double[] x2  = Convert.realArrayToComplexArray(doublearray);
	//
	//  Number[] fourier1 = Fourier.transform(x1, 1);
	//  double[] fourier2 = Fourier.transform(x2, 1);
	//
	//  Number[] x3 = Fourier.transform(fourier1, -1);
	//  double[] x4 = Fourier.transform(fourier2, -1);
	//
	//  System.out.println("Number[] x1 == " + Arrays.toString(fourier1));
	//  System.out.println("double[] x2 == " + Arrays.toString(fourier2));
	//
	//  System.out.println("Number[] x3 == " + Arrays.toString(x3));
	//  System.out.println("double[] x4 == " + Arrays.toString(x4));
	//
	//
	//  Number[] x1 == [ 10.000000000000000,  0.0, -2.0000000000000000, -2.0000000000000000,
	//                   -2.000000000000000,  0.0, -2.0000000000000000,  2.0000000000000000 ]
	//  double[] x2 == [  9.999999999939767,  0.0, -1.9999999999879536, -1.9999999999879536,
	//                   -1.9999999999879536, 0.0, -1.9999999999879536,  1.9999999999879536 ]
	//
	//  Number[] x3 == [ 1.0000000000000000, 0.0,  2.0000000000000000, 0.0,  3.000000000000000, 0.0,  4.0000000000000000, 0.0 ]
	//  double[] x4 == [ 0.9999999999879536, 0.0,  1.9999999999759073, 0.0,  2.999999999963861, 0.0,  3.9999999999518145, 0.0 ]
	
	
	
	public static double[] transform(double[] array, int sign)
	{
	
		//  computes the discrete fourier transform or dft of a
		//  set of complex numbers
		
		//  If the array is small use the quadratic / O(n^2) dft
		//  (The slow dft also allows sizes that are not powers of 2)
		
		//  The inverse transform divides the array by the number of
		//  elements, but some implementations divide both the transform
		//  and the inverse transform by the sqrt of the number of ele-
		//  ments to make the transform symmetrical.
		
		
		double[] x = new double[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    x[i] = array[i];
		
		int len = array.length;
		
		double[] y = Math.isPowerOf2(len) && (len >= minsize) ?
		
		    fft(x, sign) : dft(x, sign);
		
		int t = y.length / 2;
		
		if (sign == -1)
		
		    for (int i = 0; i < y.length; i++)
		
			y[i] /= t;
		
		if (array.length > 4*1024*1024)
		
		// call the garbage collector
		
		    System.gc();
		
		return y;
	}
	
	
	
	public static Number[] transform(Number[] array, int sign)
	{
	
		//  computes the discrete fourier transform or dft of a set of
		//  complex numbers using the fast / fft or slow / quadratic dft.
		//
		//  The inverse transform divides the array by the number of ele-
		//  ments, but some implementations divide both the transform and
		//  the inverse transform by the sqrt of the number of elements
		//  to make the transform symmetrical.
		
		
		final int p = 8;
		
		Number[] x = new Number[array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    x[i] = array[i];
		
		int len = array.length;
		
		Number[] y = Math.isPowerOf2(len) && (len >= minsize) ?
		
		    fft(x, sign) : dft(x, sign);
		
		int t = y.length / 2;
		
		if (sign == -1)
		{
			//  Divide the inverse fourier transform
			//  by the number of complex numbers
			
			for (int i = 0; i < y.length; i++)
			
			    y[i] = y[i] .divide(t);
		}
		
		//  Set the precision
		
		for (int i = 0; i < y.length; i++)
		
		    y[i] = y[i] .setPrecision(p);
		
		return y;
	}
	
	
	
	
	//  This code tests the fft multiply method.
	//
	//  The divide method works for 16 K ints (== 512 K bits) but larger
	//  sizes cause the inverter / divider to throw an arithmetic exception.
	//  There may be a carry digit error in the complexDoubleArrayToIntArray
	//  conversion method that is causing this problem.
	
	
	
	//  int size = 16*1024;
	//
	//  int[] array1 = new int[size];
	//  int[] array2 = new int[size];
	//
	//  for (int i = 0; i < size; i++)
	//  {
	//	array1[i] = Math.random(0x7fffffff);
	//	array2[i] = Math.random(0x7fffffff);
	//  }
	//
	//  Number a = new Number(array1);
	//  Number b = new Number(array2);
	//
	//  Number c = a .multiply(b);
	//
	//  System.out.println(a.bitCount() + " bits");
	//
	//  Number a1 = c.divide(b);
	//
	//  boolean bool = a1.equals(a);
	//
	//  System.out.println(bool);
	
	
	
	public static int[] multiply(int[] x, int[] y)
	{
	
		//  multiplies two int arrays using the discrete fourier transform
		
		//  This method multiplies two arrays in O(n log n)-bit operations.
		//  FFT multiplication is faster than quadratic multiplication for
		//  bit sizes >= 256 K, and faster than Karatsuba multiplication
		//  for bit sizes >= 4 M.
		
		
		//  Example  Calculate 1234 x 5678 using
		//           quadratic and fft multiplication
		//
		//  Quadratic multiplication
		//
		//	        1   2   3   4
		//	        5   6   7   8
		//	        _____________
		//
		//		8  16  24  32
		//	    7  14  21  28
		//	6  12  18  24
		//    5  10  15  20
		//  _________________________
		//
		//  0  5  16  34  60  61  52  32
		//  ____________________________
		//
		//     7   0   0   6   6   5   2
		//
		//
		//  Discrete Fourier Transform multiplication
		//
		//  int[] x = {  1, 2, 3, 4  }
		//  int[] y = {  5, 6, 7, 8  }
		//
		//  Quadruple the array length to convert x, y to complex integers
		//  and to hold the complex product w = x y
		//
		//  int[] a = {  1, 0, 2, 0, 3, 0, 4, 0,   0, 0, 0, 0, 0, 0, 0, 0 };
		//  int[] b = {  5, 0, 6, 0, 7, 0, 8, 0,   0, 0, 0, 0, 0, 0, 0, 0 };
		//
		//  compute the fourier transforms A = Fourier(a) and B = Fourier(B);
		//  compute the inner product C of the complex vectors A and B;
		//  compute the inverse Fourier transform of C; round the elements
		//  to the nearest integer by adding 1/2 to get
		//
		//  a x b == { 5, 0, 16, 0, 34, 0, 60, 0,  61, 0, 52, 0, 32, 0, 0, 0 };
		//
		//  remove the imag components (which are all zero) to get the real array
		//
		//  a x b == { 5, 16, 34, 60, 61, 52, 32, 0 }.
		//
		//  This is the product of x and y except that the array is wrapped
		//  around to the left by one digit. Rotate the array to the right by
		//  one digit and then carry the digits to find the product
		//
		//  x y == { 0, 5, 16, 34, 60, 61, 52, 32 }
		//
		//          ==  5, 16, 34, 60, 61, 52, 32
		//
		//          ==  0  7  0  0  6  6  5  2
		
		
		
		//  The fft multiply method might run out of memory because the
		//  fourier and swap methods use a lot of memory. This can be cor-
		//  rected by expanding the memory size before running the program.
		
		
		System.out.println("fft multiply");
		
		//  Equalize the array lengths
		
		if (x.length != y.length)
		{
			int length = Math.max(x.length, y.length);
			
			int[] array = (x.length <= y.length) ? x : y;
			
			int[] temp = new int[length];
			
			for (int i = 0; i < temp.length; i++) temp[i] = 0;
			
			for (int i = 0; i < array.length; i++)
			
			    temp[temp.length -1 -i] = array[array.length -1 -i];
			
			if (x.length <= y.length) x = temp;
			
			else y = temp;
		}
		
		
		//  Expand the arrays for the final carry digit
		
		int[] xtemp = new int[1 + x.length];
		int[] ytemp = new int[1 + y.length];
		
		for (int i = 0; i < x.length; i++) xtemp[i+1] = x[i];
		for (int i = 0; i < y.length; i++) ytemp[i+1] = y[i];
		
		x = xtemp;  y = ytemp;
		
		
		//  Compute the discrete fourier transform (dft) for the two input arrays
		
		double[] u = transform(doubleArray(intArrayToComplexDoubleArray(x)), 1);
		double[] v = transform(doubleArray(intArrayToComplexDoubleArray(y)), 1);
		
		
		double[] w = new double[u.length];
		
		for (int i = 0; i < w.length; i++)  w[i] = 0D;
		
		
		//  Compute the convolution / multiplication of the two complex arrays
		//
		//  For each array element w[i], compute the product w[i] = u[i] v[i]
		//
		//  u[i] v[i] = (a + bi) (c + di) = (a c - b d) + i(a d + b c)
		//
		//  (i is the imaginary number = sqrt(-1))
		
		
		for (int i = 0; i < w.length; i += 2)
		{
			w[i+0] = u[i+0] * (v[i+0]) - u[i+1] * v[i+1];
			w[i+1] = u[i+0] * (v[i+1]) + u[i+1] * v[i+0];
		}
		
		
		//  Compute the inverse discrete fourier transform
		
		w = transform(w, -1);
		
		
		//  Round the numbers up if the fractional part is >= 1/2
		//              and down if the fractional part is <  1/2
		
		for (int i = 0; i < w.length; i++) w[i] = w[i] + 0.5D;
		
		//  w is the complex product or convolution of u and v ( w = u (x) v )
		
		//  System.out.println("w == " + Arrays.toString(
		//
		//      Convert.doubleArrayToFloatArray(w)));
		
		
		//  Convert from complex array to real array
		
		int[] array = complexDoubleArrayToIntArray(w);
		
		
		//  The product is shifted left by one byte
		
		//  Shift the product right by one byte
		
		array = Math.shiftRight(array, 8);
		
		
		//  Remove the leading zeros
		
		array = Math.trim(array);
		
		return array;
	}
	
	
	
	
	//  Private methods
	
	
	private static double[] dft(double[] array, int sign)
	{
	
		//  The slow fourier transform has a quadratic O(n^2) running time
		
		//  This method computes the Fourier transform for small
		//  arrays or array sizes that are not a power of 2.
		
		
		int t = array.length / 2;
		
		double[] x = array;
		
		double[] y = new double[x.length];
		
		double[] cos_table = Math.cos_table(t);
		double[] sin_table = Math.sin_table(t);
		
		
		if (sign == 1)
		{
			for (int k = 0; k < t; k++)
			for (int n = 0; n < t; n++)
			{
				//  Compute the real and imag components
				
				//  x[k] = the sum of x[n] w ^ [k n] where w = exp(i 2 pi/N)
				//
				//  ==  [ x[n] real cos(2 pi/N k n) - x[n] imag sin(2 pi/N k n) ]
				//  + i [ x[n] real sin(2 pi/N k n) + x[n] imag cos(2 pi/N k n) ]
				
				int exp = (k*n) % t;
				
				y[2*k+0] += x[2*n+0] * cos_table[exp] - x[2*n+1] * sin_table[exp];
				y[2*k+1] += x[2*n+0] * sin_table[exp] + x[2*n+1] * cos_table[exp];
			}
		}
		
		
		if (sign == -1)
		{
			for (int n = 0; n < t; n++)
			for (int k = 0; k < t; k++)
			{
				//  Compute the real and imag components
				
				//  x[n] = the sum of 1/N x[k] w ^ [-k n] where w = exp(i 2 pi/N)
				//
				//  ==  [ x[k] real cos(2 pi/N k n) - x[k] imag sin(2 pi/N k n) ]
				//  + i [ x[k] real sin(2 pi/N k n) + x[k] imag cos(2 pi/N k n) ]
				
				//  To compute the inverse dft, the exponent can be negated
				//  or the sine can be negated.
				//
				//  Negating the exponent k*n or indexing the sine and cosine
				//  tables in reverse is equivalent to negating the sine table
				//  because  cos(-x) == cos(x)  and  sin(-x) == - sin(x).
				
				//  Negate the exponent k*n
				
				int exp = (((-k*n) % t) + t) % t;
				
				y[2*n+0] += x[2*k+0] * cos_table[exp] - x[2*k+1] * sin_table[exp];
				y[2*n+1] += x[2*k+0] * sin_table[exp] + x[2*k+1] * cos_table[exp];
			}
		}
		
		return y;
	}
	
	
	
	
	private static Number[] dft(Number[] array, int sign)
	{
	
		//  The slow fourier transform has a quadratic O(n^2) running time
		
		//  This method computes the Fourier transform for small
		//  arrays or array sizes that are not a power of 2.
		
		
		int t = array.length / 2;
		
		Number[] x = array;
		
		Number[] y = new Number[x.length];
		
		for (int i = 0; i < y.length; i++)
		
		    y[i] = new Number(0);
		
		Number N = new Number(t);
		
		Number[] cos_table = Math.cos_table(N);
		Number[] sin_table = Math.sin_table(N);
		
		
		if (sign == 1)
		{
			for (int k = 0; k < t; k++)
			for (int n = 0; n < t; n++)
			{
				//  Compute the real and imag components
				
				//  x[k] = the sum of x[n] w ^ [k n] where w = exp(i 2 pi/N)
				//
				//  ==  [ x[n] real cos(2 pi/N k n) - x[n] imag sin(2 pi/N k n) ]
				//  + i [ x[n] real sin(2 pi/N k n) + x[n] imag cos(2 pi/N k n) ]
				
				int exp = (k*n) % t;
				
				y[2*k+0] = y[2*k+0] .add( x[2*n+0].multiply(cos_table[exp])
				               .subtract( x[2*n+1].multiply(sin_table[exp]) ) );
				
				y[2*k+1] = y[2*k+1] .add( x[2*n+0].multiply(sin_table[exp])
				                    .add( x[2*n+1].multiply(cos_table[exp]) ) );
			}
		}
		
		
		if (sign == -1)
		{
			for (int n = 0; n < t; n++)
			for (int k = 0; k < t; k++)
			{
				//  Compute the real and imag components
				
				//  x[n] = the sum of 1/N x(k) w ^ [-k n] where w = exp(i 2 pi/N)
				//
				//  ==  [ x[k] real cos(2 pi/N k n) - x[k] imag sin(2 pi/N k n) ]
				//  + i [ x[k] real sin(2 pi/N k n) + x[k] imag cos(2 pi/N k n) ]
				//
				//  To compute the inverse dft, the exponent can be negated
				//  or the sine can be negated.
				//
				//  Negating the exponent k*n or indexing the sine and cosine
				//  tables in reverse is equivalent to negating the sine table
				//  because  cos(-x) == cos(x)  and  sin(-x) == - sin(x).
				
				//  Negate the exponent k*n
				
				int exp = (((-k*n) % t) + t) % t;
				
				y[2*n+0] = y[2*n+0] .add( x[2*k+0].multiply(cos_table[exp])
				               .subtract( x[2*k+1].multiply(sin_table[exp]) ) );
				
				y[2*n+1] = y[2*n+1] .add( x[2*k+0].multiply(sin_table[exp])
				                    .add( x[2*k+1].multiply(cos_table[exp]) ) );
			}
		}
		
		return y;
	}
	
	
	
	
	
	//  The Fast Fourier Transform (fft)
	//
	//  The Fast Fourier Transform (fft) is an algorithm or method for
	//  computing the Discrete Fourier Transform (dft) in linear log time
	//
	//  The fft computes the same values as the dft.
	//  (See the slow fourier transform or dft method.)
	
	
	//  The user calls the public Fourier.transform() method, not the private fft method,
	//  just as a user calls the Number.multiply() method instead of the quadratic,
	//  sesquilinear (Karatsuba), or linear log (fftmultiply) methods.
	//
	//  The Fast Fourier Transform (fft) is an algorithm or method for computing
	//  the Discrete Fourier Transform (dft), just as Karatsuba multiplication is
	//  an algorithm for fast multiplication. The fft computes and returns the same
	//  value or array of numbers as the dft method.
	//
	//  The Fast Fourier Transform requires only O(n log(n)) operations, where n is the
	//  number of bits. The Slow Fourier Transform or dft requires O(n^2) operations.
	
	
	
	
	//  The Danielson-Lanczos lemma (1942) is used to compute
	//  the dft in linear log time instead of quadratic time
	//
	//  The set of k equations
	//
	//  x(k) = x(n) w ^ (k n), where w = exp(i 2 pi/N), k = 0 to N-1
	//
	//  is equivalent to the set of k equations
	//
	//  x(k + 0 N/2) = y(k) + w(N) ^ k z(k),  k = 0 to N/2 -1
	//  x(k + 1 N/2) = y(k) - w(N) ^ k z(k),  k = 0 to N/2 -1
	//
	//  in which
	//
	//  y(k) = x(2 n + 0) w(N/2) ^ (k n sign),  k = 0 to N/2 -1,  n = 0 to N/2 -1
	//  z(k) = x(2 n + 1) w(N/2) ^ (k n sign),  k = 0 to N/2 -1,  n = 0 to N/2 -1
	//
	//  Computing y(k) or z(k) requires only one-quarter the number of multiplications
	//  required to compute x(k) because k/2 * n/2 == k n / 4; therefore computing both
	//  y(k) and z(k) requires half the number of multiplications required to compute x(k).
	//
	//  Since y(k) and z(k) have the same form as x(k), they can be computed recursively.
	//  This reduces the number of multiplications for computing x(k) from O(n^2) to
	//  O(n log n) where n is the size or number of bits.
	
	
	
	private static double[] fft(double[] x, int sign)
	{
	
		//  The fast fourier transform method
		
		//  The recursive fft is not used because the iterative fft
		//  is faster than the recursive fft and uses less memory.
		
		return ffti(x, sign);
		
		
		//  Below the minimum threshold the recursive fft calls the iter-
		//  ative fft or the quadratic / slow dft. This reduces the number
		//  of function calls by 1 / limit.
		//
		//  (For some minimum size, the quadratic dft should be just as fast
		//  as the fft, just as for some size a quadratic sorter is just as
		//  fast as a linear log sorter, and for some size a quadratic multi-
		//  plier is just as fast as a linear log multiplier.)
		//
		//  return fftr(x, sign);
	}
	
	
	
	private static Number[] fft(Number[] array, int sign)
	{
	
		//  An iterative fast fourier transform method
		
		
		//  Swap the indices
		
		array = fftSwap(array);
		
		//  Create a sine and cosine table
		
		int N = array.length / 2;
		
		//  N = the number of complex numbers
		
		Number[] sin = Math.sin_table(new Number(N));
		Number[] cos = Math.cos_table(new Number(N));
		
		
		//  Compute the Fourier transform
		
		final Number[] X = array;
		
		for (int i = N; i > 1; i /= 2)
		{
			final Number[] x, y, z;
			
			x = new Number[4*N/i];
			y = new Number[2*N/i];
			z = new Number[2*N/i];
			
			final int n = x.length / 2;
			
			final int m = sin.length / n;
			
			
			//  x[k+0 + 0N/2] = y[k] + exp(i 2 pi/N  k sign) z[k];
			//
			//               == y[k] + (cos(a k) + i sin(a k sign)) z[k]
			//
			//  x[k+0 + 1N/2] = y[k] - exp(i 2 pi/N  k sign) z[k];
			//
			//               == y[k] - (cos(a k) + i sin(a k sign)) z[k]
			
			
			//  Expand the exponential into real and imaginary parts
			//
			//  x[2k+0 + 0N/2] = y[2k+0] + real((cos[k] + isin[k]) (z[2k+0] + iz[2k+1]));
			//  x[2k+1 + 0N/2] = y[2k+1] + imag((cos[k] + isin[k]) (z[2k+0] + iz[2k+1]));
			//  x[2k+0 + 1N/2] = y[2k+0] - real((cos[k] + isin[k]) (z[2k+0] + iz[2k+1]));
			//  x[2k+1 + 1N/2] = y[2k+1] - imag((cos[k] + isin[k]) (z[2k+0] + iz[2k+1]));
			
			
			for (int j = 0; j < N; j += 2*N/i)
			{
				for (int k = 0; k < n; k++)
				{
					y[k] = X[2*j + 0*N/i + k];
					z[k] = X[2*j + 2*N/i + k];
				}
				
				for (int k = 0; k < n; k+=2)
				{
					if (sign == 1)
					{
						x[k+0] = y[k+0]. add(
						
						   (cos[k/2*m].multiply(z[k+0]). subtract(
						    sin[k/2*m].multiply(z[k+1]))) );
						
						x[k+1] = y[k+1]. add(
						
						   (cos[k/2*m].multiply(z[k+1]). add(
						    sin[k/2*m].multiply(z[k+0]))) );
						
						x[k+0 + 2*n/2] = y[k+0]. subtract(
						
						   (cos[k/2*m].multiply(z[k+0]). subtract(
						    sin[k/2*m].multiply(z[k+1]))) );
						
						x[k+1 + 2*n/2] = y[k+1]. subtract(
						
						   (cos[k/2*m].multiply(z[k+1]). add(
						    sin[k/2*m].multiply(z[k+0]))) );
					}
					
					
					else if (sign == -1)
					{
						//  Negate the sine
						
						x[k+0] = y[k+0]. add(
						
						   (cos[k/2*m].multiply(z[k+0]). add(
						    sin[k/2*m].multiply(z[k+1]))) );
						
						x[k+1] = y[k+1]. add(
						
						   (cos[k/2*m].multiply(z[k+1]). subtract(
						    sin[k/2*m].multiply(z[k+0]))) );
						
						x[k+0 + 2*n/2] = y[k+0]. subtract(
						
						   (cos[k/2*m].multiply(z[k+0]). add(
						    sin[k/2*m].multiply(z[k+1]))) );
						
						x[k+1 + 2*n/2] = y[k+1]. subtract(
						
						   (cos[k/2*m].multiply(z[k+1]). subtract(
						    sin[k/2*m].multiply(z[k+0]))) );
					}
				}
				
				for (int r = 0; r < x.length; r++)
				
				    X[2*j + r] = x[r];
			}
		}
		
		return X;
	}
	
	
	
	private static double[] ffti(double[] array, int sign)
	{
	
		//  An iterative fast fourier transform method
		//
		//  This method is called by the Fourier method
		
		
		//  Swap the indices
		
		array = fftSwap(array);
		
		
		//  Create a sine and cosine table
		
		int N = array.length / 2;
		
		//  N = the number of complex numbers
		
		double[] sin = Math.sin_table(N);
		double[] cos = Math.cos_table(N);
		
		
		//  Compute the fourier transform
		//
		//  x[k + 0 * N/2] = y[k] + exp(i 2 pi/N k sign) z[k];
		//
		//                == y[k] + (cos(a k) + i sin(a k sign)) z[k]
		//
		//  x[k + 1 * N/2] = y[k] - exp(i 2 pi/N k sign) z[k];
		//
		//                == y[k] - (cos(a k) + i sin(a k sign)) z[k]
		//
		//
		//  Expand w into real and imag values
		//
		//  x[2k+0 + 0N/2] = y[2k+0] + real((cos[k] + i sin[k]) (z[2k+0] + i z[2k+1]));
		//  x[2k+1 + 1N/2] = y[2k+1] + imag((cos[k] + i sin[k]) (z[2k+0] + i z[2k+1]));
		//  x[2k+0 + 1N/2] = y[2k+0] - real((cos[k] + i sin[k]) (z[2k+0] + i z[2k+1]));
		//  x[2k+1 + 1N/2] = y[2k+1] - imag((cos[k] + i sin[k]) (z[2k+0] + i z[2k+1]));
		
		
		final double[] X = array;
		
		for (int i = N; i > 1; i /= 2)
		{
			final double[] x, y, z;
			
			x = new double[4*N/i];
			y = new double[2*N/i];
			z = new double[2*N/i];
			
			final int n = x.length / 2;
			
			final int m = sin.length / n;
			
			for (int j = 0; j < N; j += 2*N/i)
			{
				for (int k = 0; k < n; k++)
				{
					y[k] = X[2*j + 0*N/i + k];
					z[k] = X[2*j + 2*N/i + k];
				}
				
				for (int k = 0; k < n; k+=2)
				{
					if (sign == 1)
					{
						x[k+0 + 0*n/2] = y[k+0] + (cos[k/2*m]*z[k+0] - sin[k/2*m]*z[k+1]);
						x[k+1 + 0*n/2] = y[k+1] + (cos[k/2*m]*z[k+1] + sin[k/2*m]*z[k+0]);
						x[k+0 + 2*n/2] = y[k+0] - (cos[k/2*m]*z[k+0] - sin[k/2*m]*z[k+1]);
						x[k+1 + 2*n/2] = y[k+1] - (cos[k/2*m]*z[k+1] + sin[k/2*m]*z[k+0]);
					}
					
					else if (sign == -1)
					{
						//  Negate the sine
						
						x[k+0 + 0*n/2] = y[k+0] + (cos[k/2*m]*z[k+0] + sin[k/2*m]*z[k+1]);
						x[k+1 + 0*n/2] = y[k+1] + (cos[k/2*m]*z[k+1] - sin[k/2*m]*z[k+0]);
						x[k+0 + 2*n/2] = y[k+0] - (cos[k/2*m]*z[k+0] + sin[k/2*m]*z[k+1]);
						x[k+1 + 2*n/2] = y[k+1] - (cos[k/2*m]*z[k+1] - sin[k/2*m]*z[k+0]);
					}
				}
				
				for (int r = 0; r < x.length; r++)
				
				    X[2*j + r] = x[r];
			}
		}
		
		return X;
	}
	
	
	
	private static double[] fftr(double[] x, int sign)
	{
	
		//  A recursive fast fourier transform method
		
		//  Note that the recursive fft does not use fftSwap.
		//  Only the iterative fft uses the fftSwap method.
		
		//  Test before recursion
		
		if (x.length / 2 <= minsize)
		
		    return dft(x, sign);
		
		
		//  Initialize the y and z arrays
		
		double[] y = new double[x.length/2];
		double[] z = new double[x.length/2];
		
		for (int i = 0; i < x.length/2 /2; i++)
		{
			y[2*i + 0] = x[4*i + 0];
			y[2*i + 1] = x[4*i + 1];
			z[2*i + 0] = x[4*i + 2];
			z[2*i + 1] = x[4*i + 3];
		}
		
		//  Test before recursion
		
		y = fftr(y, sign);
		z = fftr(z, sign);
		
		
		int n = x.length / 2;
		
		// the number of complex numbers
		
		
		//  Create a sine and cosine table
		
		double[] sin = Math.sin_table(n);
		double[] cos = Math.cos_table(n);
		
		int m = sin.length / n;
		
		for (int k = 0; k < n; k+=2)
		{
			if (sign == 1)
			{
				x[k+0 + 0*n/2] = y[k+0] + (cos[k/2*m]*z[k+0] - sin[k/2*m]*z[k+1]);
				x[k+1 + 0*n/2] = y[k+1] + (cos[k/2*m]*z[k+1] + sin[k/2*m]*z[k+0]);
				x[k+0 + 2*n/2] = y[k+0] - (cos[k/2*m]*z[k+0] - sin[k/2*m]*z[k+1]);
				x[k+1 + 2*n/2] = y[k+1] - (cos[k/2*m]*z[k+1] + sin[k/2*m]*z[k+0]);
			}
			
			else if (sign == -1)
			{
				x[k+0 + 0*n/2] = y[k+0] + (cos[k/2*m]*z[k+0] - sin[k/2*m]*-1.0D*z[k+1]);
				x[k+1 + 0*n/2] = y[k+1] + (cos[k/2*m]*z[k+1] + sin[k/2*m]*-1.0D*z[k+0]);
				x[k+0 + 2*n/2] = y[k+0] - (cos[k/2*m]*z[k+0] - sin[k/2*m]*-1.0D*z[k+1]);
				x[k+1 + 2*n/2] = y[k+1] - (cos[k/2*m]*z[k+1] + sin[k/2*m]*-1.0D*z[k+0]);
			}
		}
		
		return x;
	}
	
	
	
	private static int[] fftSwap(int[] array)
	{
		//  swaps the indices for the iterative fast fourier transform
		
		//  Example  Swap the array indexes for the 16-element array
		//
		//  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15
		//  0,  2,  4,  6,  8, 10, 12, 14 | 1,  3,  5,  7,  9, 11, 13, 15
		//  0,  4,  8, 12 | 2,  6, 10, 14 | 1,  5,  9, 13 | 3,  7, 11, 15
		//  0,  8 | 4, 12 | 2, 10 | 6, 14 | 1,  9 | 5, 13 | 3, 11 | 7, 15
		//  0 | 8 | 4 |12 | 2 |10 | 6 |14 | 1 | 9 | 5 |13 | 3 |11 | 7 |15
		
		int[] x = new int[array.length];
		
		for (int i = 0; i < x.length; i++)
		
		    x[i] = array[i];
		
		int N = x.length / 2;
		
		for (int i = 1; i < N; i *= 2)
		{
			//  i = 1, 2, 4, 8, ...
			
			int[] y = new int[N/i];
			int[] z = new int[N/i];
			
			for (int j = 0; j < 2*N; j += 2*N/i)
			{
				for (int k = 0; k < y.length/2; k++)
				{
					y[2*k + 0] = x[j + 4*k + 0];
					y[2*k + 1] = x[j + 4*k + 1];
					z[2*k + 0] = x[j + 4*k + 2];
					z[2*k + 1] = x[j + 4*k + 3];
				}
				
				for (int k = 0; k < N/i; k++)
				{
					x[j + 0*N/i + k] = y[k];
					x[j + 1*N/i + k] = z[k];
				}
			}
		}
		
		return x;
	}
	
	
	
	private static double[] fftSwap(double[] array)
	{
		double[] x = new double[array.length];
		
		for (int i = 0; i < x.length; i++) x[i] = array[i];
		
		int N = x.length / 2;
		
		for (int i = 1; i < N; i *= 2)
		{
			//  i = 1, 2, 4, 8, ...
			
			double[] y = new double[N/i];
			double[] z = new double[N/i];
			
			for (int j = 0; j < 2*N; j += 2*N/i)
			{
				for (int k = 0; k < y.length/2; k++)
				{
					y[2*k + 0] = x[j + 4*k + 0];
					y[2*k + 1] = x[j + 4*k + 1];
					z[2*k + 0] = x[j + 4*k + 2];
					z[2*k + 1] = x[j + 4*k + 3];
				}
				
				for (int k = 0; k < N/i; k++)
				{
					x[j + 0*N/i + k] = y[k];
					x[j + 1*N/i + k] = z[k];
				}
			}
		}
		
		if (array.length > 4*1024*1024)
		
		    System.gc();
		
		return x;
	}
	
	
	
	private static Number[] fftSwap(Number[] array)
	{
		Number[] x = new Number[array.length];
		
		for (int i = 0; i < x.length; i++)
		
		    x[i] = array[i];
		
		int N = x.length / 2;
		
		for (int i = 1; i < N; i *= 2)
		{
			//  i = 1, 2, 4, 8, ...
			
			Number[] y = new Number[N/i];
			Number[] z = new Number[N/i];
			
			for (int j = 0; j < 2*N; j += 2*N/i)
			{
				for (int k = 0; k < y.length/2; k++)
				{
					y[2*k + 0] = x[j + 4*k + 0];
					y[2*k + 1] = x[j + 4*k + 1];
					z[2*k + 0] = x[j + 4*k + 2];
					z[2*k + 1] = x[j + 4*k + 3];
				}
				
				for (int k = 0; k < N/i; k++)
				{
					x[j + 0*N/i + k] = y[k];
					x[j + 1*N/i + k] = z[k];
				}
			}
		}
		
		return x;
	}
	
	
	
	
	//  Conversion methods for complex double arrays
	//
	//  used for discrete fourier transform (dft)
	//  and fast fourier transform (fft) multiply methods
	
	
	private static double[] doubleArray(double[] array)
	{
		//  doubles the length of an array
		
		double[] d_array = new double[2*array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    d_array[1*i] = array[i];
		
		return d_array;
	}
	
	
	private static int[] intArrayToComplexArray(int[] array)
	{
		//  converts ints from real to complex
		
		int[] complex_array = new int[2*array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    complex_array[2*i] = array[i];
		
		return complex_array;
	}
	
	
	private static double[] realArrayToComplexArray(double[] array)
	{
		//  converts doubles from real to complex
		
		double[] d_array = new double[2*array.length];
		
		for (int i = 0; i < array.length; i++)
		
		    d_array[2*i] = array[i];
		
		return d_array;
	}
	
	
	private static double[] byteArrayToComplexDoubleArray(byte[] array)
	{
		return intArrayToComplexDoubleArray(
		
		    Convert.byteArrayToIntArray(array));
	}
	
	
	private static double[] doubleArrayToComplexDoubleArray(double[] array)
	{
		double[] array1 = new double[array.length*2];
		
		for (int i = 0; i < array.length; i++)
		{
			array1[2*i+0] = array[i];
			array1[2*i+1] = 0.0D;
		}
		
		return array1;
	}
	
	
	private static double[] complexDoubleArrayToDoubleArray(double[] array)
	{
		double[] array1 = new double[array.length / 2];
		
		for (int i = 0; i < array1.length; i++)
		
		    array1[i] = array[2*i+0];
		
		return array1;
	}
	
	
	private static int[] complexDoubleArrayToIntArray(double[] array)
	{
		//  converts (52-bit) complex doubles to (8-bit) real integers
		
		//  The double values greater than 255 are carried to the next 8-bit integer
		
		//  52-bit integers left shifted 8-bits
		//
		//
		//            |        |   xxxxx|xxxxxxxx|0
		//            |        | xxxxxxx|xxxxxx  |1
		//            |       x|xxxxxxxx|xxxx    |2
		//            |     xxx|xxxxxxxx|xx      |3
		//            |   xxxxx|xxxxxxxx|0       |
		//            | xxxxxxx|xxxxxx  |1       |
		//           x|xxxxxxxx|xxxx    |2       |
		//         xxx|xxxxxxxx|xx      |3       |
		//       xxxxx|xxxxxxxx|0       |        |
		//     xxxxxxx|xxxxxx  |1       |        |
		//   xxxxxxxxx|xxxx    |2       |        |
		// xxxxxxxxxxx|xx      |3       |        |
		
		
		//  Remove the imaginary components
		
		//  Copy the real numbers (a.length - even indices)
		//
		//  and remove the non-even indices or imaginary numbers
		
		double[] w = new double[array.length/4];
		
		for (int i = 0; i < w.length; i++)
		
		    w[w.length -1 -i] = array[array.length -2 -2*i];
		
		//  Convert the doubles to 8-bit integers
		
		int[][] temp0 = new int[4][w.length/4];
		int[][] temp1 = new int[4][w.length/4];
		
		for (int i = 0; i <          temp0.length; i++)
		for (int j = 0; j < w.length/temp0.length; j++)
		{
			temp0[i][j] = 0;
			temp1[i][j] = 0;
		}
		
		for (int i = 0; i < temp0.length; i++)
		{
			//  Copy the lower 32-bits
			
			for (int j = 0; j < w.length/temp0.length; j++)
			{
				if (         (temp0[i].length -1 -j) >= 0)
				     temp0[i][temp0[i].length -1 -j] +=
				
					( ((long)( w[w.length -1 -i -4*j]) & 0xffffffff ) );
			}
			
			//  Copy the upper 20-bits
			
			for (int j = 0; j < w.length/temp1.length; j++)
			{
				if (         (temp1[i].length -2 -j) >= 0)
				     temp1[i][temp1[i].length -2 -j] +=
				
					( (((long)(w[w.length -1 -i -4*j]) >> 32) & 0xffffffff ) );
			}
		}
		
		int[] array1, array2, array3;
		
		array1 = Math.add( Math.add( Math.shiftLeft(temp0[0], 32,  0), Math.shiftLeft(temp0[1], 32,  8) ),
		                   Math.add( Math.shiftLeft(temp0[2], 32, 16), Math.shiftLeft(temp0[3], 32, 24) ) );
		
		array2 = Math.add( Math.add( Math.shiftLeft(temp1[0], 32,  0), Math.shiftLeft(temp1[1], 32,  8) ),
		                   Math.add( Math.shiftLeft(temp1[2], 32, 16), Math.shiftLeft(temp1[3], 32, 24) ) );
		
		return Math.add(array1, array2);
	}
	
	
	private static double[] intArrayToComplexDoubleArray(int[] array)
	{
		//  converts an 8-bit int array to a complex double array
		
		//  Example  (a[i] and b[i] are bytes)
		//
		//  (a three-int array)
		//
		//  { a0 a1 a2 a3,  b0 b1 b2 b3,  c0 c1 c2 c3 }
		//
		//
		//  (four-int array)   (left-padded to a power of two)
		//
		//  { 0 0 0 0,  a0 a1 a2 a3,  b0 b1 b2 b3,  c0 c1 c2 c3 }
		//
		//
		//  (16-int array)     (quadrupled from 32-bit ints to 8-bit ints)
		//
		//  { 0, 0, 0, 0, a0, a1, a2, a3, b0, b1, b2, b3, c0, c1, c2, c3 }
		//
		//
		//  (32-int array)     (doubled again from real to complex)
		//
		//  {  0, 0,  0, 0,  0, 0,  0, 0, a0, 0, a1, 0, a2, 0, a3, 0
		//    b0, 0, b1, 0, b2, 0, b3, 0, c0, 0, c1, 0, c2, 0, c3, 0 }
		//
		//  The fft multiply method will double this array again and pad the right
		//  side with zeros. This makes the complex double array 16 times larger
		//  than the int array.
		//
		//  8-bit integers allow multiplication up to about 1 terabit.
		//
		//  16-bit integers would limit multiplication to 16 M bit arrays because
		//  a double holds 52 bits and a multiplication of 16-bit integers requires
		//  16-bits squared times the array length which equals 16 + 16 bits + 20 bits
		//  (for 1 million 16-bit arrays which equals 1 or 2 M bit numbers because
		//  the arrays are quadrupled or octupled by the fft multiply method.)
		
		
		int[] a = new int[array.length];
		
		for (int i = 0; i < a.length; i++) a[i] = array[i];
		
		//  Convert from 32-bit integer to 8-bit integer
		
		int[] temp_array = new int[4*a.length];
		
		for (int i = 0; i < a.length; i++)
		{
			temp_array[4*i + 3] = (a[i] >>>  0) & 0xff;
			temp_array[4*i + 2] = (a[i] >>>  8) & 0xff;
			temp_array[4*i + 1] = (a[i] >>> 16) & 0xff;
			temp_array[4*i + 0] = (a[i] >>> 24) & 0xff;
		}
		
		a = temp_array;
		
		if ((a.length & (a.length -1)) != 0)
		{
			//  Pad the array to a power of two
			
			int length = a.length;
			
			int poweroftwo = 1;
			
			while (length != 0)
			
			    { length >>= 1; poweroftwo <<= 1; }
			
			temp_array = new int[poweroftwo];
			
			for (int i = 0; i < a.length; i++)
			
			    temp_array[temp_array.length -1 -i] = a[a.length -1 -i];
			
			a = temp_array;
		}
		
		double[] d_array = new double[4*a.length];
		
		//  System.out.println(Arrays.toString(a));
		
		for (int i = 0; i < a.length; i++)
		
		    d_array[d_array.length -2 -2*i] = a[a.length -1 -i];
		
		return d_array;
	}
}


//  End class Fourier










/********************************




//  These classes are included as an example to illustrate how encryption
//  can be done using composite or multiple public keys.
//
//  The SSLSocket and SSLServerSocket classes can be excerpted and used
//  in any program that is open source and has a free or copyleft license
//  that is compatible with the GNU General Public License.
//
//  Note that if you test the ServerExample using a port number < 1024,
//  you will have to execute the SSLServerSocket program as a superuser.
//
//  You may want to use these classes instead of the regular / standard
//  SSL classes because the other classes don't use real cryptography.
//  The other SSL/TLS classes may be okay if the ciphers are replaced.



//  These classes don't use certificates signed by a trusted authority to
//  verify the authenticity of the server encryption key (unless someone
//  can write the code for it), but the client program or web browser could
//  save and display the server key hash in a label or text field to allow
//  the user to verify the key hash and to alert the user if the server key
//  changes. The user or program could also set the server key hash so that
//  if the received key hash is different from the entered value, the client
//  socket will not connect to the server until the user clicks OK to update
//  the hash if the company changes its server key.
//
//  All websites should use encrypted sockets or SSL/TLS encryption, but most
//  websites don't require a public key certificate unless the user is doing
//  online banking or purchasing something from a website using a credit card.
//  Even without key verification, public key cryptography still makes it im-
//  possible for a wiretapper to read the messages or communication.
//
//  Even if an email service provider has a public key certificate for its web-
//  site, it doesn't prevent them from substituting fake keys for some of its
//  users, just as a certificate for a public key server doesn't prevent some-
//  one from publishing fake public keys and email addresses for other users,
//  or opening an email address in someone else's name and then re-encrypting
//  and re-sending the emails to the real recipients.
//
//  Public key certificates are not required for email users or for email pro-
//  viders because users can verify that their email server is not subtituting
//  fake keys by verifying their own public keys. For example, for encrypted
//  phone calls the caller (or recipient) can verify that the phone or internet
//  service provider is not substituting fake public keys for some users by
//  reading the hash of the secret keys to the recipient to confirm that the
//  two public key agreements are identical. For unimportant phone calls,
//  e-mails, or web sites, it doesn't matter if the keys are unverified.






////  Uncomment these lines
////
////  import java.io.*;
////  import java.net.*;
////  import java.util.*;
////  import java.util.concurrent.*;
////
////  import java.awt.*;




class ServerExample
{

	private int port;
	
	private byte[] serverprivatekey;
	
	private SSLServerSocket sslserversock;
	
	private ScheduledThreadPoolExecutor executor;
	
	private int timeout = 20*1000;
	
	public ServerExample(int port, int corepoolsize, byte[] serverprivatekey)
	{
		//  Initialize the server
		
		this.port = port;
		
		this.serverprivatekey = serverprivatekey;
		
		this.executor = new ScheduledThreadPoolExecutor(corepoolsize);
		
		try
		{	sslserversock = new SSLServerSocket(
			
			    port, serverprivatekey);
		}
		
		catch (IOException ex) { System.out.println(ex); }
		
		new Thread(new Runnable()
		{
			public void run()
			{
				while (true)
				{
					SSLSocket sslsocket;
					
					try
					{	//  Wait for incoming sockets
						
						System.out.println("waiting for incoming socket");
						
						//  The accept method exchanges the public keys and
						//  computes the shared secret key. If the client closes
						//  the socket during the key exchange and key agreement,
						//  the accept method will throw an exception.
						
						sslsocket = sslserversock.accept();
						
						if (sslsocket != null)
						
						    sslsocket.setSoTimeout(timeout);
					}
					
					catch (Exception ex)
					{
						if ((sslserversock == null)
						  || sslserversock.isClosed()) break;
						
						ex.printStackTrace();
						
						continue;
					}
					
					Runnable r = new Client(sslsocket);
					
					executor.execute(r);
				}
			}
		
		}).start();
	}
	
	
	
	public void closeServerSocket()
	{
		if (sslserversock != null)
		{
			try { sslserversock.close(); }
			
			catch (IOException ex)
			
			    { System.out.println(ex); }
			
			sslserversock = null;
			
			executor.shutdown();
		}
	}
	
	
	
	private class Client implements Runnable
	{
	
		private SSLSocket sslsocket;
		
		
		public Client(SSLSocket sslsocket)
		{
			this.sslsocket = sslsocket;
		}
		
		
		public void run()
		{
		
			while (true)
			{
				//  Receive the client's public key prepended to
				//  the message text as an encrypted message
				
				try
				{	//  Read the message from the client socket
					
					String message = sslsocket.readLine();
					
					//  Process the client's request
					
					execute(sslsocket, message);
					
					continue;
				}
				
				catch (Exception ex) // IO and Socket Exception
				{
					if (ex instanceof SocketTimeoutException)
					
					    System.out.println("Socket timed out");
					
					else if (ex instanceof IOException)
					
					    System.out.println("The client closed the socket");
				}
				
				
				//  Close the sslsocket
				
				try { if (!sslsocket.isClosed()) sslsocket.close(); }
				
				catch (IOException ex) { System.out.println(ex); }
				
				sslsocket = null;
				
				break;
			}
		}
		
		
		
		//  private methods
		
		
		
		private void execute(SSLSocket sslsocket, String message) throws IOException
		{
		
			//  if (message.equals(...))
			//
			//      methodOne();
			
			//  else if (message.equals(...))
			//
			//      methodTwo();
			
			//  else  ...
			
			
			System.out.print("Server received " + message);
			
			sslsocket.writeLine("Returning message to client " + message);
		}
	}
	
	
	
	//  The main method is the code that a client program
	//
	//  would use to connect to a server computer
	
	
	public static void main(String[] args)
	{
		//  Instantiate a server socket example
		
		String hostaddr = "127.0.0.1";
		
		try
		{	hostaddr = InetAddress
			
			    .getLocalHost() .getHostAddress();
		}
		
		catch (UnknownHostException ex)
		{
			System.out.println(ex);
		}
		
		int port = 465;
		
		int corepoolsize = 256;
		
		//  the static server private key
		
		
		//  CHANGE THIS PRIVATE KEY
		
		byte[] serverprivatekey = new byte[]
		
		    { 1, 2, 3, 4, 5, 6, 7, }; // ...
		
		
		ServerExample serverexample = new
		
		    ServerExample(port, corepoolsize, serverprivatekey);
		
		try { Thread.sleep(2*1000); }
		catch (InterruptedException ex) {  }
		
		
		//  Instantiate a few client socket examples
		//  to communicate with the server socket
		
		for (int t = 0; t < 256; t++)
		{
			System.out.println();
			
			//  the one-time client private key
			
			byte[] clientprivatekey = Number
			
			    .random(64, 16) .toByteArray();
			
			SSLSocket sslsocket;
			
			try
			{	try { sslsocket = new SSLSocket(hostaddr, port, clientprivatekey); }
				
				catch (ConnectException ex)
				
				    { System.out.println("No server socket to connect to"); return; }
				
				sslsocket.writeLine("This is the first message");
				String response1 = sslsocket.readLine();
				System.out.println("\nClient received  " + response1);
				
				sslsocket.writeLine("This is the second message");
				String response2 = sslsocket.readLine();
				System.out.println("\nClient received  " + response2);
				
				sslsocket.writeLine("This is the third message");
				String response3 = sslsocket.readLine();
				System.out.println("\nClient received  " + response3);
				
				System.out.println("I am closing the client socket");
				
				sslsocket.close();
			}
			
			catch (IOException ex)
			{
				ex.printStackTrace();
			}
		}
	}
}

//  End class ServerExample








class SSLServerSocket extends ServerSocket
{

	//  Server code for encrypted communication
	//
	//  between a client and server program
	
	
	private int port;
	
	private int corepoolsize;
	
	private byte[] serverprivatekey;
	
	//  the server's public key
	
	private PublicKey[] publickey;
	
	private int timeout = 12*1000;
	
	
	public SSLServerSocket(
	
		int port, byte[] serverprivatekey) throws IOException
	{
	
		//  Initialize the server
		
		super(port);
		
		this.port = port;
		
		this.corepoolsize = corepoolsize;
		
		this.serverprivatekey = serverprivatekey;
		
		//  Generate the public key for the server socket
		
		this.publickey = PublicKey.generatePublicKey(
		
		    serverprivatekey, PublicKey.numberofciphers);
	}
	
	
	
	public SSLSocket accept() throws IOException
	{
	
		SSLSocket sslsocket = new SSLSocket();
		
		this.implAccept(sslsocket);
		
		sslsocket.init();
		
		sslsocket.setPrivateKey(serverprivatekey);
		
		boolean exchangedkeys = sslsocket.exchangeServerKeys();
		
		if (!exchangedkeys) return null;
		
		return sslsocket;
	}
}


//  End class SSLServerSocket








class SSLSocket extends Socket
{



	private String address;
	
	private int port;
	
	
	//  the public key received from the server
	
	private String receivedkey;
	private String receivedkeyhash;
	
	//  the user can set the server key hash
	//  so that the socket will not connect or
	//  will throw an exception if the received
	//  key hash does not match the server key hash
	
	//  set by the caller / user
	private String serverkeyhash;
	
	private byte[] privatekey;
	
	private PublicKey[] publickeys;
	
	private Number keyagreement;
	
	private boolean encrypted;
	
	private BufferedReader in;
	private BufferedWriter out;
	
	
	//  number of ciphers can be less than
	//  but not greater than the maximum
	
	private int maxnumberofciphers =
	
	     PublicKey.numberofciphers;
	
	
	//  constructors
	
	//  empty constructor called by the super class
	
	public SSLSocket() {  }
	
	public SSLSocket(String address, int port) throws IOException
	{
		super(address, port);
		
		byte[] randkey = Number
		
		    .random(64, 16).toByteArray();
		
		this.privatekey = randkey;
		
		init();
		
		encrypted = exchangeClientKeys();
	}
	
	public SSLSocket(String address, int port, byte[] privatekey) throws IOException
	{
		super(address, port);
		
		this.privatekey = privatekey;
		
		init();
		
		encrypted = exchangeClientKeys();
	}
	
	public void init() throws IOException
	{
		InputStreamReader inputstreamreader = new
		InputStreamReader(this.getInputStream());
		
		OutputStreamWriter outputstreamwriter = new
		OutputStreamWriter(this.getOutputStream());
		
		in  = new BufferedReader( inputstreamreader);
		out = new BufferedWriter(outputstreamwriter);
	}
	
	public void setPrivateKey(byte[] SK)
	{
		this.privatekey = SK;
	}
	
	public void setNumberOfCiphers(int numberofciphers)
	{
		this.maxnumberofciphers = numberofciphers;
	}
	
	public void setReceivedKeyHash(String hash)
	{
		//  The socket can compare the received key
		
		this.receivedkeyhash = hash;
	}
	
	public String getReceivedKey()
	{
		return receivedkey;
	}
	
	public String getReceivedKeyHash()
	{
		return receivedkeyhash;
	}
	
	public boolean isEncrypted()
	{
		return encrypted;
	}
	
	
	
	public String[] getEnabledCipherSuites()
	{
		return null;
	}
	
	public void startHandshake()
	{
		
	}
	
	
	private Object[] intersection(String[] receivedkeys, PublicKey[] publickeys)
	{
	
		//  This method finds the intersection of two sets of public keys
		
		ArrayList<String>  receivedkeysubsetlist = new ArrayList<String>();
		ArrayList<PublicKey> publickeysubsetlist = new ArrayList<PublicKey>();
		
		for (int i = 0; i < receivedkeys.length; i++)
		for (int j = 0; j <   publickeys.length; j++)
		{
			if (receivedkeys[i].length() == publickeys[j].toString().length())
			{
				receivedkeysubsetlist.add(receivedkeys[i]);
				  publickeysubsetlist.add(  publickeys[i]);
			}
		}
		
		int subsetsize = publickeysubsetlist.size();
		
		String[] receivedkeysubset = new String[subsetsize];
		
		PublicKey[] publickeysubset = new PublicKey[subsetsize];
		
		for (int i = 0; i < subsetsize; i++)
		
		    receivedkeysubset[i] = receivedkeysubsetlist.get(i);
		
		for (int i = 0; i < subsetsize; i++)
		
		    publickeysubset[i] = publickeysubsetlist.get(i);
		
		return new Object[] { receivedkeysubset, publickeysubset };
	}
	
	
	
	public boolean exchangeServerKeys() throws IOException
	{
	
		//  Generate the server public key using the max number of ciphers
		//  (The client will choose a subset of ciphers from this key)
		
		if (this.publickeys == null)
		
		    this.publickeys = PublicKey.generatePublicKey(
		
			privatekey, maxnumberofciphers);
		
		
		//  Concatenate the static public keys
		
		String str = PublicKey.joinKeys(publickeys);
		
		
		//  Send the static public server key to the client
		
		writeLine(str);
		
		
		//  Receive and verify the client's public key
		
		String message = readLine().trim();
		
		if (!PublicKey.isValidKey(message)) return false;
		
		String receivedkey = message;
		
		
		//  Find the intersection of the two sets of public keys
		
		String[] splitkeys = PublicKey.splitKeys(receivedkey);
		
		Object[] objarray = intersection(splitkeys, publickeys);
		
		String[] clientkeysubset = (String[]) objarray[0];
		
		PublicKey[] publickeysubset = (PublicKey[]) objarray[1];
		
		
		//  Set the received (client) key
		
		this.receivedkey = message;
		
		
		//  Compute the shared secret key
		
		this.keyagreement = PublicKey.generateSecretKey(
		
		    clientkeysubset, publickeysubset, PublicKey.receive_decrypt);
		
		System.out.println("server shared secret key == "
		
		    + this.keyagreement.toString(16));
		
		return true;
	}
	
	
	
	private boolean exchangeClientKeys() throws IOException
	{
	
		//  Receive and verify the server key
		
		String message = readLine();
		
		if (!PublicKey.isValidKey(message)) return false;
		
		String receivedkey = message;
		
		
		//  Reduce the number of keys in the public server key
		//  before generating the matching one-time client key
		
		String[] splitkeys = PublicKey.splitKeys(receivedkey);
		
		int t = Math.min(splitkeys.length, maxnumberofciphers);
		
		String[] subsetkey = new String[t];
		
		for (int i = 0; i < t; i++)
		
		    subsetkey[i] = splitkeys[i];
		
		publickeys = PublicKey.generateMatchingPublicKeys(
		
		    privatekey, subsetkey);
		
		//  Concatenate the one-time public keys
		
		String str = PublicKey.joinKeys(publickeys);
		
		
		//  Send the one-time client key to the server
		
		writeLine(str);
		
		
		//  Compute the shared secret key
		
		this.keyagreement = PublicKey.generateSecretKey(
		
		    subsetkey, publickeys, PublicKey.send_encrypt);
		
		//  System.out.println("key agreement == "
		//
		//    + this.keyagreement.toString(16));
		
		
		//  Set the received (server) key
		
		//  Don't set the received (server) key until after sending the client
		//  key because then the writeLine method will encrypt everything
		
		this.receivedkey = receivedkey;
		
		this.receivedkeyhash = PublicKey.hashPublicKey(receivedkey);
		
		
		
		//  If the user or client program has entered a server key hash
		//  (or a previous key hash) compare the server key hash to the
		//  received key hash to see if they match
		
		if ((serverkeyhash != null) && !serverkeyhash.isEmpty())
		{
			//  Compute the received key hash
			
			String receivedkeyhash = PublicKey.hashPublicKey(receivedkey);
			
			if (! receivedkeyhash .startsWith(serverkeyhash.trim()))
			{
				System.out.println("Server key does not match server key hash");
				
				//  ...
			}
		}
		
		else
		{	//  Compute the server key hash and save the key hash
			//  so the client program can read the key hash and
			//  display it in the program or web browser
			
			this.receivedkeyhash = PublicKey.hashPublicKey(receivedkey);
			
			//  ...
			
			//  ...
		}
		
		return true;
	}
	
	
	
	public boolean writeLine(String message) throws IOException
	{
	
		//  Encrypt the private key message
		
		if (message == null)  message = "";
		
		if ((receivedkey != null) && !receivedkey.isEmpty())
		
		    message = Cipher.encrypt(message,
		
			keyagreement.toByteArray());
		
		
		//  Send the string in units of buffer size
		
		int buffersize;
		
		try { buffersize = this.getSendBufferSize(); }
		
		catch (SocketException ex)
		{
			System.out.println(ex);
			
			return false;
		}
		
		int length = message.length();
		
		for (int i = 0; buffersize * i < length; i++)
		{
			out.write( message.substring(
			
			    buffersize * (i+0), (buffersize * (i+1) <= length) ?
			    
			    buffersize * (i+1) : length) );
		}
		
		out.write("\n");
		
		out.flush();
		
		return true;
	}
	
	
	
	public String readLine() throws IOException
	{
	
		//  Read the string from the BufferedReader
		
		String line = in.readLine();
		
		if (line == null) throw new IOException();
		
		//  Decrypt the private key message
		
		String message = line.trim();
		
		if ((keyagreement != null) && Number.isBase64(message)
		
		    && Cipher.isEncrypted(Convert.base64ToByteArray(message)))
		
		    message = Cipher.decrypt(message, keyagreement.toByteArray());
		
		return message;
	}
}


//  End class SSLSocket




********************************/










//  This software is licensed under the terms of the
//  GNU General Public License (version 3).
//
//  The crypto / math classes including the PublicKey,
//  Signature, Cipher, Math, Number, Matrix, Fourier, and
//  SSLSocket classes are copyrighted by the java math and
//  cryptography authors. The copyright holders' signature
//  key is 0000 2020 c685 5793 74c0 2d8d ef02 416c.

//  Copyright © 2020  The Java Editor authors











